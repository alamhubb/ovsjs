---
description: GuideBot 项目信息 - 项目定位、技术规范、功能设计、架构、当前状态
alwaysApply: true
---

# 🎯 GuideBot 项目信息

## 当前阶段
`STAGE_1_REQUIREMENTS_LAYER_1` - 需求设计阶段 - 第1层：功能需求

---

# 📌 项目简介

**GuideBot - AI 辅助开发引导平台**

> 让一年级小孩也能用 AI 开发网站

**GuideBot** 是一个 AI 辅助开发平台，通过强引导系统帮助零基础用户使用 AI 开发完整的网站。

**工作原理：**
```
用户想法 → AI 引导对话 → 明确需求 → AI 生成代码 → 实时预览 → 一键部署 → 完整网站
```

**核心差异化：**
- **比 bolt.new 更强大的引导系统**：不只是"生成代码"，而是"引导用户做出更好的网站"
- **目标用户下沉**：从"会用 AI 的开发者"到"零基础小白，甚至一年级小孩"
- **商业工具定位**：让用户轻松、无脑地做出网站，而不是教育用户如何用AI
- **核心理念**：减少认知负担，让用户通过简单的选择就能做出想要的网站

**与 guidebot.mdc 和 bolt.new 的关系：**
- **对标 bolt.new**：商业工具，让用户轻松开发网站
- **实现 guidebot.mdc**：将guidebot.mdc中的引导系统设计规范（七维度、分步引导）可视化为网站
- **核心区别**：GuideBot网站 是 guidebot.mdc 的Web实现，不是独立产品

---

## 项目定位

**GuideBot = AI 辅助开发平台 + 强引导系统**

**一句话：** 类似 bolt.new，但加入了强引导系统，让零基础用户也能轻松开发网站

**核心理念：** 遵循 guidebot.mdc 中定义的"核心设计理念"，具体应用为：
- **减少认知负担** → 分步引导、提供选项、让用户轻松选择
- **引导而非替代** → AI引导对话明确需求，不是替用户做决策
- **工具价值优先** → 帮用户做出网站，不是教用户学会用AI

**核心价值定位：**
- **不用深度思考怎么写提示词，也能很好的开发出产品** - GuideBot解决的核心问题
- **AI开发的核心=提示词** → GuideBot的核心价值=帮用户生成好的提示词
- 引导对话 → 为了完善提示词（用户不用想怎么写，系统主动引导）
- 提示词文档 → 可复用、可导出、可迭代
- 实时预览 → 验证提示词效果

---

## 核心功能

**基础功能（类似 bolt.new）：**
- 🤖 **AI 代码生成** - 自然语言描述 → AI 自动生成完整代码
- 👀 **实时预览** - 代码变化即时在浏览器中预览
- 📦 **一键部署** - 直接部署到 Netlify/Vercel 等平台
- ✏️ **在线编辑** - 浏览器内修改代码，无需本地环境

**差异化优势（比 bolt.new 更强）：**
- 🎯 **强引导系统** - 分步引导用户明确需求（七维度引导框架）
- 📝 **提示词优先** - 核心输出是结构化的提示词文档（可复用、可迭代）
- 🧩 **渐进式复杂度** - 从"一句话描述"到"完整提示词"，逐步深入
- 👶 **极低门槛** - 针对零基础用户（包括儿童）优化，分步引导、提供选项
- 📊 **可视化进度** - 让用户看到"第X步/共7步"，知道还剩多少
- 🎓 **知识沉淀** - 成功的提示词自动保存为模板

**目标用户：**
- **主要：** 零基础用户、非技术人员、学生（包括小学生）
- **次要：** 快速原型开发的开发者、需要引导的初级开发者

---

## 与 bolt.new 的对比

| 维度 | bolt.new | GuideBot（我们的优势） |
|------|----------|------------------------|
| **目标用户** | 会用 AI 的开发者 | 零基础小白，包括儿童 |
| **交互方式** | 直接对话生成代码 | 分步引导 + 生成代码 |
| **学习成本** | 需要知道如何描述需求 | 系统引导你明确需求 |
| **引导强度** | 弱（直接对话） | 强（分步引导、降低门槛） |
| **复杂度控制** | 一次性生成 | 渐进式，从简单到复杂 |
| **知识复用** | 无 | 案例沉淀为模板 |
| **适合场景** | 快速原型、有经验用户 | 零基础开发、需要引导的用户 |

**核心差异：** bolt.new = 工具（适合有经验用户），GuideBot = 工具（适合零基础用户，更强的引导）

---

## 关联项目

| 项目 | 路径 | 说明 | 文档 |
|------|------|------|------|
| **OVS 框架** | `../ovs/` | 声明式 UI 框架 | `../ovs/aireadme.md`<br>`../ovs/docs/USER_GUIDE.md` |

---

# 💻 技术栈和编码规范

## 通用编码规范

**沟通语言：** 全程使用中文

**代码风格：** 保持与项目空间下其他项目一致的编码风格

---

## OVS 代码规范

### 命名规范

- **组件：** `PascalCase`  
  示例：`IdeaInputForm.ovs`, `PromptDisplay.ovs`

- **变量：** `camelCase`  
  示例：`userName`, `isActive`, `taskList`

- **函数：** 动词开头  
  示例：`getUserData`, `handleClick`, `formatDate`

---

### OVS 限制与替代方案

**除法运算：**
```typescript
// ❌ 不要这样写（OVS 不支持除法）
value / 2

// ✅ 使用乘法替代
value * 0.5
```

**复杂逻辑：**
- OVS 适合简单的模板逻辑
- 复杂业务逻辑提取到 TypeScript 文件
- 在 OVS 中只调用函数，不写复杂表达式

---

### OVS 最佳实践

**组件拆分：**
```
- 一个组件只做一件事
- 超过 100 行考虑拆分
- 可复用的部分独立为组件
```

**状态管理：**
```
- 简单状态：ref / reactive
- 复杂状态：提取到独立的 TS 文件
- 跨组件通信：props / emit
```

---

## TypeScript 规范

### 类型定义

```typescript
// ✅ 定义清晰的接口
interface Project {
  id: string
  name: string
  status: 'planning' | 'developing' | 'completed'
}

// ✅ 使用类型别名
type TaskStatus = 'todo' | 'inProgress' | 'completed'
```

---

### 避免 any

```typescript
// ❌ 不要使用 any
function processData(data: any) { ... }

// ✅ 定义具体类型
function processData(data: ProjectData) { ... }
```

---

## 代码示例

### OVS 组件示例

```ovs
<script lang="ts">
import { ref } from 'vue'

interface Props {
  title: string
  count?: number
}

const props = defineProps<Props>()
const localCount = ref(props.count || 0)

const handleIncrement = () => {
  localCount.value = localCount.value + 1
}
</script>

<template>
  <div class="card">
    <h2>{{ title }}</h2>
    <p>Count: {{ localCount }}</p>
    <button @click="handleIncrement">增加</button>
  </div>
</template>

<style scoped>
.card {
  padding: 1rem;
  border: 1px solid #ccc;
}
</style>
```

---

### TypeScript 工具函数示例

```typescript
// utils/promptGenerator.ts

export interface PromptTemplate {
  task: string
  background: string
  requirements: string[]
  acceptance: string[]
}

export function generatePrompt(template: PromptTemplate): string {
  const { task, background, requirements, acceptance } = template
  
  return `
【任务】${task}

【背景】
${background}

【要求】
${requirements.map((r, i) => `${i + 1}. ${r}`).join('\n')}

【验收标准】
${acceptance.map(a => `- [ ] ${a}`).join('\n')}
  `.trim()
}
```

---

## 错误处理

**优雅的错误处理：**
```typescript
try {
  const result = await fetchData()
  // 处理成功情况
} catch (error) {
  // 提供有意义的错误信息
  console.error('获取数据失败:', error)
  showErrorMessage('无法加载数据，请稍后重试')
}
```

---

## 性能优化建议

- 大列表使用虚拟滚动
- 图片懒加载
- 合理使用 `computed` 缓存计算结果
- 避免不必要的组件重渲染

---

# 💡 功能设计

## 用户体验流程（完整版）

**阶段1：想法输入（极简化）**
- 用户：一句话描述想法（如："我想做一个任务管理工具"）
- 系统：立即识别类型，给出参考案例

**阶段2：引导对话（分步明确需求）**
- 系统通过7个维度引导用户（功能、体验、技术、数据、安全、集成、优先级）
- 每个问题都配有示例图、可选项，降低思考成本
- 用户只需"选择"或"简单描述"

**阶段3：需求确认（可视化呈现）**
- 生成需求文档，用通俗语言展示
- 用卡片、图表呈现，而非纯文字
- 用户可修改或确认

**阶段4：AI 生成代码（实时展示）**
- 调用 AI 生成代码（可能是调用 GPT-4 API 或本地大模型）
- 实时显示生成进度："正在设计页面布局..." → "正在生成组件..." → "正在连接数据..."
- 让用户感知 AI 在做什么

**阶段5：实时预览（即时反馈）**
- 代码生成后立即在右侧预览区显示效果
- 用户可以交互操作，测试功能
- 发现问题 → 用自然语言描述 → AI 修复 → 再预览

**阶段6：代码解释（教育环节）**
- 点击任何功能，系统用通俗语言解释"这段代码在做什么"
- "为什么要这样写"
- "如果你想修改XX，可以这样说..."

**阶段7：部署上线（一键完成）**
- 点击"部署"，自动推送到 Netlify/Vercel
- 生成访问链接，可分享给朋友

**阶段8：知识沉淀（可选）**
- 系统询问："要不要把这个项目保存为模板？"
- 保存后，下次开发类似项目可直接复用

---

## 最简版本（MVP，先验证核心价值）

**聚焦：** 只做"引导对话 + 提示词生成"，不做代码生成（避免初期技术复杂度）

1. **输入想法** - 用户在文本框输入项目想法
2. **引导对话** - 系统通过3-7个问题明确需求（简化版/完整版可选）
3. **生成提示词** - 生成结构化提示词（可以复制去 ChatGPT/Claude 使用）
4. **保存历史** - 本地存储，方便复用

**价值验证：** 先验证"引导系统"是否真的能帮用户更好地使用 AI，再扩展为代码生成平台

---

## 提示词生成逻辑（最简版本）

**生成方式：** 固定模板 + 简单填充

**模板结构：**
```
【任务】{用户输入的想法}

【背景】
- 这是一个新项目/功能
- 使用 {项目技术栈}

【要求】
- 实现核心功能
- 代码清晰规范
- 确保可运行

【步骤】
1. 分析需求，确定实现方案
2. 创建必要的文件和代码结构
3. 实现核心功能
4. 测试验证

【验收标准】
- [ ] 功能正常运行
- [ ] 代码无明显错误
- [ ] 符合最佳实践
```

**填充规则：**
- 【任务】→ 直接使用用户输入的想法
- 【背景】→ 使用固定模板，技术栈默认为空（或让用户选择）
- 【要求】→ 使用固定的3条通用要求
- 【步骤】→ 使用固定的4步通用流程
- 【验收标准】→ 使用固定的3条通用标准

---

## 最简版本交互流程

**单页面设计：**
- 上方：输入区（多行文本框 + 生成按钮）
- 下方：结果展示区（生成的提示词 + 复制按钮）
- 侧边：历史记录（localStorage存储，可查看/复用）

**操作流程：**
输入想法 → 点击"生成" → 展示提示词 → 点击"复制" → 完成

---

## 完整版功能（五大模块）

**1. 💭 想法收集**
- 引导式对话，将模糊想法转化为清晰需求

**2. 📋 需求拆解**
- 自动拆解为可执行任务清单

**3. 🤖 AI 操作引导（核心）**
- 生成与 AI 对话的具体提示词

**4. 📊 进度跟踪**
- 可视化项目进度，记录关键决策

**5. 📚 知识库**
- 积累成功案例，形成可复用模板

---

# 🏗️ 技术架构

## 技术架构

**设计规范：** 遵循 guidebot.mdc 中定义的"三层架构"设计模式

**GuideBot 的具体实现：**

**第1层：引导层**
- 实现方式：引导式对话界面（右侧聊天框）
- 进度显示："第X步/共7步"
- 选项提供：每个问题都有选项或示例

**第2层：上下文管理层**
- 实现方式：实时整理用户对话为结构化提示词
- 展示方式：Tab2 提示词文档
- 版本管理：localStorage 存储历史

**第3层：输出层**
- 实现方式：提示词文档（可复制、可下载）
- 验证方式：左侧实时预览
- 复用方式：保存为模板

---

## 技术选型

**MVP 阶段（只做引导+提示词）：**
- **前端：** OVS 声明式语法 → 编译为 Vue 3
- **构建：** Vite（热更新、快速）
- **语言：** TypeScript（类型安全）
- **存储：** localStorage（本地存储）
- **AI 集成：** 暂不集成（生成提示词给用户，由用户去 ChatGPT 使用）
- **核心：** 上下文管理层（把对话整理成提示词）

**完整版阶段（加入代码生成）：**
- **AI 后端：** 
  - 方案1：调用 OpenAI API（GPT-4）
  - 方案2：集成开源大模型（如 Llama、Qwen）
  - 方案3：混合模式（免费用户用开源模型，付费用户用 GPT-4）
- **代码执行环境：**
  - 方案1：WebContainer（类似 StackBlitz，纯前端运行 Node.js）
  - 方案2：后端沙箱（Docker 容器）
- **部署集成：** Netlify/Vercel API（一键部署）
- **存储：** 云端数据库（保存项目、模板）

---

## UI设计

**页面布局：左右分栏**
- **左侧：文档展示区**（实时显示生成的提示词和需求文档，纯文本）
- **右侧：对话框**（与AI对话，引导明确需求）

**左侧文档内容：**
- 需求文档（按维度组织：功能、体验、技术...）
- AI提示词（结构化格式：任务、背景、要求、验收）
- 可复制、可导出
- 核心价值：用户拿着这些文本去ChatGPT/Claude等AI工具，就能生成网站

**交互流程（MVP阶段）：**
1. 打开网站 → 右侧对话框，左侧空白
2. 输入想法 → AI引导对话（一问一答）
3. 每次对话 → 左侧实时更新文档内容
4. 完成引导 → 左侧显示完整的需求文档+提示词
5. 复制文本 → 拿去AI工具生成网站代码

---

## 组件拆分

**OVS 组件：**
```
- MainPage.ovs        // 主页面
- IdeaInput.ovs       // 输入区
- PromptDisplay.ovs   // 结果展示
- HistoryPanel.ovs    // 历史记录
- Button.ovs          // 按钮
- TextArea.ovs        // 文本框
- Card.ovs            // 卡片
```

**工具函数（TS）：**
```
- promptGenerator.ts  // 提示词生成
- storage.ts          // 本地存储
```

---

## 项目结构

```
guidebot/
├── src/
│   ├── views/
│   │   └── MainPage.ovs
│   ├── components/
│   │   ├── IdeaInput.ovs
│   │   ├── PromptDisplay.ovs
│   │   ├── HistoryPanel.ovs
│   │   ├── Button.ovs
│   │   ├── TextArea.ovs
│   │   └── Card.ovs
│   └── utils/
│       ├── promptGenerator.ts
│       └── storage.ts
├── .cursor/rules/
│   ├── guidebot.mdc    # AI 工作规则与方法论
│   └── web.mdc    # 项目信息（本文件）
├── package.json
├── vite.config.ts
└── tsconfig.json
```

**说明：** 项目不使用 README.md，所有信息都在 `.cursor/rules/` 的两个 .mdc 文件中，由 Cursor 自动加载。

---

# 📊 核心数据结构

## Project（项目）

```typescript
interface Project {
  id: string
  name: string
  status: 'planning' | 'developing' | 'completed'
  
  initialIdea: string        // 最初的想法
  createdAt: string          // 创建时间
  updatedAt: string          // 更新时间
}

// 注：完整版可能包含 requirements、tasks、notes、decisions 等字段
// 最简版本暂时只用基本字段
```

---

## Task（任务）

```typescript
interface Task {
  id: string
  title: string
  status: 'todo' | 'inProgress' | 'completed'
  priority: 'P0' | 'P1' | 'P2'
  
  prompt: string
  expectedResult: string
  checkList: string[]
  dependencies: string[]
}
```

---

## PromptTemplate（提示词模板）

```typescript
interface PromptTemplate {
  id: string
  name: string
  category: 'init' | 'feature' | 'debug' | 'optimize'
  
  template: string
  variables: {name: string, description: string}[]
  examples: string[]
  usageCount: number
}
```

---

# 🎯 当前状态与开发计划

## 项目状态

| 项目 | 状态 |
|------|------|
| **阶段** | 需求设计阶段（STAGE_1_REQUIREMENTS） |
| **版本** | 0.1.0 (规划中) |
| **核心定位** | AI 辅助开发平台 + 强引导系统（类似 bolt.new 但更强调引导和教育） |
| **目标用户** | 零基础用户，包括儿童（一年级小孩也能用） |
| **当前步骤** | 正在明确完整用户流程和技术方案 |

---

## 📍 下一步行动

**当前正在执行：** 需求引导七维度（按行业最佳实践引导用户明确需求）

**进行中：**
- ⏳ 第1层-功能需求：明确网站的主要功能和用户能做什么（需要产出完整的功能清单）

**待完成：**
- 第2层-用户体验需求
- 第3层-技术需求
- 第4层-数据需求
- 第5层-安全需求
- 第6层-集成需求
- 第7层-优先级

---

## 版本迭代路线

**MVP 阶段 - 引导系统验证（1-2周）** ←【当前】
- [x] 明确产品定位（类似 bolt.new 但更强调引导）
- [ ] 创建项目脚手架
- [ ] 实现引导对话系统（7维度引导框架）
- [ ] 实现提示词生成器（固定模板 + 智能填充）
- [ ] 本地存储功能（历史记录）
- [ ] 简化 UI（单页面，聚焦核心流程）

**阶段2 - 代码生成集成（3-4周）**
- [ ] 集成 AI 后端（OpenAI API 或开源模型）
- [ ] 实现代码生成功能
- [ ] 实现实时预览（WebContainer 或后端沙箱）
- [ ] 代码解释功能（教育环节）
- [ ] 多轮对话修复（"我想改成XX" → AI 修改代码）

**阶段3 - 部署与协作（6-8周）**
- [ ] 一键部署（Netlify/Vercel 集成）
- [ ] 云端存储（项目保存、跨设备同步）
- [ ] 模板市场（成功案例沉淀）
- [ ] 用户账号系统
- [ ] 社区分享功能

**阶段4 - 教育增强（长期）**
- [ ] AI 使用教程（嵌入式学习）
- [ ] 成就系统（激励学习）
- [ ] 儿童模式（更简化的交互和语言）
- [ ] 多语言支持

---

## 🚀 快速开始

**技术栈：** OVS + Vue 3 + TypeScript + Vite（纯前端）

**计划中的启动方式（项目文件待创建）：**
```bash
cd guidebot
npm install          # 待创建 package.json
npm run dev          # 待配置 vite
# 访问 http://localhost:5173
```

**当前状态：** 项目脚手架尚未创建，上述命令暂不可用

**文档位置：**
- AI 工作规则与方法论：`.cursor/rules/guidebot.mdc`
- 项目信息（本文件）：`.cursor/rules/web.mdc`
- 两个文件都由 Cursor 自动加载

---

# 📝 变更记录（最近3次，仅用于回滚）

## 2025-10-12 [当前会话]
- 新增核心价值定位："不用深度思考怎么写提示词，也能很好的开发出产品"
  - 位置：项目定位-核心价值定位（第51行）
  - 改动：在核心价值定位最前面增加用户原话，明确GuideBot解决的核心问题
  - 影响：比"减少认知负担"更具体地说明了GuideBot的价值
- 根本原因：用户用一句话精准描述了GuideBot的核心价值，这比现有的抽象表述更直接、更通俗

- 明确MVP阶段的UI布局：左侧=文档展示（纯文本），右侧=对话框
  - 位置：UI设计章节（第464-481行）
  - 改动：
    1. 左侧从"预览区（显示网站效果）"改为"文档展示区（提示词+需求文档）"
    2. 右侧从"工作区（多Tab切换）"改为"对话框"
    3. 交互流程：每次对话 → 左侧实时更新文档内容（不是预览网站）
    4. 核心价值：输出文本，用户复制去AI工具使用（不是GuideBot内部生成代码）
  - 影响：明确了MVP阶段不做代码生成和预览，只做"引导对话+生成文本"
- 根本原因：用户纠正"左侧是根据提示词生成的UI界面"理解错误，明确"第一版只生成文本，不生成网站"

- 重大更新：项目定位从"提示词生成工具"升级为"AI 辅助开发平台+强引导系统"
  - 更新项目简介：明确对标 bolt.new，但加入强引导和教育属性
  - 更新项目定位：从"AI 协作引导助手"到"AI 辅助开发平台 + 强引导系统"
  - 扩展核心功能：新增代码生成、实时预览、一键部署、代码解释等
  - 明确目标用户：零基础用户，包括儿童（一年级小孩也能用）
  - 新增"与 bolt.new 的对比"章节，突出差异化优势
  - 重新设计用户体验流程：从想法输入到部署上线的完整 8 步流程
  - 扩展技术选型：增加 AI 集成、代码执行环境、部署集成等方案
  - 调整版本迭代路线：MVP 聚焦"引导系统验证"，后续逐步增加代码生成和部署功能
  - 更新当前状态：正在明确完整用户流程和技术方案
- 根本原因：用户明确表达了新的需求定位："类似 bolt.new 但更高级，帮助零基础用户（甚至一年级小孩）通过引导开发网站"

## 2025-10-12 01:20
- 修复项目信息中的模糊和不完善之处
  - 补充"提示词生成逻辑"的完整填充规则（5个字段的填充方式）
  - 简化 Project 数据结构：移除未定义的类型引用，只保留基本字段
  - 更新"快速开始"章节：标注为"计划中的启动方式"，说明项目文件待创建
- 根本原因：用户要求检查规则文件，发现项目信息中有模糊和不完善之处

## 2025-10-12 01:05
- 创建 web.mdc 专属变更记录
  - 每个 .mdc 文件独立维护自己的变更历史
  - web.mdc 记录项目信息、功能设计、技术架构、状态变更
- 根本原因：用户要求分别在两个 .mdc 中创建各自的变更记录

## 2025-10-12 00:55
- 删除 README.md，内容完全迁移到 web.mdc
  - 合并内容：项目简介、核心功能、快速开始
  - 更新项目结构说明，移除 README.md 引用
  - 项目不再使用 README.md
- 根本原因：用户要求删除 README.md，避免信息分散

---

**项目版本:** 0.1.0 (规划阶段)  
**最后更新:** 2025-10-12 [当前会话 - 重大定位调整]
