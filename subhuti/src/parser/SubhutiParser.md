# SubhutiParser è¯¦ç»†è¯´æ˜æ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
2. [ä¸¤ä¸ªæ ¸å¿ƒæ ‡è¯†](#ä¸¤ä¸ªæ ¸å¿ƒæ ‡è¯†)
3. [è§„åˆ™è¯¦è§£](#è§„åˆ™è¯¦è§£)
4. [æ‰§è¡Œæµç¨‹æ¨¡æ‹Ÿ](#æ‰§è¡Œæµç¨‹æ¨¡æ‹Ÿ)
5. [å¸¸è§é—®é¢˜å’Œè°ƒè¯•](#å¸¸è§é—®é¢˜å’Œè°ƒè¯•)
6. [è®¾è®¡å“²å­¦](#è®¾è®¡å“²å­¦)

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### ä»€ä¹ˆæ˜¯ SubhutiParserï¼Ÿ

SubhutiParser æ˜¯ä¸€ä¸ªåŸºäº **PEGï¼ˆParsing Expression Grammarï¼‰** é£æ ¼çš„è§£æå™¨æ¡†æ¶ï¼Œæ ¸å¿ƒç‰¹ç‚¹ï¼š

- **é¡ºåºé€‰æ‹©ï¼ˆOrdered Choiceï¼‰**ï¼šOrè§„åˆ™æŒ‰é¡ºåºå°è¯•ï¼Œç¬¬ä¸€ä¸ªæˆåŠŸå³è¿”å›
- **å›æº¯æ”¯æŒï¼ˆBacktrackingï¼‰**ï¼šåˆ†æ”¯å¤±è´¥æ—¶å¯ä»¥å›é€€çŠ¶æ€ï¼Œå°è¯•å…¶ä»–åˆ†æ”¯
- **CSTç”Ÿæˆï¼ˆConcrete Syntax Treeï¼‰**ï¼šä¿ç•™å®Œæ•´çš„è¯­æ³•ç»“æ„ï¼ŒåŒ…æ‹¬æ‰€æœ‰token
- **è£…é¥°å™¨é©±åŠ¨**ï¼šä½¿ç”¨ `@SubhutiRule` è£…é¥°å™¨å®šä¹‰è§„åˆ™

### æ ¸å¿ƒæ¶æ„

```
Parser è§„åˆ™
    â†“
  è£…é¥°å™¨åŒ…è£…ï¼ˆ@SubhutiRuleï¼‰
    â†“
  æ‰§è¡Œè§„åˆ™ï¼ˆsubhutiRuleï¼‰
    â†“
  å¤„ç†CSTï¼ˆprocessCstï¼‰
    â†“
  ç”ŸæˆCSTæ ‘
```

---

## ğŸ”‘ ä¸¤ä¸ªæ ¸å¿ƒæ ‡è¯†

SubhutiParser ä½¿ç”¨ä¸¤ä¸ªæ ‡è¯†æ¥æ§åˆ¶è§£ææµç¨‹ï¼š

### 1. ruleMatchSuccess - å…¨å±€åŒ¹é…çŠ¶æ€

**ä½œç”¨åŸŸï¼š** å…¨å±€

**è¯­ä¹‰ï¼š** å½“å‰è§„åˆ™æ˜¯å¦å¯ä»¥ç»§ç»­æ‰§è¡Œ

**ç”¨é€”ï¼š**
- æ§åˆ¶æ•´ä¸ªè§£ææµç¨‹æ˜¯å¦ç»§ç»­
- å‡ ä¹æ‰€æœ‰è§„åˆ™å…¥å£éƒ½æ£€æŸ¥ï¼š`if (!this.ruleMatchSuccess) return`
- å¤±è´¥æ—¶ï¼šåç»­è§„åˆ™ä¸å†æ‰§è¡Œ

**çŠ¶æ€å˜åŒ–ï¼š**
```typescript
// æˆåŠŸæ—¶
this.setRuleMatchSuccess(true)

// å¤±è´¥æ—¶
this.setRuleMatchSuccess(false)
```

### 2. loopMatchSuccess - å¾ªç¯è·³å‡ºæ§åˆ¶

**ä½œç”¨åŸŸï¼š** Or/Many/Option è§„åˆ™å†…éƒ¨

**è¯­ä¹‰ï¼š** æ˜¯å¦åº”è¯¥è·³å‡º Or å¾ªç¯ï¼ˆåˆ†æ”¯æˆåŠŸä¿¡å·ï¼‰

**ç”¨é€”ï¼š**
- Orï¼šåˆ¤æ–­åˆ†æ”¯æ˜¯å¦æˆåŠŸï¼Œå†³å®š break è¿˜æ˜¯ç»§ç»­å°è¯•
- Manyï¼šæ§åˆ¶å¾ªç¯æ˜¯å¦ç»§ç»­ï¼ˆé€€å‡ºæ—¶æ€»æ˜¯è®¾ä¸º trueï¼‰
- Optionï¼šå‘å¤–ä¼ æ’­æˆåŠŸä¿¡å·ï¼ˆæ€»æ˜¯è®¾ä¸º trueï¼‰

**ç‰¹æ€§ï¼š**
- Or è§„åˆ™æ¯æ¬¡å°è¯•åˆ†æ”¯å‰é‡ç½®ä¸º false
- Option/Many é€€å‡ºæ—¶æ€»æ˜¯è®¾ä¸º true

### ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªæ ‡è¯†ï¼Ÿ

**é—®é¢˜åœºæ™¯ï¼š**
```typescript
// Or éœ€è¦"å°è¯•å¤±è´¥åç»§ç»­"çš„èƒ½åŠ›
this.Or([
  {alt: () => this.A()},  // âŒ å¤±è´¥
  {alt: () => this.B()}   // éœ€è¦ç»§ç»­å°è¯•
])
```

**å¦‚æœåªæœ‰ä¸€ä¸ªæ ‡è¯†ï¼š**
- A å¤±è´¥ â†’ è®¾ä¸º false
- B æ— æ³•æ‰§è¡Œï¼ˆå› ä¸ºæ ‡è¯†ä¸º falseï¼‰

**è§£å†³æ–¹æ¡ˆï¼šåˆ†ç¦»ä¸¤ä¸ªèŒè´£**
- `ruleMatchSuccess`ï¼šæ§åˆ¶"æ˜¯å¦å¯ä»¥æ‰§è¡Œ"ï¼ˆå›é€€æ—¶è®¾ä¸º trueï¼‰
- `loopMatchSuccess`ï¼šæ§åˆ¶"æ˜¯å¦åº”è¯¥è·³å‡º"ï¼ˆæ¯æ¬¡å°è¯•å‰é‡ç½®ï¼‰

### ååŒå·¥ä½œç¤ºä¾‹

```typescript
// Or è§„åˆ™æ‰§è¡Œæµç¨‹
1. å°è¯•åˆ†æ”¯Aå‰ï¼š
   setLoopMatchSuccess(false)      // é‡ç½®è·³å‡ºæ ‡è¯†
   ruleMatchSuccess = true         // å…è®¸æ‰§è¡Œ

2. åˆ†æ”¯Aå¤±è´¥ï¼š
   ruleMatchSuccess = false
   loopMatchSuccess = false
   åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = false â†’ ç»§ç»­å¾ªç¯

3. å›é€€ï¼š
   setBackDataAndRuleMatchSuccess() â†’ ruleMatchSuccess = true

4. å°è¯•åˆ†æ”¯Bå‰ï¼š
   setLoopMatchSuccess(false)      // é‡æ–°é‡ç½®
   ruleMatchSuccess = true         // å¯ä»¥æ‰§è¡Œ

5. åˆ†æ”¯BæˆåŠŸï¼š
   ruleMatchSuccess = true
   loopMatchSuccess = true
   åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = true â†’ break
```

---

## ğŸ“š è§„åˆ™è¯¦è§£

### Option - åŒ¹é…0æ¬¡æˆ–1æ¬¡ï¼ˆæ€»æ˜¯æˆåŠŸï¼‰

**è¯­ä¹‰ï¼š** `Option(A)` è¡¨ç¤º A å¯ä»¥å‡ºç° 0 æ¬¡æˆ– 1 æ¬¡

**æ‰§è¡Œæµç¨‹ï¼š**
```typescript
Option(fun: Function) {
    1. ä¿å­˜çŠ¶æ€å¿«ç…§
    2. æ‰§è¡Œ fun()
    3. å¦‚æœå¤±è´¥ â†’ å›é€€çŠ¶æ€ï¼ˆä½† Option æœ¬èº«ä¸å¤±è´¥ï¼‰
    4. æ— æ¡ä»¶è®¾ç½® loopMatchSuccess = true
    5. è¿”å› CST
}
```

**åœºæ™¯æ¨¡æ‹Ÿï¼š**

**åœºæ™¯1ï¼š0æ¬¡åŒ¹é…ï¼ˆå†…éƒ¨è§„åˆ™å¤±è´¥ï¼‰**
```
Tokenæµï¼š[name]

1. ä¿å­˜å¿«ç…§
2. æ‰§è¡Œ fun() â†’ å°è¯•åŒ¹é… "export"
3. å¤±è´¥ï¼šruleMatchSuccess = false
4. å›é€€ï¼šruleMatchSuccess = true âœ…
5. è®¾ç½®ï¼šloopMatchSuccess = true âœ…
6. è¿”å›ï¼šç©ºCSTï¼ˆchildrenä¸ºç©ºï¼‰

ç»“æœï¼šOption æˆåŠŸï¼Œè¿”å›ç©º CST
```

**åœºæ™¯2ï¼š1æ¬¡åŒ¹é…ï¼ˆå†…éƒ¨è§„åˆ™æˆåŠŸï¼‰**
```
Tokenæµï¼š[export, name]

1. ä¿å­˜å¿«ç…§
2. æ‰§è¡Œ fun() â†’ åŒ¹é… "export" âœ…
3. æˆåŠŸï¼šruleMatchSuccess = true, loopMatchSuccess = true
4. è®¾ç½®ï¼šloopMatchSuccess = trueï¼ˆå·²ç»æ˜¯trueï¼‰
5. è¿”å›ï¼šå¸¦å†…å®¹çš„ CST

ç»“æœï¼šOption æˆåŠŸï¼Œè¿”å›å¸¦ "export" çš„ CST
```

**å…³é”®ç‚¹ï¼š**
- ä¸ºä»€ä¹ˆæ— æ¡ä»¶è®¾ç½® `loopMatchSuccess = true`ï¼Ÿ
  - Option çš„è¯­ä¹‰æ˜¯"0æ¬¡æˆ–1æ¬¡éƒ½ç®—æˆåŠŸ"
  - å¿…é¡»å‘å¤–å±‚ Or ä¼ æ’­æˆåŠŸä¿¡å·
  - å³ä½¿ 0 æ¬¡åŒ¹é…ï¼ŒOption æœ¬èº«ä¹Ÿæ˜¯æˆåŠŸçš„

---

### Many - åŒ¹é…0æ¬¡æˆ–å¤šæ¬¡ï¼ˆæ€»æ˜¯æˆåŠŸï¼‰

**è¯­ä¹‰ï¼š** `Many(A)` è¡¨ç¤º A å¯ä»¥å‡ºç° 0 æ¬¡æˆ–å¤šæ¬¡

**æ‰§è¡Œæµç¨‹ï¼š**
```typescript
Many(fun: Function) {
    1. è®¾ç½® loopMatchSuccess = trueï¼ˆè®© while å¯ä»¥è¿›å…¥ï¼‰
    2. while (loopBranchAndRuleSuccess) {
         a. é‡ç½® loopMatchSuccess = false
         b. æ‰§è¡Œ fun()
         c. å¦‚æœå¤±è´¥ â†’ å›é€€å¹¶ break
         d. matchCount++
       }
    3. è®¾ç½® loopMatchSuccess = true
    4. è¿”å› CST
}
```

**åœºæ™¯æ¨¡æ‹Ÿï¼š**

**åœºæ™¯1ï¼š0æ¬¡åŒ¹é…ï¼ˆç¬¬ä¸€æ¬¡å°±å¤±è´¥ï¼‰**
```
Tokenæµï¼š[return]ï¼ˆæ²¡æœ‰ statementï¼‰

æ‰§è¡Œæ­¥éª¤ï¼š
1. loopMatchSuccess = true
2. è¿›å…¥ whileï¼ˆæ¡ä»¶ä¸º trueï¼‰
3. é‡ç½® loopMatchSuccess = false
4. æ‰§è¡Œ fun() â†’ å°è¯•åŒ¹é… Statement
5. å¤±è´¥ï¼šruleMatchSuccess = false
6. å›é€€ï¼šruleMatchSuccess = true
7. break
8. è®¾ç½®ï¼šloopMatchSuccess = true
9. è¿”å›ï¼šç©º CST

çŠ¶æ€å˜åŒ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ­¥éª¤            â”‚ ruleMatchSuccess â”‚ loopMatchSuccess â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. åˆå§‹è®¾ç½®     â”‚ true             â”‚ true âœ…          â”‚
â”‚ 2. è¿›å…¥while    â”‚ true             â”‚ true             â”‚
â”‚ 3. é‡ç½®         â”‚ true             â”‚ false            â”‚
â”‚ 4. fun()å¤±è´¥    â”‚ false            â”‚ false            â”‚
â”‚ 5. å›é€€         â”‚ true âœ…          â”‚ false            â”‚
â”‚ 6. é€€å‡ºè®¾ç½®     â”‚ true             â”‚ true âœ…          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“æœï¼šMany æˆåŠŸï¼ŒmatchCount = 0
```

**åœºæ™¯2ï¼š1æ¬¡åŒ¹é…**
```
Tokenæµï¼š[name, ;, return]

æ‰§è¡Œæ­¥éª¤ï¼š
ç¬¬ä¸€æ¬¡å¾ªç¯ï¼š
1. loopMatchSuccess = true
2. è¿›å…¥ while
3. é‡ç½® loopMatchSuccess = false
4. æ‰§è¡Œ fun() â†’ åŒ¹é… Statement âœ…
5. æˆåŠŸï¼šruleMatchSuccess = true, loopMatchSuccess = true
6. matchCount = 1
7. ç»§ç»­å¾ªç¯

ç¬¬äºŒæ¬¡å¾ªç¯ï¼š
1. é‡ç½® loopMatchSuccess = false
2. æ‰§è¡Œ fun() â†’ å°è¯•åŒ¹é… Statement
3. å¤±è´¥ï¼šruleMatchSuccess = false
4. å›é€€ï¼šruleMatchSuccess = true
5. break

ç»“æŸï¼š
1. è®¾ç½®ï¼šloopMatchSuccess = true
2. è¿”å›ï¼šå¸¦ 1 ä¸ªå­èŠ‚ç‚¹çš„ CST

çŠ¶æ€å˜åŒ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ­¥éª¤            â”‚ ruleMatchSuccess â”‚ loopMatchSuccess â”‚ ç»“æœ     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. åˆå§‹è®¾ç½®     â”‚ true             â”‚ true             â”‚ è¿›å…¥å¾ªç¯ â”‚
â”‚ 2. ç¬¬1æ¬¡é‡ç½®    â”‚ true             â”‚ false            â”‚          â”‚
â”‚ 3. ç¬¬1æ¬¡fun()   â”‚ true             â”‚ true âœ…          â”‚ æˆåŠŸ     â”‚
â”‚ 4. ç¬¬2æ¬¡é‡ç½®    â”‚ true             â”‚ false            â”‚          â”‚
â”‚ 5. ç¬¬2æ¬¡fun()   â”‚ false            â”‚ false            â”‚ å¤±è´¥     â”‚
â”‚ 6. å›é€€         â”‚ true             â”‚ false            â”‚          â”‚
â”‚ 7. é€€å‡ºè®¾ç½®     â”‚ true             â”‚ true             â”‚ ç»“æŸ     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“æœï¼šMany æˆåŠŸï¼ŒmatchCount = 1
```

**åœºæ™¯3ï¼šNæ¬¡åŒ¹é…**
```
Tokenæµï¼š[stmt1, ;, stmt2, ;, stmt3, ;, return]

æ¯æ¬¡å¾ªç¯ï¼š
- é‡ç½® loopMatchSuccess = false
- æ‰§è¡Œ fun() â†’ æˆåŠŸ â†’ loopMatchSuccess = true
- matchCount++
- ç»§ç»­å¾ªç¯

ç›´åˆ°æŸæ¬¡å¤±è´¥ï¼š
- å›é€€ â†’ break
- è¿”å›å¸¦ N ä¸ªå­èŠ‚ç‚¹çš„ CST

ç»“æœï¼šMany æˆåŠŸï¼ŒmatchCount = N
```

**å…³é”®ç‚¹ï¼š**
- ä¸ºä»€ä¹ˆåˆå§‹åŒ– `loopMatchSuccess = true`ï¼Ÿ
  - è®© while æ¡ä»¶ç¬¬ä¸€æ¬¡ä¸º trueï¼Œå¯ä»¥è¿›å…¥å¾ªç¯
  - å¦åˆ™é»˜è®¤å€¼ä¸º falseï¼Œwhile æ°¸è¿œä¸ä¼šè¿›å…¥
- ä¸ºä»€ä¹ˆæ¯æ¬¡å¾ªç¯é‡ç½®ä¸º falseï¼Ÿ
  - æ¸…ç©ºçŠ¶æ€ï¼Œè®©å†…éƒ¨è§„åˆ™é‡æ–°è®¾ç½®
  - å¦‚æœæˆåŠŸä¼šè®¾ä¸º trueï¼Œå¤±è´¥ä¿æŒ false
- ä¸ºä»€ä¹ˆé€€å‡ºæ—¶è®¾ä¸º trueï¼Ÿ
  - Many æ€»æ˜¯æˆåŠŸï¼ˆ0æ¬¡æˆ–å¤šæ¬¡éƒ½ç®—æˆåŠŸï¼‰
  - å¿…é¡»å‘ Or ä¼ æ’­æˆåŠŸä¿¡å·

---

### Or - é¡ºåºé€‰æ‹©ï¼ˆç¬¬ä¸€ä¸ªæˆåŠŸå³è¿”å›ï¼‰

**è¯­ä¹‰ï¼š** `Or([A, B, C])` è¡¨ç¤ºæŒ‰é¡ºåºå°è¯• Aã€Bã€Cï¼Œç¬¬ä¸€ä¸ªæˆåŠŸçš„ç«‹å³è¿”å›

**é‡è¦ç‰¹æ€§ï¼š**
- **ä¸æ˜¯è´ªå©ªåŒ¹é…**ï¼šä¸ä¼šå°è¯•æ‰€æœ‰åˆ†æ”¯é€‰æœ€é•¿
- **ä¸æ˜¯å¹¶è¡Œå°è¯•**ï¼šæŒ‰é¡ºåºå°è¯•ï¼ŒæˆåŠŸå³åœæ­¢
- **é¡ºåºå¾ˆé‡è¦**ï¼šé•¿è§„åˆ™å¿…é¡»åœ¨å‰ï¼ŒçŸ­è§„åˆ™åœ¨å

**æ‰§è¡Œæµç¨‹ï¼š**
```typescript
Or(branches: SubhutiParserOr[]) {
    for (const branch of branches) {
        1. ä¿å­˜çŠ¶æ€å¿«ç…§
        2. é‡ç½® loopMatchSuccess = false
        3. æ‰§è¡Œ branch.alt()
        4. å¦‚æœæˆåŠŸ â†’ break
        5. å¦‚æœå¤±è´¥ â†’ å›é€€çŠ¶æ€ â†’ ç»§ç»­ä¸‹ä¸€ä¸ª
    }
    6. åˆ¤æ–­æ˜¯å¦æœ‰åˆ†æ”¯æˆåŠŸ
    7. è¿”å› CST æˆ– undefined
}
```

**åœºæ™¯æ¨¡æ‹Ÿï¼š**

**åœºæ™¯1ï¼šç¬¬ä¸€ä¸ªåˆ†æ”¯æˆåŠŸ**
```
Tokenæµï¼š[name]

this.Or([
  {alt: () => this.Identifier()},  // åˆ†æ”¯A
  {alt: () => this.Literal()}      // åˆ†æ”¯B
])

æ‰§è¡Œæ­¥éª¤ï¼š
1. å°è¯•åˆ†æ”¯Aï¼ˆIdentifierï¼‰
   a. ä¿å­˜å¿«ç…§
   b. loopMatchSuccess = false
   c. æ‰§è¡Œ Identifier() â†’ åŒ¹é… "name" âœ…
   d. ruleMatchSuccess = true, loopMatchSuccess = true
   e. åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = true â†’ break

2. é€€å‡ºå¾ªç¯
   åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = true
   è¿”å›ï¼šCSTï¼ˆIdentifierèŠ‚ç‚¹ï¼‰

çŠ¶æ€å˜åŒ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ­¥éª¤         â”‚ ruleMatchSuccess â”‚ loopMatchSuccess â”‚ ç»“æœ       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. é‡ç½®      â”‚ true             â”‚ false            â”‚            â”‚
â”‚ 2. æ‰§è¡ŒA     â”‚ true             â”‚ true âœ…          â”‚ æˆåŠŸ       â”‚
â”‚ 3. åˆ¤æ–­      â”‚ true             â”‚ true             â”‚ break      â”‚
â”‚ 4. æœ€ååˆ¤æ–­  â”‚ true             â”‚ true             â”‚ è¿”å›CST âœ… â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“æœï¼šOr æˆåŠŸï¼Œè¿”å›ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„ CST
```

**åœºæ™¯2ï¼šç¬¬ä¸€ä¸ªå¤±è´¥ï¼Œç¬¬äºŒä¸ªæˆåŠŸ**
```
Tokenæµï¼š[123]

this.Or([
  {alt: () => this.Identifier()},  // åˆ†æ”¯A
  {alt: () => this.Literal()}      // åˆ†æ”¯B
])

æ‰§è¡Œæ­¥éª¤ï¼š
1. å°è¯•åˆ†æ”¯Aï¼ˆIdentifierï¼‰
   a. ä¿å­˜å¿«ç…§
   b. loopMatchSuccess = false
   c. æ‰§è¡Œ Identifier() â†’ å°è¯•åŒ¹é…æ ‡è¯†ç¬¦
   d. å¤±è´¥ï¼šruleMatchSuccess = false, loopMatchSuccess = false
   e. åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = false â†’ ç»§ç»­
   f. å›é€€ï¼šruleMatchSuccess = true âœ…

2. å°è¯•åˆ†æ”¯Bï¼ˆLiteralï¼‰
   a. ä¿å­˜å¿«ç…§
   b. loopMatchSuccess = false
   c. æ‰§è¡Œ Literal() â†’ åŒ¹é… "123" âœ…
   d. ruleMatchSuccess = true, loopMatchSuccess = true
   e. åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = true â†’ break

3. é€€å‡ºå¾ªç¯
   åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = true
   è¿”å›ï¼šCSTï¼ˆLiteralèŠ‚ç‚¹ï¼‰

çŠ¶æ€å˜åŒ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ­¥éª¤         â”‚ ruleMatchSuccess â”‚ loopMatchSuccess â”‚ ç»“æœ       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. åˆ†æ”¯Aé‡ç½® â”‚ true             â”‚ false            â”‚            â”‚
â”‚ 2. æ‰§è¡ŒA     â”‚ false            â”‚ false            â”‚ å¤±è´¥       â”‚
â”‚ 3. å›é€€      â”‚ true âœ…          â”‚ false            â”‚ å…è®¸ç»§ç»­   â”‚
â”‚ 4. åˆ†æ”¯Bé‡ç½® â”‚ true             â”‚ false            â”‚            â”‚
â”‚ 5. æ‰§è¡ŒB     â”‚ true             â”‚ true âœ…          â”‚ æˆåŠŸ       â”‚
â”‚ 6. åˆ¤æ–­      â”‚ true             â”‚ true             â”‚ break      â”‚
â”‚ 7. æœ€ååˆ¤æ–­  â”‚ true             â”‚ true             â”‚ è¿”å›CST âœ… â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“æœï¼šOr æˆåŠŸï¼Œè¿”å›ç¬¬äºŒä¸ªåˆ†æ”¯çš„ CST
```

**åœºæ™¯3ï¼šæ‰€æœ‰åˆ†æ”¯éƒ½å¤±è´¥**
```
Tokenæµï¼š[;]

this.Or([
  {alt: () => this.Identifier()},  // åˆ†æ”¯A
  {alt: () => this.Literal()}      // åˆ†æ”¯Bï¼ˆæœ€åä¸€ä¸ªï¼‰
])

æ‰§è¡Œæ­¥éª¤ï¼š
1. å°è¯•åˆ†æ”¯Aï¼ˆIdentifierï¼‰
   a. å¤±è´¥
   b. å›é€€ï¼šruleMatchSuccess = true âœ…

2. å°è¯•åˆ†æ”¯Bï¼ˆLiteralï¼Œæœ€åä¸€ä¸ªï¼‰
   a. ä¿å­˜å¿«ç…§
   b. loopMatchSuccess = false
   c. æ‰§è¡Œ Literal() â†’ å¤±è´¥
   d. ruleMatchSuccess = false, loopMatchSuccess = false
   e. åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = false â†’ ç»§ç»­
   f. å›é€€ï¼ˆæœ€åä¸€ä¸ªï¼‰ï¼šä¸ä¿®æ”¹ ruleMatchSuccess âš ï¸
      â†’ ruleMatchSuccess ä¿æŒä¸º false

3. é€€å‡ºå¾ªç¯
   åˆ¤æ–­ï¼šloopBranchAndRuleSuccess = false
   è¿”å›ï¼šundefined

çŠ¶æ€å˜åŒ–ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ­¥éª¤         â”‚ ruleMatchSuccess â”‚ loopMatchSuccess â”‚ ç»“æœ         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. åˆ†æ”¯A     â”‚ false            â”‚ false            â”‚ å¤±è´¥         â”‚
â”‚ 2. å›é€€      â”‚ true âœ…          â”‚ false            â”‚ ç»§ç»­å°è¯•     â”‚
â”‚ 3. åˆ†æ”¯B     â”‚ false            â”‚ false            â”‚ å¤±è´¥ï¼ˆæœ€åï¼‰ â”‚
â”‚ 4. å›é€€      â”‚ false âš ï¸         â”‚ false            â”‚ ä¸ä¿®æ”¹çŠ¶æ€   â”‚
â”‚ 5. æœ€ååˆ¤æ–­  â”‚ false            â”‚ false            â”‚ è¿”å›undefinedâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç»“æœï¼šOr å¤±è´¥ï¼Œè¿”å› undefinedï¼Œå‘å¤–ä¼ æ’­å¤±è´¥ä¿¡å·
```

**å…³é”®ç‚¹ï¼š**
- ä¸ºä»€ä¹ˆæ¯æ¬¡å°è¯•å‰é‡ç½® `loopMatchSuccess = false`ï¼Ÿ
  - æ¸…é™¤ä¸Šä¸€ä¸ªåˆ†æ”¯çš„çŠ¶æ€
  - è®©å½“å‰åˆ†æ”¯"é‡æ–°å¼€å§‹"
  - é˜²æ­¢ä¸Šä¸€ä¸ªåˆ†æ”¯çš„æˆåŠŸçŠ¶æ€å½±å“å½“å‰åˆ†æ”¯
  
- ä¸ºä»€ä¹ˆéæœ€ååˆ†æ”¯å¤±è´¥è¦è®¾ç½® `ruleMatchSuccess = true`ï¼Ÿ
  - å…è®¸ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªåˆ†æ”¯
  - ä¸èƒ½è®©è¿™æ¬¡å¤±è´¥é˜»æ­¢åç»­æ‰§è¡Œ
  
- ä¸ºä»€ä¹ˆæœ€ååˆ†æ”¯å¤±è´¥ä¸ä¿®æ”¹ `ruleMatchSuccess`ï¼Ÿ
  - æ‰€æœ‰åˆ†æ”¯éƒ½å¤±è´¥ï¼Œæ•´ä¸ª Or å¤±è´¥
  - ä¿æŒ `ruleMatchSuccess = false`ï¼Œå‘å¤–ä¼ æ’­å¤±è´¥ä¿¡å·

---

### AT_LEAST_ONE - åŒ¹é…1æ¬¡æˆ–å¤šæ¬¡

**è¯­ä¹‰ï¼š** `AT_LEAST_ONE(A)` è¡¨ç¤º A è‡³å°‘å‡ºç° 1 æ¬¡

**ä¸ Many çš„åŒºåˆ«ï¼š**
- Manyï¼š0 æ¬¡æˆåŠŸä¹Ÿç®—æˆåŠŸ
- AT_LEAST_ONEï¼šè‡³å°‘ 1 æ¬¡æˆåŠŸæ‰ç®—æˆåŠŸ

**æ‰§è¡Œæµç¨‹ï¼š**
```typescript
AT_LEAST_ONE(fun: Function) {
    let index = 0
    while (ruleMatchSuccess) {
        if (index > 0) {
            // ç¬¬2æ¬¡åŠä»¥åï¼šå…è®¸å¤±è´¥ï¼ˆç±»ä¼¼Manyï¼‰
            ä¿å­˜å¿«ç…§
            æ‰§è¡Œ fun()
            å¦‚æœå¤±è´¥ â†’ å›é€€å¹¶ break
        } else {
            // ç¬¬1æ¬¡ï¼šå¿…é¡»æˆåŠŸ
            æ‰§è¡Œ fun()
            å¦‚æœå¤±è´¥ â†’ å‘å¤–ä¼ æ’­å¤±è´¥ï¼ˆä¸å›é€€ï¼‰
        }
        index++
    }
}
```

**åœºæ™¯æ¨¡æ‹Ÿï¼š**

**åœºæ™¯1ï¼šç¬¬1æ¬¡å¤±è´¥**
```
Tokenæµï¼š[return]ï¼ˆæ²¡æœ‰ statementï¼‰

æ‰§è¡Œæ­¥éª¤ï¼š
1. index = 0ï¼ˆç¬¬1æ¬¡ï¼‰
2. æ‰§è¡Œ fun() â†’ å¤±è´¥
3. ruleMatchSuccess = false
4. ä¸å›é€€ï¼Œç›´æ¥é€€å‡º
5. å‘å¤–ä¼ æ’­å¤±è´¥ä¿¡å·

ç»“æœï¼šAT_LEAST_ONE å¤±è´¥
```

**åœºæ™¯2ï¼šåŒ¹é…Næ¬¡**
```
Tokenæµï¼š[stmt1, ;, stmt2, ;, return]

æ‰§è¡Œæ­¥éª¤ï¼š
ç¬¬1æ¬¡ï¼ˆindex = 0ï¼‰ï¼š
- æ‰§è¡Œ fun() â†’ æˆåŠŸ âœ…
- index = 1

ç¬¬2æ¬¡ï¼ˆindex = 1ï¼‰ï¼š
- ä¿å­˜å¿«ç…§ï¼ˆå…è®¸å¤±è´¥ï¼‰
- æ‰§è¡Œ fun() â†’ æˆåŠŸ âœ…
- index = 2

ç¬¬3æ¬¡ï¼ˆindex = 2ï¼‰ï¼š
- ä¿å­˜å¿«ç…§
- æ‰§è¡Œ fun() â†’ å¤±è´¥
- å›é€€å¹¶ break

ç»“æœï¼šAT_LEAST_ONE æˆåŠŸï¼ŒåŒ¹é… 2 æ¬¡
```

---

## ğŸ”„ å›é€€æœºåˆ¶è¯¦è§£

### backData å¿«ç…§ç»“æ„

```typescript
interface SubhutiBackData {
    tokenIndex: number              // tokens è¯»å–ä½ç½®
    curCstChildrenLength: number    // children æ•°ç»„é•¿åº¦
    curCstTokensLength: number      // tokens æ•°ç»„é•¿åº¦
}
```

**ç‰¹ç‚¹ï¼š**
- O(1) æ—¶é—´å¤æ‚åº¦ï¼ˆåªæ‹·è´ 3 ä¸ªæ•°å­—ï¼‰
- é¿å…æ·±æ‹·è´ï¼ˆæ¯”æ·±æ‹·è´å¿« 1000 å€ä»¥ä¸Šï¼‰

### ä¸¤ç§å›é€€æ–¹æ³•

**æ–¹æ³•1ï¼šsetBackDataAndRuleMatchSuccess(backData)**

**è¯­ä¹‰ï¼š** æ’¤é”€å°è¯•ï¼Œæ¢å¤çŠ¶æ€ï¼Œå¹¶å…è®¸ç»§ç»­æ‰§è¡Œ

**ä½¿ç”¨åœºæ™¯ï¼š**
- Orè§„åˆ™ï¼šéæœ€ååˆ†æ”¯å¤±è´¥
- Manyè§„åˆ™ï¼šæŸæ¬¡å¾ªç¯å¤±è´¥
- Optionè§„åˆ™ï¼šå†…éƒ¨è§„åˆ™å¤±è´¥

**æ“ä½œï¼š**
```typescript
1. è®¾ç½® ruleMatchSuccess = trueï¼ˆå…è®¸ç»§ç»­ï¼‰
2. æ¢å¤ tokenIndex
3. åˆ é™¤æ–°å¢çš„ children
4. åˆ é™¤æ–°å¢çš„ tokens
```

**æ–¹æ³•2ï¼šsetBackDataNoContinueMatch(backData)**

**è¯­ä¹‰ï¼š** åªæ’¤é”€æ•°æ®ï¼Œä¸æ”¹å˜æ‰§è¡ŒçŠ¶æ€

**ä½¿ç”¨åœºæ™¯ï¼š**
- Orè§„åˆ™ï¼šæœ€åä¸€ä¸ªåˆ†æ”¯å¤±è´¥

**æ“ä½œï¼š**
```typescript
1. ä¸ä¿®æ”¹ ruleMatchSuccessï¼ˆä¿æŒä¸º falseï¼‰
2. æ¢å¤ tokenIndex
3. åˆ é™¤æ–°å¢çš„ children
4. åˆ é™¤æ–°å¢çš„ tokens
```

### å›é€€ç¤ºä¾‹

```
åˆå§‹çŠ¶æ€ï¼š
tokenIndex = 5
children = [A, B]
tokens = [tok1, tok2]

æ‰§è¡Œåˆ†æ”¯ï¼š
tokenIndex = 8ï¼ˆæ¶ˆè€—äº†3ä¸ªtokenï¼‰
children = [A, B, C, D]ï¼ˆæ–°å¢2ä¸ªèŠ‚ç‚¹ï¼‰
tokens = [tok1, tok2, tok3, tok4, tok5]ï¼ˆæ–°å¢3ä¸ªtokenï¼‰

å›é€€åï¼š
tokenIndex = 5ï¼ˆæ¢å¤ï¼‰
children = [A, B]ï¼ˆåˆ é™¤Cã€Dï¼‰
tokens = [tok1, tok2]ï¼ˆåˆ é™¤tok3ã€tok4ã€tok5ï¼‰
```

---

## ğŸ› å¸¸è§é—®é¢˜å’Œè°ƒè¯•

### é—®é¢˜1ï¼šOr è§„åˆ™æ°¸è¿œé€‰ç¬¬ä¸€ä¸ªåˆ†æ”¯

**ç—‡çŠ¶ï¼š**
```typescript
this.Or([
  {alt: () => this.Identifier()},        // æ€»æ˜¯åŒ¹é…è¿™ä¸ª
  {alt: () => this.IdentifierWithType()} // æ°¸è¿œä¸ä¼šå°è¯•
])
```

**åŸå› ï¼š** çŸ­è§„åˆ™åœ¨å‰ï¼Œé•¿è§„åˆ™åœ¨å

**è§£å†³ï¼š** è°ƒæ•´é¡ºåºï¼Œé•¿è§„åˆ™åœ¨å‰
```typescript
this.Or([
  {alt: () => this.IdentifierWithType()}, // âœ… é•¿è§„åˆ™åœ¨å‰
  {alt: () => this.Identifier()}          // çŸ­è§„åˆ™åœ¨å
])
```

### é—®é¢˜2ï¼šMany è§„åˆ™æ°¸è¿œä¸è¿›å…¥å¾ªç¯

**ç—‡çŠ¶ï¼š** Many æ€»æ˜¯åŒ¹é… 0 æ¬¡

**åŸå› ï¼š** å¿˜è®°åˆå§‹åŒ– `loopMatchSuccess = true`

**ä»£ç ï¼š**
```typescript
// âŒ é”™è¯¯
Many(fun: Function) {
    while (this.loopBranchAndRuleSuccess) {  // æ°¸è¿œä¸º false
        // ...
    }
}

// âœ… æ­£ç¡®
Many(fun: Function) {
    this.setLoopMatchSuccess(true)  // åˆå§‹åŒ–
    while (this.loopBranchAndRuleSuccess) {
        // ...
    }
}
```

### é—®é¢˜3ï¼šè§£æå¤±è´¥ä½†æ²¡æœ‰é”™è¯¯ä¿¡æ¯

**ç—‡çŠ¶ï¼š** è¿”å›ç©º CSTï¼Œä¸çŸ¥é“å“ªé‡Œå¤±è´¥äº†

**è°ƒè¯•æ–¹æ³•ï¼š**
```typescript
// 1. æ£€æŸ¥ ruleMatchSuccess
console.log('ruleMatchSuccess:', parser.ruleMatchSuccess)

// 2. æŸ¥çœ‹ ruleExecErrorStack
console.log('é”™è¯¯æ ˆ:', parser.ruleExecErrorStack)

// 3. æŸ¥çœ‹å‰©ä½™ tokens
console.log('å‰©ä½™tokens:', parser.tokens)

// 4. æ‰“å° CST
parser.printCst()
```

### é—®é¢˜4ï¼šå›é€€æ²¡æœ‰ç”Ÿæ•ˆ

**ç—‡çŠ¶ï¼š** åˆ†æ”¯å¤±è´¥åçŠ¶æ€æ²¡æœ‰æ¢å¤

**æ£€æŸ¥æ¸…å•ï¼š**
- [ ] æ˜¯å¦åœ¨å°è¯•å‰ä¿å­˜äº†å¿«ç…§ï¼Ÿ`const backData = this.backData`
- [ ] æ˜¯å¦åœ¨å¤±è´¥åè°ƒç”¨äº†å›é€€ï¼Ÿ`this.setBackDataAndRuleMatchSuccess(backData)`
- [ ] æ˜¯å¦åœ¨ Or çš„æœ€åä¸€ä¸ªåˆ†æ”¯ç”¨äº†æ­£ç¡®çš„å›é€€æ–¹æ³•ï¼Ÿ

### é—®é¢˜5ï¼šOption/Many ä¸å‘ Or ä¼ æ’­æˆåŠŸä¿¡å·

**ç—‡çŠ¶ï¼š** Option 0æ¬¡åŒ¹é…åï¼ŒOr ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªåˆ†æ”¯

**åŸå› ï¼š** å¿˜è®°è®¾ç½® `loopMatchSuccess = true`

**æ£€æŸ¥ï¼š**
```typescript
// âœ… æ­£ç¡®ï¼šOption/Many é€€å‡ºæ—¶å¿…é¡»è®¾ç½®
this.setLoopMatchSuccess(true)
```

---

## ğŸ¨ è®¾è®¡å“²å­¦

### 1. PEG vs ä¼ ç»Ÿ Parser Generator

| ç‰¹æ€§ | SubhutiParser (PEG) | ä¼ ç»Ÿ LR/LALR |
|------|---------------------|--------------|
| åŒ¹é…ç­–ç•¥ | ç¬¬ä¸€ä¸ªæˆåŠŸ | æœ€é•¿åŒ¹é… |
| è§„åˆ™é¡ºåº | â­â­â­ å…³é”® | ä¸é‡è¦ |
| å›æº¯ | æ”¯æŒ | ä¸æ”¯æŒ |
| äºŒä¹‰æ€§ | ç¨‹åºå‘˜æ§åˆ¶ | è‡ªåŠ¨æ£€æµ‹ |
| æ€§èƒ½ | å¿«ï¼ˆé¿å…é¢„æµ‹ï¼‰ | ä¸­ç­‰ |

### 2. ä¸ºä»€ä¹ˆé€‰æ‹© PEGï¼Ÿ

**ä¼˜ç‚¹ï¼š**
- **ç®€å•ç›´è§‚**ï¼šè§„åˆ™å°±æ˜¯ä»£ç ï¼Œå®¹æ˜“ç†è§£
- **å¼ºå¤§è¡¨è¾¾åŠ›**ï¼šæ”¯æŒä»»æ„å‰ç»ã€å›æº¯
- **æ— äºŒä¹‰æ€§**ï¼šé¡ºåºé€‰æ‹©ï¼Œç¨‹åºå‘˜å®Œå…¨æ§åˆ¶
- **æ˜“äºè°ƒè¯•**ï¼šå¯ä»¥å•æ­¥è·Ÿè¸ªæ‰§è¡Œ

**ç¼ºç‚¹ï¼š**
- **è§„åˆ™é¡ºåºæ•æ„Ÿ**ï¼šå¿…é¡»æ‰‹åŠ¨ä¿è¯é•¿è§„åˆ™åœ¨å‰
- **å¯èƒ½æ€§èƒ½é—®é¢˜**ï¼šå›æº¯å¯èƒ½å¯¼è‡´æŒ‡æ•°å¤æ‚åº¦ï¼ˆéœ€è¦ memoizationï¼‰

### 3. æ ¸å¿ƒè®¾è®¡å†³ç­–

**å†³ç­–1ï¼šä¸¤ä¸ªæ ‡è¯†åˆ†ç¦»**

**é—®é¢˜ï¼š** Or éœ€è¦"å°è¯•å¤±è´¥åç»§ç»­"ï¼Œä½†å¤±è´¥çŠ¶æ€ä¼šé˜»æ­¢æ‰§è¡Œ

**æ–¹æ¡ˆAï¼š** å•ä¸ªæ ‡è¯†ï¼ŒOr å†…éƒ¨ç‰¹æ®Šå¤„ç†ï¼ˆå¤æ‚ï¼‰

**æ–¹æ¡ˆBï¼š** åˆ†ç¦»ä¸¤ä¸ªæ ‡è¯†ï¼ˆå½“å‰æ–¹æ¡ˆï¼‰ âœ…
- `ruleMatchSuccess`ï¼šèƒ½å¦æ‰§è¡Œ
- `loopMatchSuccess`ï¼šæ˜¯å¦æˆåŠŸ

**å†³ç­–2ï¼šOption/Many æ€»æ˜¯æˆåŠŸ**

**é—®é¢˜ï¼š** Option 0æ¬¡åŒ¹é…ç®—æˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Ÿ

**æ–¹æ¡ˆAï¼š** 0æ¬¡ç®—å¤±è´¥ï¼Œè®© Or å°è¯•å…¶ä»–åˆ†æ”¯
- é—®é¢˜ï¼šè¿å "0 æ¬¡æˆ– 1 æ¬¡" çš„è¯­ä¹‰

**æ–¹æ¡ˆBï¼š** 0æ¬¡ç®—æˆåŠŸï¼ˆå½“å‰æ–¹æ¡ˆï¼‰ âœ…
- ç¬¦åˆè¯­ä¹‰
- éœ€è¦æ— æ¡ä»¶è®¾ç½® `loopMatchSuccess = true`

**å†³ç­–3ï¼šå¿«ç…§ç´¢å¼•ä¼˜åŒ–**

**é—®é¢˜ï¼š** å›é€€éœ€è¦æ¢å¤çŠ¶æ€ï¼Œå¦‚ä½•é«˜æ•ˆï¼Ÿ

**æ–¹æ¡ˆAï¼š** æ·±æ‹·è´æ‰€æœ‰æ•°æ®ï¼ˆæ…¢ï¼ŒO(n)ï¼‰

**æ–¹æ¡ˆBï¼š** åªè®°å½•ç´¢å¼•/é•¿åº¦ï¼ˆå½“å‰æ–¹æ¡ˆï¼‰ âœ…
- O(1) æ—¶é—´å¤æ‚åº¦
- é€šè¿‡ä¿®æ”¹é•¿åº¦"åˆ é™¤"å…ƒç´ 

---

## ğŸ“– ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼

```typescript
class ArithmeticParser extends SubhutiParser {
    @SubhutiRule
    Expression() {
        this.Term()
        this.Many(() => {
            this.Or([
                {alt: () => this.tokenConsumer.Plus()},
                {alt: () => this.tokenConsumer.Minus()}
            ])
            this.Term()
        })
    }

    @SubhutiRule
    Term() {
        this.Factor()
        this.Many(() => {
            this.Or([
                {alt: () => this.tokenConsumer.Star()},
                {alt: () => this.tokenConsumer.Slash()}
            ])
            this.Factor()
        })
    }

    @SubhutiRule
    Factor() {
        this.Or([
            {alt: () => this.tokenConsumer.Number()},
            {alt: () => {
                this.tokenConsumer.LParen()
                this.Expression()
                this.tokenConsumer.RParen()
            }}
        ])
    }
}
```

### ç¤ºä¾‹2ï¼šImportDeclaration

```typescript
@SubhutiRule
ImportDeclaration() {
    this.tokenConsumer.ImportTok()
    this.ImportClause()
    this.FromClause()
}

@SubhutiRule
ImportClause() {
    this.Or([
        {alt: () => this.ImportedDefaultBinding()},
        {alt: () => this.NameSpaceImport()},
        {alt: () => this.NamedImports()},
        {alt: () => {
            this.ImportedDefaultBinding()
            this.tokenConsumer.Comma()
            this.Or([
                {alt: () => this.NameSpaceImport()},
                {alt: () => this.NamedImports()}
            ])
        }}
    ])
}

@SubhutiRule
ImportSpecifier() {
    this.Or([
        // âœ… é•¿è§„åˆ™åœ¨å‰ï¼šname as userName
        {alt: () => {
            this.tokenConsumer.Identifier()
            this.tokenConsumer.AsTok()
            this.ImportedBinding()
        }},
        // çŸ­è§„åˆ™åœ¨åï¼šname
        {alt: () => this.ImportedBinding()}
    ])
}
```

---

## ğŸ”¬ æ€§èƒ½ä¼˜åŒ–

### 1. å¿«ç…§ç´¢å¼•ä¼˜åŒ–

**åŸç†ï¼š** ä¸æ·±æ‹·è´æ•°æ®ï¼Œåªè®°å½•ç´¢å¼•å’Œé•¿åº¦

**æ•ˆæœï¼š**
- å¿«ç…§åˆ›å»ºï¼šO(1)
- å›é€€æ“ä½œï¼šO(1)
- æ¯”æ·±æ‹·è´å¿« 1000 å€ä»¥ä¸Š

### 2. Token ç´¢å¼•è®¿é—®

**åŸç†ï¼š** ä½¿ç”¨ç´¢å¼•è€Œé shift() åˆ é™¤å…ƒç´ 

```typescript
// âŒ æ…¢ï¼šæ¯æ¬¡ O(n)
const token = this.tokens.shift()

// âœ… å¿«ï¼šæ¯æ¬¡ O(1)
const token = this._tokens[this.tokenIndex++]
```

### 3. CST ä¼˜åŒ–

**ä¼˜åŒ–1ï¼šåˆ é™¤ç©ºæ•°ç»„**
```typescript
if (!cst.children?.length) {
    cst.children = undefined  // èŠ‚çœå†…å­˜
}
```

**ä¼˜åŒ–2ï¼šæƒ°æ€§è®¡ç®— loc**
```typescript
// åªåœ¨éœ€è¦æ—¶è®¡ç®—ä½ç½®ä¿¡æ¯
if (cst.children[0]?.loc) {
    cst.loc = {
        start: cst.children[0].loc.start,
        end: lastChild.loc.end
    }
}
```

---

## ğŸ“ å­¦ä¹ è¦ç‚¹

### å…³é”®æ¦‚å¿µ

1. **Or æ˜¯é¡ºåºé€‰æ‹©**
   - ä¸æ˜¯è´ªå©ªåŒ¹é…
   - ä¸æ˜¯å¹¶è¡Œå°è¯•
   - ç¬¬ä¸€ä¸ªæˆåŠŸå³è¿”å›

2. **è§„åˆ™é¡ºåºå½±å“ç»“æœ**
   - é•¿è§„åˆ™å¿…é¡»åœ¨å‰
   - çŸ­è§„åˆ™åœ¨åä½œä¸ºå›é€€

3. **å›é€€æœ‰æ€§èƒ½ä»£ä»·**
   - é¢‘ç¹å›é€€å½±å“æ€§èƒ½
   - æŠŠå¸¸è§æƒ…å†µæ”¾å‰é¢

4. **Option/Many æ€»æ˜¯æˆåŠŸ**
   - 0 æ¬¡åŒ¹é…ä¹Ÿç®—æˆåŠŸ
   - å¿…é¡»å‘ Or ä¼ æ’­æˆåŠŸä¿¡å·

### å®ç”¨æŠ€å·§

**æŠ€å·§1ï¼šæ³¨é‡Šæ ‡æ³¨è§„åˆ™é•¿åº¦**
```typescript
this.Or([
    // é•¿è§„åˆ™ï¼šproperty: value
    {alt: () => { /* ... */ }},
    // çŸ­è§„åˆ™ï¼šproperty
    {alt: () => { /* ... */ }}
])
```

**æŠ€å·§2ï¼šä½¿ç”¨ Option ç®€åŒ–**
```typescript
// ä»£æ›¿ï¼š
// this.Or([
//   {alt: () => { this.A(); this.B() }},
//   {alt: () => this.A()}
// ])

// ä½¿ç”¨ï¼š
this.A()
this.Option(() => this.B())
```

**æŠ€å·§3ï¼šå¤æ‚è§„åˆ™æ‹†åˆ†**
```typescript
// æ‹†åˆ†ä¸ºå¤šä¸ªå­è§„åˆ™ï¼Œæé«˜å¯è¯»æ€§
ComplexRule() {
    this.Or([
        {alt: () => this.LongForm()},
        {alt: () => this.ShortForm()}
    ])
}
```

---

## ğŸ“š å‚è€ƒèµ„æº

- [PEG - Wikipedia](https://en.wikipedia.org/wiki/Parsing_expression_grammar)
- [Packrat Parsing](https://bford.info/packrat/)
- [Parser Combinators](https://en.wikipedia.org/wiki/Parser_combinator)

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** 1.0.0  
**æœ€åæ›´æ–°ï¼š** 2025-01-08  
**ç»´æŠ¤è€…ï¼š** AI è¾…åŠ©å¼€å‘

