# Subhuti - Parser Generator Framework

## 项目定位

轻量级、高性能的 PEG (Parsing Expression Grammar) Parser Generator 框架，用 TypeScript 构建，专为快速开发编程语言解析器设计。

**名称由来：** Subhuti (सुभूति) - 菩提祖师，孙悟空的师父，寓意让编程语言转换如七十二变般灵活。

**核心价值：** 通过定义相同语法结构和名称的两个语法文件，实现不同编程语言之间的自动转换。

## 技术架构（v4.4.0）

### 核心特性

**1. Packrat Parsing（线性时间复杂度）**
- LRU 缓存策略（基于 `lru-cache` 包）
- 避免重复解析，O(n) 时间复杂度
- 自动管理缓存生命周期

**2. allowError 机制（智能错误管理）**
- Or 规则：前 N-1 分支允许失败（返回 undefined）
- 最后分支：失败时抛出详细错误（位置、期望、实际、规则栈）
- RAII 模式：自动恢复 allowError 状态（try-finally 保证）

**3. PEG 风格语法**
- 顺序选择（Ordered Choice）：第一个成功即返回
- 自动回溯（Backtracking）：失败时恢复状态
- 程序员控制规则顺序：无二义性

**4. 装饰器系统**
- `@Subhuti`：类装饰器，标记 Parser 类
- `@SubhutiRule`：方法装饰器，包装规则执行

### 核心组件

```
SubhutiLexer - 词法分析器
├── tokenize(sourceCode): SubhutiMatchToken[]
├── setTokens(tokens): void
└── hasUnclosedTemplate(): boolean  # 模板字符串检测

SubhutiParser - 语法分析器（核心）
├── consume(tokenName): SubhutiCst | undefined
├── Or(alternatives): SubhutiCst | undefined
├── Many(fn): SubhutiCst | undefined
├── AtLeastOne(fn): SubhutiCst | undefined
├── Option(fn): SubhutiCst | undefined
├── cache(enable): this  # 链式调用
├── debug(enable): this
└── errorHandler(enable): this

SubhutiTokenConsumer - Token 消费器
└── 为每个 Token 生成 consume 方法（动态代理）

SubhutiCst - 具体语法树
├── name: string
├── children?: SubhutiCst[]
├── value?: string  # Token 节点的值
├── loc: SubhutiSourceLocation
├── getChild(name, index): SubhutiCst | undefined
├── getChildren(name): SubhutiCst[]
├── getToken(tokenName): SubhutiCst | undefined
└── hasChild(name): boolean

SubhutiPackratCache - Packrat 缓存（LRU）
├── get(ruleName, tokenIndex): CacheResult | undefined
├── set(ruleName, tokenIndex, result): void
└── clear(): void

SubhutiErrorHandler - 错误处理
└── createError(context): SubhutiParseError
```

## Parser 规则编写指南

### ⚠️ 核心原则：Or 规则顺序

**关键特性：** Or 规则按顺序尝试，**第一个成功即返回**（不是贪婪/最长匹配）

**规则：** 长规则在前，短规则在后

```typescript
// ✅ 正确
ImportSpecifier() {
  this.Or([
    // 长规则：name as userName
    { alt: () => {
      this.Identifier()
      this.AsTok()
      this.ImportedBinding()
    }},
    // 短规则：name
    { alt: () => this.ImportedBinding() }
  ])
}

// ❌ 错误：短规则在前
ImportSpecifier() {
  this.Or([
    { alt: () => this.ImportedBinding() },  // 消费 "name" 后立即返回
    { alt: () => {                          // 永远不会执行
      this.Identifier()
      this.AsTok()
      this.ImportedBinding()
    }}
  ])
}
```

**问题分析：**
```
Token流：[name, as, userName]

短规则在前：
1. 第一个分支：ImportedBinding() 消费 "name" → ✅ 成功
2. Or 立即返回，剩余 [as, userName]
3. 上层规则期望 , 或 }，实际遇到 as → ❌ 解析失败

长规则在前：
1. 第一个分支：Identifier() → ✅, AsTok() → ✅, ImportedBinding() → ✅
2. 全部成功，返回 ✅
```

### 最佳实践

**1. 长规则优先**
```typescript
PropertyDefinition() {
  this.Or([
    { alt: () => {
      // 长规则：{ key: value }
      this.PropertyName()
      this.Colon()
      this.AssignmentExpression()
    }},
    { alt: () => this.MethodDefinition() },
    { alt: () => this.IdentifierReference() }  // 短规则最后
  ])
}
```

**2. 使用 Option 代替 Or（可选部分）**
```typescript
// 更清晰的表达
ImportSpecifier() {
  this.Identifier()
  this.Option(() => {
    this.AsTok()
    this.Identifier()
  })
}
```

**3. 添加注释**
```typescript
this.Or([
  // 长规则：完整形式
  { alt: () => { /* ... */ } },
  // 短规则：简写形式
  { alt: () => { /* ... */ } }
])
```

## API 速查

### Parser 方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `Or(alternatives)` | 顺序选择（第一个成功） | `this.Or([{alt: () => ...}])` |
| `Many(fn)` | 0 次或多次 | `this.Many(() => this.Statement())` |
| `AtLeastOne(fn)` | 1 次或多次 | `this.AtLeastOne(() => this.Param())` |
| `Option(fn)` | 0 次或 1 次 | `this.Option(() => this.ElseClause())` |
| `consume(token)` | 消费 token | `this.consume('Identifier')` |

### CST 辅助方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `getChild(name, index)` | 获取第 N 个子节点 | `cst.getChild('Expression', 0)` |
| `getChildren(name)` | 获取所有指定子节点 | `cst.getChildren('Statement')` |
| `getToken(tokenName)` | 获取 token 节点 | `cst.getToken('Identifier')` |
| `hasChild(name)` | 检查是否存在子节点 | `cst.hasChild('ElseClause')` |
| `childCount` | 子节点数量 | `cst.childCount` |
| `isToken` | 是否为 token 节点 | `cst.isToken` |
| `isEmpty` | 是否为空节点 | `cst.isEmpty` |

## 调试技巧

**1. 启用调试输出**
```typescript
const parser = new MyParser(tokenStream).debug(true)
```

**2. 查看 CST 结构**
```typescript
console.log(JSON.stringify(cst, null, 2))
```

**3. 错误处理**
```typescript
const parser = new MyParser(tokenStream).errorHandler(true)
try {
  const cst = parser.Statement()
} catch (error) {
  console.error(error.message, error.position, error.ruleStack)
}
```

## 实际应用

**Slime 项目** - JavaScript ES5/ES6 Parser
- 使用 Subhuti 构建完整 JS 解析器
- 支持所有核心语法（import/export、箭头函数、模板字符串等）
- 成功案例：规则顺序调整解决 import 重命名问题

## 项目信息

- **版本：** 0.1.3
- **仓库：** https://github.com/alamhubb/subhuti
- **作者：** alamhubb
- **许可：** MIT

---

**最后更新：** 2025-11-04
