Annex C (informative) The Strict Mode of ECMAScript
The strict mode restriction and exceptions

implements, interface, let, package, private, protected, public, static, and yield are reserved words within strict mode code. (12.7.2).
A conforming implementation, when processing strict mode code, must disallow instances of the productions NumericLiteral :: LegacyOctalIntegerLiteral and DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral .
A conforming implementation, when processing strict mode code, must disallow instances of the productions EscapeSequence :: LegacyOctalEscapeSequence and EscapeSequence :: NonOctalDecimalEscapeSequence .
Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its LeftHandSideExpression must not evaluate to an unresolvable Reference. If it does a ReferenceError exception is thrown (6.2.5.6). The LeftHandSideExpression also may not be a reference to a data property with the attribute value { [[Writable]]: false }, to an accessor property with the attribute value { [[Set]]: undefined }, nor to a non-existent property of an object whose [[Extensible]] internal slot is false. In these cases a TypeError exception is thrown (13.15).
An IdentifierReference with the StringValue "eval" or "arguments" may not appear as the LeftHandSideExpression of an Assignment operator (13.15) or of an UpdateExpression (13.4) or as the UnaryExpression operated upon by a Prefix Increment (13.4.4) or a Prefix Decrement (13.4.5) operator.
Arguments objects for strict functions define a non-configurable accessor property "callee" which throws a TypeError exception on access (10.4.4.6).
Arguments objects for strict functions do not dynamically share their array-indexed property values with the corresponding formal parameter bindings of their functions. (10.4.4).
For strict functions, if an arguments object is created the binding of the local identifier arguments to the arguments object is immutable and hence may not be the target of an assignment expression. (10.2.11).
It is a SyntaxError if the StringValue of a BindingIdentifier is either "eval" or "arguments" within strict mode code (13.1.1).
Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (19.2.1).
If this is evaluated within strict mode code, then the this value is not coerced to an object. A this value of either undefined or null is not converted to the global object and primitive values are not converted to wrapper objects. The this value passed via a function call (including calls made using Function.prototype.apply and Function.prototype.call) do not coerce the passed this value to an object (10.2.1.2, 20.2.3.1, 20.2.3.3).
When a delete operator occurs within strict mode code, a SyntaxError is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name (13.5.1.1).
When a delete operator occurs within strict mode code, a TypeError is thrown if the property to be deleted has the attribute { [[Configurable]]: false } or otherwise cannot be deleted (13.5.1.2).
Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such a context is a SyntaxError (14.11.1).
It is a SyntaxError if a CatchParameter occurs within strict mode code and the BoundNames of CatchParameter contains either eval or arguments (14.15.1).
It is a SyntaxError if the same BindingIdentifier appears more than once in the FormalParameters of a strict function. An attempt to create such a function using a Function, Generator, or AsyncFunction constructor is a SyntaxError (15.2.1, 20.2.1.1.1).
An implementation may not extend, beyond that defined in this specification, the meanings within strict functions of properties named "caller" or "arguments" of function instances.