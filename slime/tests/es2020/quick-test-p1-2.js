// ES2020 P1-2 验证：OptionalChaining 词法约束
// 规范要求：?. [lookahead ∉ DecimalDigit]

// ============================================
// 合法的可选链（应该通过）
// ============================================

// 测试1：属性访问
const t1 = obj?.prop
const t2 = obj?.nested?.deep

// 测试2：计算属性
const t3 = obj?.['key']
const t4 = obj?.[expr]

// 测试3：方法调用
const t5 = obj?.method()
const t6 = obj?.method?.()

// 测试4：数组访问
const t7 = arr?.[0]
const t8 = arr?.[0]?.prop

// 测试5：链式调用
const t9 = obj?.a?.b?.c
const t10 = obj?.method1()?.method2()?.result

// ============================================
// 边界情况1：三元运算符（应该合法）
// ============================================

// ?. 中间有空格，应该被解析为三元运算符
const t11 = a ? .3 : b      // 三元运算符：a ? 0.3 : b
const t12 = a ? .5e2 : b    // 三元运算符：a ? 50 : b
const t13 = x ? .5 : y      // 三元运算符：x ? 0.5 : y

// ============================================
// 边界情况2：?. 后跟数字（规范禁止）
// ============================================

// 注意：以下语法按规范应该报错
// 但由于词法层无法实现前瞻，会被解析为 ?. + 数字字面量
// 这是当前实现的已知限制

// const t14 = obj?.3          // 规范：词法错误
// const t15 = obj?.5e2        // 规范：词法错误
// const t16 = obj?.0x10       // 规范：词法错误

// 因为会导致词法错误，我们用注释形式存在
// 实际测试中不会执行这些代码

console.log('✅ OptionalChaining 边界测试完成')




















