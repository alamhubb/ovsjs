# Slime - JavaScript AST 工具链

## 项目定位
提供完整的 JavaScript AST 操作能力，包括ES5/ES6解析器、AST工具类、代码生成器。

## 当前任务：修复ES6 Parser失败测试

### 正在修复的测试用例
**测试文件：** `tests/cases/single/05-logical-ops.js`  
**预期通过时间：** <5分钟  
**优先级：** P1（影响3个测试）

### 实时诊断记录

**【最新诊断】2025-10-16 (第三轮 - 根因确认)**

**操作记录：**
- 执行：`npx tsx test-runner.ts tests/cases/single/05-logical-ops.js`
- 检查：`Es6Parser.ts` 第645-670行 `UnaryExpression()` 方法

**根因确认：**
```typescript
// Es6Parser.ts:645-670
@SubhutiRule
UnaryExpression() {
  this.Or([
    {
      alt: () => {
        this.Or([...operators...])
        this.UnaryExpression()  // ❌ 递归调用，但没有return
      }
    },
    {alt: () => this.AwaitExpression()},
    {alt: () => this.PostfixExpression()}
  ])
  // ❌ 方法结束，没有return语句
}
```

**结论1：UnaryExpression方法缺少return语句**
- 在Subhuti框架中，每个@SubhutiRule方法都应该返回CST节点
- 当前实现只调用了子规则，但没有return，导致返回undefined
- undefined被当作CST节点传递，后续访问.children时崩溃

**结论2：所有调用UnaryExpression的地方都会出问题**
- `MultiplicativeExpression()`：第674、677行
- `AwaitExpression()`：第1645行
- 影响范围：所有包含一元运算符的表达式（!、+、-、~、typeof等）

**结论3：Subhuti框架的CST自动创建机制**
- 查看 `SubhutiParser.processCst` (第271-327行)发现：
  - 第280行：自动创建children数组 `cst.children = []`
  - 第293行：执行规则方法 `let res = targetFun.apply(this)`
  - 第320行：返回自动创建的cst（不使用方法返回值）
- 结论：方法不需要return语句，CST由框架自动创建
- 其他方法（MultiplicativeExpression等）也没有return语句

**结论4：dump-cst确认CST结构异常**
- 执行：`npx tsx dump-cst.ts tests/cases/single/05-logical-ops.js`
- 输出：24个UnaryExpression节点，每个都只有`{"name": "UnaryExpression"}`
- 确认：children属性完全不存在（不是空数组，而是undefined）

**结论5：定位到SubhutiParser优化代码**
- 查看 `SubhutiParser.processCst` 第249-250行：
  ```typescript
  if (!cst.children?.length) {
    cst.children = undefined  // ⚠️ 空数组被优化为undefined
  }
  ```
- 问题：UnaryExpression的children是空数组（没有子节点），被优化成undefined
- 但为什么children是空？UnaryExpression调用了Or和子规则，应该有children才对

**结论6：Or方法返回值不影响children**
- Or方法确实有返回值（第657行：`return this.getCurCst()`）
- 但processCst第293行接收后不使用这个返回值
- Or只是选择分支，不创建子CST节点

**结论7：children来源于子规则调用**
- 对比MultiplicativeExpression（工作正常）：
  ```typescript
  MultiplicativeExpression() {
    this.UnaryExpression()  // ← 调用@SubhutiRule，创建子CST
    this.Many(() => {
      this.MultiplicativeOperator()
      this.UnaryExpression()
    })
  }
  ```
- UnaryExpression自身：
  ```typescript
  UnaryExpression() {
    this.Or([
      {alt: () => {
        this.Or([...operators...])  // ← 只消费token，不创建子CST
        this.UnaryExpression()       // ← 递归调用，应该创建子CST，但为什么没有？
      }},
      ...
    ])
  }
  ```

**结论8：最小测试用例揭示关键问题**
- 创建：`tests/temp-minimal-not.js` 内容：`var x = !true;`
- dump-cst输出：2个UnaryExpression
  - 第1个：有children `[Exclamation token, 第2个UnaryExpression]` ✅
  - 第2个：只有name，无children ❌
- 说明：第1个UnaryExpression匹配了`!`和递归调用，但递归返回的UnaryExpression是空的

**结论9：第2个UnaryExpression应该匹配PostfixExpression分支**
- UnaryExpression的Or有3个分支：
  1. `operator + UnaryExpression` - 已被第1个匹配消耗
  2. `AwaitExpression` - 需要await关键字，true不匹配
  3. `PostfixExpression` - 应该能匹配true
- PostfixExpression → LeftHandSideExpression → Or(CallExpression | NewExpression)

**结论10：CallExpression vs NewExpression分支分析**
- CallExpression要求：`MemberExpression + Arguments()`
  - true是PrimaryExpression，可以通过MemberExpression
  - 但true后面没有`()`，Arguments失败 ❌
- NewExpression要求：`MemberExpression` 或 `new + NewExpression`
  - true是PrimaryExpression，可以通过MemberExpression ✅
  - 应该能成功匹配
  
**结论11：关键疑问 - 为什么NewExpression分支没有添加子节点？**
- 查看Es6Parser第505-519行NewExpression实现
- 查看Es6Parser第378-418行MemberExpression实现
- 查看Es6Parser第242-318行PrimaryExpression实现
- 怀疑：某个环节的Or分支失败，或者CST被优化掉了

**临时文件清单：**
- `tests/temp-minimal-not.js` - 最小复现用例
- `tests/temp-logical-not.js` - 早期诊断文件（可删除）

---

## 测试通过率：31/40 (77.5%)

**失败测试用例（9个）：**

### A类：CST节点loc信息缺失（6个测试）
1. **08-for-loop.js** - `Cannot read properties of undefined (reading 'end')`
2. **19-for-of-loop.js** - `Cannot read properties of undefined (reading 'end')`
3. **21-generator.js** - `Cannot read properties of undefined (reading 'end')`
4. **28-weakmap-weakset.js** - `Cannot read properties of undefined (reading 'end')`
5. **29-async-await.js** - `Cannot read properties of undefined (reading 'end')`
6. **23-functions.js (combined)** - `Cannot read properties of undefined (reading 'end')`

### B类：运算符支持缺失（3个测试）
7. **05-logical-ops.js** - `暂不支持的类型：Exclamation` [正在修复]
8. **21-simple-roundtrip.js (combined)** - `暂不支持的类型：Exclamation`
9. **25-operators-all.js (combined)** - `暂不支持的类型：TypeofTok`

## 测试架构

**测试入口：**
- `test-runner.ts` - 单例测试入口（日常修复使用）
- `test-all.ts` - 完整测试套件（最后验证使用）
- `dump-cst.ts` - CST结构查看工具（调试专用）

**测试流程：**
1. 单用例测试：`npx tsx test-runner.ts <path>`
2. 诊断CST结构：`npx tsx dump-cst.ts <path>`
3. 修复代码
4. 复跑验证
5. 完整测试：`npx tsx test-all.ts`

## 修复优先级

**P0（影响6个测试）：** CST节点loc信息缺失
- 修复位置：`SubhutiParser.ts` 的 `processCst` 方法
- 预期效果：6个测试通过，通过率提升到92.5%

**P1（影响3个测试，正在修复）：** 运算符支持
- 修复位置：Parser层或AST转换层
- 预期效果：3个测试通过，通过率达到100%

---

# 变更记录

## 2025-10-16 [当前会话 - 测试架构重构]
- **测试入口重组：**
  - `test-runner.ts` → 单例测试入口（符合"一个个测试修复"原则）
  - `test-all.ts` → 完整测试套件（从原test-runner.ts迁移）
  - 删除：`test-single.ts`（功能被test-runner.ts替代）
- **实时诊断记录机制：**
  - 创建：`.cursor/rules/project.mdc`
  - 记录：正在修复的测试用例、诊断过程、当前假设、下一步行动
  - 目的：支持断点重续，会话中断后可快速恢复上下文
- **规则更新触发反思流程：**
  - 问题：违反"单文件测试执行原则"（直接运行test-runner.ts批量测试）
  - 更新：测试架构重组，确保test-runner.ts作为单例入口
  - 检查：冗余文件已删除，职责清晰
- **开始修复：05-logical-ops.js**
  - 问题定位：Parser层CST结构不完整（只有运算符，没有操作数）
  - 进行中：调查Or分支选择逻辑
