'use strict';

var node_module = require('node:module');
var require$$0$1 = require('util');
var path$1 = require('path');
var require$$2 = require('os');
var require$$3 = require('crypto');
var require$$4 = require('net');
var require$$0$2 = require('url');
var fs = require('fs');
var require$$3$1 = require('child_process');
var require$$0$3 = require('assert');
var require$$1 = require('events');
var require$$3$2 = require('http');
var require$$4$1 = require('https');
var require$$7 = require('tls');
var require$$9 = require('zlib');
var ts = require('typescript');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path$1);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var node$4 = {};

var main$6 = {};

const require$1 = node_module.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('language-server.cjs', document.baseURI).href)));
function __require() { return require$1("node:util"); }

var is$2 = {};

var hasRequiredIs$2;

function requireIs$2 () {
	if (hasRequiredIs$2) return is$2;
	hasRequiredIs$2 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$2, "__esModule", { value: true });
	is$2.thenable = is$2.typedArray = is$2.stringArray = is$2.array = is$2.func = is$2.error = is$2.number = is$2.string = is$2.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$2.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$2.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$2.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$2.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$2.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$2.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$2.stringArray = stringArray;
	function typedArray(value, check) {
	    return Array.isArray(value) && value.every(check);
	}
	is$2.typedArray = typedArray;
	function thenable(value) {
	    return value && func(value.then);
	}
	is$2.thenable = thenable;
	return is$2;
}

var server$2 = {};

var main$5 = {};

var main$4 = {};

var ril = {};

var api$2 = {};

var messages$1 = {};

var is$1 = {};

var hasRequiredIs$1;

function requireIs$1 () {
	if (hasRequiredIs$1) return is$1;
	hasRequiredIs$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(is$1, "__esModule", { value: true });
	is$1.stringArray = is$1.array = is$1.func = is$1.error = is$1.number = is$1.string = is$1.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is$1.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is$1.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is$1.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is$1.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is$1.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is$1.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is$1.stringArray = stringArray;
	return is$1;
}

var hasRequiredMessages$1;

function requireMessages$1 () {
	if (hasRequiredMessages$1) return messages$1;
	hasRequiredMessages$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messages$1, "__esModule", { value: true });
	messages$1.Message = messages$1.NotificationType9 = messages$1.NotificationType8 = messages$1.NotificationType7 = messages$1.NotificationType6 = messages$1.NotificationType5 = messages$1.NotificationType4 = messages$1.NotificationType3 = messages$1.NotificationType2 = messages$1.NotificationType1 = messages$1.NotificationType0 = messages$1.NotificationType = messages$1.RequestType9 = messages$1.RequestType8 = messages$1.RequestType7 = messages$1.RequestType6 = messages$1.RequestType5 = messages$1.RequestType4 = messages$1.RequestType3 = messages$1.RequestType2 = messages$1.RequestType1 = messages$1.RequestType = messages$1.RequestType0 = messages$1.AbstractMessageSignature = messages$1.ParameterStructures = messages$1.ResponseError = messages$1.ErrorCodes = void 0;
	const is = requireIs$1();
	/**
	 * Predefined error codes.
	 */
	var ErrorCodes;
	(function (ErrorCodes) {
	    // Defined by JSON RPC
	    ErrorCodes.ParseError = -32700;
	    ErrorCodes.InvalidRequest = -32600;
	    ErrorCodes.MethodNotFound = -32601;
	    ErrorCodes.InvalidParams = -32602;
	    ErrorCodes.InternalError = -32603;
	    /**
	     * This is the start range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code. No application error codes should
	     * be defined between the start and end range. For backwards
	     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
	     * are left in the range.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
	    /** @deprecated use  jsonrpcReservedErrorRangeStart */
	    ErrorCodes.serverErrorStart = -32099;
	    /**
	     * An error occurred when write a message to the transport layer.
	     */
	    ErrorCodes.MessageWriteError = -32099;
	    /**
	     * An error occurred when reading a message from the transport layer.
	     */
	    ErrorCodes.MessageReadError = -32098;
	    /**
	     * The connection got disposed or lost and all pending responses got
	     * rejected.
	     */
	    ErrorCodes.PendingResponseRejected = -32097;
	    /**
	     * The connection is inactive and a use of it failed.
	     */
	    ErrorCodes.ConnectionInactive = -32096;
	    /**
	     * Error code indicating that a server received a notification or
	     * request before the server has received the `initialize` request.
	     */
	    ErrorCodes.ServerNotInitialized = -32002;
	    ErrorCodes.UnknownErrorCode = -32001;
	    /**
	     * This is the end range of JSON RPC reserved error codes.
	     * It doesn't denote a real error code.
	     *
	     * @since 3.16.0
	    */
	    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32e3;
	    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
	    ErrorCodes.serverErrorEnd = -32e3;
	})(ErrorCodes || (messages$1.ErrorCodes = ErrorCodes = {}));
	/**
	 * An error object return in a response in case a request
	 * has failed.
	 */
	class ResponseError extends Error {
	    constructor(code, message, data) {
	        super(message);
	        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
	        this.data = data;
	        Object.setPrototypeOf(this, ResponseError.prototype);
	    }
	    toJson() {
	        const result = {
	            code: this.code,
	            message: this.message
	        };
	        if (this.data !== undefined) {
	            result.data = this.data;
	        }
	        return result;
	    }
	}
	messages$1.ResponseError = ResponseError;
	class ParameterStructures {
	    constructor(kind) {
	        this.kind = kind;
	    }
	    static is(value) {
	        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
	    }
	    toString() {
	        return this.kind;
	    }
	}
	messages$1.ParameterStructures = ParameterStructures;
	/**
	 * The parameter structure is automatically inferred on the number of parameters
	 * and the parameter type in case of a single param.
	 */
	ParameterStructures.auto = new ParameterStructures('auto');
	/**
	 * Forces `byPosition` parameter structure. This is useful if you have a single
	 * parameter which has a literal type.
	 */
	ParameterStructures.byPosition = new ParameterStructures('byPosition');
	/**
	 * Forces `byName` parameter structure. This is only useful when having a single
	 * parameter. The library will report errors if used with a different number of
	 * parameters.
	 */
	ParameterStructures.byName = new ParameterStructures('byName');
	/**
	 * An abstract implementation of a MessageType.
	 */
	class AbstractMessageSignature {
	    constructor(method, numberOfParams) {
	        this.method = method;
	        this.numberOfParams = numberOfParams;
	    }
	    get parameterStructures() {
	        return ParameterStructures.auto;
	    }
	}
	messages$1.AbstractMessageSignature = AbstractMessageSignature;
	/**
	 * Classes to type request response pairs
	 */
	class RequestType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.RequestType0 = RequestType0;
	class RequestType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType = RequestType;
	class RequestType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.RequestType1 = RequestType1;
	class RequestType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.RequestType2 = RequestType2;
	class RequestType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.RequestType3 = RequestType3;
	class RequestType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.RequestType4 = RequestType4;
	class RequestType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.RequestType5 = RequestType5;
	class RequestType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.RequestType6 = RequestType6;
	class RequestType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.RequestType7 = RequestType7;
	class RequestType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.RequestType8 = RequestType8;
	class RequestType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.RequestType9 = RequestType9;
	class NotificationType extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType = NotificationType;
	class NotificationType0 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 0);
	    }
	}
	messages$1.NotificationType0 = NotificationType0;
	class NotificationType1 extends AbstractMessageSignature {
	    constructor(method, _parameterStructures = ParameterStructures.auto) {
	        super(method, 1);
	        this._parameterStructures = _parameterStructures;
	    }
	    get parameterStructures() {
	        return this._parameterStructures;
	    }
	}
	messages$1.NotificationType1 = NotificationType1;
	class NotificationType2 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 2);
	    }
	}
	messages$1.NotificationType2 = NotificationType2;
	class NotificationType3 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 3);
	    }
	}
	messages$1.NotificationType3 = NotificationType3;
	class NotificationType4 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 4);
	    }
	}
	messages$1.NotificationType4 = NotificationType4;
	class NotificationType5 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 5);
	    }
	}
	messages$1.NotificationType5 = NotificationType5;
	class NotificationType6 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 6);
	    }
	}
	messages$1.NotificationType6 = NotificationType6;
	class NotificationType7 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 7);
	    }
	}
	messages$1.NotificationType7 = NotificationType7;
	class NotificationType8 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 8);
	    }
	}
	messages$1.NotificationType8 = NotificationType8;
	class NotificationType9 extends AbstractMessageSignature {
	    constructor(method) {
	        super(method, 9);
	    }
	}
	messages$1.NotificationType9 = NotificationType9;
	var Message;
	(function (Message) {
	    /**
	     * Tests if the given message is a request message
	     */
	    function isRequest(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
	    }
	    Message.isRequest = isRequest;
	    /**
	     * Tests if the given message is a notification message
	     */
	    function isNotification(message) {
	        const candidate = message;
	        return candidate && is.string(candidate.method) && message.id === void 0;
	    }
	    Message.isNotification = isNotification;
	    /**
	     * Tests if the given message is a response message
	     */
	    function isResponse(message) {
	        const candidate = message;
	        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
	    }
	    Message.isResponse = isResponse;
	})(Message || (messages$1.Message = Message = {}));
	return messages$1;
}

var linkedMap = {};

var hasRequiredLinkedMap;

function requireLinkedMap () {
	if (hasRequiredLinkedMap) return linkedMap;
	hasRequiredLinkedMap = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	var _a;
	Object.defineProperty(linkedMap, "__esModule", { value: true });
	linkedMap.LRUCache = linkedMap.LinkedMap = linkedMap.Touch = void 0;
	var Touch;
	(function (Touch) {
	    Touch.None = 0;
	    Touch.First = 1;
	    Touch.AsOld = Touch.First;
	    Touch.Last = 2;
	    Touch.AsNew = Touch.Last;
	})(Touch || (linkedMap.Touch = Touch = {}));
	class LinkedMap {
	    constructor() {
	        this[_a] = 'LinkedMap';
	        this._map = new Map();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state = 0;
	    }
	    clear() {
	        this._map.clear();
	        this._head = undefined;
	        this._tail = undefined;
	        this._size = 0;
	        this._state++;
	    }
	    isEmpty() {
	        return !this._head && !this._tail;
	    }
	    get size() {
	        return this._size;
	    }
	    get first() {
	        return this._head?.value;
	    }
	    get last() {
	        return this._tail?.value;
	    }
	    has(key) {
	        return this._map.has(key);
	    }
	    get(key, touch = Touch.None) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        if (touch !== Touch.None) {
	            this.touch(item, touch);
	        }
	        return item.value;
	    }
	    set(key, value, touch = Touch.None) {
	        let item = this._map.get(key);
	        if (item) {
	            item.value = value;
	            if (touch !== Touch.None) {
	                this.touch(item, touch);
	            }
	        }
	        else {
	            item = { key, value, next: undefined, previous: undefined };
	            switch (touch) {
	                case Touch.None:
	                    this.addItemLast(item);
	                    break;
	                case Touch.First:
	                    this.addItemFirst(item);
	                    break;
	                case Touch.Last:
	                    this.addItemLast(item);
	                    break;
	                default:
	                    this.addItemLast(item);
	                    break;
	            }
	            this._map.set(key, item);
	            this._size++;
	        }
	        return this;
	    }
	    delete(key) {
	        return !!this.remove(key);
	    }
	    remove(key) {
	        const item = this._map.get(key);
	        if (!item) {
	            return undefined;
	        }
	        this._map.delete(key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    shift() {
	        if (!this._head && !this._tail) {
	            return undefined;
	        }
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        const item = this._head;
	        this._map.delete(item.key);
	        this.removeItem(item);
	        this._size--;
	        return item.value;
	    }
	    forEach(callbackfn, thisArg) {
	        const state = this._state;
	        let current = this._head;
	        while (current) {
	            if (thisArg) {
	                callbackfn.bind(thisArg)(current.value, current.key, this);
	            }
	            else {
	                callbackfn(current.value, current.key, this);
	            }
	            if (this._state !== state) {
	                throw new Error(`LinkedMap got modified during iteration.`);
	            }
	            current = current.next;
	        }
	    }
	    keys() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.key, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    values() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: current.value, done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    entries() {
	        const state = this._state;
	        let current = this._head;
	        const iterator = {
	            [Symbol.iterator]: () => {
	                return iterator;
	            },
	            next: () => {
	                if (this._state !== state) {
	                    throw new Error(`LinkedMap got modified during iteration.`);
	                }
	                if (current) {
	                    const result = { value: [current.key, current.value], done: false };
	                    current = current.next;
	                    return result;
	                }
	                else {
	                    return { value: undefined, done: true };
	                }
	            }
	        };
	        return iterator;
	    }
	    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
	        return this.entries();
	    }
	    trimOld(newSize) {
	        if (newSize >= this.size) {
	            return;
	        }
	        if (newSize === 0) {
	            this.clear();
	            return;
	        }
	        let current = this._head;
	        let currentSize = this.size;
	        while (current && currentSize > newSize) {
	            this._map.delete(current.key);
	            current = current.next;
	            currentSize--;
	        }
	        this._head = current;
	        this._size = currentSize;
	        if (current) {
	            current.previous = undefined;
	        }
	        this._state++;
	    }
	    addItemFirst(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._tail = item;
	        }
	        else if (!this._head) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.next = this._head;
	            this._head.previous = item;
	        }
	        this._head = item;
	        this._state++;
	    }
	    addItemLast(item) {
	        // First time Insert
	        if (!this._head && !this._tail) {
	            this._head = item;
	        }
	        else if (!this._tail) {
	            throw new Error('Invalid list');
	        }
	        else {
	            item.previous = this._tail;
	            this._tail.next = item;
	        }
	        this._tail = item;
	        this._state++;
	    }
	    removeItem(item) {
	        if (item === this._head && item === this._tail) {
	            this._head = undefined;
	            this._tail = undefined;
	        }
	        else if (item === this._head) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.next) {
	                throw new Error('Invalid list');
	            }
	            item.next.previous = undefined;
	            this._head = item.next;
	        }
	        else if (item === this._tail) {
	            // This can only happened if size === 1 which is handle
	            // by the case above.
	            if (!item.previous) {
	                throw new Error('Invalid list');
	            }
	            item.previous.next = undefined;
	            this._tail = item.previous;
	        }
	        else {
	            const next = item.next;
	            const previous = item.previous;
	            if (!next || !previous) {
	                throw new Error('Invalid list');
	            }
	            next.previous = previous;
	            previous.next = next;
	        }
	        item.next = undefined;
	        item.previous = undefined;
	        this._state++;
	    }
	    touch(item, touch) {
	        if (!this._head || !this._tail) {
	            throw new Error('Invalid list');
	        }
	        if ((touch !== Touch.First && touch !== Touch.Last)) {
	            return;
	        }
	        if (touch === Touch.First) {
	            if (item === this._head) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item
	            if (item === this._tail) {
	                // previous must be defined since item was not head but is tail
	                // So there are more than on item in the map
	                previous.next = undefined;
	                this._tail = previous;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            // Insert the node at head
	            item.previous = undefined;
	            item.next = this._head;
	            this._head.previous = item;
	            this._head = item;
	            this._state++;
	        }
	        else if (touch === Touch.Last) {
	            if (item === this._tail) {
	                return;
	            }
	            const next = item.next;
	            const previous = item.previous;
	            // Unlink the item.
	            if (item === this._head) {
	                // next must be defined since item was not tail but is head
	                // So there are more than on item in the map
	                next.previous = undefined;
	                this._head = next;
	            }
	            else {
	                // Both next and previous are not undefined since item was neither head nor tail.
	                next.previous = previous;
	                previous.next = next;
	            }
	            item.next = undefined;
	            item.previous = this._tail;
	            this._tail.next = item;
	            this._tail = item;
	            this._state++;
	        }
	    }
	    toJSON() {
	        const data = [];
	        this.forEach((value, key) => {
	            data.push([key, value]);
	        });
	        return data;
	    }
	    fromJSON(data) {
	        this.clear();
	        for (const [key, value] of data) {
	            this.set(key, value);
	        }
	    }
	}
	linkedMap.LinkedMap = LinkedMap;
	class LRUCache extends LinkedMap {
	    constructor(limit, ratio = 1) {
	        super();
	        this._limit = limit;
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	    }
	    get limit() {
	        return this._limit;
	    }
	    set limit(limit) {
	        this._limit = limit;
	        this.checkTrim();
	    }
	    get ratio() {
	        return this._ratio;
	    }
	    set ratio(ratio) {
	        this._ratio = Math.min(Math.max(0, ratio), 1);
	        this.checkTrim();
	    }
	    get(key, touch = Touch.AsNew) {
	        return super.get(key, touch);
	    }
	    peek(key) {
	        return super.get(key, Touch.None);
	    }
	    set(key, value) {
	        super.set(key, value, Touch.Last);
	        this.checkTrim();
	        return this;
	    }
	    checkTrim() {
	        if (this.size > this._limit) {
	            this.trimOld(Math.round(this._limit * this._ratio));
	        }
	    }
	}
	linkedMap.LRUCache = LRUCache;
	return linkedMap;
}

var disposable = {};

var hasRequiredDisposable;

function requireDisposable () {
	if (hasRequiredDisposable) return disposable;
	hasRequiredDisposable = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(disposable, "__esModule", { value: true });
	disposable.Disposable = void 0;
	var Disposable;
	(function (Disposable) {
	    function create(func) {
	        return {
	            dispose: func
	        };
	    }
	    Disposable.create = create;
	})(Disposable || (disposable.Disposable = Disposable = {}));
	return disposable;
}

var events = {};

var ral$1 = {};

var hasRequiredRal$1;

function requireRal$1 () {
	if (hasRequiredRal$1) return ral$1;
	hasRequiredRal$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(ral$1, "__esModule", { value: true });
	let _ral;
	function RAL() {
	    if (_ral === undefined) {
	        throw new Error(`No runtime abstraction layer installed`);
	    }
	    return _ral;
	}
	(function (RAL) {
	    function install(ral) {
	        if (ral === undefined) {
	            throw new Error(`No runtime abstraction layer provided`);
	        }
	        _ral = ral;
	    }
	    RAL.install = install;
	})(RAL || (RAL = {}));
	ral$1.default = RAL;
	return ral$1;
}

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(events, "__esModule", { value: true });
	events.Emitter = events.Event = void 0;
	const ral_1 = requireRal$1();
	var Event;
	(function (Event) {
	    const _disposable = { dispose() { } };
	    Event.None = function () { return _disposable; };
	})(Event || (events.Event = Event = {}));
	class CallbackList {
	    add(callback, context = null, bucket) {
	        if (!this._callbacks) {
	            this._callbacks = [];
	            this._contexts = [];
	        }
	        this._callbacks.push(callback);
	        this._contexts.push(context);
	        if (Array.isArray(bucket)) {
	            bucket.push({ dispose: () => this.remove(callback, context) });
	        }
	    }
	    remove(callback, context = null) {
	        if (!this._callbacks) {
	            return;
	        }
	        let foundCallbackWithDifferentContext = false;
	        for (let i = 0, len = this._callbacks.length; i < len; i++) {
	            if (this._callbacks[i] === callback) {
	                if (this._contexts[i] === context) {
	                    // callback & context match => remove it
	                    this._callbacks.splice(i, 1);
	                    this._contexts.splice(i, 1);
	                    return;
	                }
	                else {
	                    foundCallbackWithDifferentContext = true;
	                }
	            }
	        }
	        if (foundCallbackWithDifferentContext) {
	            throw new Error('When adding a listener with a context, you should remove it with the same context');
	        }
	    }
	    invoke(...args) {
	        if (!this._callbacks) {
	            return [];
	        }
	        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
	        for (let i = 0, len = callbacks.length; i < len; i++) {
	            try {
	                ret.push(callbacks[i].apply(contexts[i], args));
	            }
	            catch (e) {
	                // eslint-disable-next-line no-console
	                (0, ral_1.default)().console.error(e);
	            }
	        }
	        return ret;
	    }
	    isEmpty() {
	        return !this._callbacks || this._callbacks.length === 0;
	    }
	    dispose() {
	        this._callbacks = undefined;
	        this._contexts = undefined;
	    }
	}
	class Emitter {
	    constructor(_options) {
	        this._options = _options;
	    }
	    /**
	     * For the public to allow to subscribe
	     * to events from this Emitter
	     */
	    get event() {
	        if (!this._event) {
	            this._event = (listener, thisArgs, disposables) => {
	                if (!this._callbacks) {
	                    this._callbacks = new CallbackList();
	                }
	                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
	                    this._options.onFirstListenerAdd(this);
	                }
	                this._callbacks.add(listener, thisArgs);
	                const result = {
	                    dispose: () => {
	                        if (!this._callbacks) {
	                            // disposable is disposed after emitter is disposed.
	                            return;
	                        }
	                        this._callbacks.remove(listener, thisArgs);
	                        result.dispose = Emitter._noop;
	                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
	                            this._options.onLastListenerRemove(this);
	                        }
	                    }
	                };
	                if (Array.isArray(disposables)) {
	                    disposables.push(result);
	                }
	                return result;
	            };
	        }
	        return this._event;
	    }
	    /**
	     * To be kept private to fire an event to
	     * subscribers
	     */
	    fire(event) {
	        if (this._callbacks) {
	            this._callbacks.invoke.call(this._callbacks, event);
	        }
	    }
	    dispose() {
	        if (this._callbacks) {
	            this._callbacks.dispose();
	            this._callbacks = undefined;
	        }
	    }
	}
	events.Emitter = Emitter;
	Emitter._noop = function () { };
	return events;
}

var cancellation$1 = {};

var hasRequiredCancellation$1;

function requireCancellation$1 () {
	if (hasRequiredCancellation$1) return cancellation$1;
	hasRequiredCancellation$1 = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(cancellation$1, "__esModule", { value: true });
	cancellation$1.CancellationTokenSource = cancellation$1.CancellationToken = void 0;
	const ral_1 = requireRal$1();
	const Is = requireIs$1();
	const events_1 = requireEvents();
	var CancellationToken;
	(function (CancellationToken) {
	    CancellationToken.None = Object.freeze({
	        isCancellationRequested: false,
	        onCancellationRequested: events_1.Event.None
	    });
	    CancellationToken.Cancelled = Object.freeze({
	        isCancellationRequested: true,
	        onCancellationRequested: events_1.Event.None
	    });
	    function is(value) {
	        const candidate = value;
	        return candidate && (candidate === CancellationToken.None
	            || candidate === CancellationToken.Cancelled
	            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
	    }
	    CancellationToken.is = is;
	})(CancellationToken || (cancellation$1.CancellationToken = CancellationToken = {}));
	const shortcutEvent = Object.freeze(function (callback, context) {
	    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
	    return { dispose() { handle.dispose(); } };
	});
	class MutableToken {
	    constructor() {
	        this._isCancelled = false;
	    }
	    cancel() {
	        if (!this._isCancelled) {
	            this._isCancelled = true;
	            if (this._emitter) {
	                this._emitter.fire(undefined);
	                this.dispose();
	            }
	        }
	    }
	    get isCancellationRequested() {
	        return this._isCancelled;
	    }
	    get onCancellationRequested() {
	        if (this._isCancelled) {
	            return shortcutEvent;
	        }
	        if (!this._emitter) {
	            this._emitter = new events_1.Emitter();
	        }
	        return this._emitter.event;
	    }
	    dispose() {
	        if (this._emitter) {
	            this._emitter.dispose();
	            this._emitter = undefined;
	        }
	    }
	}
	class CancellationTokenSource {
	    get token() {
	        if (!this._token) {
	            // be lazy and create the token only when
	            // actually needed
	            this._token = new MutableToken();
	        }
	        return this._token;
	    }
	    cancel() {
	        if (!this._token) {
	            // save an object by returning the default
	            // cancelled token when cancellation happens
	            // before someone asks for the token
	            this._token = CancellationToken.Cancelled;
	        }
	        else {
	            this._token.cancel();
	        }
	    }
	    dispose() {
	        if (!this._token) {
	            // ensure to initialize with an empty token if we had none
	            this._token = CancellationToken.None;
	        }
	        else if (this._token instanceof MutableToken) {
	            // actually dispose
	            this._token.dispose();
	        }
	    }
	}
	cancellation$1.CancellationTokenSource = CancellationTokenSource;
	return cancellation$1;
}

var sharedArrayCancellation = {};

var hasRequiredSharedArrayCancellation;

function requireSharedArrayCancellation () {
	if (hasRequiredSharedArrayCancellation) return sharedArrayCancellation;
	hasRequiredSharedArrayCancellation = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(sharedArrayCancellation, "__esModule", { value: true });
	sharedArrayCancellation.SharedArrayReceiverStrategy = sharedArrayCancellation.SharedArraySenderStrategy = void 0;
	const cancellation_1 = requireCancellation$1();
	var CancellationState;
	(function (CancellationState) {
	    CancellationState.Continue = 0;
	    CancellationState.Cancelled = 1;
	})(CancellationState || (CancellationState = {}));
	class SharedArraySenderStrategy {
	    constructor() {
	        this.buffers = new Map();
	    }
	    enableCancellation(request) {
	        if (request.id === null) {
	            return;
	        }
	        const buffer = new SharedArrayBuffer(4);
	        const data = new Int32Array(buffer, 0, 1);
	        data[0] = CancellationState.Continue;
	        this.buffers.set(request.id, buffer);
	        request.$cancellationData = buffer;
	    }
	    async sendCancellation(_conn, id) {
	        const buffer = this.buffers.get(id);
	        if (buffer === undefined) {
	            return;
	        }
	        const data = new Int32Array(buffer, 0, 1);
	        Atomics.store(data, 0, CancellationState.Cancelled);
	    }
	    cleanup(id) {
	        this.buffers.delete(id);
	    }
	    dispose() {
	        this.buffers.clear();
	    }
	}
	sharedArrayCancellation.SharedArraySenderStrategy = SharedArraySenderStrategy;
	class SharedArrayBufferCancellationToken {
	    constructor(buffer) {
	        this.data = new Int32Array(buffer, 0, 1);
	    }
	    get isCancellationRequested() {
	        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
	    }
	    get onCancellationRequested() {
	        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
	    }
	}
	class SharedArrayBufferCancellationTokenSource {
	    constructor(buffer) {
	        this.token = new SharedArrayBufferCancellationToken(buffer);
	    }
	    cancel() {
	    }
	    dispose() {
	    }
	}
	class SharedArrayReceiverStrategy {
	    constructor() {
	        this.kind = 'request';
	    }
	    createCancellationTokenSource(request) {
	        const buffer = request.$cancellationData;
	        if (buffer === undefined) {
	            return new cancellation_1.CancellationTokenSource();
	        }
	        return new SharedArrayBufferCancellationTokenSource(buffer);
	    }
	}
	sharedArrayCancellation.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
	return sharedArrayCancellation;
}

var messageReader = {};

var semaphore = {};

var hasRequiredSemaphore;

function requireSemaphore () {
	if (hasRequiredSemaphore) return semaphore;
	hasRequiredSemaphore = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semaphore, "__esModule", { value: true });
	semaphore.Semaphore = void 0;
	const ral_1 = requireRal$1();
	class Semaphore {
	    constructor(capacity = 1) {
	        if (capacity <= 0) {
	            throw new Error('Capacity must be greater than 0');
	        }
	        this._capacity = capacity;
	        this._active = 0;
	        this._waiting = [];
	    }
	    lock(thunk) {
	        return new Promise((resolve, reject) => {
	            this._waiting.push({ thunk, resolve, reject });
	            this.runNext();
	        });
	    }
	    get active() {
	        return this._active;
	    }
	    runNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
	    }
	    doRunNext() {
	        if (this._waiting.length === 0 || this._active === this._capacity) {
	            return;
	        }
	        const next = this._waiting.shift();
	        this._active++;
	        if (this._active > this._capacity) {
	            throw new Error(`To many thunks active`);
	        }
	        try {
	            const result = next.thunk();
	            if (result instanceof Promise) {
	                result.then((value) => {
	                    this._active--;
	                    next.resolve(value);
	                    this.runNext();
	                }, (err) => {
	                    this._active--;
	                    next.reject(err);
	                    this.runNext();
	                });
	            }
	            else {
	                this._active--;
	                next.resolve(result);
	                this.runNext();
	            }
	        }
	        catch (err) {
	            this._active--;
	            next.reject(err);
	            this.runNext();
	        }
	    }
	}
	semaphore.Semaphore = Semaphore;
	return semaphore;
}

var hasRequiredMessageReader;

function requireMessageReader () {
	if (hasRequiredMessageReader) return messageReader;
	hasRequiredMessageReader = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageReader, "__esModule", { value: true });
	messageReader.ReadableStreamMessageReader = messageReader.AbstractMessageReader = messageReader.MessageReader = void 0;
	const ral_1 = requireRal$1();
	const Is = requireIs$1();
	const events_1 = requireEvents();
	const semaphore_1 = requireSemaphore();
	var MessageReader;
	(function (MessageReader) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
	            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
	    }
	    MessageReader.is = is;
	})(MessageReader || (messageReader.MessageReader = MessageReader = {}));
	class AbstractMessageReader {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	        this.partialMessageEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error) {
	        this.errorEmitter.fire(this.asError(error));
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    get onPartialMessage() {
	        return this.partialMessageEmitter.event;
	    }
	    firePartialMessage(info) {
	        this.partialMessageEmitter.fire(info);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageReader.AbstractMessageReader = AbstractMessageReader;
	var ResolvedMessageReaderOptions;
	(function (ResolvedMessageReaderOptions) {
	    function fromOptions(options) {
	        let charset;
	        let contentDecoder;
	        const contentDecoders = new Map();
	        let contentTypeDecoder;
	        const contentTypeDecoders = new Map();
	        if (options === undefined || typeof options === 'string') {
	            charset = options ?? 'utf-8';
	        }
	        else {
	            charset = options.charset ?? 'utf-8';
	            if (options.contentDecoder !== undefined) {
	                contentDecoder = options.contentDecoder;
	                contentDecoders.set(contentDecoder.name, contentDecoder);
	            }
	            if (options.contentDecoders !== undefined) {
	                for (const decoder of options.contentDecoders) {
	                    contentDecoders.set(decoder.name, decoder);
	                }
	            }
	            if (options.contentTypeDecoder !== undefined) {
	                contentTypeDecoder = options.contentTypeDecoder;
	                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	            }
	            if (options.contentTypeDecoders !== undefined) {
	                for (const decoder of options.contentTypeDecoders) {
	                    contentTypeDecoders.set(decoder.name, decoder);
	                }
	            }
	        }
	        if (contentTypeDecoder === undefined) {
	            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
	            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
	        }
	        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
	    }
	    ResolvedMessageReaderOptions.fromOptions = fromOptions;
	})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
	class ReadableStreamMessageReader extends AbstractMessageReader {
	    constructor(readable, options) {
	        super();
	        this.readable = readable;
	        this.options = ResolvedMessageReaderOptions.fromOptions(options);
	        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
	        this._partialMessageTimeout = 10000;
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.readSemaphore = new semaphore_1.Semaphore(1);
	    }
	    set partialMessageTimeout(timeout) {
	        this._partialMessageTimeout = timeout;
	    }
	    get partialMessageTimeout() {
	        return this._partialMessageTimeout;
	    }
	    listen(callback) {
	        this.nextMessageLength = -1;
	        this.messageToken = 0;
	        this.partialMessageTimer = undefined;
	        this.callback = callback;
	        const result = this.readable.onData((data) => {
	            this.onData(data);
	        });
	        this.readable.onError((error) => this.fireError(error));
	        this.readable.onClose(() => this.fireClose());
	        return result;
	    }
	    onData(data) {
	        try {
	            this.buffer.append(data);
	            while (true) {
	                if (this.nextMessageLength === -1) {
	                    const headers = this.buffer.tryReadHeaders(true);
	                    if (!headers) {
	                        return;
	                    }
	                    const contentLength = headers.get('content-length');
	                    if (!contentLength) {
	                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
	                        return;
	                    }
	                    const length = parseInt(contentLength);
	                    if (isNaN(length)) {
	                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
	                        return;
	                    }
	                    this.nextMessageLength = length;
	                }
	                const body = this.buffer.tryReadBody(this.nextMessageLength);
	                if (body === undefined) {
	                    /** We haven't received the full message yet. */
	                    this.setPartialMessageTimer();
	                    return;
	                }
	                this.clearPartialMessageTimer();
	                this.nextMessageLength = -1;
	                // Make sure that we convert one received message after the
	                // other. Otherwise it could happen that a decoding of a second
	                // smaller message finished before the decoding of a first larger
	                // message and then we would deliver the second message first.
	                this.readSemaphore.lock(async () => {
	                    const bytes = this.options.contentDecoder !== undefined
	                        ? await this.options.contentDecoder.decode(body)
	                        : body;
	                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
	                    this.callback(message);
	                }).catch((error) => {
	                    this.fireError(error);
	                });
	            }
	        }
	        catch (error) {
	            this.fireError(error);
	        }
	    }
	    clearPartialMessageTimer() {
	        if (this.partialMessageTimer) {
	            this.partialMessageTimer.dispose();
	            this.partialMessageTimer = undefined;
	        }
	    }
	    setPartialMessageTimer() {
	        this.clearPartialMessageTimer();
	        if (this._partialMessageTimeout <= 0) {
	            return;
	        }
	        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
	            this.partialMessageTimer = undefined;
	            if (token === this.messageToken) {
	                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
	                this.setPartialMessageTimer();
	            }
	        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
	    }
	}
	messageReader.ReadableStreamMessageReader = ReadableStreamMessageReader;
	return messageReader;
}

var messageWriter = {};

var hasRequiredMessageWriter;

function requireMessageWriter () {
	if (hasRequiredMessageWriter) return messageWriter;
	hasRequiredMessageWriter = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messageWriter, "__esModule", { value: true });
	messageWriter.WriteableStreamMessageWriter = messageWriter.AbstractMessageWriter = messageWriter.MessageWriter = void 0;
	const ral_1 = requireRal$1();
	const Is = requireIs$1();
	const semaphore_1 = requireSemaphore();
	const events_1 = requireEvents();
	const ContentLength = 'Content-Length: ';
	const CRLF = '\r\n';
	var MessageWriter;
	(function (MessageWriter) {
	    function is(value) {
	        let candidate = value;
	        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
	            Is.func(candidate.onError) && Is.func(candidate.write);
	    }
	    MessageWriter.is = is;
	})(MessageWriter || (messageWriter.MessageWriter = MessageWriter = {}));
	class AbstractMessageWriter {
	    constructor() {
	        this.errorEmitter = new events_1.Emitter();
	        this.closeEmitter = new events_1.Emitter();
	    }
	    dispose() {
	        this.errorEmitter.dispose();
	        this.closeEmitter.dispose();
	    }
	    get onError() {
	        return this.errorEmitter.event;
	    }
	    fireError(error, message, count) {
	        this.errorEmitter.fire([this.asError(error), message, count]);
	    }
	    get onClose() {
	        return this.closeEmitter.event;
	    }
	    fireClose() {
	        this.closeEmitter.fire(undefined);
	    }
	    asError(error) {
	        if (error instanceof Error) {
	            return error;
	        }
	        else {
	            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
	        }
	    }
	}
	messageWriter.AbstractMessageWriter = AbstractMessageWriter;
	var ResolvedMessageWriterOptions;
	(function (ResolvedMessageWriterOptions) {
	    function fromOptions(options) {
	        if (options === undefined || typeof options === 'string') {
	            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
	        }
	        else {
	            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
	        }
	    }
	    ResolvedMessageWriterOptions.fromOptions = fromOptions;
	})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
	class WriteableStreamMessageWriter extends AbstractMessageWriter {
	    constructor(writable, options) {
	        super();
	        this.writable = writable;
	        this.options = ResolvedMessageWriterOptions.fromOptions(options);
	        this.errorCount = 0;
	        this.writeSemaphore = new semaphore_1.Semaphore(1);
	        this.writable.onError((error) => this.fireError(error));
	        this.writable.onClose(() => this.fireClose());
	    }
	    async write(msg) {
	        return this.writeSemaphore.lock(async () => {
	            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
	                if (this.options.contentEncoder !== undefined) {
	                    return this.options.contentEncoder.encode(buffer);
	                }
	                else {
	                    return buffer;
	                }
	            });
	            return payload.then((buffer) => {
	                const headers = [];
	                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
	                headers.push(CRLF);
	                return this.doWrite(msg, headers, buffer);
	            }, (error) => {
	                this.fireError(error);
	                throw error;
	            });
	        });
	    }
	    async doWrite(msg, headers, data) {
	        try {
	            await this.writable.write(headers.join(''), 'ascii');
	            return this.writable.write(data);
	        }
	        catch (error) {
	            this.handleError(error, msg);
	            return Promise.reject(error);
	        }
	    }
	    handleError(error, msg) {
	        this.errorCount++;
	        this.fireError(error, msg, this.errorCount);
	    }
	    end() {
	        this.writable.end();
	    }
	}
	messageWriter.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
	return messageWriter;
}

var messageBuffer = {};

var hasRequiredMessageBuffer;

function requireMessageBuffer () {
	if (hasRequiredMessageBuffer) return messageBuffer;
	hasRequiredMessageBuffer = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(messageBuffer, "__esModule", { value: true });
	messageBuffer.AbstractMessageBuffer = void 0;
	const CR = 13;
	const LF = 10;
	const CRLF = '\r\n';
	class AbstractMessageBuffer {
	    constructor(encoding = 'utf-8') {
	        this._encoding = encoding;
	        this._chunks = [];
	        this._totalLength = 0;
	    }
	    get encoding() {
	        return this._encoding;
	    }
	    append(chunk) {
	        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
	        this._chunks.push(toAppend);
	        this._totalLength += toAppend.byteLength;
	    }
	    tryReadHeaders(lowerCaseKeys = false) {
	        if (this._chunks.length === 0) {
	            return undefined;
	        }
	        let state = 0;
	        let chunkIndex = 0;
	        let offset = 0;
	        let chunkBytesRead = 0;
	        row: while (chunkIndex < this._chunks.length) {
	            const chunk = this._chunks[chunkIndex];
	            offset = 0;
	            while (offset < chunk.length) {
	                const value = chunk[offset];
	                switch (value) {
	                    case CR:
	                        switch (state) {
	                            case 0:
	                                state = 1;
	                                break;
	                            case 2:
	                                state = 3;
	                                break;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    case LF:
	                        switch (state) {
	                            case 1:
	                                state = 2;
	                                break;
	                            case 3:
	                                state = 4;
	                                offset++;
	                                break row;
	                            default:
	                                state = 0;
	                        }
	                        break;
	                    default:
	                        state = 0;
	                }
	                offset++;
	            }
	            chunkBytesRead += chunk.byteLength;
	            chunkIndex++;
	        }
	        if (state !== 4) {
	            return undefined;
	        }
	        // The buffer contains the two CRLF at the end. So we will
	        // have two empty lines after the split at the end as well.
	        const buffer = this._read(chunkBytesRead + offset);
	        const result = new Map();
	        const headers = this.toString(buffer, 'ascii').split(CRLF);
	        if (headers.length < 2) {
	            return result;
	        }
	        for (let i = 0; i < headers.length - 2; i++) {
	            const header = headers[i];
	            const index = header.indexOf(':');
	            if (index === -1) {
	                throw new Error(`Message header must separate key and value using ':'\n${header}`);
	            }
	            const key = header.substr(0, index);
	            const value = header.substr(index + 1).trim();
	            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
	        }
	        return result;
	    }
	    tryReadBody(length) {
	        if (this._totalLength < length) {
	            return undefined;
	        }
	        return this._read(length);
	    }
	    get numberOfBytes() {
	        return this._totalLength;
	    }
	    _read(byteCount) {
	        if (byteCount === 0) {
	            return this.emptyBuffer();
	        }
	        if (byteCount > this._totalLength) {
	            throw new Error(`Cannot read so many bytes!`);
	        }
	        if (this._chunks[0].byteLength === byteCount) {
	            // super fast path, precisely first chunk must be returned
	            const chunk = this._chunks[0];
	            this._chunks.shift();
	            this._totalLength -= byteCount;
	            return this.asNative(chunk);
	        }
	        if (this._chunks[0].byteLength > byteCount) {
	            // fast path, the reading is entirely within the first chunk
	            const chunk = this._chunks[0];
	            const result = this.asNative(chunk, byteCount);
	            this._chunks[0] = chunk.slice(byteCount);
	            this._totalLength -= byteCount;
	            return result;
	        }
	        const result = this.allocNative(byteCount);
	        let resultOffset = 0;
	        let chunkIndex = 0;
	        while (byteCount > 0) {
	            const chunk = this._chunks[chunkIndex];
	            if (chunk.byteLength > byteCount) {
	                // this chunk will survive
	                const chunkPart = chunk.slice(0, byteCount);
	                result.set(chunkPart, resultOffset);
	                resultOffset += byteCount;
	                this._chunks[chunkIndex] = chunk.slice(byteCount);
	                this._totalLength -= byteCount;
	                byteCount -= byteCount;
	            }
	            else {
	                // this chunk will be entirely read
	                result.set(chunk, resultOffset);
	                resultOffset += chunk.byteLength;
	                this._chunks.shift();
	                this._totalLength -= chunk.byteLength;
	                byteCount -= chunk.byteLength;
	            }
	        }
	        return result;
	    }
	}
	messageBuffer.AbstractMessageBuffer = AbstractMessageBuffer;
	return messageBuffer;
}

var connection$2 = {};

var hasRequiredConnection$1;

function requireConnection$1 () {
	if (hasRequiredConnection$1) return connection$2;
	hasRequiredConnection$1 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createMessageConnection = exports$1.ConnectionOptions = exports$1.MessageStrategy = exports$1.CancellationStrategy = exports$1.CancellationSenderStrategy = exports$1.CancellationReceiverStrategy = exports$1.RequestCancellationReceiverStrategy = exports$1.IdCancellationReceiverStrategy = exports$1.ConnectionStrategy = exports$1.ConnectionError = exports$1.ConnectionErrors = exports$1.LogTraceNotification = exports$1.SetTraceNotification = exports$1.TraceFormat = exports$1.TraceValues = exports$1.Trace = exports$1.NullLogger = exports$1.ProgressType = exports$1.ProgressToken = void 0;
		const ral_1 = requireRal$1();
		const Is = requireIs$1();
		const messages_1 = requireMessages$1();
		const linkedMap_1 = requireLinkedMap();
		const events_1 = requireEvents();
		const cancellation_1 = requireCancellation$1();
		var CancelNotification;
		(function (CancelNotification) {
		    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
		})(CancelNotification || (CancelNotification = {}));
		var ProgressToken;
		(function (ProgressToken) {
		    function is(value) {
		        return typeof value === 'string' || typeof value === 'number';
		    }
		    ProgressToken.is = is;
		})(ProgressToken || (exports$1.ProgressToken = ProgressToken = {}));
		var ProgressNotification;
		(function (ProgressNotification) {
		    ProgressNotification.type = new messages_1.NotificationType('$/progress');
		})(ProgressNotification || (ProgressNotification = {}));
		class ProgressType {
		    constructor() {
		    }
		}
		exports$1.ProgressType = ProgressType;
		var StarRequestHandler;
		(function (StarRequestHandler) {
		    function is(value) {
		        return Is.func(value);
		    }
		    StarRequestHandler.is = is;
		})(StarRequestHandler || (StarRequestHandler = {}));
		exports$1.NullLogger = Object.freeze({
		    error: () => { },
		    warn: () => { },
		    info: () => { },
		    log: () => { }
		});
		var Trace;
		(function (Trace) {
		    Trace[Trace["Off"] = 0] = "Off";
		    Trace[Trace["Messages"] = 1] = "Messages";
		    Trace[Trace["Compact"] = 2] = "Compact";
		    Trace[Trace["Verbose"] = 3] = "Verbose";
		})(Trace || (exports$1.Trace = Trace = {}));
		var TraceValues;
		(function (TraceValues) {
		    /**
		     * Turn tracing off.
		     */
		    TraceValues.Off = 'off';
		    /**
		     * Trace messages only.
		     */
		    TraceValues.Messages = 'messages';
		    /**
		     * Compact message tracing.
		     */
		    TraceValues.Compact = 'compact';
		    /**
		     * Verbose message tracing.
		     */
		    TraceValues.Verbose = 'verbose';
		})(TraceValues || (exports$1.TraceValues = TraceValues = {}));
		(function (Trace) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return Trace.Off;
		        }
		        value = value.toLowerCase();
		        switch (value) {
		            case 'off':
		                return Trace.Off;
		            case 'messages':
		                return Trace.Messages;
		            case 'compact':
		                return Trace.Compact;
		            case 'verbose':
		                return Trace.Verbose;
		            default:
		                return Trace.Off;
		        }
		    }
		    Trace.fromString = fromString;
		    function toString(value) {
		        switch (value) {
		            case Trace.Off:
		                return 'off';
		            case Trace.Messages:
		                return 'messages';
		            case Trace.Compact:
		                return 'compact';
		            case Trace.Verbose:
		                return 'verbose';
		            default:
		                return 'off';
		        }
		    }
		    Trace.toString = toString;
		})(Trace || (exports$1.Trace = Trace = {}));
		var TraceFormat;
		(function (TraceFormat) {
		    TraceFormat["Text"] = "text";
		    TraceFormat["JSON"] = "json";
		})(TraceFormat || (exports$1.TraceFormat = TraceFormat = {}));
		(function (TraceFormat) {
		    function fromString(value) {
		        if (!Is.string(value)) {
		            return TraceFormat.Text;
		        }
		        value = value.toLowerCase();
		        if (value === 'json') {
		            return TraceFormat.JSON;
		        }
		        else {
		            return TraceFormat.Text;
		        }
		    }
		    TraceFormat.fromString = fromString;
		})(TraceFormat || (exports$1.TraceFormat = TraceFormat = {}));
		var SetTraceNotification;
		(function (SetTraceNotification) {
		    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
		})(SetTraceNotification || (exports$1.SetTraceNotification = SetTraceNotification = {}));
		var LogTraceNotification;
		(function (LogTraceNotification) {
		    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
		})(LogTraceNotification || (exports$1.LogTraceNotification = LogTraceNotification = {}));
		var ConnectionErrors;
		(function (ConnectionErrors) {
		    /**
		     * The connection is closed.
		     */
		    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
		    /**
		     * The connection got disposed.
		     */
		    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
		    /**
		     * The connection is already in listening mode.
		     */
		    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
		})(ConnectionErrors || (exports$1.ConnectionErrors = ConnectionErrors = {}));
		class ConnectionError extends Error {
		    constructor(code, message) {
		        super(message);
		        this.code = code;
		        Object.setPrototypeOf(this, ConnectionError.prototype);
		    }
		}
		exports$1.ConnectionError = ConnectionError;
		var ConnectionStrategy;
		(function (ConnectionStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.cancelUndispatched);
		    }
		    ConnectionStrategy.is = is;
		})(ConnectionStrategy || (exports$1.ConnectionStrategy = ConnectionStrategy = {}));
		var IdCancellationReceiverStrategy;
		(function (IdCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    IdCancellationReceiverStrategy.is = is;
		})(IdCancellationReceiverStrategy || (exports$1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
		var RequestCancellationReceiverStrategy;
		(function (RequestCancellationReceiverStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
		    }
		    RequestCancellationReceiverStrategy.is = is;
		})(RequestCancellationReceiverStrategy || (exports$1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
		var CancellationReceiverStrategy;
		(function (CancellationReceiverStrategy) {
		    CancellationReceiverStrategy.Message = Object.freeze({
		        createCancellationTokenSource(_) {
		            return new cancellation_1.CancellationTokenSource();
		        }
		    });
		    function is(value) {
		        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
		    }
		    CancellationReceiverStrategy.is = is;
		})(CancellationReceiverStrategy || (exports$1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
		var CancellationSenderStrategy;
		(function (CancellationSenderStrategy) {
		    CancellationSenderStrategy.Message = Object.freeze({
		        sendCancellation(conn, id) {
		            return conn.sendNotification(CancelNotification.type, { id });
		        },
		        cleanup(_) { }
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
		    }
		    CancellationSenderStrategy.is = is;
		})(CancellationSenderStrategy || (exports$1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
		var CancellationStrategy;
		(function (CancellationStrategy) {
		    CancellationStrategy.Message = Object.freeze({
		        receiver: CancellationReceiverStrategy.Message,
		        sender: CancellationSenderStrategy.Message
		    });
		    function is(value) {
		        const candidate = value;
		        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
		    }
		    CancellationStrategy.is = is;
		})(CancellationStrategy || (exports$1.CancellationStrategy = CancellationStrategy = {}));
		var MessageStrategy;
		(function (MessageStrategy) {
		    function is(value) {
		        const candidate = value;
		        return candidate && Is.func(candidate.handleMessage);
		    }
		    MessageStrategy.is = is;
		})(MessageStrategy || (exports$1.MessageStrategy = MessageStrategy = {}));
		var ConnectionOptions;
		(function (ConnectionOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
		    }
		    ConnectionOptions.is = is;
		})(ConnectionOptions || (exports$1.ConnectionOptions = ConnectionOptions = {}));
		var ConnectionState;
		(function (ConnectionState) {
		    ConnectionState[ConnectionState["New"] = 1] = "New";
		    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
		    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
		    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
		})(ConnectionState || (ConnectionState = {}));
		function createMessageConnection(messageReader, messageWriter, _logger, options) {
		    const logger = _logger !== undefined ? _logger : exports$1.NullLogger;
		    let sequenceNumber = 0;
		    let notificationSequenceNumber = 0;
		    let unknownResponseSequenceNumber = 0;
		    const version = '2.0';
		    let starRequestHandler = undefined;
		    const requestHandlers = new Map();
		    let starNotificationHandler = undefined;
		    const notificationHandlers = new Map();
		    const progressHandlers = new Map();
		    let timer;
		    let messageQueue = new linkedMap_1.LinkedMap();
		    let responsePromises = new Map();
		    let knownCanceledRequests = new Set();
		    let requestTokens = new Map();
		    let trace = Trace.Off;
		    let traceFormat = TraceFormat.Text;
		    let tracer;
		    let state = ConnectionState.New;
		    const errorEmitter = new events_1.Emitter();
		    const closeEmitter = new events_1.Emitter();
		    const unhandledNotificationEmitter = new events_1.Emitter();
		    const unhandledProgressEmitter = new events_1.Emitter();
		    const disposeEmitter = new events_1.Emitter();
		    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
		    function createRequestQueueKey(id) {
		        if (id === null) {
		            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
		        }
		        return 'req-' + id.toString();
		    }
		    function createResponseQueueKey(id) {
		        if (id === null) {
		            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
		        }
		        else {
		            return 'res-' + id.toString();
		        }
		    }
		    function createNotificationQueueKey() {
		        return 'not-' + (++notificationSequenceNumber).toString();
		    }
		    function addMessageToQueue(queue, message) {
		        if (messages_1.Message.isRequest(message)) {
		            queue.set(createRequestQueueKey(message.id), message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            queue.set(createResponseQueueKey(message.id), message);
		        }
		        else {
		            queue.set(createNotificationQueueKey(), message);
		        }
		    }
		    function cancelUndispatched(_message) {
		        return undefined;
		    }
		    function isListening() {
		        return state === ConnectionState.Listening;
		    }
		    function isClosed() {
		        return state === ConnectionState.Closed;
		    }
		    function isDisposed() {
		        return state === ConnectionState.Disposed;
		    }
		    function closeHandler() {
		        if (state === ConnectionState.New || state === ConnectionState.Listening) {
		            state = ConnectionState.Closed;
		            closeEmitter.fire(undefined);
		        }
		        // If the connection is disposed don't sent close events.
		    }
		    function readErrorHandler(error) {
		        errorEmitter.fire([error, undefined, undefined]);
		    }
		    function writeErrorHandler(data) {
		        errorEmitter.fire(data);
		    }
		    messageReader.onClose(closeHandler);
		    messageReader.onError(readErrorHandler);
		    messageWriter.onClose(closeHandler);
		    messageWriter.onError(writeErrorHandler);
		    function triggerMessageQueue() {
		        if (timer || messageQueue.size === 0) {
		            return;
		        }
		        timer = (0, ral_1.default)().timer.setImmediate(() => {
		            timer = undefined;
		            processMessageQueue();
		        });
		    }
		    function handleMessage(message) {
		        if (messages_1.Message.isRequest(message)) {
		            handleRequest(message);
		        }
		        else if (messages_1.Message.isNotification(message)) {
		            handleNotification(message);
		        }
		        else if (messages_1.Message.isResponse(message)) {
		            handleResponse(message);
		        }
		        else {
		            handleInvalidMessage(message);
		        }
		    }
		    function processMessageQueue() {
		        if (messageQueue.size === 0) {
		            return;
		        }
		        const message = messageQueue.shift();
		        try {
		            const messageStrategy = options?.messageStrategy;
		            if (MessageStrategy.is(messageStrategy)) {
		                messageStrategy.handleMessage(message, handleMessage);
		            }
		            else {
		                handleMessage(message);
		            }
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    }
		    const callback = (message) => {
		        try {
		            // We have received a cancellation message. Check if the message is still in the queue
		            // and cancel it if allowed to do so.
		            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
		                const cancelId = message.params.id;
		                const key = createRequestQueueKey(cancelId);
		                const toCancel = messageQueue.get(key);
		                if (messages_1.Message.isRequest(toCancel)) {
		                    const strategy = options?.connectionStrategy;
		                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
		                    if (response && (response.error !== undefined || response.result !== undefined)) {
		                        messageQueue.delete(key);
		                        requestTokens.delete(cancelId);
		                        response.id = toCancel.id;
		                        traceSendingResponse(response, message.method, Date.now());
		                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
		                        return;
		                    }
		                }
		                const cancellationToken = requestTokens.get(cancelId);
		                // The request is already running. Cancel the token
		                if (cancellationToken !== undefined) {
		                    cancellationToken.cancel();
		                    traceReceivedNotification(message);
		                    return;
		                }
		                else {
		                    // Remember the cancel but still queue the message to
		                    // clean up state in process message.
		                    knownCanceledRequests.add(cancelId);
		                }
		            }
		            addMessageToQueue(messageQueue, message);
		        }
		        finally {
		            triggerMessageQueue();
		        }
		    };
		    function handleRequest(requestMessage) {
		        if (isDisposed()) {
		            // we return here silently since we fired an event when the
		            // connection got disposed.
		            return;
		        }
		        function reply(resultOrError, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id
		            };
		            if (resultOrError instanceof messages_1.ResponseError) {
		                message.error = resultOrError.toJson();
		            }
		            else {
		                message.result = resultOrError === undefined ? null : resultOrError;
		            }
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replyError(error, method, startTime) {
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                error: error.toJson()
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        function replySuccess(result, method, startTime) {
		            // The JSON RPC defines that a response must either have a result or an error
		            // So we can't treat undefined as a valid response result.
		            if (result === undefined) {
		                result = null;
		            }
		            const message = {
		                jsonrpc: version,
		                id: requestMessage.id,
		                result: result
		            };
		            traceSendingResponse(message, method, startTime);
		            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
		        }
		        traceReceivedRequest(requestMessage);
		        const element = requestHandlers.get(requestMessage.method);
		        let type;
		        let requestHandler;
		        if (element) {
		            type = element.type;
		            requestHandler = element.handler;
		        }
		        const startTime = Date.now();
		        if (requestHandler || starRequestHandler) {
		            const tokenKey = requestMessage.id ?? String(Date.now()); //
		            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
		                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
		                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
		            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
		                cancellationSource.cancel();
		            }
		            if (requestMessage.id !== null) {
		                requestTokens.set(tokenKey, cancellationSource);
		            }
		            try {
		                let handlerResult;
		                if (requestHandler) {
		                    if (requestMessage.params === undefined) {
		                        if (type !== undefined && type.numberOfParams !== 0) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(cancellationSource.token);
		                    }
		                    else if (Array.isArray(requestMessage.params)) {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
		                            return;
		                        }
		                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
		                    }
		                }
		                else if (starRequestHandler) {
		                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
		                }
		                const promise = handlerResult;
		                if (!handlerResult) {
		                    requestTokens.delete(tokenKey);
		                    replySuccess(handlerResult, requestMessage.method, startTime);
		                }
		                else if (promise.then) {
		                    promise.then((resultOrError) => {
		                        requestTokens.delete(tokenKey);
		                        reply(resultOrError, requestMessage.method, startTime);
		                    }, error => {
		                        requestTokens.delete(tokenKey);
		                        if (error instanceof messages_1.ResponseError) {
		                            replyError(error, requestMessage.method, startTime);
		                        }
		                        else if (error && Is.string(error.message)) {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                        }
		                        else {
		                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                        }
		                    });
		                }
		                else {
		                    requestTokens.delete(tokenKey);
		                    reply(handlerResult, requestMessage.method, startTime);
		                }
		            }
		            catch (error) {
		                requestTokens.delete(tokenKey);
		                if (error instanceof messages_1.ResponseError) {
		                    reply(error, requestMessage.method, startTime);
		                }
		                else if (error && Is.string(error.message)) {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
		                }
		                else {
		                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
		                }
		            }
		        }
		        else {
		            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
		        }
		    }
		    function handleResponse(responseMessage) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        if (responseMessage.id === null) {
		            if (responseMessage.error) {
		                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
		            }
		            else {
		                logger.error(`Received response message without id. No further error information provided.`);
		            }
		        }
		        else {
		            const key = responseMessage.id;
		            const responsePromise = responsePromises.get(key);
		            traceReceivedResponse(responseMessage, responsePromise);
		            if (responsePromise !== undefined) {
		                responsePromises.delete(key);
		                try {
		                    if (responseMessage.error) {
		                        const error = responseMessage.error;
		                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
		                    }
		                    else if (responseMessage.result !== undefined) {
		                        responsePromise.resolve(responseMessage.result);
		                    }
		                    else {
		                        throw new Error('Should never happen.');
		                    }
		                }
		                catch (error) {
		                    if (error.message) {
		                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
		                    }
		                    else {
		                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
		                    }
		                }
		            }
		        }
		    }
		    function handleNotification(message) {
		        if (isDisposed()) {
		            // See handle request.
		            return;
		        }
		        let type = undefined;
		        let notificationHandler;
		        if (message.method === CancelNotification.type.method) {
		            const cancelId = message.params.id;
		            knownCanceledRequests.delete(cancelId);
		            traceReceivedNotification(message);
		            return;
		        }
		        else {
		            const element = notificationHandlers.get(message.method);
		            if (element) {
		                notificationHandler = element.handler;
		                type = element.type;
		            }
		        }
		        if (notificationHandler || starNotificationHandler) {
		            try {
		                traceReceivedNotification(message);
		                if (notificationHandler) {
		                    if (message.params === undefined) {
		                        if (type !== undefined) {
		                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
		                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
		                            }
		                        }
		                        notificationHandler();
		                    }
		                    else if (Array.isArray(message.params)) {
		                        // There are JSON-RPC libraries that send progress message as positional params although
		                        // specified as named. So convert them if this is the case.
		                        const params = message.params;
		                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
		                            notificationHandler({ token: params[0], value: params[1] });
		                        }
		                        else {
		                            if (type !== undefined) {
		                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
		                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
		                                }
		                                if (type.numberOfParams !== message.params.length) {
		                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
		                                }
		                            }
		                            notificationHandler(...params);
		                        }
		                    }
		                    else {
		                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
		                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
		                        }
		                        notificationHandler(message.params);
		                    }
		                }
		                else if (starNotificationHandler) {
		                    starNotificationHandler(message.method, message.params);
		                }
		            }
		            catch (error) {
		                if (error.message) {
		                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
		                }
		                else {
		                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
		                }
		            }
		        }
		        else {
		            unhandledNotificationEmitter.fire(message);
		        }
		    }
		    function handleInvalidMessage(message) {
		        if (!message) {
		            logger.error('Received empty message.');
		            return;
		        }
		        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
		        // Test whether we find an id to reject the promise
		        const responseMessage = message;
		        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
		            const key = responseMessage.id;
		            const responseHandler = responsePromises.get(key);
		            if (responseHandler) {
		                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
		            }
		        }
		    }
		    function stringifyTrace(params) {
		        if (params === undefined || params === null) {
		            return undefined;
		        }
		        switch (trace) {
		            case Trace.Verbose:
		                return JSON.stringify(params, null, 4);
		            case Trace.Compact:
		                return JSON.stringify(params);
		            default:
		                return undefined;
		        }
		    }
		    function traceSendingRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('send-request', message);
		        }
		    }
		    function traceSendingNotification(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Sending notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('send-notification', message);
		        }
		    }
		    function traceSendingResponse(message, method, startTime) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
		        }
		        else {
		            logLSPMessage('send-response', message);
		        }
		    }
		    function traceReceivedRequest(message) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
		                data = `Params: ${stringifyTrace(message.params)}\n\n`;
		            }
		            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
		        }
		        else {
		            logLSPMessage('receive-request', message);
		        }
		    }
		    function traceReceivedNotification(message) {
		        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.params) {
		                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
		                }
		                else {
		                    data = 'No parameters provided.\n\n';
		                }
		            }
		            tracer.log(`Received notification '${message.method}'.`, data);
		        }
		        else {
		            logLSPMessage('receive-notification', message);
		        }
		    }
		    function traceReceivedResponse(message, responsePromise) {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        if (traceFormat === TraceFormat.Text) {
		            let data = undefined;
		            if (trace === Trace.Verbose || trace === Trace.Compact) {
		                if (message.error && message.error.data) {
		                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
		                }
		                else {
		                    if (message.result) {
		                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
		                    }
		                    else if (message.error === undefined) {
		                        data = 'No result returned.\n\n';
		                    }
		                }
		            }
		            if (responsePromise) {
		                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
		                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
		            }
		            else {
		                tracer.log(`Received response ${message.id} without active response promise.`, data);
		            }
		        }
		        else {
		            logLSPMessage('receive-response', message);
		        }
		    }
		    function logLSPMessage(type, message) {
		        if (!tracer || trace === Trace.Off) {
		            return;
		        }
		        const lspMessage = {
		            isLSPMessage: true,
		            type,
		            message,
		            timestamp: Date.now()
		        };
		        tracer.log(lspMessage);
		    }
		    function throwIfClosedOrDisposed() {
		        if (isClosed()) {
		            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
		        }
		        if (isDisposed()) {
		            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
		        }
		    }
		    function throwIfListening() {
		        if (isListening()) {
		            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
		        }
		    }
		    function throwIfNotListening() {
		        if (!isListening()) {
		            throw new Error('Call listen() first.');
		        }
		    }
		    function undefinedToNull(param) {
		        if (param === undefined) {
		            return null;
		        }
		        else {
		            return param;
		        }
		    }
		    function nullToUndefined(param) {
		        if (param === null) {
		            return undefined;
		        }
		        else {
		            return param;
		        }
		    }
		    function isNamedParam(param) {
		        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
		    }
		    function computeSingleParam(parameterStructures, param) {
		        switch (parameterStructures) {
		            case messages_1.ParameterStructures.auto:
		                if (isNamedParam(param)) {
		                    return nullToUndefined(param);
		                }
		                else {
		                    return [undefinedToNull(param)];
		                }
		            case messages_1.ParameterStructures.byName:
		                if (!isNamedParam(param)) {
		                    throw new Error(`Received parameters by name but param is not an object literal.`);
		                }
		                return nullToUndefined(param);
		            case messages_1.ParameterStructures.byPosition:
		                return [undefinedToNull(param)];
		            default:
		                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
		        }
		    }
		    function computeMessageParams(type, params) {
		        let result;
		        const numberOfParams = type.numberOfParams;
		        switch (numberOfParams) {
		            case 0:
		                result = undefined;
		                break;
		            case 1:
		                result = computeSingleParam(type.parameterStructures, params[0]);
		                break;
		            default:
		                result = [];
		                for (let i = 0; i < params.length && i < numberOfParams; i++) {
		                    result.push(undefinedToNull(params[i]));
		                }
		                if (params.length < numberOfParams) {
		                    for (let i = params.length; i < numberOfParams; i++) {
		                        result.push(null);
		                    }
		                }
		                break;
		        }
		        return result;
		    }
		    const connection = {
		        sendNotification: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            let method;
		            let messageParams;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		            }
		            const notificationMessage = {
		                jsonrpc: version,
		                method: method,
		                params: messageParams
		            };
		            traceSendingNotification(notificationMessage);
		            return messageWriter.write(notificationMessage).catch((error) => {
		                logger.error(`Sending notification failed.`);
		                throw error;
		            });
		        },
		        onNotification: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method;
		            if (Is.func(type)) {
		                starNotificationHandler = type;
		            }
		            else if (handler) {
		                if (Is.string(type)) {
		                    method = type;
		                    notificationHandlers.set(type, { type: undefined, handler });
		                }
		                else {
		                    method = type.method;
		                    notificationHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method !== undefined) {
		                        notificationHandlers.delete(method);
		                    }
		                    else {
		                        starNotificationHandler = undefined;
		                    }
		                }
		            };
		        },
		        onProgress: (_type, token, handler) => {
		            if (progressHandlers.has(token)) {
		                throw new Error(`Progress handler for token ${token} already registered`);
		            }
		            progressHandlers.set(token, handler);
		            return {
		                dispose: () => {
		                    progressHandlers.delete(token);
		                }
		            };
		        },
		        sendProgress: (_type, token, value) => {
		            // This should not await but simple return to ensure that we don't have another
		            // async scheduling. Otherwise one send could overtake another send.
		            return connection.sendNotification(ProgressNotification.type, { token, value });
		        },
		        onUnhandledProgress: unhandledProgressEmitter.event,
		        sendRequest: (type, ...args) => {
		            throwIfClosedOrDisposed();
		            throwIfNotListening();
		            let method;
		            let messageParams;
		            let token = undefined;
		            if (Is.string(type)) {
		                method = type;
		                const first = args[0];
		                const last = args[args.length - 1];
		                let paramStart = 0;
		                let parameterStructures = messages_1.ParameterStructures.auto;
		                if (messages_1.ParameterStructures.is(first)) {
		                    paramStart = 1;
		                    parameterStructures = first;
		                }
		                let paramEnd = args.length;
		                if (cancellation_1.CancellationToken.is(last)) {
		                    paramEnd = paramEnd - 1;
		                    token = last;
		                }
		                const numberOfParams = paramEnd - paramStart;
		                switch (numberOfParams) {
		                    case 0:
		                        messageParams = undefined;
		                        break;
		                    case 1:
		                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
		                        break;
		                    default:
		                        if (parameterStructures === messages_1.ParameterStructures.byName) {
		                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
		                        }
		                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
		                        break;
		                }
		            }
		            else {
		                const params = args;
		                method = type.method;
		                messageParams = computeMessageParams(type, params);
		                const numberOfParams = type.numberOfParams;
		                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
		            }
		            const id = sequenceNumber++;
		            let disposable;
		            if (token) {
		                disposable = token.onCancellationRequested(() => {
		                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
		                    if (p === undefined) {
		                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
		                        return Promise.resolve();
		                    }
		                    else {
		                        return p.catch(() => {
		                            logger.log(`Sending cancellation messages for id ${id} failed`);
		                        });
		                    }
		                });
		            }
		            const requestMessage = {
		                jsonrpc: version,
		                id: id,
		                method: method,
		                params: messageParams
		            };
		            traceSendingRequest(requestMessage);
		            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
		                cancellationStrategy.sender.enableCancellation(requestMessage);
		            }
		            return new Promise(async (resolve, reject) => {
		                const resolveWithCleanup = (r) => {
		                    resolve(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const rejectWithCleanup = (r) => {
		                    reject(r);
		                    cancellationStrategy.sender.cleanup(id);
		                    disposable?.dispose();
		                };
		                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
		                try {
		                    await messageWriter.write(requestMessage);
		                    responsePromises.set(id, responsePromise);
		                }
		                catch (error) {
		                    logger.error(`Sending request failed.`);
		                    // Writing the message failed. So we need to reject the promise.
		                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
		                    throw error;
		                }
		            });
		        },
		        onRequest: (type, handler) => {
		            throwIfClosedOrDisposed();
		            let method = null;
		            if (StarRequestHandler.is(type)) {
		                method = undefined;
		                starRequestHandler = type;
		            }
		            else if (Is.string(type)) {
		                method = null;
		                if (handler !== undefined) {
		                    method = type;
		                    requestHandlers.set(type, { handler: handler, type: undefined });
		                }
		            }
		            else {
		                if (handler !== undefined) {
		                    method = type.method;
		                    requestHandlers.set(type.method, { type, handler });
		                }
		            }
		            return {
		                dispose: () => {
		                    if (method === null) {
		                        return;
		                    }
		                    if (method !== undefined) {
		                        requestHandlers.delete(method);
		                    }
		                    else {
		                        starRequestHandler = undefined;
		                    }
		                }
		            };
		        },
		        hasPendingResponse: () => {
		            return responsePromises.size > 0;
		        },
		        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
		            let _sendNotification = false;
		            let _traceFormat = TraceFormat.Text;
		            if (sendNotificationOrTraceOptions !== undefined) {
		                if (Is.boolean(sendNotificationOrTraceOptions)) {
		                    _sendNotification = sendNotificationOrTraceOptions;
		                }
		                else {
		                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
		                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
		                }
		            }
		            trace = _value;
		            traceFormat = _traceFormat;
		            if (trace === Trace.Off) {
		                tracer = undefined;
		            }
		            else {
		                tracer = _tracer;
		            }
		            if (_sendNotification && !isClosed() && !isDisposed()) {
		                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
		            }
		        },
		        onError: errorEmitter.event,
		        onClose: closeEmitter.event,
		        onUnhandledNotification: unhandledNotificationEmitter.event,
		        onDispose: disposeEmitter.event,
		        end: () => {
		            messageWriter.end();
		        },
		        dispose: () => {
		            if (isDisposed()) {
		                return;
		            }
		            state = ConnectionState.Disposed;
		            disposeEmitter.fire(undefined);
		            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
		            for (const promise of responsePromises.values()) {
		                promise.reject(error);
		            }
		            responsePromises = new Map();
		            requestTokens = new Map();
		            knownCanceledRequests = new Set();
		            messageQueue = new linkedMap_1.LinkedMap();
		            // Test for backwards compatibility
		            if (Is.func(messageWriter.dispose)) {
		                messageWriter.dispose();
		            }
		            if (Is.func(messageReader.dispose)) {
		                messageReader.dispose();
		            }
		        },
		        listen: () => {
		            throwIfClosedOrDisposed();
		            throwIfListening();
		            state = ConnectionState.Listening;
		            messageReader.listen(callback);
		        },
		        inspect: () => {
		            // eslint-disable-next-line no-console
		            (0, ral_1.default)().console.log('inspect');
		        }
		    };
		    connection.onNotification(LogTraceNotification.type, (params) => {
		        if (trace === Trace.Off || !tracer) {
		            return;
		        }
		        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
		        tracer.log(params.message, verbose ? params.verbose : undefined);
		    });
		    connection.onNotification(ProgressNotification.type, (params) => {
		        const handler = progressHandlers.get(params.token);
		        if (handler) {
		            handler(params.value);
		        }
		        else {
		            unhandledProgressEmitter.fire(params);
		        }
		    });
		    return connection;
		}
		exports$1.createMessageConnection = createMessageConnection; 
	} (connection$2));
	return connection$2;
}

var hasRequiredApi$2;

function requireApi$2 () {
	if (hasRequiredApi$2) return api$2;
	hasRequiredApi$2 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.ProgressType = exports$1.ProgressToken = exports$1.createMessageConnection = exports$1.NullLogger = exports$1.ConnectionOptions = exports$1.ConnectionStrategy = exports$1.AbstractMessageBuffer = exports$1.WriteableStreamMessageWriter = exports$1.AbstractMessageWriter = exports$1.MessageWriter = exports$1.ReadableStreamMessageReader = exports$1.AbstractMessageReader = exports$1.MessageReader = exports$1.SharedArrayReceiverStrategy = exports$1.SharedArraySenderStrategy = exports$1.CancellationToken = exports$1.CancellationTokenSource = exports$1.Emitter = exports$1.Event = exports$1.Disposable = exports$1.LRUCache = exports$1.Touch = exports$1.LinkedMap = exports$1.ParameterStructures = exports$1.NotificationType9 = exports$1.NotificationType8 = exports$1.NotificationType7 = exports$1.NotificationType6 = exports$1.NotificationType5 = exports$1.NotificationType4 = exports$1.NotificationType3 = exports$1.NotificationType2 = exports$1.NotificationType1 = exports$1.NotificationType0 = exports$1.NotificationType = exports$1.ErrorCodes = exports$1.ResponseError = exports$1.RequestType9 = exports$1.RequestType8 = exports$1.RequestType7 = exports$1.RequestType6 = exports$1.RequestType5 = exports$1.RequestType4 = exports$1.RequestType3 = exports$1.RequestType2 = exports$1.RequestType1 = exports$1.RequestType0 = exports$1.RequestType = exports$1.Message = exports$1.RAL = void 0;
		exports$1.MessageStrategy = exports$1.CancellationStrategy = exports$1.CancellationSenderStrategy = exports$1.CancellationReceiverStrategy = exports$1.ConnectionError = exports$1.ConnectionErrors = exports$1.LogTraceNotification = exports$1.SetTraceNotification = exports$1.TraceFormat = exports$1.TraceValues = exports$1.Trace = void 0;
		const messages_1 = requireMessages$1();
		Object.defineProperty(exports$1, "Message", { enumerable: true, get: function () { return messages_1.Message; } });
		Object.defineProperty(exports$1, "RequestType", { enumerable: true, get: function () { return messages_1.RequestType; } });
		Object.defineProperty(exports$1, "RequestType0", { enumerable: true, get: function () { return messages_1.RequestType0; } });
		Object.defineProperty(exports$1, "RequestType1", { enumerable: true, get: function () { return messages_1.RequestType1; } });
		Object.defineProperty(exports$1, "RequestType2", { enumerable: true, get: function () { return messages_1.RequestType2; } });
		Object.defineProperty(exports$1, "RequestType3", { enumerable: true, get: function () { return messages_1.RequestType3; } });
		Object.defineProperty(exports$1, "RequestType4", { enumerable: true, get: function () { return messages_1.RequestType4; } });
		Object.defineProperty(exports$1, "RequestType5", { enumerable: true, get: function () { return messages_1.RequestType5; } });
		Object.defineProperty(exports$1, "RequestType6", { enumerable: true, get: function () { return messages_1.RequestType6; } });
		Object.defineProperty(exports$1, "RequestType7", { enumerable: true, get: function () { return messages_1.RequestType7; } });
		Object.defineProperty(exports$1, "RequestType8", { enumerable: true, get: function () { return messages_1.RequestType8; } });
		Object.defineProperty(exports$1, "RequestType9", { enumerable: true, get: function () { return messages_1.RequestType9; } });
		Object.defineProperty(exports$1, "ResponseError", { enumerable: true, get: function () { return messages_1.ResponseError; } });
		Object.defineProperty(exports$1, "ErrorCodes", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });
		Object.defineProperty(exports$1, "NotificationType", { enumerable: true, get: function () { return messages_1.NotificationType; } });
		Object.defineProperty(exports$1, "NotificationType0", { enumerable: true, get: function () { return messages_1.NotificationType0; } });
		Object.defineProperty(exports$1, "NotificationType1", { enumerable: true, get: function () { return messages_1.NotificationType1; } });
		Object.defineProperty(exports$1, "NotificationType2", { enumerable: true, get: function () { return messages_1.NotificationType2; } });
		Object.defineProperty(exports$1, "NotificationType3", { enumerable: true, get: function () { return messages_1.NotificationType3; } });
		Object.defineProperty(exports$1, "NotificationType4", { enumerable: true, get: function () { return messages_1.NotificationType4; } });
		Object.defineProperty(exports$1, "NotificationType5", { enumerable: true, get: function () { return messages_1.NotificationType5; } });
		Object.defineProperty(exports$1, "NotificationType6", { enumerable: true, get: function () { return messages_1.NotificationType6; } });
		Object.defineProperty(exports$1, "NotificationType7", { enumerable: true, get: function () { return messages_1.NotificationType7; } });
		Object.defineProperty(exports$1, "NotificationType8", { enumerable: true, get: function () { return messages_1.NotificationType8; } });
		Object.defineProperty(exports$1, "NotificationType9", { enumerable: true, get: function () { return messages_1.NotificationType9; } });
		Object.defineProperty(exports$1, "ParameterStructures", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });
		const linkedMap_1 = requireLinkedMap();
		Object.defineProperty(exports$1, "LinkedMap", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });
		Object.defineProperty(exports$1, "LRUCache", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });
		Object.defineProperty(exports$1, "Touch", { enumerable: true, get: function () { return linkedMap_1.Touch; } });
		const disposable_1 = requireDisposable();
		Object.defineProperty(exports$1, "Disposable", { enumerable: true, get: function () { return disposable_1.Disposable; } });
		const events_1 = requireEvents();
		Object.defineProperty(exports$1, "Event", { enumerable: true, get: function () { return events_1.Event; } });
		Object.defineProperty(exports$1, "Emitter", { enumerable: true, get: function () { return events_1.Emitter; } });
		const cancellation_1 = requireCancellation$1();
		Object.defineProperty(exports$1, "CancellationTokenSource", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });
		Object.defineProperty(exports$1, "CancellationToken", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });
		const sharedArrayCancellation_1 = requireSharedArrayCancellation();
		Object.defineProperty(exports$1, "SharedArraySenderStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });
		Object.defineProperty(exports$1, "SharedArrayReceiverStrategy", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });
		const messageReader_1 = requireMessageReader();
		Object.defineProperty(exports$1, "MessageReader", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });
		Object.defineProperty(exports$1, "AbstractMessageReader", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });
		Object.defineProperty(exports$1, "ReadableStreamMessageReader", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });
		const messageWriter_1 = requireMessageWriter();
		Object.defineProperty(exports$1, "MessageWriter", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });
		Object.defineProperty(exports$1, "AbstractMessageWriter", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });
		Object.defineProperty(exports$1, "WriteableStreamMessageWriter", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });
		const messageBuffer_1 = requireMessageBuffer();
		Object.defineProperty(exports$1, "AbstractMessageBuffer", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });
		const connection_1 = requireConnection$1();
		Object.defineProperty(exports$1, "ConnectionStrategy", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });
		Object.defineProperty(exports$1, "ConnectionOptions", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });
		Object.defineProperty(exports$1, "NullLogger", { enumerable: true, get: function () { return connection_1.NullLogger; } });
		Object.defineProperty(exports$1, "createMessageConnection", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });
		Object.defineProperty(exports$1, "ProgressToken", { enumerable: true, get: function () { return connection_1.ProgressToken; } });
		Object.defineProperty(exports$1, "ProgressType", { enumerable: true, get: function () { return connection_1.ProgressType; } });
		Object.defineProperty(exports$1, "Trace", { enumerable: true, get: function () { return connection_1.Trace; } });
		Object.defineProperty(exports$1, "TraceValues", { enumerable: true, get: function () { return connection_1.TraceValues; } });
		Object.defineProperty(exports$1, "TraceFormat", { enumerable: true, get: function () { return connection_1.TraceFormat; } });
		Object.defineProperty(exports$1, "SetTraceNotification", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });
		Object.defineProperty(exports$1, "LogTraceNotification", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });
		Object.defineProperty(exports$1, "ConnectionErrors", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });
		Object.defineProperty(exports$1, "ConnectionError", { enumerable: true, get: function () { return connection_1.ConnectionError; } });
		Object.defineProperty(exports$1, "CancellationReceiverStrategy", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });
		Object.defineProperty(exports$1, "CancellationSenderStrategy", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });
		Object.defineProperty(exports$1, "CancellationStrategy", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });
		Object.defineProperty(exports$1, "MessageStrategy", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });
		const ral_1 = requireRal$1();
		exports$1.RAL = ral_1.default; 
	} (api$2));
	return api$2;
}

var hasRequiredRil;

function requireRil () {
	if (hasRequiredRil) return ril;
	hasRequiredRil = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(ril, "__esModule", { value: true });
	const util_1 = require$$0$1;
	const api_1 = requireApi$2();
	class MessageBuffer extends api_1.AbstractMessageBuffer {
	    constructor(encoding = 'utf-8') {
	        super(encoding);
	    }
	    emptyBuffer() {
	        return MessageBuffer.emptyBuffer;
	    }
	    fromString(value, encoding) {
	        return Buffer.from(value, encoding);
	    }
	    toString(value, encoding) {
	        if (value instanceof Buffer) {
	            return value.toString(encoding);
	        }
	        else {
	            return new util_1.TextDecoder(encoding).decode(value);
	        }
	    }
	    asNative(buffer, length) {
	        if (length === undefined) {
	            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
	        }
	        else {
	            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
	        }
	    }
	    allocNative(length) {
	        return Buffer.allocUnsafe(length);
	    }
	}
	MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
	class ReadableStreamWrapper {
	    constructor(stream) {
	        this.stream = stream;
	    }
	    onClose(listener) {
	        this.stream.on('close', listener);
	        return api_1.Disposable.create(() => this.stream.off('close', listener));
	    }
	    onError(listener) {
	        this.stream.on('error', listener);
	        return api_1.Disposable.create(() => this.stream.off('error', listener));
	    }
	    onEnd(listener) {
	        this.stream.on('end', listener);
	        return api_1.Disposable.create(() => this.stream.off('end', listener));
	    }
	    onData(listener) {
	        this.stream.on('data', listener);
	        return api_1.Disposable.create(() => this.stream.off('data', listener));
	    }
	}
	class WritableStreamWrapper {
	    constructor(stream) {
	        this.stream = stream;
	    }
	    onClose(listener) {
	        this.stream.on('close', listener);
	        return api_1.Disposable.create(() => this.stream.off('close', listener));
	    }
	    onError(listener) {
	        this.stream.on('error', listener);
	        return api_1.Disposable.create(() => this.stream.off('error', listener));
	    }
	    onEnd(listener) {
	        this.stream.on('end', listener);
	        return api_1.Disposable.create(() => this.stream.off('end', listener));
	    }
	    write(data, encoding) {
	        return new Promise((resolve, reject) => {
	            const callback = (error) => {
	                if (error === undefined || error === null) {
	                    resolve();
	                }
	                else {
	                    reject(error);
	                }
	            };
	            if (typeof data === 'string') {
	                this.stream.write(data, encoding, callback);
	            }
	            else {
	                this.stream.write(data, callback);
	            }
	        });
	    }
	    end() {
	        this.stream.end();
	    }
	}
	const _ril = Object.freeze({
	    messageBuffer: Object.freeze({
	        create: (encoding) => new MessageBuffer(encoding)
	    }),
	    applicationJson: Object.freeze({
	        encoder: Object.freeze({
	            name: 'application/json',
	            encode: (msg, options) => {
	                try {
	                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
	                }
	                catch (err) {
	                    return Promise.reject(err);
	                }
	            }
	        }),
	        decoder: Object.freeze({
	            name: 'application/json',
	            decode: (buffer, options) => {
	                try {
	                    if (buffer instanceof Buffer) {
	                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
	                    }
	                    else {
	                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
	                    }
	                }
	                catch (err) {
	                    return Promise.reject(err);
	                }
	            }
	        })
	    }),
	    stream: Object.freeze({
	        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
	        asWritableStream: (stream) => new WritableStreamWrapper(stream)
	    }),
	    console: console,
	    timer: Object.freeze({
	        setTimeout(callback, ms, ...args) {
	            const handle = setTimeout(callback, ms, ...args);
	            return { dispose: () => clearTimeout(handle) };
	        },
	        setImmediate(callback, ...args) {
	            const handle = setImmediate(callback, ...args);
	            return { dispose: () => clearImmediate(handle) };
	        },
	        setInterval(callback, ms, ...args) {
	            const handle = setInterval(callback, ms, ...args);
	            return { dispose: () => clearInterval(handle) };
	        }
	    })
	});
	function RIL() {
	    return _ril;
	}
	(function (RIL) {
	    function install() {
	        api_1.RAL.install(_ril);
	    }
	    RIL.install = install;
	})(RIL || (RIL = {}));
	ril.default = RIL;
	return ril;
}

var hasRequiredMain$5;

function requireMain$5 () {
	if (hasRequiredMain$5) return main$4;
	hasRequiredMain$5 = 1;
	(function (exports$1) {
		var __createBinding = (main$4 && main$4.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$4 && main$4.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createMessageConnection = exports$1.createServerSocketTransport = exports$1.createClientSocketTransport = exports$1.createServerPipeTransport = exports$1.createClientPipeTransport = exports$1.generateRandomPipeName = exports$1.StreamMessageWriter = exports$1.StreamMessageReader = exports$1.SocketMessageWriter = exports$1.SocketMessageReader = exports$1.PortMessageWriter = exports$1.PortMessageReader = exports$1.IPCMessageWriter = exports$1.IPCMessageReader = void 0;
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ----------------------------------------------------------------------------------------- */
		const ril_1 = requireRil();
		// Install the node runtime abstract.
		ril_1.default.install();
		const path = path$1;
		const os = require$$2;
		const crypto_1 = require$$3;
		const net_1 = require$$4;
		const api_1 = requireApi$2();
		__exportStar(requireApi$2(), exports$1);
		class IPCMessageReader extends api_1.AbstractMessageReader {
		    constructor(process) {
		        super();
		        this.process = process;
		        let eventEmitter = this.process;
		        eventEmitter.on('error', (error) => this.fireError(error));
		        eventEmitter.on('close', () => this.fireClose());
		    }
		    listen(callback) {
		        this.process.on('message', callback);
		        return api_1.Disposable.create(() => this.process.off('message', callback));
		    }
		}
		exports$1.IPCMessageReader = IPCMessageReader;
		class IPCMessageWriter extends api_1.AbstractMessageWriter {
		    constructor(process) {
		        super();
		        this.process = process;
		        this.errorCount = 0;
		        const eventEmitter = this.process;
		        eventEmitter.on('error', (error) => this.fireError(error));
		        eventEmitter.on('close', () => this.fireClose);
		    }
		    write(msg) {
		        try {
		            if (typeof this.process.send === 'function') {
		                this.process.send(msg, undefined, undefined, (error) => {
		                    if (error) {
		                        this.errorCount++;
		                        this.handleError(error, msg);
		                    }
		                    else {
		                        this.errorCount = 0;
		                    }
		                });
		            }
		            return Promise.resolve();
		        }
		        catch (error) {
		            this.handleError(error, msg);
		            return Promise.reject(error);
		        }
		    }
		    handleError(error, msg) {
		        this.errorCount++;
		        this.fireError(error, msg, this.errorCount);
		    }
		    end() {
		    }
		}
		exports$1.IPCMessageWriter = IPCMessageWriter;
		class PortMessageReader extends api_1.AbstractMessageReader {
		    constructor(port) {
		        super();
		        this.onData = new api_1.Emitter;
		        port.on('close', () => this.fireClose);
		        port.on('error', (error) => this.fireError(error));
		        port.on('message', (message) => {
		            this.onData.fire(message);
		        });
		    }
		    listen(callback) {
		        return this.onData.event(callback);
		    }
		}
		exports$1.PortMessageReader = PortMessageReader;
		class PortMessageWriter extends api_1.AbstractMessageWriter {
		    constructor(port) {
		        super();
		        this.port = port;
		        this.errorCount = 0;
		        port.on('close', () => this.fireClose());
		        port.on('error', (error) => this.fireError(error));
		    }
		    write(msg) {
		        try {
		            this.port.postMessage(msg);
		            return Promise.resolve();
		        }
		        catch (error) {
		            this.handleError(error, msg);
		            return Promise.reject(error);
		        }
		    }
		    handleError(error, msg) {
		        this.errorCount++;
		        this.fireError(error, msg, this.errorCount);
		    }
		    end() {
		    }
		}
		exports$1.PortMessageWriter = PortMessageWriter;
		class SocketMessageReader extends api_1.ReadableStreamMessageReader {
		    constructor(socket, encoding = 'utf-8') {
		        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
		    }
		}
		exports$1.SocketMessageReader = SocketMessageReader;
		class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
		    constructor(socket, options) {
		        super((0, ril_1.default)().stream.asWritableStream(socket), options);
		        this.socket = socket;
		    }
		    dispose() {
		        super.dispose();
		        this.socket.destroy();
		    }
		}
		exports$1.SocketMessageWriter = SocketMessageWriter;
		class StreamMessageReader extends api_1.ReadableStreamMessageReader {
		    constructor(readable, encoding) {
		        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
		    }
		}
		exports$1.StreamMessageReader = StreamMessageReader;
		class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
		    constructor(writable, options) {
		        super((0, ril_1.default)().stream.asWritableStream(writable), options);
		    }
		}
		exports$1.StreamMessageWriter = StreamMessageWriter;
		const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
		const safeIpcPathLengths = new Map([
		    ['linux', 107],
		    ['darwin', 103]
		]);
		function generateRandomPipeName() {
		    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
		    if (process.platform === 'win32') {
		        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
		    }
		    let result;
		    if (XDG_RUNTIME_DIR) {
		        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
		    }
		    else {
		        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
		    }
		    const limit = safeIpcPathLengths.get(process.platform);
		    if (limit !== undefined && result.length > limit) {
		        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
		    }
		    return result;
		}
		exports$1.generateRandomPipeName = generateRandomPipeName;
		function createClientPipeTransport(pipeName, encoding = 'utf-8') {
		    let connectResolve;
		    const connected = new Promise((resolve, _reject) => {
		        connectResolve = resolve;
		    });
		    return new Promise((resolve, reject) => {
		        let server = (0, net_1.createServer)((socket) => {
		            server.close();
		            connectResolve([
		                new SocketMessageReader(socket, encoding),
		                new SocketMessageWriter(socket, encoding)
		            ]);
		        });
		        server.on('error', reject);
		        server.listen(pipeName, () => {
		            server.removeListener('error', reject);
		            resolve({
		                onConnected: () => { return connected; }
		            });
		        });
		    });
		}
		exports$1.createClientPipeTransport = createClientPipeTransport;
		function createServerPipeTransport(pipeName, encoding = 'utf-8') {
		    const socket = (0, net_1.createConnection)(pipeName);
		    return [
		        new SocketMessageReader(socket, encoding),
		        new SocketMessageWriter(socket, encoding)
		    ];
		}
		exports$1.createServerPipeTransport = createServerPipeTransport;
		function createClientSocketTransport(port, encoding = 'utf-8') {
		    let connectResolve;
		    const connected = new Promise((resolve, _reject) => {
		        connectResolve = resolve;
		    });
		    return new Promise((resolve, reject) => {
		        const server = (0, net_1.createServer)((socket) => {
		            server.close();
		            connectResolve([
		                new SocketMessageReader(socket, encoding),
		                new SocketMessageWriter(socket, encoding)
		            ]);
		        });
		        server.on('error', reject);
		        server.listen(port, '127.0.0.1', () => {
		            server.removeListener('error', reject);
		            resolve({
		                onConnected: () => { return connected; }
		            });
		        });
		    });
		}
		exports$1.createClientSocketTransport = createClientSocketTransport;
		function createServerSocketTransport(port, encoding = 'utf-8') {
		    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
		    return [
		        new SocketMessageReader(socket, encoding),
		        new SocketMessageWriter(socket, encoding)
		    ];
		}
		exports$1.createServerSocketTransport = createServerSocketTransport;
		function isReadableStream(value) {
		    const candidate = value;
		    return candidate.read !== undefined && candidate.addListener !== undefined;
		}
		function isWritableStream(value) {
		    const candidate = value;
		    return candidate.write !== undefined && candidate.addListener !== undefined;
		}
		function createMessageConnection(input, output, logger, options) {
		    if (!logger) {
		        logger = api_1.NullLogger;
		    }
		    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
		    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
		    if (api_1.ConnectionStrategy.is(options)) {
		        options = { connectionStrategy: options };
		    }
		    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
		}
		exports$1.createMessageConnection = createMessageConnection; 
	} (main$4));
	return main$4;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node$3;
var hasRequiredNode$4;

function requireNode$4 () {
	if (hasRequiredNode$4) return node$3;
	hasRequiredNode$4 = 1;

	node$3 = requireMain$5();
	return node$3;
}

var api$1 = {};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var main$3 = {exports: {}};

var hasRequiredMain$4;

function requireMain$4 () {
	if (hasRequiredMain$4) return main$3.exports;
	hasRequiredMain$4 = 1;
	(function (module, exports$1) {
		(function (factory) {
		    {
		        var v = factory(commonjsRequire, exports$1);
		        if (v !== undefined) module.exports = v;
		    }
		})(function (require, exports$1) {
		    Object.defineProperty(exports$1, "__esModule", { value: true });
		    exports$1.TextDocument = exports$1.EOL = exports$1.WorkspaceFolder = exports$1.InlineCompletionContext = exports$1.SelectedCompletionInfo = exports$1.InlineCompletionTriggerKind = exports$1.InlineCompletionList = exports$1.InlineCompletionItem = exports$1.StringValue = exports$1.InlayHint = exports$1.InlayHintLabelPart = exports$1.InlayHintKind = exports$1.InlineValueContext = exports$1.InlineValueEvaluatableExpression = exports$1.InlineValueVariableLookup = exports$1.InlineValueText = exports$1.SemanticTokens = exports$1.SemanticTokenModifiers = exports$1.SemanticTokenTypes = exports$1.SelectionRange = exports$1.DocumentLink = exports$1.FormattingOptions = exports$1.CodeLens = exports$1.CodeAction = exports$1.CodeActionContext = exports$1.CodeActionTriggerKind = exports$1.CodeActionKind = exports$1.DocumentSymbol = exports$1.WorkspaceSymbol = exports$1.SymbolInformation = exports$1.SymbolTag = exports$1.SymbolKind = exports$1.DocumentHighlight = exports$1.DocumentHighlightKind = exports$1.SignatureInformation = exports$1.ParameterInformation = exports$1.Hover = exports$1.MarkedString = exports$1.CompletionList = exports$1.CompletionItem = exports$1.CompletionItemLabelDetails = exports$1.InsertTextMode = exports$1.InsertReplaceEdit = exports$1.CompletionItemTag = exports$1.InsertTextFormat = exports$1.CompletionItemKind = exports$1.MarkupContent = exports$1.MarkupKind = exports$1.TextDocumentItem = exports$1.OptionalVersionedTextDocumentIdentifier = exports$1.VersionedTextDocumentIdentifier = exports$1.TextDocumentIdentifier = exports$1.WorkspaceChange = exports$1.WorkspaceEdit = exports$1.DeleteFile = exports$1.RenameFile = exports$1.CreateFile = exports$1.TextDocumentEdit = exports$1.AnnotatedTextEdit = exports$1.ChangeAnnotationIdentifier = exports$1.ChangeAnnotation = exports$1.TextEdit = exports$1.Command = exports$1.Diagnostic = exports$1.CodeDescription = exports$1.DiagnosticTag = exports$1.DiagnosticSeverity = exports$1.DiagnosticRelatedInformation = exports$1.FoldingRange = exports$1.FoldingRangeKind = exports$1.ColorPresentation = exports$1.ColorInformation = exports$1.Color = exports$1.LocationLink = exports$1.Location = exports$1.Range = exports$1.Position = exports$1.uinteger = exports$1.integer = exports$1.URI = exports$1.DocumentUri = void 0;
		    var DocumentUri;
		    (function (DocumentUri) {
		        function is(value) {
		            return typeof value === 'string';
		        }
		        DocumentUri.is = is;
		    })(DocumentUri || (exports$1.DocumentUri = DocumentUri = {}));
		    var URI;
		    (function (URI) {
		        function is(value) {
		            return typeof value === 'string';
		        }
		        URI.is = is;
		    })(URI || (exports$1.URI = URI = {}));
		    var integer;
		    (function (integer) {
		        integer.MIN_VALUE = -2147483648;
		        integer.MAX_VALUE = 2147483647;
		        function is(value) {
		            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
		        }
		        integer.is = is;
		    })(integer || (exports$1.integer = integer = {}));
		    var uinteger;
		    (function (uinteger) {
		        uinteger.MIN_VALUE = 0;
		        uinteger.MAX_VALUE = 2147483647;
		        function is(value) {
		            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
		        }
		        uinteger.is = is;
		    })(uinteger || (exports$1.uinteger = uinteger = {}));
		    /**
		     * The Position namespace provides helper functions to work with
		     * {@link Position} literals.
		     */
		    var Position;
		    (function (Position) {
		        /**
		         * Creates a new Position literal from the given line and character.
		         * @param line The position's line.
		         * @param character The position's character.
		         */
		        function create(line, character) {
		            if (line === Number.MAX_VALUE) {
		                line = uinteger.MAX_VALUE;
		            }
		            if (character === Number.MAX_VALUE) {
		                character = uinteger.MAX_VALUE;
		            }
		            return { line: line, character: character };
		        }
		        Position.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Position} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
		        }
		        Position.is = is;
		    })(Position || (exports$1.Position = Position = {}));
		    /**
		     * The Range namespace provides helper functions to work with
		     * {@link Range} literals.
		     */
		    var Range;
		    (function (Range) {
		        function create(one, two, three, four) {
		            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
		                return { start: Position.create(one, two), end: Position.create(three, four) };
		            }
		            else if (Position.is(one) && Position.is(two)) {
		                return { start: one, end: two };
		            }
		            else {
		                throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
		            }
		        }
		        Range.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Range} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
		        }
		        Range.is = is;
		    })(Range || (exports$1.Range = Range = {}));
		    /**
		     * The Location namespace provides helper functions to work with
		     * {@link Location} literals.
		     */
		    var Location;
		    (function (Location) {
		        /**
		         * Creates a Location literal.
		         * @param uri The location's uri.
		         * @param range The location's range.
		         */
		        function create(uri, range) {
		            return { uri: uri, range: range };
		        }
		        Location.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Location} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
		        }
		        Location.is = is;
		    })(Location || (exports$1.Location = Location = {}));
		    /**
		     * The LocationLink namespace provides helper functions to work with
		     * {@link LocationLink} literals.
		     */
		    var LocationLink;
		    (function (LocationLink) {
		        /**
		         * Creates a LocationLink literal.
		         * @param targetUri The definition's uri.
		         * @param targetRange The full range of the definition.
		         * @param targetSelectionRange The span of the symbol definition at the target.
		         * @param originSelectionRange The span of the symbol being defined in the originating source file.
		         */
		        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
		            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
		        }
		        LocationLink.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link LocationLink} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
		                && Range.is(candidate.targetSelectionRange)
		                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
		        }
		        LocationLink.is = is;
		    })(LocationLink || (exports$1.LocationLink = LocationLink = {}));
		    /**
		     * The Color namespace provides helper functions to work with
		     * {@link Color} literals.
		     */
		    var Color;
		    (function (Color) {
		        /**
		         * Creates a new Color literal.
		         */
		        function create(red, green, blue, alpha) {
		            return {
		                red: red,
		                green: green,
		                blue: blue,
		                alpha: alpha,
		            };
		        }
		        Color.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Color} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
		                && Is.numberRange(candidate.green, 0, 1)
		                && Is.numberRange(candidate.blue, 0, 1)
		                && Is.numberRange(candidate.alpha, 0, 1);
		        }
		        Color.is = is;
		    })(Color || (exports$1.Color = Color = {}));
		    /**
		     * The ColorInformation namespace provides helper functions to work with
		     * {@link ColorInformation} literals.
		     */
		    var ColorInformation;
		    (function (ColorInformation) {
		        /**
		         * Creates a new ColorInformation literal.
		         */
		        function create(range, color) {
		            return {
		                range: range,
		                color: color,
		            };
		        }
		        ColorInformation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
		        }
		        ColorInformation.is = is;
		    })(ColorInformation || (exports$1.ColorInformation = ColorInformation = {}));
		    /**
		     * The Color namespace provides helper functions to work with
		     * {@link ColorPresentation} literals.
		     */
		    var ColorPresentation;
		    (function (ColorPresentation) {
		        /**
		         * Creates a new ColorInformation literal.
		         */
		        function create(label, textEdit, additionalTextEdits) {
		            return {
		                label: label,
		                textEdit: textEdit,
		                additionalTextEdits: additionalTextEdits,
		            };
		        }
		        ColorPresentation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.label)
		                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
		                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
		        }
		        ColorPresentation.is = is;
		    })(ColorPresentation || (exports$1.ColorPresentation = ColorPresentation = {}));
		    /**
		     * A set of predefined range kinds.
		     */
		    var FoldingRangeKind;
		    (function (FoldingRangeKind) {
		        /**
		         * Folding range for a comment
		         */
		        FoldingRangeKind.Comment = 'comment';
		        /**
		         * Folding range for an import or include
		         */
		        FoldingRangeKind.Imports = 'imports';
		        /**
		         * Folding range for a region (e.g. `#region`)
		         */
		        FoldingRangeKind.Region = 'region';
		    })(FoldingRangeKind || (exports$1.FoldingRangeKind = FoldingRangeKind = {}));
		    /**
		     * The folding range namespace provides helper functions to work with
		     * {@link FoldingRange} literals.
		     */
		    var FoldingRange;
		    (function (FoldingRange) {
		        /**
		         * Creates a new FoldingRange literal.
		         */
		        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
		            var result = {
		                startLine: startLine,
		                endLine: endLine
		            };
		            if (Is.defined(startCharacter)) {
		                result.startCharacter = startCharacter;
		            }
		            if (Is.defined(endCharacter)) {
		                result.endCharacter = endCharacter;
		            }
		            if (Is.defined(kind)) {
		                result.kind = kind;
		            }
		            if (Is.defined(collapsedText)) {
		                result.collapsedText = collapsedText;
		            }
		            return result;
		        }
		        FoldingRange.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link FoldingRange} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
		                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
		                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
		                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
		        }
		        FoldingRange.is = is;
		    })(FoldingRange || (exports$1.FoldingRange = FoldingRange = {}));
		    /**
		     * The DiagnosticRelatedInformation namespace provides helper functions to work with
		     * {@link DiagnosticRelatedInformation} literals.
		     */
		    var DiagnosticRelatedInformation;
		    (function (DiagnosticRelatedInformation) {
		        /**
		         * Creates a new DiagnosticRelatedInformation literal.
		         */
		        function create(location, message) {
		            return {
		                location: location,
		                message: message
		            };
		        }
		        DiagnosticRelatedInformation.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
		        }
		        DiagnosticRelatedInformation.is = is;
		    })(DiagnosticRelatedInformation || (exports$1.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
		    /**
		     * The diagnostic's severity.
		     */
		    var DiagnosticSeverity;
		    (function (DiagnosticSeverity) {
		        /**
		         * Reports an error.
		         */
		        DiagnosticSeverity.Error = 1;
		        /**
		         * Reports a warning.
		         */
		        DiagnosticSeverity.Warning = 2;
		        /**
		         * Reports an information.
		         */
		        DiagnosticSeverity.Information = 3;
		        /**
		         * Reports a hint.
		         */
		        DiagnosticSeverity.Hint = 4;
		    })(DiagnosticSeverity || (exports$1.DiagnosticSeverity = DiagnosticSeverity = {}));
		    /**
		     * The diagnostic tags.
		     *
		     * @since 3.15.0
		     */
		    var DiagnosticTag;
		    (function (DiagnosticTag) {
		        /**
		         * Unused or unnecessary code.
		         *
		         * Clients are allowed to render diagnostics with this tag faded out instead of having
		         * an error squiggle.
		         */
		        DiagnosticTag.Unnecessary = 1;
		        /**
		         * Deprecated or obsolete code.
		         *
		         * Clients are allowed to rendered diagnostics with this tag strike through.
		         */
		        DiagnosticTag.Deprecated = 2;
		    })(DiagnosticTag || (exports$1.DiagnosticTag = DiagnosticTag = {}));
		    /**
		     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
		     *
		     * @since 3.16.0
		     */
		    var CodeDescription;
		    (function (CodeDescription) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.href);
		        }
		        CodeDescription.is = is;
		    })(CodeDescription || (exports$1.CodeDescription = CodeDescription = {}));
		    /**
		     * The Diagnostic namespace provides helper functions to work with
		     * {@link Diagnostic} literals.
		     */
		    var Diagnostic;
		    (function (Diagnostic) {
		        /**
		         * Creates a new Diagnostic literal.
		         */
		        function create(range, message, severity, code, source, relatedInformation) {
		            var result = { range: range, message: message };
		            if (Is.defined(severity)) {
		                result.severity = severity;
		            }
		            if (Is.defined(code)) {
		                result.code = code;
		            }
		            if (Is.defined(source)) {
		                result.source = source;
		            }
		            if (Is.defined(relatedInformation)) {
		                result.relatedInformation = relatedInformation;
		            }
		            return result;
		        }
		        Diagnostic.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Diagnostic} interface.
		         */
		        function is(value) {
		            var _a;
		            var candidate = value;
		            return Is.defined(candidate)
		                && Range.is(candidate.range)
		                && Is.string(candidate.message)
		                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
		                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
		                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
		                && (Is.string(candidate.source) || Is.undefined(candidate.source))
		                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
		        }
		        Diagnostic.is = is;
		    })(Diagnostic || (exports$1.Diagnostic = Diagnostic = {}));
		    /**
		     * The Command namespace provides helper functions to work with
		     * {@link Command} literals.
		     */
		    var Command;
		    (function (Command) {
		        /**
		         * Creates a new Command literal.
		         */
		        function create(title, command) {
		            var args = [];
		            for (var _i = 2; _i < arguments.length; _i++) {
		                args[_i - 2] = arguments[_i];
		            }
		            var result = { title: title, command: command };
		            if (Is.defined(args) && args.length > 0) {
		                result.arguments = args;
		            }
		            return result;
		        }
		        Command.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link Command} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
		        }
		        Command.is = is;
		    })(Command || (exports$1.Command = Command = {}));
		    /**
		     * The TextEdit namespace provides helper function to create replace,
		     * insert and delete edits more easily.
		     */
		    var TextEdit;
		    (function (TextEdit) {
		        /**
		         * Creates a replace text edit.
		         * @param range The range of text to be replaced.
		         * @param newText The new text.
		         */
		        function replace(range, newText) {
		            return { range: range, newText: newText };
		        }
		        TextEdit.replace = replace;
		        /**
		         * Creates an insert text edit.
		         * @param position The position to insert the text at.
		         * @param newText The text to be inserted.
		         */
		        function insert(position, newText) {
		            return { range: { start: position, end: position }, newText: newText };
		        }
		        TextEdit.insert = insert;
		        /**
		         * Creates a delete text edit.
		         * @param range The range of text to be deleted.
		         */
		        function del(range) {
		            return { range: range, newText: '' };
		        }
		        TextEdit.del = del;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate)
		                && Is.string(candidate.newText)
		                && Range.is(candidate.range);
		        }
		        TextEdit.is = is;
		    })(TextEdit || (exports$1.TextEdit = TextEdit = {}));
		    var ChangeAnnotation;
		    (function (ChangeAnnotation) {
		        function create(label, needsConfirmation, description) {
		            var result = { label: label };
		            if (needsConfirmation !== undefined) {
		                result.needsConfirmation = needsConfirmation;
		            }
		            if (description !== undefined) {
		                result.description = description;
		            }
		            return result;
		        }
		        ChangeAnnotation.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
		                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
		                (Is.string(candidate.description) || candidate.description === undefined);
		        }
		        ChangeAnnotation.is = is;
		    })(ChangeAnnotation || (exports$1.ChangeAnnotation = ChangeAnnotation = {}));
		    var ChangeAnnotationIdentifier;
		    (function (ChangeAnnotationIdentifier) {
		        function is(value) {
		            var candidate = value;
		            return Is.string(candidate);
		        }
		        ChangeAnnotationIdentifier.is = is;
		    })(ChangeAnnotationIdentifier || (exports$1.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
		    var AnnotatedTextEdit;
		    (function (AnnotatedTextEdit) {
		        /**
		         * Creates an annotated replace text edit.
		         *
		         * @param range The range of text to be replaced.
		         * @param newText The new text.
		         * @param annotation The annotation.
		         */
		        function replace(range, newText, annotation) {
		            return { range: range, newText: newText, annotationId: annotation };
		        }
		        AnnotatedTextEdit.replace = replace;
		        /**
		         * Creates an annotated insert text edit.
		         *
		         * @param position The position to insert the text at.
		         * @param newText The text to be inserted.
		         * @param annotation The annotation.
		         */
		        function insert(position, newText, annotation) {
		            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
		        }
		        AnnotatedTextEdit.insert = insert;
		        /**
		         * Creates an annotated delete text edit.
		         *
		         * @param range The range of text to be deleted.
		         * @param annotation The annotation.
		         */
		        function del(range, annotation) {
		            return { range: range, newText: '', annotationId: annotation };
		        }
		        AnnotatedTextEdit.del = del;
		        function is(value) {
		            var candidate = value;
		            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        AnnotatedTextEdit.is = is;
		    })(AnnotatedTextEdit || (exports$1.AnnotatedTextEdit = AnnotatedTextEdit = {}));
		    /**
		     * The TextDocumentEdit namespace provides helper function to create
		     * an edit that manipulates a text document.
		     */
		    var TextDocumentEdit;
		    (function (TextDocumentEdit) {
		        /**
		         * Creates a new `TextDocumentEdit`
		         */
		        function create(textDocument, edits) {
		            return { textDocument: textDocument, edits: edits };
		        }
		        TextDocumentEdit.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate)
		                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
		                && Array.isArray(candidate.edits);
		        }
		        TextDocumentEdit.is = is;
		    })(TextDocumentEdit || (exports$1.TextDocumentEdit = TextDocumentEdit = {}));
		    var CreateFile;
		    (function (CreateFile) {
		        function create(uri, options, annotation) {
		            var result = {
		                kind: 'create',
		                uri: uri
		            };
		            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        CreateFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
		                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        CreateFile.is = is;
		    })(CreateFile || (exports$1.CreateFile = CreateFile = {}));
		    var RenameFile;
		    (function (RenameFile) {
		        function create(oldUri, newUri, options, annotation) {
		            var result = {
		                kind: 'rename',
		                oldUri: oldUri,
		                newUri: newUri
		            };
		            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        RenameFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
		                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        RenameFile.is = is;
		    })(RenameFile || (exports$1.RenameFile = RenameFile = {}));
		    var DeleteFile;
		    (function (DeleteFile) {
		        function create(uri, options, annotation) {
		            var result = {
		                kind: 'delete',
		                uri: uri
		            };
		            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
		                result.options = options;
		            }
		            if (annotation !== undefined) {
		                result.annotationId = annotation;
		            }
		            return result;
		        }
		        DeleteFile.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
		                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
		        }
		        DeleteFile.is = is;
		    })(DeleteFile || (exports$1.DeleteFile = DeleteFile = {}));
		    var WorkspaceEdit;
		    (function (WorkspaceEdit) {
		        function is(value) {
		            var candidate = value;
		            return candidate &&
		                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
		                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
		                    if (Is.string(change.kind)) {
		                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
		                    }
		                    else {
		                        return TextDocumentEdit.is(change);
		                    }
		                }));
		        }
		        WorkspaceEdit.is = is;
		    })(WorkspaceEdit || (exports$1.WorkspaceEdit = WorkspaceEdit = {}));
		    var TextEditChangeImpl = /** @class */ (function () {
		        function TextEditChangeImpl(edits, changeAnnotations) {
		            this.edits = edits;
		            this.changeAnnotations = changeAnnotations;
		        }
		        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.insert(position, newText);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.insert(position, newText, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.insert(position, newText, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.replace(range, newText);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.replace(range, newText, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.replace(range, newText, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.delete = function (range, annotation) {
		            var edit;
		            var id;
		            if (annotation === undefined) {
		                edit = TextEdit.del(range);
		            }
		            else if (ChangeAnnotationIdentifier.is(annotation)) {
		                id = annotation;
		                edit = AnnotatedTextEdit.del(range, annotation);
		            }
		            else {
		                this.assertChangeAnnotations(this.changeAnnotations);
		                id = this.changeAnnotations.manage(annotation);
		                edit = AnnotatedTextEdit.del(range, id);
		            }
		            this.edits.push(edit);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        TextEditChangeImpl.prototype.add = function (edit) {
		            this.edits.push(edit);
		        };
		        TextEditChangeImpl.prototype.all = function () {
		            return this.edits;
		        };
		        TextEditChangeImpl.prototype.clear = function () {
		            this.edits.splice(0, this.edits.length);
		        };
		        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
		            if (value === undefined) {
		                throw new Error("Text edit change is not configured to manage change annotations.");
		            }
		        };
		        return TextEditChangeImpl;
		    }());
		    /**
		     * A helper class
		     */
		    var ChangeAnnotations = /** @class */ (function () {
		        function ChangeAnnotations(annotations) {
		            this._annotations = annotations === undefined ? Object.create(null) : annotations;
		            this._counter = 0;
		            this._size = 0;
		        }
		        ChangeAnnotations.prototype.all = function () {
		            return this._annotations;
		        };
		        Object.defineProperty(ChangeAnnotations.prototype, "size", {
		            get: function () {
		                return this._size;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
		            var id;
		            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
		                id = idOrAnnotation;
		            }
		            else {
		                id = this.nextId();
		                annotation = idOrAnnotation;
		            }
		            if (this._annotations[id] !== undefined) {
		                throw new Error("Id ".concat(id, " is already in use."));
		            }
		            if (annotation === undefined) {
		                throw new Error("No annotation provided for id ".concat(id));
		            }
		            this._annotations[id] = annotation;
		            this._size++;
		            return id;
		        };
		        ChangeAnnotations.prototype.nextId = function () {
		            this._counter++;
		            return this._counter.toString();
		        };
		        return ChangeAnnotations;
		    }());
		    /**
		     * A workspace change helps constructing changes to a workspace.
		     */
		    var WorkspaceChange = /** @class */ (function () {
		        function WorkspaceChange(workspaceEdit) {
		            var _this = this;
		            this._textEditChanges = Object.create(null);
		            if (workspaceEdit !== undefined) {
		                this._workspaceEdit = workspaceEdit;
		                if (workspaceEdit.documentChanges) {
		                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
		                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		                    workspaceEdit.documentChanges.forEach(function (change) {
		                        if (TextDocumentEdit.is(change)) {
		                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
		                            _this._textEditChanges[change.textDocument.uri] = textEditChange;
		                        }
		                    });
		                }
		                else if (workspaceEdit.changes) {
		                    Object.keys(workspaceEdit.changes).forEach(function (key) {
		                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
		                        _this._textEditChanges[key] = textEditChange;
		                    });
		                }
		            }
		            else {
		                this._workspaceEdit = {};
		            }
		        }
		        Object.defineProperty(WorkspaceChange.prototype, "edit", {
		            /**
		             * Returns the underlying {@link WorkspaceEdit} literal
		             * use to be returned from a workspace edit operation like rename.
		             */
		            get: function () {
		                this.initDocumentChanges();
		                if (this._changeAnnotations !== undefined) {
		                    if (this._changeAnnotations.size === 0) {
		                        this._workspaceEdit.changeAnnotations = undefined;
		                    }
		                    else {
		                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		                    }
		                }
		                return this._workspaceEdit;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        WorkspaceChange.prototype.getTextEditChange = function (key) {
		            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
		                this.initDocumentChanges();
		                if (this._workspaceEdit.documentChanges === undefined) {
		                    throw new Error('Workspace edit is not configured for document changes.');
		                }
		                var textDocument = { uri: key.uri, version: key.version };
		                var result = this._textEditChanges[textDocument.uri];
		                if (!result) {
		                    var edits = [];
		                    var textDocumentEdit = {
		                        textDocument: textDocument,
		                        edits: edits
		                    };
		                    this._workspaceEdit.documentChanges.push(textDocumentEdit);
		                    result = new TextEditChangeImpl(edits, this._changeAnnotations);
		                    this._textEditChanges[textDocument.uri] = result;
		                }
		                return result;
		            }
		            else {
		                this.initChanges();
		                if (this._workspaceEdit.changes === undefined) {
		                    throw new Error('Workspace edit is not configured for normal text edit changes.');
		                }
		                var result = this._textEditChanges[key];
		                if (!result) {
		                    var edits = [];
		                    this._workspaceEdit.changes[key] = edits;
		                    result = new TextEditChangeImpl(edits);
		                    this._textEditChanges[key] = result;
		                }
		                return result;
		            }
		        };
		        WorkspaceChange.prototype.initDocumentChanges = function () {
		            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
		                this._changeAnnotations = new ChangeAnnotations();
		                this._workspaceEdit.documentChanges = [];
		                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
		            }
		        };
		        WorkspaceChange.prototype.initChanges = function () {
		            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
		                this._workspaceEdit.changes = Object.create(null);
		            }
		        };
		        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = CreateFile.create(uri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = CreateFile.create(uri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = RenameFile.create(oldUri, newUri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = RenameFile.create(oldUri, newUri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
		            this.initDocumentChanges();
		            if (this._workspaceEdit.documentChanges === undefined) {
		                throw new Error('Workspace edit is not configured for document changes.');
		            }
		            var annotation;
		            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
		                annotation = optionsOrAnnotation;
		            }
		            else {
		                options = optionsOrAnnotation;
		            }
		            var operation;
		            var id;
		            if (annotation === undefined) {
		                operation = DeleteFile.create(uri, options);
		            }
		            else {
		                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
		                operation = DeleteFile.create(uri, options, id);
		            }
		            this._workspaceEdit.documentChanges.push(operation);
		            if (id !== undefined) {
		                return id;
		            }
		        };
		        return WorkspaceChange;
		    }());
		    exports$1.WorkspaceChange = WorkspaceChange;
		    /**
		     * The TextDocumentIdentifier namespace provides helper functions to work with
		     * {@link TextDocumentIdentifier} literals.
		     */
		    var TextDocumentIdentifier;
		    (function (TextDocumentIdentifier) {
		        /**
		         * Creates a new TextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         */
		        function create(uri) {
		            return { uri: uri };
		        }
		        TextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri);
		        }
		        TextDocumentIdentifier.is = is;
		    })(TextDocumentIdentifier || (exports$1.TextDocumentIdentifier = TextDocumentIdentifier = {}));
		    /**
		     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
		     * {@link VersionedTextDocumentIdentifier} literals.
		     */
		    var VersionedTextDocumentIdentifier;
		    (function (VersionedTextDocumentIdentifier) {
		        /**
		         * Creates a new VersionedTextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         * @param version The document's version.
		         */
		        function create(uri, version) {
		            return { uri: uri, version: version };
		        }
		        VersionedTextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
		        }
		        VersionedTextDocumentIdentifier.is = is;
		    })(VersionedTextDocumentIdentifier || (exports$1.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
		    /**
		     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
		     * {@link OptionalVersionedTextDocumentIdentifier} literals.
		     */
		    var OptionalVersionedTextDocumentIdentifier;
		    (function (OptionalVersionedTextDocumentIdentifier) {
		        /**
		         * Creates a new OptionalVersionedTextDocumentIdentifier literal.
		         * @param uri The document's uri.
		         * @param version The document's version.
		         */
		        function create(uri, version) {
		            return { uri: uri, version: version };
		        }
		        OptionalVersionedTextDocumentIdentifier.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
		        }
		        OptionalVersionedTextDocumentIdentifier.is = is;
		    })(OptionalVersionedTextDocumentIdentifier || (exports$1.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
		    /**
		     * The TextDocumentItem namespace provides helper functions to work with
		     * {@link TextDocumentItem} literals.
		     */
		    var TextDocumentItem;
		    (function (TextDocumentItem) {
		        /**
		         * Creates a new TextDocumentItem literal.
		         * @param uri The document's uri.
		         * @param languageId The document's language identifier.
		         * @param version The document's version number.
		         * @param text The document's text.
		         */
		        function create(uri, languageId, version, text) {
		            return { uri: uri, languageId: languageId, version: version, text: text };
		        }
		        TextDocumentItem.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
		        }
		        TextDocumentItem.is = is;
		    })(TextDocumentItem || (exports$1.TextDocumentItem = TextDocumentItem = {}));
		    /**
		     * Describes the content type that a client supports in various
		     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
		     *
		     * Please note that `MarkupKinds` must not start with a `$`. This kinds
		     * are reserved for internal usage.
		     */
		    var MarkupKind;
		    (function (MarkupKind) {
		        /**
		         * Plain text is supported as a content format
		         */
		        MarkupKind.PlainText = 'plaintext';
		        /**
		         * Markdown is supported as a content format
		         */
		        MarkupKind.Markdown = 'markdown';
		        /**
		         * Checks whether the given value is a value of the {@link MarkupKind} type.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
		        }
		        MarkupKind.is = is;
		    })(MarkupKind || (exports$1.MarkupKind = MarkupKind = {}));
		    var MarkupContent;
		    (function (MarkupContent) {
		        /**
		         * Checks whether the given value conforms to the {@link MarkupContent} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
		        }
		        MarkupContent.is = is;
		    })(MarkupContent || (exports$1.MarkupContent = MarkupContent = {}));
		    /**
		     * The kind of a completion entry.
		     */
		    var CompletionItemKind;
		    (function (CompletionItemKind) {
		        CompletionItemKind.Text = 1;
		        CompletionItemKind.Method = 2;
		        CompletionItemKind.Function = 3;
		        CompletionItemKind.Constructor = 4;
		        CompletionItemKind.Field = 5;
		        CompletionItemKind.Variable = 6;
		        CompletionItemKind.Class = 7;
		        CompletionItemKind.Interface = 8;
		        CompletionItemKind.Module = 9;
		        CompletionItemKind.Property = 10;
		        CompletionItemKind.Unit = 11;
		        CompletionItemKind.Value = 12;
		        CompletionItemKind.Enum = 13;
		        CompletionItemKind.Keyword = 14;
		        CompletionItemKind.Snippet = 15;
		        CompletionItemKind.Color = 16;
		        CompletionItemKind.File = 17;
		        CompletionItemKind.Reference = 18;
		        CompletionItemKind.Folder = 19;
		        CompletionItemKind.EnumMember = 20;
		        CompletionItemKind.Constant = 21;
		        CompletionItemKind.Struct = 22;
		        CompletionItemKind.Event = 23;
		        CompletionItemKind.Operator = 24;
		        CompletionItemKind.TypeParameter = 25;
		    })(CompletionItemKind || (exports$1.CompletionItemKind = CompletionItemKind = {}));
		    /**
		     * Defines whether the insert text in a completion item should be interpreted as
		     * plain text or a snippet.
		     */
		    var InsertTextFormat;
		    (function (InsertTextFormat) {
		        /**
		         * The primary text to be inserted is treated as a plain string.
		         */
		        InsertTextFormat.PlainText = 1;
		        /**
		         * The primary text to be inserted is treated as a snippet.
		         *
		         * A snippet can define tab stops and placeholders with `$1`, `$2`
		         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
		         * the end of the snippet. Placeholders with equal identifiers are linked,
		         * that is typing in one will update others too.
		         *
		         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
		         */
		        InsertTextFormat.Snippet = 2;
		    })(InsertTextFormat || (exports$1.InsertTextFormat = InsertTextFormat = {}));
		    /**
		     * Completion item tags are extra annotations that tweak the rendering of a completion
		     * item.
		     *
		     * @since 3.15.0
		     */
		    var CompletionItemTag;
		    (function (CompletionItemTag) {
		        /**
		         * Render a completion as obsolete, usually using a strike-out.
		         */
		        CompletionItemTag.Deprecated = 1;
		    })(CompletionItemTag || (exports$1.CompletionItemTag = CompletionItemTag = {}));
		    /**
		     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
		     *
		     * @since 3.16.0
		     */
		    var InsertReplaceEdit;
		    (function (InsertReplaceEdit) {
		        /**
		         * Creates a new insert / replace edit
		         */
		        function create(newText, insert, replace) {
		            return { newText: newText, insert: insert, replace: replace };
		        }
		        InsertReplaceEdit.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
		        }
		        InsertReplaceEdit.is = is;
		    })(InsertReplaceEdit || (exports$1.InsertReplaceEdit = InsertReplaceEdit = {}));
		    /**
		     * How whitespace and indentation is handled during completion
		     * item insertion.
		     *
		     * @since 3.16.0
		     */
		    var InsertTextMode;
		    (function (InsertTextMode) {
		        /**
		         * The insertion or replace strings is taken as it is. If the
		         * value is multi line the lines below the cursor will be
		         * inserted using the indentation defined in the string value.
		         * The client will not apply any kind of adjustments to the
		         * string.
		         */
		        InsertTextMode.asIs = 1;
		        /**
		         * The editor adjusts leading whitespace of new lines so that
		         * they match the indentation up to the cursor of the line for
		         * which the item is accepted.
		         *
		         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
		         * multi line completion item is indented using 2 tabs and all
		         * following lines inserted will be indented using 2 tabs as well.
		         */
		        InsertTextMode.adjustIndentation = 2;
		    })(InsertTextMode || (exports$1.InsertTextMode = InsertTextMode = {}));
		    var CompletionItemLabelDetails;
		    (function (CompletionItemLabelDetails) {
		        function is(value) {
		            var candidate = value;
		            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
		                (Is.string(candidate.description) || candidate.description === undefined);
		        }
		        CompletionItemLabelDetails.is = is;
		    })(CompletionItemLabelDetails || (exports$1.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
		    /**
		     * The CompletionItem namespace provides functions to deal with
		     * completion items.
		     */
		    var CompletionItem;
		    (function (CompletionItem) {
		        /**
		         * Create a completion item and seed it with a label.
		         * @param label The completion item's label
		         */
		        function create(label) {
		            return { label: label };
		        }
		        CompletionItem.create = create;
		    })(CompletionItem || (exports$1.CompletionItem = CompletionItem = {}));
		    /**
		     * The CompletionList namespace provides functions to deal with
		     * completion lists.
		     */
		    var CompletionList;
		    (function (CompletionList) {
		        /**
		         * Creates a new completion list.
		         *
		         * @param items The completion items.
		         * @param isIncomplete The list is not complete.
		         */
		        function create(items, isIncomplete) {
		            return { items: items ? items : [], isIncomplete: !!isIncomplete };
		        }
		        CompletionList.create = create;
		    })(CompletionList || (exports$1.CompletionList = CompletionList = {}));
		    var MarkedString;
		    (function (MarkedString) {
		        /**
		         * Creates a marked string from plain text.
		         *
		         * @param plainText The plain text.
		         */
		        function fromPlainText(plainText) {
		            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
		        }
		        MarkedString.fromPlainText = fromPlainText;
		        /**
		         * Checks whether the given value conforms to the {@link MarkedString} type.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
		        }
		        MarkedString.is = is;
		    })(MarkedString || (exports$1.MarkedString = MarkedString = {}));
		    var Hover;
		    (function (Hover) {
		        /**
		         * Checks whether the given value conforms to the {@link Hover} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
		                MarkedString.is(candidate.contents) ||
		                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
		        }
		        Hover.is = is;
		    })(Hover || (exports$1.Hover = Hover = {}));
		    /**
		     * The ParameterInformation namespace provides helper functions to work with
		     * {@link ParameterInformation} literals.
		     */
		    var ParameterInformation;
		    (function (ParameterInformation) {
		        /**
		         * Creates a new parameter information literal.
		         *
		         * @param label A label string.
		         * @param documentation A doc string.
		         */
		        function create(label, documentation) {
		            return documentation ? { label: label, documentation: documentation } : { label: label };
		        }
		        ParameterInformation.create = create;
		    })(ParameterInformation || (exports$1.ParameterInformation = ParameterInformation = {}));
		    /**
		     * The SignatureInformation namespace provides helper functions to work with
		     * {@link SignatureInformation} literals.
		     */
		    var SignatureInformation;
		    (function (SignatureInformation) {
		        function create(label, documentation) {
		            var parameters = [];
		            for (var _i = 2; _i < arguments.length; _i++) {
		                parameters[_i - 2] = arguments[_i];
		            }
		            var result = { label: label };
		            if (Is.defined(documentation)) {
		                result.documentation = documentation;
		            }
		            if (Is.defined(parameters)) {
		                result.parameters = parameters;
		            }
		            else {
		                result.parameters = [];
		            }
		            return result;
		        }
		        SignatureInformation.create = create;
		    })(SignatureInformation || (exports$1.SignatureInformation = SignatureInformation = {}));
		    /**
		     * A document highlight kind.
		     */
		    var DocumentHighlightKind;
		    (function (DocumentHighlightKind) {
		        /**
		         * A textual occurrence.
		         */
		        DocumentHighlightKind.Text = 1;
		        /**
		         * Read-access of a symbol, like reading a variable.
		         */
		        DocumentHighlightKind.Read = 2;
		        /**
		         * Write-access of a symbol, like writing to a variable.
		         */
		        DocumentHighlightKind.Write = 3;
		    })(DocumentHighlightKind || (exports$1.DocumentHighlightKind = DocumentHighlightKind = {}));
		    /**
		     * DocumentHighlight namespace to provide helper functions to work with
		     * {@link DocumentHighlight} literals.
		     */
		    var DocumentHighlight;
		    (function (DocumentHighlight) {
		        /**
		         * Create a DocumentHighlight object.
		         * @param range The range the highlight applies to.
		         * @param kind The highlight kind
		         */
		        function create(range, kind) {
		            var result = { range: range };
		            if (Is.number(kind)) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        DocumentHighlight.create = create;
		    })(DocumentHighlight || (exports$1.DocumentHighlight = DocumentHighlight = {}));
		    /**
		     * A symbol kind.
		     */
		    var SymbolKind;
		    (function (SymbolKind) {
		        SymbolKind.File = 1;
		        SymbolKind.Module = 2;
		        SymbolKind.Namespace = 3;
		        SymbolKind.Package = 4;
		        SymbolKind.Class = 5;
		        SymbolKind.Method = 6;
		        SymbolKind.Property = 7;
		        SymbolKind.Field = 8;
		        SymbolKind.Constructor = 9;
		        SymbolKind.Enum = 10;
		        SymbolKind.Interface = 11;
		        SymbolKind.Function = 12;
		        SymbolKind.Variable = 13;
		        SymbolKind.Constant = 14;
		        SymbolKind.String = 15;
		        SymbolKind.Number = 16;
		        SymbolKind.Boolean = 17;
		        SymbolKind.Array = 18;
		        SymbolKind.Object = 19;
		        SymbolKind.Key = 20;
		        SymbolKind.Null = 21;
		        SymbolKind.EnumMember = 22;
		        SymbolKind.Struct = 23;
		        SymbolKind.Event = 24;
		        SymbolKind.Operator = 25;
		        SymbolKind.TypeParameter = 26;
		    })(SymbolKind || (exports$1.SymbolKind = SymbolKind = {}));
		    /**
		     * Symbol tags are extra annotations that tweak the rendering of a symbol.
		     *
		     * @since 3.16
		     */
		    var SymbolTag;
		    (function (SymbolTag) {
		        /**
		         * Render a symbol as obsolete, usually using a strike-out.
		         */
		        SymbolTag.Deprecated = 1;
		    })(SymbolTag || (exports$1.SymbolTag = SymbolTag = {}));
		    var SymbolInformation;
		    (function (SymbolInformation) {
		        /**
		         * Creates a new symbol information literal.
		         *
		         * @param name The name of the symbol.
		         * @param kind The kind of the symbol.
		         * @param range The range of the location of the symbol.
		         * @param uri The resource of the location of symbol.
		         * @param containerName The name of the symbol containing the symbol.
		         */
		        function create(name, kind, range, uri, containerName) {
		            var result = {
		                name: name,
		                kind: kind,
		                location: { uri: uri, range: range }
		            };
		            if (containerName) {
		                result.containerName = containerName;
		            }
		            return result;
		        }
		        SymbolInformation.create = create;
		    })(SymbolInformation || (exports$1.SymbolInformation = SymbolInformation = {}));
		    var WorkspaceSymbol;
		    (function (WorkspaceSymbol) {
		        /**
		         * Create a new workspace symbol.
		         *
		         * @param name The name of the symbol.
		         * @param kind The kind of the symbol.
		         * @param uri The resource of the location of the symbol.
		         * @param range An options range of the location.
		         * @returns A WorkspaceSymbol.
		         */
		        function create(name, kind, uri, range) {
		            return range !== undefined
		                ? { name: name, kind: kind, location: { uri: uri, range: range } }
		                : { name: name, kind: kind, location: { uri: uri } };
		        }
		        WorkspaceSymbol.create = create;
		    })(WorkspaceSymbol || (exports$1.WorkspaceSymbol = WorkspaceSymbol = {}));
		    var DocumentSymbol;
		    (function (DocumentSymbol) {
		        /**
		         * Creates a new symbol information literal.
		         *
		         * @param name The name of the symbol.
		         * @param detail The detail of the symbol.
		         * @param kind The kind of the symbol.
		         * @param range The range of the symbol.
		         * @param selectionRange The selectionRange of the symbol.
		         * @param children Children of the symbol.
		         */
		        function create(name, detail, kind, range, selectionRange, children) {
		            var result = {
		                name: name,
		                detail: detail,
		                kind: kind,
		                range: range,
		                selectionRange: selectionRange
		            };
		            if (children !== undefined) {
		                result.children = children;
		            }
		            return result;
		        }
		        DocumentSymbol.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return candidate &&
		                Is.string(candidate.name) && Is.number(candidate.kind) &&
		                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
		                (candidate.detail === undefined || Is.string(candidate.detail)) &&
		                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
		                (candidate.children === undefined || Array.isArray(candidate.children)) &&
		                (candidate.tags === undefined || Array.isArray(candidate.tags));
		        }
		        DocumentSymbol.is = is;
		    })(DocumentSymbol || (exports$1.DocumentSymbol = DocumentSymbol = {}));
		    /**
		     * A set of predefined code action kinds
		     */
		    var CodeActionKind;
		    (function (CodeActionKind) {
		        /**
		         * Empty kind.
		         */
		        CodeActionKind.Empty = '';
		        /**
		         * Base kind for quickfix actions: 'quickfix'
		         */
		        CodeActionKind.QuickFix = 'quickfix';
		        /**
		         * Base kind for refactoring actions: 'refactor'
		         */
		        CodeActionKind.Refactor = 'refactor';
		        /**
		         * Base kind for refactoring extraction actions: 'refactor.extract'
		         *
		         * Example extract actions:
		         *
		         * - Extract method
		         * - Extract function
		         * - Extract variable
		         * - Extract interface from class
		         * - ...
		         */
		        CodeActionKind.RefactorExtract = 'refactor.extract';
		        /**
		         * Base kind for refactoring inline actions: 'refactor.inline'
		         *
		         * Example inline actions:
		         *
		         * - Inline function
		         * - Inline variable
		         * - Inline constant
		         * - ...
		         */
		        CodeActionKind.RefactorInline = 'refactor.inline';
		        /**
		         * Base kind for refactoring rewrite actions: 'refactor.rewrite'
		         *
		         * Example rewrite actions:
		         *
		         * - Convert JavaScript function to class
		         * - Add or remove parameter
		         * - Encapsulate field
		         * - Make method static
		         * - Move method to base class
		         * - ...
		         */
		        CodeActionKind.RefactorRewrite = 'refactor.rewrite';
		        /**
		         * Base kind for source actions: `source`
		         *
		         * Source code actions apply to the entire file.
		         */
		        CodeActionKind.Source = 'source';
		        /**
		         * Base kind for an organize imports source action: `source.organizeImports`
		         */
		        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
		        /**
		         * Base kind for auto-fix source actions: `source.fixAll`.
		         *
		         * Fix all actions automatically fix errors that have a clear fix that do not require user input.
		         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
		         *
		         * @since 3.15.0
		         */
		        CodeActionKind.SourceFixAll = 'source.fixAll';
		    })(CodeActionKind || (exports$1.CodeActionKind = CodeActionKind = {}));
		    /**
		     * The reason why code actions were requested.
		     *
		     * @since 3.17.0
		     */
		    var CodeActionTriggerKind;
		    (function (CodeActionTriggerKind) {
		        /**
		         * Code actions were explicitly requested by the user or by an extension.
		         */
		        CodeActionTriggerKind.Invoked = 1;
		        /**
		         * Code actions were requested automatically.
		         *
		         * This typically happens when current selection in a file changes, but can
		         * also be triggered when file content changes.
		         */
		        CodeActionTriggerKind.Automatic = 2;
		    })(CodeActionTriggerKind || (exports$1.CodeActionTriggerKind = CodeActionTriggerKind = {}));
		    /**
		     * The CodeActionContext namespace provides helper functions to work with
		     * {@link CodeActionContext} literals.
		     */
		    var CodeActionContext;
		    (function (CodeActionContext) {
		        /**
		         * Creates a new CodeActionContext literal.
		         */
		        function create(diagnostics, only, triggerKind) {
		            var result = { diagnostics: diagnostics };
		            if (only !== undefined && only !== null) {
		                result.only = only;
		            }
		            if (triggerKind !== undefined && triggerKind !== null) {
		                result.triggerKind = triggerKind;
		            }
		            return result;
		        }
		        CodeActionContext.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
		                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
		                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
		        }
		        CodeActionContext.is = is;
		    })(CodeActionContext || (exports$1.CodeActionContext = CodeActionContext = {}));
		    var CodeAction;
		    (function (CodeAction) {
		        function create(title, kindOrCommandOrEdit, kind) {
		            var result = { title: title };
		            var checkKind = true;
		            if (typeof kindOrCommandOrEdit === 'string') {
		                checkKind = false;
		                result.kind = kindOrCommandOrEdit;
		            }
		            else if (Command.is(kindOrCommandOrEdit)) {
		                result.command = kindOrCommandOrEdit;
		            }
		            else {
		                result.edit = kindOrCommandOrEdit;
		            }
		            if (checkKind && kind !== undefined) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        CodeAction.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate && Is.string(candidate.title) &&
		                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
		                (candidate.kind === undefined || Is.string(candidate.kind)) &&
		                (candidate.edit !== undefined || candidate.command !== undefined) &&
		                (candidate.command === undefined || Command.is(candidate.command)) &&
		                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
		                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
		        }
		        CodeAction.is = is;
		    })(CodeAction || (exports$1.CodeAction = CodeAction = {}));
		    /**
		     * The CodeLens namespace provides helper functions to work with
		     * {@link CodeLens} literals.
		     */
		    var CodeLens;
		    (function (CodeLens) {
		        /**
		         * Creates a new CodeLens literal.
		         */
		        function create(range, data) {
		            var result = { range: range };
		            if (Is.defined(data)) {
		                result.data = data;
		            }
		            return result;
		        }
		        CodeLens.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link CodeLens} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
		        }
		        CodeLens.is = is;
		    })(CodeLens || (exports$1.CodeLens = CodeLens = {}));
		    /**
		     * The FormattingOptions namespace provides helper functions to work with
		     * {@link FormattingOptions} literals.
		     */
		    var FormattingOptions;
		    (function (FormattingOptions) {
		        /**
		         * Creates a new FormattingOptions literal.
		         */
		        function create(tabSize, insertSpaces) {
		            return { tabSize: tabSize, insertSpaces: insertSpaces };
		        }
		        FormattingOptions.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
		        }
		        FormattingOptions.is = is;
		    })(FormattingOptions || (exports$1.FormattingOptions = FormattingOptions = {}));
		    /**
		     * The DocumentLink namespace provides helper functions to work with
		     * {@link DocumentLink} literals.
		     */
		    var DocumentLink;
		    (function (DocumentLink) {
		        /**
		         * Creates a new DocumentLink literal.
		         */
		        function create(range, target, data) {
		            return { range: range, target: target, data: data };
		        }
		        DocumentLink.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link DocumentLink} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
		        }
		        DocumentLink.is = is;
		    })(DocumentLink || (exports$1.DocumentLink = DocumentLink = {}));
		    /**
		     * The SelectionRange namespace provides helper function to work with
		     * SelectionRange literals.
		     */
		    var SelectionRange;
		    (function (SelectionRange) {
		        /**
		         * Creates a new SelectionRange
		         * @param range the range.
		         * @param parent an optional parent.
		         */
		        function create(range, parent) {
		            return { range: range, parent: parent };
		        }
		        SelectionRange.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
		        }
		        SelectionRange.is = is;
		    })(SelectionRange || (exports$1.SelectionRange = SelectionRange = {}));
		    /**
		     * A set of predefined token types. This set is not fixed
		     * an clients can specify additional token types via the
		     * corresponding client capabilities.
		     *
		     * @since 3.16.0
		     */
		    var SemanticTokenTypes;
		    (function (SemanticTokenTypes) {
		        SemanticTokenTypes["namespace"] = "namespace";
		        /**
		         * Represents a generic type. Acts as a fallback for types which can't be mapped to
		         * a specific type like class or enum.
		         */
		        SemanticTokenTypes["type"] = "type";
		        SemanticTokenTypes["class"] = "class";
		        SemanticTokenTypes["enum"] = "enum";
		        SemanticTokenTypes["interface"] = "interface";
		        SemanticTokenTypes["struct"] = "struct";
		        SemanticTokenTypes["typeParameter"] = "typeParameter";
		        SemanticTokenTypes["parameter"] = "parameter";
		        SemanticTokenTypes["variable"] = "variable";
		        SemanticTokenTypes["property"] = "property";
		        SemanticTokenTypes["enumMember"] = "enumMember";
		        SemanticTokenTypes["event"] = "event";
		        SemanticTokenTypes["function"] = "function";
		        SemanticTokenTypes["method"] = "method";
		        SemanticTokenTypes["macro"] = "macro";
		        SemanticTokenTypes["keyword"] = "keyword";
		        SemanticTokenTypes["modifier"] = "modifier";
		        SemanticTokenTypes["comment"] = "comment";
		        SemanticTokenTypes["string"] = "string";
		        SemanticTokenTypes["number"] = "number";
		        SemanticTokenTypes["regexp"] = "regexp";
		        SemanticTokenTypes["operator"] = "operator";
		        /**
		         * @since 3.17.0
		         */
		        SemanticTokenTypes["decorator"] = "decorator";
		    })(SemanticTokenTypes || (exports$1.SemanticTokenTypes = SemanticTokenTypes = {}));
		    /**
		     * A set of predefined token modifiers. This set is not fixed
		     * an clients can specify additional token types via the
		     * corresponding client capabilities.
		     *
		     * @since 3.16.0
		     */
		    var SemanticTokenModifiers;
		    (function (SemanticTokenModifiers) {
		        SemanticTokenModifiers["declaration"] = "declaration";
		        SemanticTokenModifiers["definition"] = "definition";
		        SemanticTokenModifiers["readonly"] = "readonly";
		        SemanticTokenModifiers["static"] = "static";
		        SemanticTokenModifiers["deprecated"] = "deprecated";
		        SemanticTokenModifiers["abstract"] = "abstract";
		        SemanticTokenModifiers["async"] = "async";
		        SemanticTokenModifiers["modification"] = "modification";
		        SemanticTokenModifiers["documentation"] = "documentation";
		        SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
		    })(SemanticTokenModifiers || (exports$1.SemanticTokenModifiers = SemanticTokenModifiers = {}));
		    /**
		     * @since 3.16.0
		     */
		    var SemanticTokens;
		    (function (SemanticTokens) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
		                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
		        }
		        SemanticTokens.is = is;
		    })(SemanticTokens || (exports$1.SemanticTokens = SemanticTokens = {}));
		    /**
		     * The InlineValueText namespace provides functions to deal with InlineValueTexts.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueText;
		    (function (InlineValueText) {
		        /**
		         * Creates a new InlineValueText literal.
		         */
		        function create(range, text) {
		            return { range: range, text: text };
		        }
		        InlineValueText.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
		        }
		        InlineValueText.is = is;
		    })(InlineValueText || (exports$1.InlineValueText = InlineValueText = {}));
		    /**
		     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueVariableLookup;
		    (function (InlineValueVariableLookup) {
		        /**
		         * Creates a new InlineValueText literal.
		         */
		        function create(range, variableName, caseSensitiveLookup) {
		            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
		        }
		        InlineValueVariableLookup.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
		                && (Is.string(candidate.variableName) || candidate.variableName === undefined);
		        }
		        InlineValueVariableLookup.is = is;
		    })(InlineValueVariableLookup || (exports$1.InlineValueVariableLookup = InlineValueVariableLookup = {}));
		    /**
		     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueEvaluatableExpression;
		    (function (InlineValueEvaluatableExpression) {
		        /**
		         * Creates a new InlineValueEvaluatableExpression literal.
		         */
		        function create(range, expression) {
		            return { range: range, expression: expression };
		        }
		        InlineValueEvaluatableExpression.create = create;
		        function is(value) {
		            var candidate = value;
		            return candidate !== undefined && candidate !== null && Range.is(candidate.range)
		                && (Is.string(candidate.expression) || candidate.expression === undefined);
		        }
		        InlineValueEvaluatableExpression.is = is;
		    })(InlineValueEvaluatableExpression || (exports$1.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
		    /**
		     * The InlineValueContext namespace provides helper functions to work with
		     * {@link InlineValueContext} literals.
		     *
		     * @since 3.17.0
		     */
		    var InlineValueContext;
		    (function (InlineValueContext) {
		        /**
		         * Creates a new InlineValueContext literal.
		         */
		        function create(frameId, stoppedLocation) {
		            return { frameId: frameId, stoppedLocation: stoppedLocation };
		        }
		        InlineValueContext.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Range.is(value.stoppedLocation);
		        }
		        InlineValueContext.is = is;
		    })(InlineValueContext || (exports$1.InlineValueContext = InlineValueContext = {}));
		    /**
		     * Inlay hint kinds.
		     *
		     * @since 3.17.0
		     */
		    var InlayHintKind;
		    (function (InlayHintKind) {
		        /**
		         * An inlay hint that for a type annotation.
		         */
		        InlayHintKind.Type = 1;
		        /**
		         * An inlay hint that is for a parameter.
		         */
		        InlayHintKind.Parameter = 2;
		        function is(value) {
		            return value === 1 || value === 2;
		        }
		        InlayHintKind.is = is;
		    })(InlayHintKind || (exports$1.InlayHintKind = InlayHintKind = {}));
		    var InlayHintLabelPart;
		    (function (InlayHintLabelPart) {
		        function create(value) {
		            return { value: value };
		        }
		        InlayHintLabelPart.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate)
		                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
		                && (candidate.location === undefined || Location.is(candidate.location))
		                && (candidate.command === undefined || Command.is(candidate.command));
		        }
		        InlayHintLabelPart.is = is;
		    })(InlayHintLabelPart || (exports$1.InlayHintLabelPart = InlayHintLabelPart = {}));
		    var InlayHint;
		    (function (InlayHint) {
		        function create(position, label, kind) {
		            var result = { position: position, label: label };
		            if (kind !== undefined) {
		                result.kind = kind;
		            }
		            return result;
		        }
		        InlayHint.create = create;
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && Position.is(candidate.position)
		                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
		                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
		                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
		                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
		                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
		                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
		        }
		        InlayHint.is = is;
		    })(InlayHint || (exports$1.InlayHint = InlayHint = {}));
		    var StringValue;
		    (function (StringValue) {
		        function createSnippet(value) {
		            return { kind: 'snippet', value: value };
		        }
		        StringValue.createSnippet = createSnippet;
		    })(StringValue || (exports$1.StringValue = StringValue = {}));
		    var InlineCompletionItem;
		    (function (InlineCompletionItem) {
		        function create(insertText, filterText, range, command) {
		            return { insertText: insertText, filterText: filterText, range: range, command: command };
		        }
		        InlineCompletionItem.create = create;
		    })(InlineCompletionItem || (exports$1.InlineCompletionItem = InlineCompletionItem = {}));
		    var InlineCompletionList;
		    (function (InlineCompletionList) {
		        function create(items) {
		            return { items: items };
		        }
		        InlineCompletionList.create = create;
		    })(InlineCompletionList || (exports$1.InlineCompletionList = InlineCompletionList = {}));
		    /**
		     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
		     *
		     * @since 3.18.0
		     * @proposed
		     */
		    var InlineCompletionTriggerKind;
		    (function (InlineCompletionTriggerKind) {
		        /**
		         * Completion was triggered explicitly by a user gesture.
		         */
		        InlineCompletionTriggerKind.Invoked = 0;
		        /**
		         * Completion was triggered automatically while editing.
		         */
		        InlineCompletionTriggerKind.Automatic = 1;
		    })(InlineCompletionTriggerKind || (exports$1.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
		    var SelectedCompletionInfo;
		    (function (SelectedCompletionInfo) {
		        function create(range, text) {
		            return { range: range, text: text };
		        }
		        SelectedCompletionInfo.create = create;
		    })(SelectedCompletionInfo || (exports$1.SelectedCompletionInfo = SelectedCompletionInfo = {}));
		    var InlineCompletionContext;
		    (function (InlineCompletionContext) {
		        function create(triggerKind, selectedCompletionInfo) {
		            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };
		        }
		        InlineCompletionContext.create = create;
		    })(InlineCompletionContext || (exports$1.InlineCompletionContext = InlineCompletionContext = {}));
		    var WorkspaceFolder;
		    (function (WorkspaceFolder) {
		        function is(value) {
		            var candidate = value;
		            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
		        }
		        WorkspaceFolder.is = is;
		    })(WorkspaceFolder || (exports$1.WorkspaceFolder = WorkspaceFolder = {}));
		    exports$1.EOL = ['\n', '\r\n', '\r'];
		    /**
		     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
		     */
		    var TextDocument;
		    (function (TextDocument) {
		        /**
		         * Creates a new ITextDocument literal from the given uri and content.
		         * @param uri The document's uri.
		         * @param languageId The document's language Id.
		         * @param version The document's version.
		         * @param content The document's content.
		         */
		        function create(uri, languageId, version, content) {
		            return new FullTextDocument(uri, languageId, version, content);
		        }
		        TextDocument.create = create;
		        /**
		         * Checks whether the given literal conforms to the {@link ITextDocument} interface.
		         */
		        function is(value) {
		            var candidate = value;
		            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
		                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
		        }
		        TextDocument.is = is;
		        function applyEdits(document, edits) {
		            var text = document.getText();
		            var sortedEdits = mergeSort(edits, function (a, b) {
		                var diff = a.range.start.line - b.range.start.line;
		                if (diff === 0) {
		                    return a.range.start.character - b.range.start.character;
		                }
		                return diff;
		            });
		            var lastModifiedOffset = text.length;
		            for (var i = sortedEdits.length - 1; i >= 0; i--) {
		                var e = sortedEdits[i];
		                var startOffset = document.offsetAt(e.range.start);
		                var endOffset = document.offsetAt(e.range.end);
		                if (endOffset <= lastModifiedOffset) {
		                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
		                }
		                else {
		                    throw new Error('Overlapping edit');
		                }
		                lastModifiedOffset = startOffset;
		            }
		            return text;
		        }
		        TextDocument.applyEdits = applyEdits;
		        function mergeSort(data, compare) {
		            if (data.length <= 1) {
		                // sorted
		                return data;
		            }
		            var p = (data.length / 2) | 0;
		            var left = data.slice(0, p);
		            var right = data.slice(p);
		            mergeSort(left, compare);
		            mergeSort(right, compare);
		            var leftIdx = 0;
		            var rightIdx = 0;
		            var i = 0;
		            while (leftIdx < left.length && rightIdx < right.length) {
		                var ret = compare(left[leftIdx], right[rightIdx]);
		                if (ret <= 0) {
		                    // smaller_equal -> take left to preserve order
		                    data[i++] = left[leftIdx++];
		                }
		                else {
		                    // greater -> take right
		                    data[i++] = right[rightIdx++];
		                }
		            }
		            while (leftIdx < left.length) {
		                data[i++] = left[leftIdx++];
		            }
		            while (rightIdx < right.length) {
		                data[i++] = right[rightIdx++];
		            }
		            return data;
		        }
		    })(TextDocument || (exports$1.TextDocument = TextDocument = {}));
		    /**
		     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
		     */
		    var FullTextDocument = /** @class */ (function () {
		        function FullTextDocument(uri, languageId, version, content) {
		            this._uri = uri;
		            this._languageId = languageId;
		            this._version = version;
		            this._content = content;
		            this._lineOffsets = undefined;
		        }
		        Object.defineProperty(FullTextDocument.prototype, "uri", {
		            get: function () {
		                return this._uri;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        Object.defineProperty(FullTextDocument.prototype, "languageId", {
		            get: function () {
		                return this._languageId;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        Object.defineProperty(FullTextDocument.prototype, "version", {
		            get: function () {
		                return this._version;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        FullTextDocument.prototype.getText = function (range) {
		            if (range) {
		                var start = this.offsetAt(range.start);
		                var end = this.offsetAt(range.end);
		                return this._content.substring(start, end);
		            }
		            return this._content;
		        };
		        FullTextDocument.prototype.update = function (event, version) {
		            this._content = event.text;
		            this._version = version;
		            this._lineOffsets = undefined;
		        };
		        FullTextDocument.prototype.getLineOffsets = function () {
		            if (this._lineOffsets === undefined) {
		                var lineOffsets = [];
		                var text = this._content;
		                var isLineStart = true;
		                for (var i = 0; i < text.length; i++) {
		                    if (isLineStart) {
		                        lineOffsets.push(i);
		                        isLineStart = false;
		                    }
		                    var ch = text.charAt(i);
		                    isLineStart = (ch === '\r' || ch === '\n');
		                    if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
		                        i++;
		                    }
		                }
		                if (isLineStart && text.length > 0) {
		                    lineOffsets.push(text.length);
		                }
		                this._lineOffsets = lineOffsets;
		            }
		            return this._lineOffsets;
		        };
		        FullTextDocument.prototype.positionAt = function (offset) {
		            offset = Math.max(Math.min(offset, this._content.length), 0);
		            var lineOffsets = this.getLineOffsets();
		            var low = 0, high = lineOffsets.length;
		            if (high === 0) {
		                return Position.create(0, offset);
		            }
		            while (low < high) {
		                var mid = Math.floor((low + high) / 2);
		                if (lineOffsets[mid] > offset) {
		                    high = mid;
		                }
		                else {
		                    low = mid + 1;
		                }
		            }
		            // low is the least x for which the line offset is larger than the current offset
		            // or array.length if no line offset is larger than the current offset
		            var line = low - 1;
		            return Position.create(line, offset - lineOffsets[line]);
		        };
		        FullTextDocument.prototype.offsetAt = function (position) {
		            var lineOffsets = this.getLineOffsets();
		            if (position.line >= lineOffsets.length) {
		                return this._content.length;
		            }
		            else if (position.line < 0) {
		                return 0;
		            }
		            var lineOffset = lineOffsets[position.line];
		            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
		            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
		        };
		        Object.defineProperty(FullTextDocument.prototype, "lineCount", {
		            get: function () {
		                return this.getLineOffsets().length;
		            },
		            enumerable: false,
		            configurable: true
		        });
		        return FullTextDocument;
		    }());
		    var Is;
		    (function (Is) {
		        var toString = Object.prototype.toString;
		        function defined(value) {
		            return typeof value !== 'undefined';
		        }
		        Is.defined = defined;
		        function undefined$1(value) {
		            return typeof value === 'undefined';
		        }
		        Is.undefined = undefined$1;
		        function boolean(value) {
		            return value === true || value === false;
		        }
		        Is.boolean = boolean;
		        function string(value) {
		            return toString.call(value) === '[object String]';
		        }
		        Is.string = string;
		        function number(value) {
		            return toString.call(value) === '[object Number]';
		        }
		        Is.number = number;
		        function numberRange(value, min, max) {
		            return toString.call(value) === '[object Number]' && min <= value && value <= max;
		        }
		        Is.numberRange = numberRange;
		        function integer(value) {
		            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
		        }
		        Is.integer = integer;
		        function uinteger(value) {
		            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
		        }
		        Is.uinteger = uinteger;
		        function func(value) {
		            return toString.call(value) === '[object Function]';
		        }
		        Is.func = func;
		        function objectLiteral(value) {
		            // Strictly speaking class instances pass this check as well. Since the LSP
		            // doesn't use classes we ignore this for now. If we do we need to add something
		            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
		            return value !== null && typeof value === 'object';
		        }
		        Is.objectLiteral = objectLiteral;
		        function typedArray(value, check) {
		            return Array.isArray(value) && value.every(check);
		        }
		        Is.typedArray = typedArray;
		    })(Is || (Is = {}));
		}); 
	} (main$3, main$3.exports));
	return main$3.exports;
}

var messages = {};

var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages;
	hasRequiredMessages = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(messages, "__esModule", { value: true });
	messages.ProtocolNotificationType = messages.ProtocolNotificationType0 = messages.ProtocolRequestType = messages.ProtocolRequestType0 = messages.RegistrationType = messages.MessageDirection = void 0;
	const vscode_jsonrpc_1 = requireMain$5();
	var MessageDirection;
	(function (MessageDirection) {
	    MessageDirection["clientToServer"] = "clientToServer";
	    MessageDirection["serverToClient"] = "serverToClient";
	    MessageDirection["both"] = "both";
	})(MessageDirection || (messages.MessageDirection = MessageDirection = {}));
	class RegistrationType {
	    constructor(method) {
	        this.method = method;
	    }
	}
	messages.RegistrationType = RegistrationType;
	class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
	    constructor(method) {
	        super(method);
	    }
	}
	messages.ProtocolRequestType0 = ProtocolRequestType0;
	class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
	    constructor(method) {
	        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
	    }
	}
	messages.ProtocolRequestType = ProtocolRequestType;
	class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
	    constructor(method) {
	        super(method);
	    }
	}
	messages.ProtocolNotificationType0 = ProtocolNotificationType0;
	class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
	    constructor(method) {
	        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
	    }
	}
	messages.ProtocolNotificationType = ProtocolNotificationType;
	return messages;
}

var protocol$1 = {};

var is = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is;
	hasRequiredIs = 1;
	Object.defineProperty(is, "__esModule", { value: true });
	is.objectLiteral = is.typedArray = is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;
	function boolean(value) {
	    return value === true || value === false;
	}
	is.boolean = boolean;
	function string(value) {
	    return typeof value === 'string' || value instanceof String;
	}
	is.string = string;
	function number(value) {
	    return typeof value === 'number' || value instanceof Number;
	}
	is.number = number;
	function error(value) {
	    return value instanceof Error;
	}
	is.error = error;
	function func(value) {
	    return typeof value === 'function';
	}
	is.func = func;
	function array(value) {
	    return Array.isArray(value);
	}
	is.array = array;
	function stringArray(value) {
	    return array(value) && value.every(elem => string(elem));
	}
	is.stringArray = stringArray;
	function typedArray(value, check) {
	    return Array.isArray(value) && value.every(check);
	}
	is.typedArray = typedArray;
	function objectLiteral(value) {
	    // Strictly speaking class instances pass this check as well. Since the LSP
	    // doesn't use classes we ignore this for now. If we do we need to add something
	    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
	    return value !== null && typeof value === 'object';
	}
	is.objectLiteral = objectLiteral;
	return is;
}

var protocol_implementation = {};

var hasRequiredProtocol_implementation;

function requireProtocol_implementation () {
	if (hasRequiredProtocol_implementation) return protocol_implementation;
	hasRequiredProtocol_implementation = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_implementation, "__esModule", { value: true });
	protocol_implementation.ImplementationRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the implementation locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Definition} or a Thenable that resolves to such.
	 */
	var ImplementationRequest;
	(function (ImplementationRequest) {
	    ImplementationRequest.method = 'textDocument/implementation';
	    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
	})(ImplementationRequest || (protocol_implementation.ImplementationRequest = ImplementationRequest = {}));
	return protocol_implementation;
}

var protocol_typeDefinition = {};

var hasRequiredProtocol_typeDefinition;

function requireProtocol_typeDefinition () {
	if (hasRequiredProtocol_typeDefinition) return protocol_typeDefinition;
	hasRequiredProtocol_typeDefinition = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_typeDefinition, "__esModule", { value: true });
	protocol_typeDefinition.TypeDefinitionRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the type definition locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Definition} or a Thenable that resolves to such.
	 */
	var TypeDefinitionRequest;
	(function (TypeDefinitionRequest) {
	    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
	    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
	})(TypeDefinitionRequest || (protocol_typeDefinition.TypeDefinitionRequest = TypeDefinitionRequest = {}));
	return protocol_typeDefinition;
}

var protocol_workspaceFolder = {};

var hasRequiredProtocol_workspaceFolder;

function requireProtocol_workspaceFolder () {
	if (hasRequiredProtocol_workspaceFolder) return protocol_workspaceFolder;
	hasRequiredProtocol_workspaceFolder = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_workspaceFolder, "__esModule", { value: true });
	protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolder.WorkspaceFoldersRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
	 */
	var WorkspaceFoldersRequest;
	(function (WorkspaceFoldersRequest) {
	    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
	    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
	})(WorkspaceFoldersRequest || (protocol_workspaceFolder.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
	/**
	 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	 * folder configuration changes.
	 */
	var DidChangeWorkspaceFoldersNotification;
	(function (DidChangeWorkspaceFoldersNotification) {
	    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
	    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
	})(DidChangeWorkspaceFoldersNotification || (protocol_workspaceFolder.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
	return protocol_workspaceFolder;
}

var protocol_configuration = {};

var hasRequiredProtocol_configuration;

function requireProtocol_configuration () {
	if (hasRequiredProtocol_configuration) return protocol_configuration;
	hasRequiredProtocol_configuration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_configuration, "__esModule", { value: true });
	protocol_configuration.ConfigurationRequest = void 0;
	const messages_1 = requireMessages();
	//---- Get Configuration request ----
	/**
	 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
	 * configuration setting.
	 *
	 * This pull model replaces the old push model were the client signaled configuration change via an
	 * event. If the server still needs to react to configuration changes (since the server caches the
	 * result of `workspace/configuration` requests) the server should register for an empty configuration
	 * change event and empty the cache if such an event is received.
	 */
	var ConfigurationRequest;
	(function (ConfigurationRequest) {
	    ConfigurationRequest.method = 'workspace/configuration';
	    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
	})(ConfigurationRequest || (protocol_configuration.ConfigurationRequest = ConfigurationRequest = {}));
	return protocol_configuration;
}

var protocol_colorProvider = {};

var hasRequiredProtocol_colorProvider;

function requireProtocol_colorProvider () {
	if (hasRequiredProtocol_colorProvider) return protocol_colorProvider;
	hasRequiredProtocol_colorProvider = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_colorProvider, "__esModule", { value: true });
	protocol_colorProvider.ColorPresentationRequest = protocol_colorProvider.DocumentColorRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to list all color symbols found in a given text document. The request's
	 * parameter is of type {@link DocumentColorParams} the
	 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	 * that resolves to such.
	 */
	var DocumentColorRequest;
	(function (DocumentColorRequest) {
	    DocumentColorRequest.method = 'textDocument/documentColor';
	    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
	})(DocumentColorRequest || (protocol_colorProvider.DocumentColorRequest = DocumentColorRequest = {}));
	/**
	 * A request to list all presentation for a color. The request's
	 * parameter is of type {@link ColorPresentationParams} the
	 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	 * that resolves to such.
	 */
	var ColorPresentationRequest;
	(function (ColorPresentationRequest) {
	    ColorPresentationRequest.method = 'textDocument/colorPresentation';
	    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
	})(ColorPresentationRequest || (protocol_colorProvider.ColorPresentationRequest = ColorPresentationRequest = {}));
	return protocol_colorProvider;
}

var protocol_foldingRange = {};

var hasRequiredProtocol_foldingRange;

function requireProtocol_foldingRange () {
	if (hasRequiredProtocol_foldingRange) return protocol_foldingRange;
	hasRequiredProtocol_foldingRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_foldingRange, "__esModule", { value: true });
	protocol_foldingRange.FoldingRangeRefreshRequest = protocol_foldingRange.FoldingRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide folding ranges in a document. The request's
	 * parameter is of type {@link FoldingRangeParams}, the
	 * response is of type {@link FoldingRangeList} or a Thenable
	 * that resolves to such.
	 */
	var FoldingRangeRequest;
	(function (FoldingRangeRequest) {
	    FoldingRangeRequest.method = 'textDocument/foldingRange';
	    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
	})(FoldingRangeRequest || (protocol_foldingRange.FoldingRangeRequest = FoldingRangeRequest = {}));
	/**
	 * @since 3.18.0
	 * @proposed
	 */
	var FoldingRangeRefreshRequest;
	(function (FoldingRangeRefreshRequest) {
	    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
	    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
	})(FoldingRangeRefreshRequest || (protocol_foldingRange.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
	return protocol_foldingRange;
}

var protocol_declaration = {};

var hasRequiredProtocol_declaration;

function requireProtocol_declaration () {
	if (hasRequiredProtocol_declaration) return protocol_declaration;
	hasRequiredProtocol_declaration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_declaration, "__esModule", { value: true });
	protocol_declaration.DeclarationRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to resolve the type definition locations of a symbol at a given text
	 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
	 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
	 * or a Thenable that resolves to such.
	 */
	var DeclarationRequest;
	(function (DeclarationRequest) {
	    DeclarationRequest.method = 'textDocument/declaration';
	    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
	})(DeclarationRequest || (protocol_declaration.DeclarationRequest = DeclarationRequest = {}));
	return protocol_declaration;
}

var protocol_selectionRange = {};

var hasRequiredProtocol_selectionRange;

function requireProtocol_selectionRange () {
	if (hasRequiredProtocol_selectionRange) return protocol_selectionRange;
	hasRequiredProtocol_selectionRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_selectionRange, "__esModule", { value: true });
	protocol_selectionRange.SelectionRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide selection ranges in a document. The request's
	 * parameter is of type {@link SelectionRangeParams}, the
	 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
	 * that resolves to such.
	 */
	var SelectionRangeRequest;
	(function (SelectionRangeRequest) {
	    SelectionRangeRequest.method = 'textDocument/selectionRange';
	    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
	})(SelectionRangeRequest || (protocol_selectionRange.SelectionRangeRequest = SelectionRangeRequest = {}));
	return protocol_selectionRange;
}

var protocol_progress = {};

var hasRequiredProtocol_progress;

function requireProtocol_progress () {
	if (hasRequiredProtocol_progress) return protocol_progress;
	hasRequiredProtocol_progress = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_progress, "__esModule", { value: true });
	protocol_progress.WorkDoneProgressCancelNotification = protocol_progress.WorkDoneProgressCreateRequest = protocol_progress.WorkDoneProgress = void 0;
	const vscode_jsonrpc_1 = requireMain$5();
	const messages_1 = requireMessages();
	var WorkDoneProgress;
	(function (WorkDoneProgress) {
	    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
	    function is(value) {
	        return value === WorkDoneProgress.type;
	    }
	    WorkDoneProgress.is = is;
	})(WorkDoneProgress || (protocol_progress.WorkDoneProgress = WorkDoneProgress = {}));
	/**
	 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
	 * reporting from the server.
	 */
	var WorkDoneProgressCreateRequest;
	(function (WorkDoneProgressCreateRequest) {
	    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
	    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
	})(WorkDoneProgressCreateRequest || (protocol_progress.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
	/**
	 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
	 * initiated on the server side.
	 */
	var WorkDoneProgressCancelNotification;
	(function (WorkDoneProgressCancelNotification) {
	    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
	    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
	})(WorkDoneProgressCancelNotification || (protocol_progress.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
	return protocol_progress;
}

var protocol_callHierarchy = {};

var hasRequiredProtocol_callHierarchy;

function requireProtocol_callHierarchy () {
	if (hasRequiredProtocol_callHierarchy) return protocol_callHierarchy;
	hasRequiredProtocol_callHierarchy = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_callHierarchy, "__esModule", { value: true });
	protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = protocol_callHierarchy.CallHierarchyIncomingCallsRequest = protocol_callHierarchy.CallHierarchyPrepareRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to result a `CallHierarchyItem` in a document at a given position.
	 * Can be used as an input to an incoming or outgoing call hierarchy.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyPrepareRequest;
	(function (CallHierarchyPrepareRequest) {
	    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
	    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
	})(CallHierarchyPrepareRequest || (protocol_callHierarchy.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
	/**
	 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyIncomingCallsRequest;
	(function (CallHierarchyIncomingCallsRequest) {
	    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
	    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
	})(CallHierarchyIncomingCallsRequest || (protocol_callHierarchy.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
	/**
	 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
	 *
	 * @since 3.16.0
	 */
	var CallHierarchyOutgoingCallsRequest;
	(function (CallHierarchyOutgoingCallsRequest) {
	    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
	    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
	})(CallHierarchyOutgoingCallsRequest || (protocol_callHierarchy.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
	return protocol_callHierarchy;
}

var protocol_semanticTokens = {};

var hasRequiredProtocol_semanticTokens;

function requireProtocol_semanticTokens () {
	if (hasRequiredProtocol_semanticTokens) return protocol_semanticTokens;
	hasRequiredProtocol_semanticTokens = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_semanticTokens, "__esModule", { value: true });
	protocol_semanticTokens.SemanticTokensRefreshRequest = protocol_semanticTokens.SemanticTokensRangeRequest = protocol_semanticTokens.SemanticTokensDeltaRequest = protocol_semanticTokens.SemanticTokensRequest = protocol_semanticTokens.SemanticTokensRegistrationType = protocol_semanticTokens.TokenFormat = void 0;
	const messages_1 = requireMessages();
	//------- 'textDocument/semanticTokens' -----
	var TokenFormat;
	(function (TokenFormat) {
	    TokenFormat.Relative = 'relative';
	})(TokenFormat || (protocol_semanticTokens.TokenFormat = TokenFormat = {}));
	var SemanticTokensRegistrationType;
	(function (SemanticTokensRegistrationType) {
	    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
	    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
	})(SemanticTokensRegistrationType || (protocol_semanticTokens.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRequest;
	(function (SemanticTokensRequest) {
	    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
	    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
	    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensRequest || (protocol_semanticTokens.SemanticTokensRequest = SemanticTokensRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensDeltaRequest;
	(function (SemanticTokensDeltaRequest) {
	    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
	    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
	    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensDeltaRequest || (protocol_semanticTokens.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRangeRequest;
	(function (SemanticTokensRangeRequest) {
	    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
	    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
	    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
	})(SemanticTokensRangeRequest || (protocol_semanticTokens.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
	/**
	 * @since 3.16.0
	 */
	var SemanticTokensRefreshRequest;
	(function (SemanticTokensRefreshRequest) {
	    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
	    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
	})(SemanticTokensRefreshRequest || (protocol_semanticTokens.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
	return protocol_semanticTokens;
}

var protocol_showDocument = {};

var hasRequiredProtocol_showDocument;

function requireProtocol_showDocument () {
	if (hasRequiredProtocol_showDocument) return protocol_showDocument;
	hasRequiredProtocol_showDocument = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_showDocument, "__esModule", { value: true });
	protocol_showDocument.ShowDocumentRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to show a document. This request might open an
	 * external program depending on the value of the URI to open.
	 * For example a request to open `https://code.visualstudio.com/`
	 * will very likely open the URI in a WEB browser.
	 *
	 * @since 3.16.0
	*/
	var ShowDocumentRequest;
	(function (ShowDocumentRequest) {
	    ShowDocumentRequest.method = 'window/showDocument';
	    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
	})(ShowDocumentRequest || (protocol_showDocument.ShowDocumentRequest = ShowDocumentRequest = {}));
	return protocol_showDocument;
}

var protocol_linkedEditingRange = {};

var hasRequiredProtocol_linkedEditingRange;

function requireProtocol_linkedEditingRange () {
	if (hasRequiredProtocol_linkedEditingRange) return protocol_linkedEditingRange;
	hasRequiredProtocol_linkedEditingRange = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_linkedEditingRange, "__esModule", { value: true });
	protocol_linkedEditingRange.LinkedEditingRangeRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide ranges that can be edited together.
	 *
	 * @since 3.16.0
	 */
	var LinkedEditingRangeRequest;
	(function (LinkedEditingRangeRequest) {
	    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
	    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
	})(LinkedEditingRangeRequest || (protocol_linkedEditingRange.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
	return protocol_linkedEditingRange;
}

var protocol_fileOperations = {};

var hasRequiredProtocol_fileOperations;

function requireProtocol_fileOperations () {
	if (hasRequiredProtocol_fileOperations) return protocol_fileOperations;
	hasRequiredProtocol_fileOperations = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_fileOperations, "__esModule", { value: true });
	protocol_fileOperations.WillDeleteFilesRequest = protocol_fileOperations.DidDeleteFilesNotification = protocol_fileOperations.DidRenameFilesNotification = protocol_fileOperations.WillRenameFilesRequest = protocol_fileOperations.DidCreateFilesNotification = protocol_fileOperations.WillCreateFilesRequest = protocol_fileOperations.FileOperationPatternKind = void 0;
	const messages_1 = requireMessages();
	/**
	 * A pattern kind describing if a glob pattern matches a file a folder or
	 * both.
	 *
	 * @since 3.16.0
	 */
	var FileOperationPatternKind;
	(function (FileOperationPatternKind) {
	    /**
	     * The pattern matches a file only.
	     */
	    FileOperationPatternKind.file = 'file';
	    /**
	     * The pattern matches a folder only.
	     */
	    FileOperationPatternKind.folder = 'folder';
	})(FileOperationPatternKind || (protocol_fileOperations.FileOperationPatternKind = FileOperationPatternKind = {}));
	/**
	 * The will create files request is sent from the client to the server before files are actually
	 * created as long as the creation is triggered from within the client.
	 *
	 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
	 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
	 * to be created.
	 *
	 * @since 3.16.0
	 */
	var WillCreateFilesRequest;
	(function (WillCreateFilesRequest) {
	    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
	    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
	})(WillCreateFilesRequest || (protocol_fileOperations.WillCreateFilesRequest = WillCreateFilesRequest = {}));
	/**
	 * The did create files notification is sent from the client to the server when
	 * files were created from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidCreateFilesNotification;
	(function (DidCreateFilesNotification) {
	    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
	    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
	})(DidCreateFilesNotification || (protocol_fileOperations.DidCreateFilesNotification = DidCreateFilesNotification = {}));
	/**
	 * The will rename files request is sent from the client to the server before files are actually
	 * renamed as long as the rename is triggered from within the client.
	 *
	 * @since 3.16.0
	 */
	var WillRenameFilesRequest;
	(function (WillRenameFilesRequest) {
	    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
	    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
	})(WillRenameFilesRequest || (protocol_fileOperations.WillRenameFilesRequest = WillRenameFilesRequest = {}));
	/**
	 * The did rename files notification is sent from the client to the server when
	 * files were renamed from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidRenameFilesNotification;
	(function (DidRenameFilesNotification) {
	    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
	    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
	})(DidRenameFilesNotification || (protocol_fileOperations.DidRenameFilesNotification = DidRenameFilesNotification = {}));
	/**
	 * The will delete files request is sent from the client to the server before files are actually
	 * deleted as long as the deletion is triggered from within the client.
	 *
	 * @since 3.16.0
	 */
	var DidDeleteFilesNotification;
	(function (DidDeleteFilesNotification) {
	    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
	    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
	})(DidDeleteFilesNotification || (protocol_fileOperations.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
	/**
	 * The did delete files notification is sent from the client to the server when
	 * files were deleted from within the client.
	 *
	 * @since 3.16.0
	 */
	var WillDeleteFilesRequest;
	(function (WillDeleteFilesRequest) {
	    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
	    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
	})(WillDeleteFilesRequest || (protocol_fileOperations.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
	return protocol_fileOperations;
}

var protocol_moniker = {};

var hasRequiredProtocol_moniker;

function requireProtocol_moniker () {
	if (hasRequiredProtocol_moniker) return protocol_moniker;
	hasRequiredProtocol_moniker = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_moniker, "__esModule", { value: true });
	protocol_moniker.MonikerRequest = protocol_moniker.MonikerKind = protocol_moniker.UniquenessLevel = void 0;
	const messages_1 = requireMessages();
	/**
	 * Moniker uniqueness level to define scope of the moniker.
	 *
	 * @since 3.16.0
	 */
	var UniquenessLevel;
	(function (UniquenessLevel) {
	    /**
	     * The moniker is only unique inside a document
	     */
	    UniquenessLevel.document = 'document';
	    /**
	     * The moniker is unique inside a project for which a dump got created
	     */
	    UniquenessLevel.project = 'project';
	    /**
	     * The moniker is unique inside the group to which a project belongs
	     */
	    UniquenessLevel.group = 'group';
	    /**
	     * The moniker is unique inside the moniker scheme.
	     */
	    UniquenessLevel.scheme = 'scheme';
	    /**
	     * The moniker is globally unique
	     */
	    UniquenessLevel.global = 'global';
	})(UniquenessLevel || (protocol_moniker.UniquenessLevel = UniquenessLevel = {}));
	/**
	 * The moniker kind.
	 *
	 * @since 3.16.0
	 */
	var MonikerKind;
	(function (MonikerKind) {
	    /**
	     * The moniker represent a symbol that is imported into a project
	     */
	    MonikerKind.$import = 'import';
	    /**
	     * The moniker represents a symbol that is exported from a project
	     */
	    MonikerKind.$export = 'export';
	    /**
	     * The moniker represents a symbol that is local to a project (e.g. a local
	     * variable of a function, a class not visible outside the project, ...)
	     */
	    MonikerKind.local = 'local';
	})(MonikerKind || (protocol_moniker.MonikerKind = MonikerKind = {}));
	/**
	 * A request to get the moniker of a symbol at a given text document position.
	 * The request parameter is of type {@link TextDocumentPositionParams}.
	 * The response is of type {@link Moniker Moniker[]} or `null`.
	 */
	var MonikerRequest;
	(function (MonikerRequest) {
	    MonikerRequest.method = 'textDocument/moniker';
	    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
	})(MonikerRequest || (protocol_moniker.MonikerRequest = MonikerRequest = {}));
	return protocol_moniker;
}

var protocol_typeHierarchy = {};

var hasRequiredProtocol_typeHierarchy;

function requireProtocol_typeHierarchy () {
	if (hasRequiredProtocol_typeHierarchy) return protocol_typeHierarchy;
	hasRequiredProtocol_typeHierarchy = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_typeHierarchy, "__esModule", { value: true });
	protocol_typeHierarchy.TypeHierarchySubtypesRequest = protocol_typeHierarchy.TypeHierarchySupertypesRequest = protocol_typeHierarchy.TypeHierarchyPrepareRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to result a `TypeHierarchyItem` in a document at a given position.
	 * Can be used as an input to a subtypes or supertypes type hierarchy.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchyPrepareRequest;
	(function (TypeHierarchyPrepareRequest) {
	    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
	    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
	})(TypeHierarchyPrepareRequest || (protocol_typeHierarchy.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
	/**
	 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchySupertypesRequest;
	(function (TypeHierarchySupertypesRequest) {
	    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
	    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
	})(TypeHierarchySupertypesRequest || (protocol_typeHierarchy.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
	/**
	 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
	 *
	 * @since 3.17.0
	 */
	var TypeHierarchySubtypesRequest;
	(function (TypeHierarchySubtypesRequest) {
	    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
	    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
	})(TypeHierarchySubtypesRequest || (protocol_typeHierarchy.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
	return protocol_typeHierarchy;
}

var protocol_inlineValue = {};

var hasRequiredProtocol_inlineValue;

function requireProtocol_inlineValue () {
	if (hasRequiredProtocol_inlineValue) return protocol_inlineValue;
	hasRequiredProtocol_inlineValue = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlineValue, "__esModule", { value: true });
	protocol_inlineValue.InlineValueRefreshRequest = protocol_inlineValue.InlineValueRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inline values in a document. The request's parameter is of
	 * type {@link InlineValueParams}, the response is of type
	 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlineValueRequest;
	(function (InlineValueRequest) {
	    InlineValueRequest.method = 'textDocument/inlineValue';
	    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
	})(InlineValueRequest || (protocol_inlineValue.InlineValueRequest = InlineValueRequest = {}));
	/**
	 * @since 3.17.0
	 */
	var InlineValueRefreshRequest;
	(function (InlineValueRefreshRequest) {
	    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
	    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
	})(InlineValueRefreshRequest || (protocol_inlineValue.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
	return protocol_inlineValue;
}

var protocol_inlayHint = {};

var hasRequiredProtocol_inlayHint;

function requireProtocol_inlayHint () {
	if (hasRequiredProtocol_inlayHint) return protocol_inlayHint;
	hasRequiredProtocol_inlayHint = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlayHint, "__esModule", { value: true });
	protocol_inlayHint.InlayHintRefreshRequest = protocol_inlayHint.InlayHintResolveRequest = protocol_inlayHint.InlayHintRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inlay hints in a document. The request's parameter is of
	 * type {@link InlayHintsParams}, the response is of type
	 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlayHintRequest;
	(function (InlayHintRequest) {
	    InlayHintRequest.method = 'textDocument/inlayHint';
	    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
	})(InlayHintRequest || (protocol_inlayHint.InlayHintRequest = InlayHintRequest = {}));
	/**
	 * A request to resolve additional properties for an inlay hint.
	 * The request's parameter is of type {@link InlayHint}, the response is
	 * of type {@link InlayHint} or a Thenable that resolves to such.
	 *
	 * @since 3.17.0
	 */
	var InlayHintResolveRequest;
	(function (InlayHintResolveRequest) {
	    InlayHintResolveRequest.method = 'inlayHint/resolve';
	    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
	})(InlayHintResolveRequest || (protocol_inlayHint.InlayHintResolveRequest = InlayHintResolveRequest = {}));
	/**
	 * @since 3.17.0
	 */
	var InlayHintRefreshRequest;
	(function (InlayHintRefreshRequest) {
	    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
	    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
	})(InlayHintRefreshRequest || (protocol_inlayHint.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
	return protocol_inlayHint;
}

var protocol_diagnostic = {};

var hasRequiredProtocol_diagnostic;

function requireProtocol_diagnostic () {
	if (hasRequiredProtocol_diagnostic) return protocol_diagnostic;
	hasRequiredProtocol_diagnostic = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_diagnostic, "__esModule", { value: true });
	protocol_diagnostic.DiagnosticRefreshRequest = protocol_diagnostic.WorkspaceDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticRequest = protocol_diagnostic.DocumentDiagnosticReportKind = protocol_diagnostic.DiagnosticServerCancellationData = void 0;
	const vscode_jsonrpc_1 = requireMain$5();
	const Is = requireIs();
	const messages_1 = requireMessages();
	/**
	 * @since 3.17.0
	 */
	var DiagnosticServerCancellationData;
	(function (DiagnosticServerCancellationData) {
	    function is(value) {
	        const candidate = value;
	        return candidate && Is.boolean(candidate.retriggerRequest);
	    }
	    DiagnosticServerCancellationData.is = is;
	})(DiagnosticServerCancellationData || (protocol_diagnostic.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
	/**
	 * The document diagnostic report kinds.
	 *
	 * @since 3.17.0
	 */
	var DocumentDiagnosticReportKind;
	(function (DocumentDiagnosticReportKind) {
	    /**
	     * A diagnostic report with a full
	     * set of problems.
	     */
	    DocumentDiagnosticReportKind.Full = 'full';
	    /**
	     * A report indicating that the last
	     * returned report is still accurate.
	     */
	    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
	})(DocumentDiagnosticReportKind || (protocol_diagnostic.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
	/**
	 * The document diagnostic request definition.
	 *
	 * @since 3.17.0
	 */
	var DocumentDiagnosticRequest;
	(function (DocumentDiagnosticRequest) {
	    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
	    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
	    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
	})(DocumentDiagnosticRequest || (protocol_diagnostic.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
	/**
	 * The workspace diagnostic request definition.
	 *
	 * @since 3.17.0
	 */
	var WorkspaceDiagnosticRequest;
	(function (WorkspaceDiagnosticRequest) {
	    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
	    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
	    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
	})(WorkspaceDiagnosticRequest || (protocol_diagnostic.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
	/**
	 * The diagnostic refresh request definition.
	 *
	 * @since 3.17.0
	 */
	var DiagnosticRefreshRequest;
	(function (DiagnosticRefreshRequest) {
	    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
	    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
	    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
	})(DiagnosticRefreshRequest || (protocol_diagnostic.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
	return protocol_diagnostic;
}

var protocol_notebook = {};

var hasRequiredProtocol_notebook;

function requireProtocol_notebook () {
	if (hasRequiredProtocol_notebook) return protocol_notebook;
	hasRequiredProtocol_notebook = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(protocol_notebook, "__esModule", { value: true });
	protocol_notebook.DidCloseNotebookDocumentNotification = protocol_notebook.DidSaveNotebookDocumentNotification = protocol_notebook.DidChangeNotebookDocumentNotification = protocol_notebook.NotebookCellArrayChange = protocol_notebook.DidOpenNotebookDocumentNotification = protocol_notebook.NotebookDocumentSyncRegistrationType = protocol_notebook.NotebookDocument = protocol_notebook.NotebookCell = protocol_notebook.ExecutionSummary = protocol_notebook.NotebookCellKind = void 0;
	const vscode_languageserver_types_1 = requireMain$4();
	const Is = requireIs();
	const messages_1 = requireMessages();
	/**
	 * A notebook cell kind.
	 *
	 * @since 3.17.0
	 */
	var NotebookCellKind;
	(function (NotebookCellKind) {
	    /**
	     * A markup-cell is formatted source that is used for display.
	     */
	    NotebookCellKind.Markup = 1;
	    /**
	     * A code-cell is source code.
	     */
	    NotebookCellKind.Code = 2;
	    function is(value) {
	        return value === 1 || value === 2;
	    }
	    NotebookCellKind.is = is;
	})(NotebookCellKind || (protocol_notebook.NotebookCellKind = NotebookCellKind = {}));
	var ExecutionSummary;
	(function (ExecutionSummary) {
	    function create(executionOrder, success) {
	        const result = { executionOrder };
	        if (success === true || success === false) {
	            result.success = success;
	        }
	        return result;
	    }
	    ExecutionSummary.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
	    }
	    ExecutionSummary.is = is;
	    function equals(one, other) {
	        if (one === other) {
	            return true;
	        }
	        if (one === null || one === undefined || other === null || other === undefined) {
	            return false;
	        }
	        return one.executionOrder === other.executionOrder && one.success === other.success;
	    }
	    ExecutionSummary.equals = equals;
	})(ExecutionSummary || (protocol_notebook.ExecutionSummary = ExecutionSummary = {}));
	var NotebookCell;
	(function (NotebookCell) {
	    function create(kind, document) {
	        return { kind, document };
	    }
	    NotebookCell.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
	            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
	    }
	    NotebookCell.is = is;
	    function diff(one, two) {
	        const result = new Set();
	        if (one.document !== two.document) {
	            result.add('document');
	        }
	        if (one.kind !== two.kind) {
	            result.add('kind');
	        }
	        if (one.executionSummary !== two.executionSummary) {
	            result.add('executionSummary');
	        }
	        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
	            result.add('metadata');
	        }
	        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
	            result.add('executionSummary');
	        }
	        return result;
	    }
	    NotebookCell.diff = diff;
	    function equalsMetadata(one, other) {
	        if (one === other) {
	            return true;
	        }
	        if (one === null || one === undefined || other === null || other === undefined) {
	            return false;
	        }
	        if (typeof one !== typeof other) {
	            return false;
	        }
	        if (typeof one !== 'object') {
	            return false;
	        }
	        const oneArray = Array.isArray(one);
	        const otherArray = Array.isArray(other);
	        if (oneArray !== otherArray) {
	            return false;
	        }
	        if (oneArray && otherArray) {
	            if (one.length !== other.length) {
	                return false;
	            }
	            for (let i = 0; i < one.length; i++) {
	                if (!equalsMetadata(one[i], other[i])) {
	                    return false;
	                }
	            }
	        }
	        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
	            const oneKeys = Object.keys(one);
	            const otherKeys = Object.keys(other);
	            if (oneKeys.length !== otherKeys.length) {
	                return false;
	            }
	            oneKeys.sort();
	            otherKeys.sort();
	            if (!equalsMetadata(oneKeys, otherKeys)) {
	                return false;
	            }
	            for (let i = 0; i < oneKeys.length; i++) {
	                const prop = oneKeys[i];
	                if (!equalsMetadata(one[prop], other[prop])) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	})(NotebookCell || (protocol_notebook.NotebookCell = NotebookCell = {}));
	var NotebookDocument;
	(function (NotebookDocument) {
	    function create(uri, notebookType, version, cells) {
	        return { uri, notebookType, version, cells };
	    }
	    NotebookDocument.create = create;
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
	    }
	    NotebookDocument.is = is;
	})(NotebookDocument || (protocol_notebook.NotebookDocument = NotebookDocument = {}));
	var NotebookDocumentSyncRegistrationType;
	(function (NotebookDocumentSyncRegistrationType) {
	    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
	    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
	    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
	})(NotebookDocumentSyncRegistrationType || (protocol_notebook.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
	/**
	 * A notification sent when a notebook opens.
	 *
	 * @since 3.17.0
	 */
	var DidOpenNotebookDocumentNotification;
	(function (DidOpenNotebookDocumentNotification) {
	    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
	    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
	    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidOpenNotebookDocumentNotification || (protocol_notebook.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
	var NotebookCellArrayChange;
	(function (NotebookCellArrayChange) {
	    function is(value) {
	        const candidate = value;
	        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
	    }
	    NotebookCellArrayChange.is = is;
	    function create(start, deleteCount, cells) {
	        const result = { start, deleteCount };
	        if (cells !== undefined) {
	            result.cells = cells;
	        }
	        return result;
	    }
	    NotebookCellArrayChange.create = create;
	})(NotebookCellArrayChange || (protocol_notebook.NotebookCellArrayChange = NotebookCellArrayChange = {}));
	var DidChangeNotebookDocumentNotification;
	(function (DidChangeNotebookDocumentNotification) {
	    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
	    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
	    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidChangeNotebookDocumentNotification || (protocol_notebook.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
	/**
	 * A notification sent when a notebook document is saved.
	 *
	 * @since 3.17.0
	 */
	var DidSaveNotebookDocumentNotification;
	(function (DidSaveNotebookDocumentNotification) {
	    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
	    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
	    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidSaveNotebookDocumentNotification || (protocol_notebook.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
	/**
	 * A notification sent when a notebook closes.
	 *
	 * @since 3.17.0
	 */
	var DidCloseNotebookDocumentNotification;
	(function (DidCloseNotebookDocumentNotification) {
	    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
	    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
	    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
	    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
	})(DidCloseNotebookDocumentNotification || (protocol_notebook.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
	return protocol_notebook;
}

var protocol_inlineCompletion = {};

var hasRequiredProtocol_inlineCompletion;

function requireProtocol_inlineCompletion () {
	if (hasRequiredProtocol_inlineCompletion) return protocol_inlineCompletion;
	hasRequiredProtocol_inlineCompletion = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(protocol_inlineCompletion, "__esModule", { value: true });
	protocol_inlineCompletion.InlineCompletionRequest = void 0;
	const messages_1 = requireMessages();
	/**
	 * A request to provide inline completions in a document. The request's parameter is of
	 * type {@link InlineCompletionParams}, the response is of type
	 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
	 *
	 * @since 3.18.0
	 * @proposed
	 */
	var InlineCompletionRequest;
	(function (InlineCompletionRequest) {
	    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
	    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
	    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
	})(InlineCompletionRequest || (protocol_inlineCompletion.InlineCompletionRequest = InlineCompletionRequest = {}));
	return protocol_inlineCompletion;
}

var hasRequiredProtocol$1;

function requireProtocol$1 () {
	if (hasRequiredProtocol$1) return protocol$1;
	hasRequiredProtocol$1 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.WorkspaceSymbolRequest = exports$1.CodeActionResolveRequest = exports$1.CodeActionRequest = exports$1.DocumentSymbolRequest = exports$1.DocumentHighlightRequest = exports$1.ReferencesRequest = exports$1.DefinitionRequest = exports$1.SignatureHelpRequest = exports$1.SignatureHelpTriggerKind = exports$1.HoverRequest = exports$1.CompletionResolveRequest = exports$1.CompletionRequest = exports$1.CompletionTriggerKind = exports$1.PublishDiagnosticsNotification = exports$1.WatchKind = exports$1.RelativePattern = exports$1.FileChangeType = exports$1.DidChangeWatchedFilesNotification = exports$1.WillSaveTextDocumentWaitUntilRequest = exports$1.WillSaveTextDocumentNotification = exports$1.TextDocumentSaveReason = exports$1.DidSaveTextDocumentNotification = exports$1.DidCloseTextDocumentNotification = exports$1.DidChangeTextDocumentNotification = exports$1.TextDocumentContentChangeEvent = exports$1.DidOpenTextDocumentNotification = exports$1.TextDocumentSyncKind = exports$1.TelemetryEventNotification = exports$1.LogMessageNotification = exports$1.ShowMessageRequest = exports$1.ShowMessageNotification = exports$1.MessageType = exports$1.DidChangeConfigurationNotification = exports$1.ExitNotification = exports$1.ShutdownRequest = exports$1.InitializedNotification = exports$1.InitializeErrorCodes = exports$1.InitializeRequest = exports$1.WorkDoneProgressOptions = exports$1.TextDocumentRegistrationOptions = exports$1.StaticRegistrationOptions = exports$1.PositionEncodingKind = exports$1.FailureHandlingKind = exports$1.ResourceOperationKind = exports$1.UnregistrationRequest = exports$1.RegistrationRequest = exports$1.DocumentSelector = exports$1.NotebookCellTextDocumentFilter = exports$1.NotebookDocumentFilter = exports$1.TextDocumentFilter = void 0;
		exports$1.MonikerRequest = exports$1.MonikerKind = exports$1.UniquenessLevel = exports$1.WillDeleteFilesRequest = exports$1.DidDeleteFilesNotification = exports$1.WillRenameFilesRequest = exports$1.DidRenameFilesNotification = exports$1.WillCreateFilesRequest = exports$1.DidCreateFilesNotification = exports$1.FileOperationPatternKind = exports$1.LinkedEditingRangeRequest = exports$1.ShowDocumentRequest = exports$1.SemanticTokensRegistrationType = exports$1.SemanticTokensRefreshRequest = exports$1.SemanticTokensRangeRequest = exports$1.SemanticTokensDeltaRequest = exports$1.SemanticTokensRequest = exports$1.TokenFormat = exports$1.CallHierarchyPrepareRequest = exports$1.CallHierarchyOutgoingCallsRequest = exports$1.CallHierarchyIncomingCallsRequest = exports$1.WorkDoneProgressCancelNotification = exports$1.WorkDoneProgressCreateRequest = exports$1.WorkDoneProgress = exports$1.SelectionRangeRequest = exports$1.DeclarationRequest = exports$1.FoldingRangeRefreshRequest = exports$1.FoldingRangeRequest = exports$1.ColorPresentationRequest = exports$1.DocumentColorRequest = exports$1.ConfigurationRequest = exports$1.DidChangeWorkspaceFoldersNotification = exports$1.WorkspaceFoldersRequest = exports$1.TypeDefinitionRequest = exports$1.ImplementationRequest = exports$1.ApplyWorkspaceEditRequest = exports$1.ExecuteCommandRequest = exports$1.PrepareRenameRequest = exports$1.RenameRequest = exports$1.PrepareSupportDefaultBehavior = exports$1.DocumentOnTypeFormattingRequest = exports$1.DocumentRangesFormattingRequest = exports$1.DocumentRangeFormattingRequest = exports$1.DocumentFormattingRequest = exports$1.DocumentLinkResolveRequest = exports$1.DocumentLinkRequest = exports$1.CodeLensRefreshRequest = exports$1.CodeLensResolveRequest = exports$1.CodeLensRequest = exports$1.WorkspaceSymbolResolveRequest = void 0;
		exports$1.InlineCompletionRequest = exports$1.DidCloseNotebookDocumentNotification = exports$1.DidSaveNotebookDocumentNotification = exports$1.DidChangeNotebookDocumentNotification = exports$1.NotebookCellArrayChange = exports$1.DidOpenNotebookDocumentNotification = exports$1.NotebookDocumentSyncRegistrationType = exports$1.NotebookDocument = exports$1.NotebookCell = exports$1.ExecutionSummary = exports$1.NotebookCellKind = exports$1.DiagnosticRefreshRequest = exports$1.WorkspaceDiagnosticRequest = exports$1.DocumentDiagnosticRequest = exports$1.DocumentDiagnosticReportKind = exports$1.DiagnosticServerCancellationData = exports$1.InlayHintRefreshRequest = exports$1.InlayHintResolveRequest = exports$1.InlayHintRequest = exports$1.InlineValueRefreshRequest = exports$1.InlineValueRequest = exports$1.TypeHierarchySupertypesRequest = exports$1.TypeHierarchySubtypesRequest = exports$1.TypeHierarchyPrepareRequest = void 0;
		const messages_1 = requireMessages();
		const vscode_languageserver_types_1 = requireMain$4();
		const Is = requireIs();
		const protocol_implementation_1 = requireProtocol_implementation();
		Object.defineProperty(exports$1, "ImplementationRequest", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });
		const protocol_typeDefinition_1 = requireProtocol_typeDefinition();
		Object.defineProperty(exports$1, "TypeDefinitionRequest", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });
		const protocol_workspaceFolder_1 = requireProtocol_workspaceFolder();
		Object.defineProperty(exports$1, "WorkspaceFoldersRequest", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });
		Object.defineProperty(exports$1, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });
		const protocol_configuration_1 = requireProtocol_configuration();
		Object.defineProperty(exports$1, "ConfigurationRequest", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });
		const protocol_colorProvider_1 = requireProtocol_colorProvider();
		Object.defineProperty(exports$1, "DocumentColorRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });
		Object.defineProperty(exports$1, "ColorPresentationRequest", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });
		const protocol_foldingRange_1 = requireProtocol_foldingRange();
		Object.defineProperty(exports$1, "FoldingRangeRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });
		Object.defineProperty(exports$1, "FoldingRangeRefreshRequest", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } });
		const protocol_declaration_1 = requireProtocol_declaration();
		Object.defineProperty(exports$1, "DeclarationRequest", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });
		const protocol_selectionRange_1 = requireProtocol_selectionRange();
		Object.defineProperty(exports$1, "SelectionRangeRequest", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });
		const protocol_progress_1 = requireProtocol_progress();
		Object.defineProperty(exports$1, "WorkDoneProgress", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });
		Object.defineProperty(exports$1, "WorkDoneProgressCreateRequest", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });
		Object.defineProperty(exports$1, "WorkDoneProgressCancelNotification", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });
		const protocol_callHierarchy_1 = requireProtocol_callHierarchy();
		Object.defineProperty(exports$1, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });
		Object.defineProperty(exports$1, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });
		Object.defineProperty(exports$1, "CallHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });
		const protocol_semanticTokens_1 = requireProtocol_semanticTokens();
		Object.defineProperty(exports$1, "TokenFormat", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });
		Object.defineProperty(exports$1, "SemanticTokensRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });
		Object.defineProperty(exports$1, "SemanticTokensDeltaRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });
		Object.defineProperty(exports$1, "SemanticTokensRangeRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });
		Object.defineProperty(exports$1, "SemanticTokensRefreshRequest", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });
		Object.defineProperty(exports$1, "SemanticTokensRegistrationType", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });
		const protocol_showDocument_1 = requireProtocol_showDocument();
		Object.defineProperty(exports$1, "ShowDocumentRequest", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });
		const protocol_linkedEditingRange_1 = requireProtocol_linkedEditingRange();
		Object.defineProperty(exports$1, "LinkedEditingRangeRequest", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });
		const protocol_fileOperations_1 = requireProtocol_fileOperations();
		Object.defineProperty(exports$1, "FileOperationPatternKind", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });
		Object.defineProperty(exports$1, "DidCreateFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });
		Object.defineProperty(exports$1, "WillCreateFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });
		Object.defineProperty(exports$1, "DidRenameFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });
		Object.defineProperty(exports$1, "WillRenameFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });
		Object.defineProperty(exports$1, "DidDeleteFilesNotification", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });
		Object.defineProperty(exports$1, "WillDeleteFilesRequest", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });
		const protocol_moniker_1 = requireProtocol_moniker();
		Object.defineProperty(exports$1, "UniquenessLevel", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });
		Object.defineProperty(exports$1, "MonikerKind", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });
		Object.defineProperty(exports$1, "MonikerRequest", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });
		const protocol_typeHierarchy_1 = requireProtocol_typeHierarchy();
		Object.defineProperty(exports$1, "TypeHierarchyPrepareRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });
		Object.defineProperty(exports$1, "TypeHierarchySubtypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });
		Object.defineProperty(exports$1, "TypeHierarchySupertypesRequest", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });
		const protocol_inlineValue_1 = requireProtocol_inlineValue();
		Object.defineProperty(exports$1, "InlineValueRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });
		Object.defineProperty(exports$1, "InlineValueRefreshRequest", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });
		const protocol_inlayHint_1 = requireProtocol_inlayHint();
		Object.defineProperty(exports$1, "InlayHintRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });
		Object.defineProperty(exports$1, "InlayHintResolveRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });
		Object.defineProperty(exports$1, "InlayHintRefreshRequest", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });
		const protocol_diagnostic_1 = requireProtocol_diagnostic();
		Object.defineProperty(exports$1, "DiagnosticServerCancellationData", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });
		Object.defineProperty(exports$1, "DocumentDiagnosticReportKind", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });
		Object.defineProperty(exports$1, "DocumentDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });
		Object.defineProperty(exports$1, "WorkspaceDiagnosticRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });
		Object.defineProperty(exports$1, "DiagnosticRefreshRequest", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });
		const protocol_notebook_1 = requireProtocol_notebook();
		Object.defineProperty(exports$1, "NotebookCellKind", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });
		Object.defineProperty(exports$1, "ExecutionSummary", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });
		Object.defineProperty(exports$1, "NotebookCell", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });
		Object.defineProperty(exports$1, "NotebookDocument", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });
		Object.defineProperty(exports$1, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });
		Object.defineProperty(exports$1, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });
		Object.defineProperty(exports$1, "NotebookCellArrayChange", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });
		Object.defineProperty(exports$1, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });
		Object.defineProperty(exports$1, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });
		Object.defineProperty(exports$1, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });
		const protocol_inlineCompletion_1 = requireProtocol_inlineCompletion();
		Object.defineProperty(exports$1, "InlineCompletionRequest", { enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } });
		/**
		 * The TextDocumentFilter namespace provides helper functions to work with
		 * {@link TextDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var TextDocumentFilter;
		(function (TextDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
		    }
		    TextDocumentFilter.is = is;
		})(TextDocumentFilter || (exports$1.TextDocumentFilter = TextDocumentFilter = {}));
		/**
		 * The NotebookDocumentFilter namespace provides helper functions to work with
		 * {@link NotebookDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var NotebookDocumentFilter;
		(function (NotebookDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
		    }
		    NotebookDocumentFilter.is = is;
		})(NotebookDocumentFilter || (exports$1.NotebookDocumentFilter = NotebookDocumentFilter = {}));
		/**
		 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
		 * {@link NotebookCellTextDocumentFilter} literals.
		 *
		 * @since 3.17.0
		 */
		var NotebookCellTextDocumentFilter;
		(function (NotebookCellTextDocumentFilter) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate)
		            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
		            && (candidate.language === undefined || Is.string(candidate.language));
		    }
		    NotebookCellTextDocumentFilter.is = is;
		})(NotebookCellTextDocumentFilter || (exports$1.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
		/**
		 * The DocumentSelector namespace provides helper functions to work with
		 * {@link DocumentSelector}s.
		 */
		var DocumentSelector;
		(function (DocumentSelector) {
		    function is(value) {
		        if (!Array.isArray(value)) {
		            return false;
		        }
		        for (let elem of value) {
		            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
		                return false;
		            }
		        }
		        return true;
		    }
		    DocumentSelector.is = is;
		})(DocumentSelector || (exports$1.DocumentSelector = DocumentSelector = {}));
		/**
		 * The `client/registerCapability` request is sent from the server to the client to register a new capability
		 * handler on the client side.
		 */
		var RegistrationRequest;
		(function (RegistrationRequest) {
		    RegistrationRequest.method = 'client/registerCapability';
		    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
		})(RegistrationRequest || (exports$1.RegistrationRequest = RegistrationRequest = {}));
		/**
		 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
		 * handler on the client side.
		 */
		var UnregistrationRequest;
		(function (UnregistrationRequest) {
		    UnregistrationRequest.method = 'client/unregisterCapability';
		    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
		})(UnregistrationRequest || (exports$1.UnregistrationRequest = UnregistrationRequest = {}));
		var ResourceOperationKind;
		(function (ResourceOperationKind) {
		    /**
		     * Supports creating new files and folders.
		     */
		    ResourceOperationKind.Create = 'create';
		    /**
		     * Supports renaming existing files and folders.
		     */
		    ResourceOperationKind.Rename = 'rename';
		    /**
		     * Supports deleting existing files and folders.
		     */
		    ResourceOperationKind.Delete = 'delete';
		})(ResourceOperationKind || (exports$1.ResourceOperationKind = ResourceOperationKind = {}));
		var FailureHandlingKind;
		(function (FailureHandlingKind) {
		    /**
		     * Applying the workspace change is simply aborted if one of the changes provided
		     * fails. All operations executed before the failing operation stay executed.
		     */
		    FailureHandlingKind.Abort = 'abort';
		    /**
		     * All operations are executed transactional. That means they either all
		     * succeed or no changes at all are applied to the workspace.
		     */
		    FailureHandlingKind.Transactional = 'transactional';
		    /**
		     * If the workspace edit contains only textual file changes they are executed transactional.
		     * If resource changes (create, rename or delete file) are part of the change the failure
		     * handling strategy is abort.
		     */
		    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
		    /**
		     * The client tries to undo the operations already executed. But there is no
		     * guarantee that this is succeeding.
		     */
		    FailureHandlingKind.Undo = 'undo';
		})(FailureHandlingKind || (exports$1.FailureHandlingKind = FailureHandlingKind = {}));
		/**
		 * A set of predefined position encoding kinds.
		 *
		 * @since 3.17.0
		 */
		var PositionEncodingKind;
		(function (PositionEncodingKind) {
		    /**
		     * Character offsets count UTF-8 code units (e.g. bytes).
		     */
		    PositionEncodingKind.UTF8 = 'utf-8';
		    /**
		     * Character offsets count UTF-16 code units.
		     *
		     * This is the default and must always be supported
		     * by servers
		     */
		    PositionEncodingKind.UTF16 = 'utf-16';
		    /**
		     * Character offsets count UTF-32 code units.
		     *
		     * Implementation note: these are the same as Unicode codepoints,
		     * so this `PositionEncodingKind` may also be used for an
		     * encoding-agnostic representation of character offsets.
		     */
		    PositionEncodingKind.UTF32 = 'utf-32';
		})(PositionEncodingKind || (exports$1.PositionEncodingKind = PositionEncodingKind = {}));
		/**
		 * The StaticRegistrationOptions namespace provides helper functions to work with
		 * {@link StaticRegistrationOptions} literals.
		 */
		var StaticRegistrationOptions;
		(function (StaticRegistrationOptions) {
		    function hasId(value) {
		        const candidate = value;
		        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
		    }
		    StaticRegistrationOptions.hasId = hasId;
		})(StaticRegistrationOptions || (exports$1.StaticRegistrationOptions = StaticRegistrationOptions = {}));
		/**
		 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
		 * {@link TextDocumentRegistrationOptions} literals.
		 */
		var TextDocumentRegistrationOptions;
		(function (TextDocumentRegistrationOptions) {
		    function is(value) {
		        const candidate = value;
		        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
		    }
		    TextDocumentRegistrationOptions.is = is;
		})(TextDocumentRegistrationOptions || (exports$1.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
		/**
		 * The WorkDoneProgressOptions namespace provides helper functions to work with
		 * {@link WorkDoneProgressOptions} literals.
		 */
		var WorkDoneProgressOptions;
		(function (WorkDoneProgressOptions) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
		    }
		    WorkDoneProgressOptions.is = is;
		    function hasWorkDoneProgress(value) {
		        const candidate = value;
		        return candidate && Is.boolean(candidate.workDoneProgress);
		    }
		    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
		})(WorkDoneProgressOptions || (exports$1.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
		/**
		 * The initialize request is sent from the client to the server.
		 * It is sent once as the request after starting up the server.
		 * The requests parameter is of type {@link InitializeParams}
		 * the response if of type {@link InitializeResult} of a Thenable that
		 * resolves to such.
		 */
		var InitializeRequest;
		(function (InitializeRequest) {
		    InitializeRequest.method = 'initialize';
		    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
		})(InitializeRequest || (exports$1.InitializeRequest = InitializeRequest = {}));
		/**
		 * Known error codes for an `InitializeErrorCodes`;
		 */
		var InitializeErrorCodes;
		(function (InitializeErrorCodes) {
		    /**
		     * If the protocol version provided by the client can't be handled by the server.
		     *
		     * @deprecated This initialize error got replaced by client capabilities. There is
		     * no version handshake in version 3.0x
		     */
		    InitializeErrorCodes.unknownProtocolVersion = 1;
		})(InitializeErrorCodes || (exports$1.InitializeErrorCodes = InitializeErrorCodes = {}));
		/**
		 * The initialized notification is sent from the client to the
		 * server after the client is fully initialized and the server
		 * is allowed to send requests from the server to the client.
		 */
		var InitializedNotification;
		(function (InitializedNotification) {
		    InitializedNotification.method = 'initialized';
		    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
		})(InitializedNotification || (exports$1.InitializedNotification = InitializedNotification = {}));
		//---- Shutdown Method ----
		/**
		 * A shutdown request is sent from the client to the server.
		 * It is sent once when the client decides to shutdown the
		 * server. The only notification that is sent after a shutdown request
		 * is the exit event.
		 */
		var ShutdownRequest;
		(function (ShutdownRequest) {
		    ShutdownRequest.method = 'shutdown';
		    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
		})(ShutdownRequest || (exports$1.ShutdownRequest = ShutdownRequest = {}));
		//---- Exit Notification ----
		/**
		 * The exit event is sent from the client to the server to
		 * ask the server to exit its process.
		 */
		var ExitNotification;
		(function (ExitNotification) {
		    ExitNotification.method = 'exit';
		    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
		})(ExitNotification || (exports$1.ExitNotification = ExitNotification = {}));
		/**
		 * The configuration change notification is sent from the client to the server
		 * when the client's configuration has changed. The notification contains
		 * the changed configuration as defined by the language client.
		 */
		var DidChangeConfigurationNotification;
		(function (DidChangeConfigurationNotification) {
		    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
		    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
		})(DidChangeConfigurationNotification || (exports$1.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
		//---- Message show and log notifications ----
		/**
		 * The message type
		 */
		var MessageType;
		(function (MessageType) {
		    /**
		     * An error message.
		     */
		    MessageType.Error = 1;
		    /**
		     * A warning message.
		     */
		    MessageType.Warning = 2;
		    /**
		     * An information message.
		     */
		    MessageType.Info = 3;
		    /**
		     * A log message.
		     */
		    MessageType.Log = 4;
		    /**
		     * A debug message.
		     *
		     * @since 3.18.0
		     */
		    MessageType.Debug = 5;
		})(MessageType || (exports$1.MessageType = MessageType = {}));
		/**
		 * The show message notification is sent from a server to a client to ask
		 * the client to display a particular message in the user interface.
		 */
		var ShowMessageNotification;
		(function (ShowMessageNotification) {
		    ShowMessageNotification.method = 'window/showMessage';
		    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
		})(ShowMessageNotification || (exports$1.ShowMessageNotification = ShowMessageNotification = {}));
		/**
		 * The show message request is sent from the server to the client to show a message
		 * and a set of options actions to the user.
		 */
		var ShowMessageRequest;
		(function (ShowMessageRequest) {
		    ShowMessageRequest.method = 'window/showMessageRequest';
		    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
		})(ShowMessageRequest || (exports$1.ShowMessageRequest = ShowMessageRequest = {}));
		/**
		 * The log message notification is sent from the server to the client to ask
		 * the client to log a particular message.
		 */
		var LogMessageNotification;
		(function (LogMessageNotification) {
		    LogMessageNotification.method = 'window/logMessage';
		    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
		})(LogMessageNotification || (exports$1.LogMessageNotification = LogMessageNotification = {}));
		//---- Telemetry notification
		/**
		 * The telemetry event notification is sent from the server to the client to ask
		 * the client to log telemetry data.
		 */
		var TelemetryEventNotification;
		(function (TelemetryEventNotification) {
		    TelemetryEventNotification.method = 'telemetry/event';
		    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
		})(TelemetryEventNotification || (exports$1.TelemetryEventNotification = TelemetryEventNotification = {}));
		/**
		 * Defines how the host (editor) should sync
		 * document changes to the language server.
		 */
		var TextDocumentSyncKind;
		(function (TextDocumentSyncKind) {
		    /**
		     * Documents should not be synced at all.
		     */
		    TextDocumentSyncKind.None = 0;
		    /**
		     * Documents are synced by always sending the full content
		     * of the document.
		     */
		    TextDocumentSyncKind.Full = 1;
		    /**
		     * Documents are synced by sending the full content on open.
		     * After that only incremental updates to the document are
		     * send.
		     */
		    TextDocumentSyncKind.Incremental = 2;
		})(TextDocumentSyncKind || (exports$1.TextDocumentSyncKind = TextDocumentSyncKind = {}));
		/**
		 * The document open notification is sent from the client to the server to signal
		 * newly opened text documents. The document's truth is now managed by the client
		 * and the server must not try to read the document's truth using the document's
		 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
		 * mean that its content is presented in an editor. An open notification must not
		 * be sent more than once without a corresponding close notification send before.
		 * This means open and close notification must be balanced and the max open count
		 * is one.
		 */
		var DidOpenTextDocumentNotification;
		(function (DidOpenTextDocumentNotification) {
		    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
		    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
		})(DidOpenTextDocumentNotification || (exports$1.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
		var TextDocumentContentChangeEvent;
		(function (TextDocumentContentChangeEvent) {
		    /**
		     * Checks whether the information describes a delta event.
		     */
		    function isIncremental(event) {
		        let candidate = event;
		        return candidate !== undefined && candidate !== null &&
		            typeof candidate.text === 'string' && candidate.range !== undefined &&
		            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
		    }
		    TextDocumentContentChangeEvent.isIncremental = isIncremental;
		    /**
		     * Checks whether the information describes a full replacement event.
		     */
		    function isFull(event) {
		        let candidate = event;
		        return candidate !== undefined && candidate !== null &&
		            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
		    }
		    TextDocumentContentChangeEvent.isFull = isFull;
		})(TextDocumentContentChangeEvent || (exports$1.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
		/**
		 * The document change notification is sent from the client to the server to signal
		 * changes to a text document.
		 */
		var DidChangeTextDocumentNotification;
		(function (DidChangeTextDocumentNotification) {
		    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
		    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
		})(DidChangeTextDocumentNotification || (exports$1.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
		/**
		 * The document close notification is sent from the client to the server when
		 * the document got closed in the client. The document's truth now exists where
		 * the document's uri points to (e.g. if the document's uri is a file uri the
		 * truth now exists on disk). As with the open notification the close notification
		 * is about managing the document's content. Receiving a close notification
		 * doesn't mean that the document was open in an editor before. A close
		 * notification requires a previous open notification to be sent.
		 */
		var DidCloseTextDocumentNotification;
		(function (DidCloseTextDocumentNotification) {
		    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
		    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
		})(DidCloseTextDocumentNotification || (exports$1.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
		/**
		 * The document save notification is sent from the client to the server when
		 * the document got saved in the client.
		 */
		var DidSaveTextDocumentNotification;
		(function (DidSaveTextDocumentNotification) {
		    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
		    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
		})(DidSaveTextDocumentNotification || (exports$1.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
		/**
		 * Represents reasons why a text document is saved.
		 */
		var TextDocumentSaveReason;
		(function (TextDocumentSaveReason) {
		    /**
		     * Manually triggered, e.g. by the user pressing save, by starting debugging,
		     * or by an API call.
		     */
		    TextDocumentSaveReason.Manual = 1;
		    /**
		     * Automatic after a delay.
		     */
		    TextDocumentSaveReason.AfterDelay = 2;
		    /**
		     * When the editor lost focus.
		     */
		    TextDocumentSaveReason.FocusOut = 3;
		})(TextDocumentSaveReason || (exports$1.TextDocumentSaveReason = TextDocumentSaveReason = {}));
		/**
		 * A document will save notification is sent from the client to the server before
		 * the document is actually saved.
		 */
		var WillSaveTextDocumentNotification;
		(function (WillSaveTextDocumentNotification) {
		    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
		    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
		})(WillSaveTextDocumentNotification || (exports$1.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
		/**
		 * A document will save request is sent from the client to the server before
		 * the document is actually saved. The request can return an array of TextEdits
		 * which will be applied to the text document before it is saved. Please note that
		 * clients might drop results if computing the text edits took too long or if a
		 * server constantly fails on this request. This is done to keep the save fast and
		 * reliable.
		 */
		var WillSaveTextDocumentWaitUntilRequest;
		(function (WillSaveTextDocumentWaitUntilRequest) {
		    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
		    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
		})(WillSaveTextDocumentWaitUntilRequest || (exports$1.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
		/**
		 * The watched files notification is sent from the client to the server when
		 * the client detects changes to file watched by the language client.
		 */
		var DidChangeWatchedFilesNotification;
		(function (DidChangeWatchedFilesNotification) {
		    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
		    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
		    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
		})(DidChangeWatchedFilesNotification || (exports$1.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
		/**
		 * The file event type
		 */
		var FileChangeType;
		(function (FileChangeType) {
		    /**
		     * The file got created.
		     */
		    FileChangeType.Created = 1;
		    /**
		     * The file got changed.
		     */
		    FileChangeType.Changed = 2;
		    /**
		     * The file got deleted.
		     */
		    FileChangeType.Deleted = 3;
		})(FileChangeType || (exports$1.FileChangeType = FileChangeType = {}));
		var RelativePattern;
		(function (RelativePattern) {
		    function is(value) {
		        const candidate = value;
		        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
		    }
		    RelativePattern.is = is;
		})(RelativePattern || (exports$1.RelativePattern = RelativePattern = {}));
		var WatchKind;
		(function (WatchKind) {
		    /**
		     * Interested in create events.
		     */
		    WatchKind.Create = 1;
		    /**
		     * Interested in change events
		     */
		    WatchKind.Change = 2;
		    /**
		     * Interested in delete events
		     */
		    WatchKind.Delete = 4;
		})(WatchKind || (exports$1.WatchKind = WatchKind = {}));
		/**
		 * Diagnostics notification are sent from the server to the client to signal
		 * results of validation runs.
		 */
		var PublishDiagnosticsNotification;
		(function (PublishDiagnosticsNotification) {
		    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
		    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
		    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
		})(PublishDiagnosticsNotification || (exports$1.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
		/**
		 * How a completion was triggered
		 */
		var CompletionTriggerKind;
		(function (CompletionTriggerKind) {
		    /**
		     * Completion was triggered by typing an identifier (24x7 code
		     * complete), manual invocation (e.g Ctrl+Space) or via API.
		     */
		    CompletionTriggerKind.Invoked = 1;
		    /**
		     * Completion was triggered by a trigger character specified by
		     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
		     */
		    CompletionTriggerKind.TriggerCharacter = 2;
		    /**
		     * Completion was re-triggered as current completion list is incomplete
		     */
		    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
		})(CompletionTriggerKind || (exports$1.CompletionTriggerKind = CompletionTriggerKind = {}));
		/**
		 * Request to request completion at a given text document position. The request's
		 * parameter is of type {@link TextDocumentPosition} the response
		 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
		 * or a Thenable that resolves to such.
		 *
		 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
		 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
		 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
		 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
		 */
		var CompletionRequest;
		(function (CompletionRequest) {
		    CompletionRequest.method = 'textDocument/completion';
		    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
		})(CompletionRequest || (exports$1.CompletionRequest = CompletionRequest = {}));
		/**
		 * Request to resolve additional information for a given completion item.The request's
		 * parameter is of type {@link CompletionItem} the response
		 * is of type {@link CompletionItem} or a Thenable that resolves to such.
		 */
		var CompletionResolveRequest;
		(function (CompletionResolveRequest) {
		    CompletionResolveRequest.method = 'completionItem/resolve';
		    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
		})(CompletionResolveRequest || (exports$1.CompletionResolveRequest = CompletionResolveRequest = {}));
		/**
		 * Request to request hover information at a given text document position. The request's
		 * parameter is of type {@link TextDocumentPosition} the response is of
		 * type {@link Hover} or a Thenable that resolves to such.
		 */
		var HoverRequest;
		(function (HoverRequest) {
		    HoverRequest.method = 'textDocument/hover';
		    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
		})(HoverRequest || (exports$1.HoverRequest = HoverRequest = {}));
		/**
		 * How a signature help was triggered.
		 *
		 * @since 3.15.0
		 */
		var SignatureHelpTriggerKind;
		(function (SignatureHelpTriggerKind) {
		    /**
		     * Signature help was invoked manually by the user or by a command.
		     */
		    SignatureHelpTriggerKind.Invoked = 1;
		    /**
		     * Signature help was triggered by a trigger character.
		     */
		    SignatureHelpTriggerKind.TriggerCharacter = 2;
		    /**
		     * Signature help was triggered by the cursor moving or by the document content changing.
		     */
		    SignatureHelpTriggerKind.ContentChange = 3;
		})(SignatureHelpTriggerKind || (exports$1.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
		var SignatureHelpRequest;
		(function (SignatureHelpRequest) {
		    SignatureHelpRequest.method = 'textDocument/signatureHelp';
		    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
		})(SignatureHelpRequest || (exports$1.SignatureHelpRequest = SignatureHelpRequest = {}));
		/**
		 * A request to resolve the definition location of a symbol at a given text
		 * document position. The request's parameter is of type {@link TextDocumentPosition}
		 * the response is of either type {@link Definition} or a typed array of
		 * {@link DefinitionLink} or a Thenable that resolves to such.
		 */
		var DefinitionRequest;
		(function (DefinitionRequest) {
		    DefinitionRequest.method = 'textDocument/definition';
		    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
		})(DefinitionRequest || (exports$1.DefinitionRequest = DefinitionRequest = {}));
		/**
		 * A request to resolve project-wide references for the symbol denoted
		 * by the given text document position. The request's parameter is of
		 * type {@link ReferenceParams} the response is of type
		 * {@link Location Location[]} or a Thenable that resolves to such.
		 */
		var ReferencesRequest;
		(function (ReferencesRequest) {
		    ReferencesRequest.method = 'textDocument/references';
		    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
		})(ReferencesRequest || (exports$1.ReferencesRequest = ReferencesRequest = {}));
		/**
		 * Request to resolve a {@link DocumentHighlight} for a given
		 * text document position. The request's parameter is of type {@link TextDocumentPosition}
		 * the request response is an array of type {@link DocumentHighlight}
		 * or a Thenable that resolves to such.
		 */
		var DocumentHighlightRequest;
		(function (DocumentHighlightRequest) {
		    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
		    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
		})(DocumentHighlightRequest || (exports$1.DocumentHighlightRequest = DocumentHighlightRequest = {}));
		/**
		 * A request to list all symbols found in a given text document. The request's
		 * parameter is of type {@link TextDocumentIdentifier} the
		 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
		 * that resolves to such.
		 */
		var DocumentSymbolRequest;
		(function (DocumentSymbolRequest) {
		    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
		    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
		})(DocumentSymbolRequest || (exports$1.DocumentSymbolRequest = DocumentSymbolRequest = {}));
		/**
		 * A request to provide commands for the given text document and range.
		 */
		var CodeActionRequest;
		(function (CodeActionRequest) {
		    CodeActionRequest.method = 'textDocument/codeAction';
		    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
		})(CodeActionRequest || (exports$1.CodeActionRequest = CodeActionRequest = {}));
		/**
		 * Request to resolve additional information for a given code action.The request's
		 * parameter is of type {@link CodeAction} the response
		 * is of type {@link CodeAction} or a Thenable that resolves to such.
		 */
		var CodeActionResolveRequest;
		(function (CodeActionResolveRequest) {
		    CodeActionResolveRequest.method = 'codeAction/resolve';
		    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
		})(CodeActionResolveRequest || (exports$1.CodeActionResolveRequest = CodeActionResolveRequest = {}));
		/**
		 * A request to list project-wide symbols matching the query string given
		 * by the {@link WorkspaceSymbolParams}. The response is
		 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
		 * resolves to such.
		 *
		 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
		 *  need to advertise support for WorkspaceSymbols via the client capability
		 *  `workspace.symbol.resolveSupport`.
		 *
		 */
		var WorkspaceSymbolRequest;
		(function (WorkspaceSymbolRequest) {
		    WorkspaceSymbolRequest.method = 'workspace/symbol';
		    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
		})(WorkspaceSymbolRequest || (exports$1.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
		/**
		 * A request to resolve the range inside the workspace
		 * symbol's location.
		 *
		 * @since 3.17.0
		 */
		var WorkspaceSymbolResolveRequest;
		(function (WorkspaceSymbolResolveRequest) {
		    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
		    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
		})(WorkspaceSymbolResolveRequest || (exports$1.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
		/**
		 * A request to provide code lens for the given text document.
		 */
		var CodeLensRequest;
		(function (CodeLensRequest) {
		    CodeLensRequest.method = 'textDocument/codeLens';
		    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
		})(CodeLensRequest || (exports$1.CodeLensRequest = CodeLensRequest = {}));
		/**
		 * A request to resolve a command for a given code lens.
		 */
		var CodeLensResolveRequest;
		(function (CodeLensResolveRequest) {
		    CodeLensResolveRequest.method = 'codeLens/resolve';
		    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
		})(CodeLensResolveRequest || (exports$1.CodeLensResolveRequest = CodeLensResolveRequest = {}));
		/**
		 * A request to refresh all code actions
		 *
		 * @since 3.16.0
		 */
		var CodeLensRefreshRequest;
		(function (CodeLensRefreshRequest) {
		    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
		    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
		})(CodeLensRefreshRequest || (exports$1.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
		/**
		 * A request to provide document links
		 */
		var DocumentLinkRequest;
		(function (DocumentLinkRequest) {
		    DocumentLinkRequest.method = 'textDocument/documentLink';
		    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
		})(DocumentLinkRequest || (exports$1.DocumentLinkRequest = DocumentLinkRequest = {}));
		/**
		 * Request to resolve additional information for a given document link. The request's
		 * parameter is of type {@link DocumentLink} the response
		 * is of type {@link DocumentLink} or a Thenable that resolves to such.
		 */
		var DocumentLinkResolveRequest;
		(function (DocumentLinkResolveRequest) {
		    DocumentLinkResolveRequest.method = 'documentLink/resolve';
		    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
		})(DocumentLinkResolveRequest || (exports$1.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
		/**
		 * A request to format a whole document.
		 */
		var DocumentFormattingRequest;
		(function (DocumentFormattingRequest) {
		    DocumentFormattingRequest.method = 'textDocument/formatting';
		    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
		})(DocumentFormattingRequest || (exports$1.DocumentFormattingRequest = DocumentFormattingRequest = {}));
		/**
		 * A request to format a range in a document.
		 */
		var DocumentRangeFormattingRequest;
		(function (DocumentRangeFormattingRequest) {
		    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
		    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
		})(DocumentRangeFormattingRequest || (exports$1.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
		/**
		 * A request to format ranges in a document.
		 *
		 * @since 3.18.0
		 * @proposed
		 */
		var DocumentRangesFormattingRequest;
		(function (DocumentRangesFormattingRequest) {
		    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
		    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
		})(DocumentRangesFormattingRequest || (exports$1.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
		/**
		 * A request to format a document on type.
		 */
		var DocumentOnTypeFormattingRequest;
		(function (DocumentOnTypeFormattingRequest) {
		    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
		    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
		})(DocumentOnTypeFormattingRequest || (exports$1.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
		//---- Rename ----------------------------------------------
		var PrepareSupportDefaultBehavior;
		(function (PrepareSupportDefaultBehavior) {
		    /**
		     * The client's default behavior is to select the identifier
		     * according the to language's syntax rule.
		     */
		    PrepareSupportDefaultBehavior.Identifier = 1;
		})(PrepareSupportDefaultBehavior || (exports$1.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
		/**
		 * A request to rename a symbol.
		 */
		var RenameRequest;
		(function (RenameRequest) {
		    RenameRequest.method = 'textDocument/rename';
		    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
		})(RenameRequest || (exports$1.RenameRequest = RenameRequest = {}));
		/**
		 * A request to test and perform the setup necessary for a rename.
		 *
		 * @since 3.16 - support for default behavior
		 */
		var PrepareRenameRequest;
		(function (PrepareRenameRequest) {
		    PrepareRenameRequest.method = 'textDocument/prepareRename';
		    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
		})(PrepareRenameRequest || (exports$1.PrepareRenameRequest = PrepareRenameRequest = {}));
		/**
		 * A request send from the client to the server to execute a command. The request might return
		 * a workspace edit which the client will apply to the workspace.
		 */
		var ExecuteCommandRequest;
		(function (ExecuteCommandRequest) {
		    ExecuteCommandRequest.method = 'workspace/executeCommand';
		    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
		    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
		})(ExecuteCommandRequest || (exports$1.ExecuteCommandRequest = ExecuteCommandRequest = {}));
		/**
		 * A request sent from the server to the client to modified certain resources.
		 */
		var ApplyWorkspaceEditRequest;
		(function (ApplyWorkspaceEditRequest) {
		    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
		    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
		    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
		})(ApplyWorkspaceEditRequest || (exports$1.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {})); 
	} (protocol$1));
	return protocol$1;
}

var connection$1 = {};

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection$1;
	hasRequiredConnection = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(connection$1, "__esModule", { value: true });
	connection$1.createProtocolConnection = void 0;
	const vscode_jsonrpc_1 = requireMain$5();
	function createProtocolConnection(input, output, logger, options) {
	    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
	        options = { connectionStrategy: options };
	    }
	    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
	}
	connection$1.createProtocolConnection = createProtocolConnection;
	return connection$1;
}

var hasRequiredApi$1;

function requireApi$1 () {
	if (hasRequiredApi$1) return api$1;
	hasRequiredApi$1 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (api$1 && api$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (api$1 && api$1.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.LSPErrorCodes = exports$1.createProtocolConnection = void 0;
		__exportStar(requireMain$5(), exports$1);
		__exportStar(requireMain$4(), exports$1);
		__exportStar(requireMessages(), exports$1);
		__exportStar(requireProtocol$1(), exports$1);
		var connection_1 = requireConnection();
		Object.defineProperty(exports$1, "createProtocolConnection", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });
		var LSPErrorCodes;
		(function (LSPErrorCodes) {
		    /**
		    * This is the start range of LSP reserved error codes.
		    * It doesn't denote a real error code.
		    *
		    * @since 3.16.0
		    */
		    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
		    /**
		     * A request failed but it was syntactically correct, e.g the
		     * method name was known and the parameters were valid. The error
		     * message should contain human readable information about why
		     * the request failed.
		     *
		     * @since 3.17.0
		     */
		    LSPErrorCodes.RequestFailed = -32803;
		    /**
		     * The server cancelled the request. This error code should
		     * only be used for requests that explicitly support being
		     * server cancellable.
		     *
		     * @since 3.17.0
		     */
		    LSPErrorCodes.ServerCancelled = -32802;
		    /**
		     * The server detected that the content of a document got
		     * modified outside normal conditions. A server should
		     * NOT send this error code if it detects a content change
		     * in it unprocessed messages. The result even computed
		     * on an older state might still be useful for the client.
		     *
		     * If a client decides that a result is not of any use anymore
		     * the client should cancel the request.
		     */
		    LSPErrorCodes.ContentModified = -32801;
		    /**
		     * The client has canceled a request and a server as detected
		     * the cancel.
		     */
		    LSPErrorCodes.RequestCancelled = -32800;
		    /**
		    * This is the end range of LSP reserved error codes.
		    * It doesn't denote a real error code.
		    *
		    * @since 3.16.0
		    */
		    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
		})(LSPErrorCodes || (exports$1.LSPErrorCodes = LSPErrorCodes = {})); 
	} (api$1));
	return api$1;
}

var hasRequiredMain$3;

function requireMain$3 () {
	if (hasRequiredMain$3) return main$5;
	hasRequiredMain$3 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (main$5 && main$5.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$5 && main$5.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createProtocolConnection = void 0;
		const node_1 = requireNode$4();
		__exportStar(requireNode$4(), exports$1);
		__exportStar(requireApi$1(), exports$1);
		function createProtocolConnection(input, output, logger, options) {
		    return (0, node_1.createMessageConnection)(input, output, logger, options);
		}
		exports$1.createProtocolConnection = createProtocolConnection; 
	} (main$5));
	return main$5;
}

var uuid = {};

var hasRequiredUuid;

function requireUuid () {
	if (hasRequiredUuid) return uuid;
	hasRequiredUuid = 1;
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	Object.defineProperty(uuid, "__esModule", { value: true });
	uuid.generateUuid = uuid.parse = uuid.isUUID = uuid.v4 = uuid.empty = void 0;
	class ValueUUID {
	    constructor(_value) {
	        this._value = _value;
	        // empty
	    }
	    asHex() {
	        return this._value;
	    }
	    equals(other) {
	        return this.asHex() === other.asHex();
	    }
	}
	class V4UUID extends ValueUUID {
	    static _oneOf(array) {
	        return array[Math.floor(array.length * Math.random())];
	    }
	    static _randomHex() {
	        return V4UUID._oneOf(V4UUID._chars);
	    }
	    constructor() {
	        super([
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            '4',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._oneOf(V4UUID._timeHighBits),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            '-',
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	            V4UUID._randomHex(),
	        ].join(''));
	    }
	}
	V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
	V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
	/**
	 * An empty UUID that contains only zeros.
	 */
	uuid.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
	function v4() {
	    return new V4UUID();
	}
	uuid.v4 = v4;
	const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
	function isUUID(value) {
	    return _UUIDPattern.test(value);
	}
	uuid.isUUID = isUUID;
	/**
	 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
	 * @param value A uuid string.
	 */
	function parse(value) {
	    if (!isUUID(value)) {
	        throw new Error('invalid uuid');
	    }
	    return new ValueUUID(value);
	}
	uuid.parse = parse;
	function generateUuid() {
	    return v4().asHex();
	}
	uuid.generateUuid = generateUuid;
	return uuid;
}

var progress = {};

var hasRequiredProgress;

function requireProgress () {
	if (hasRequiredProgress) return progress;
	hasRequiredProgress = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(progress, "__esModule", { value: true });
	progress.attachPartialResult = progress.ProgressFeature = progress.attachWorkDone = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const uuid_1 = requireUuid();
	class WorkDoneProgressReporterImpl {
	    constructor(_connection, _token) {
	        this._connection = _connection;
	        this._token = _token;
	        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
	    }
	    begin(title, percentage, message, cancellable) {
	        let param = {
	            kind: 'begin',
	            title,
	            percentage,
	            message,
	            cancellable
	        };
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
	    }
	    report(arg0, arg1) {
	        let param = {
	            kind: 'report'
	        };
	        if (typeof arg0 === 'number') {
	            param.percentage = arg0;
	            if (arg1 !== undefined) {
	                param.message = arg1;
	            }
	        }
	        else {
	            param.message = arg0;
	        }
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
	    }
	    done() {
	        WorkDoneProgressReporterImpl.Instances.delete(this._token);
	        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
	    }
	}
	WorkDoneProgressReporterImpl.Instances = new Map();
	class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
	    constructor(connection, token) {
	        super(connection, token);
	        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
	    }
	    get token() {
	        return this._source.token;
	    }
	    done() {
	        this._source.dispose();
	        super.done();
	    }
	    cancel() {
	        this._source.cancel();
	    }
	}
	class NullProgressReporter {
	    constructor() {
	    }
	    begin() {
	    }
	    report() {
	    }
	    done() {
	    }
	}
	class NullProgressServerReporter extends NullProgressReporter {
	    constructor() {
	        super();
	        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
	    }
	    get token() {
	        return this._source.token;
	    }
	    done() {
	        this._source.dispose();
	    }
	    cancel() {
	        this._source.cancel();
	    }
	}
	function attachWorkDone(connection, params) {
	    if (params === undefined || params.workDoneToken === undefined) {
	        return new NullProgressReporter();
	    }
	    const token = params.workDoneToken;
	    delete params.workDoneToken;
	    return new WorkDoneProgressReporterImpl(connection, token);
	}
	progress.attachWorkDone = attachWorkDone;
	const ProgressFeature = (Base) => {
	    return class extends Base {
	        constructor() {
	            super();
	            this._progressSupported = false;
	        }
	        initialize(capabilities) {
	            super.initialize(capabilities);
	            if (capabilities?.window?.workDoneProgress === true) {
	                this._progressSupported = true;
	                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
	                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
	                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
	                        progress.cancel();
	                    }
	                });
	            }
	        }
	        attachWorkDoneProgress(token) {
	            if (token === undefined) {
	                return new NullProgressReporter();
	            }
	            else {
	                return new WorkDoneProgressReporterImpl(this.connection, token);
	            }
	        }
	        createWorkDoneProgress() {
	            if (this._progressSupported) {
	                const token = (0, uuid_1.generateUuid)();
	                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
	                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
	                    return result;
	                });
	            }
	            else {
	                return Promise.resolve(new NullProgressServerReporter());
	            }
	        }
	    };
	};
	progress.ProgressFeature = ProgressFeature;
	var ResultProgress;
	(function (ResultProgress) {
	    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
	})(ResultProgress || (ResultProgress = {}));
	class ResultProgressReporterImpl {
	    constructor(_connection, _token) {
	        this._connection = _connection;
	        this._token = _token;
	    }
	    report(data) {
	        this._connection.sendProgress(ResultProgress.type, this._token, data);
	    }
	}
	function attachPartialResult(connection, params) {
	    if (params === undefined || params.partialResultToken === undefined) {
	        return undefined;
	    }
	    const token = params.partialResultToken;
	    delete params.partialResultToken;
	    return new ResultProgressReporterImpl(connection, token);
	}
	progress.attachPartialResult = attachPartialResult;
	return progress;
}

var configuration = {};

var hasRequiredConfiguration;

function requireConfiguration () {
	if (hasRequiredConfiguration) return configuration;
	hasRequiredConfiguration = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(configuration, "__esModule", { value: true });
	configuration.ConfigurationFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const Is = requireIs$2();
	const ConfigurationFeature = (Base) => {
	    return class extends Base {
	        getConfiguration(arg) {
	            if (!arg) {
	                return this._getConfiguration({});
	            }
	            else if (Is.string(arg)) {
	                return this._getConfiguration({ section: arg });
	            }
	            else {
	                return this._getConfiguration(arg);
	            }
	        }
	        _getConfiguration(arg) {
	            let params = {
	                items: Array.isArray(arg) ? arg : [arg]
	            };
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
	                if (Array.isArray(result)) {
	                    return Array.isArray(arg) ? result : result[0];
	                }
	                else {
	                    return Array.isArray(arg) ? [] : null;
	                }
	            });
	        }
	    };
	};
	configuration.ConfigurationFeature = ConfigurationFeature;
	return configuration;
}

var workspaceFolder = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredWorkspaceFolder;

function requireWorkspaceFolder () {
	if (hasRequiredWorkspaceFolder) return workspaceFolder;
	hasRequiredWorkspaceFolder = 1;
	Object.defineProperty(workspaceFolder, "__esModule", { value: true });
	workspaceFolder.WorkspaceFoldersFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const WorkspaceFoldersFeature = (Base) => {
	    return class extends Base {
	        constructor() {
	            super();
	            this._notificationIsAutoRegistered = false;
	        }
	        initialize(capabilities) {
	            super.initialize(capabilities);
	            let workspaceCapabilities = capabilities.workspace;
	            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
	                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
	                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
	                    this._onDidChangeWorkspaceFolders.fire(params.event);
	                });
	            }
	        }
	        fillServerCapabilities(capabilities) {
	            super.fillServerCapabilities(capabilities);
	            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
	            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';
	        }
	        getWorkspaceFolders() {
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
	        }
	        get onDidChangeWorkspaceFolders() {
	            if (!this._onDidChangeWorkspaceFolders) {
	                throw new Error('Client doesn\'t support sending workspace folder change events.');
	            }
	            if (!this._notificationIsAutoRegistered && !this._unregistration) {
	                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
	            }
	            return this._onDidChangeWorkspaceFolders.event;
	        }
	    };
	};
	workspaceFolder.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
	return workspaceFolder;
}

var callHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredCallHierarchy;

function requireCallHierarchy () {
	if (hasRequiredCallHierarchy) return callHierarchy;
	hasRequiredCallHierarchy = 1;
	Object.defineProperty(callHierarchy, "__esModule", { value: true });
	callHierarchy.CallHierarchyFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const CallHierarchyFeature = (Base) => {
	    return class extends Base {
	        get callHierarchy() {
	            return {
	                onPrepare: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	                    });
	                },
	                onIncomingCalls: (handler) => {
	                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onOutgoingCalls: (handler) => {
	                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	callHierarchy.CallHierarchyFeature = CallHierarchyFeature;
	return callHierarchy;
}

var semanticTokens = {};

var hasRequiredSemanticTokens;

function requireSemanticTokens () {
	if (hasRequiredSemanticTokens) return semanticTokens;
	hasRequiredSemanticTokens = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(semanticTokens, "__esModule", { value: true });
	semanticTokens.SemanticTokensBuilder = semanticTokens.SemanticTokensDiff = semanticTokens.SemanticTokensFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const SemanticTokensFeature = (Base) => {
	    return class extends Base {
	        get semanticTokens() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
	                },
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onDelta: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onRange: (handler) => {
	                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	semanticTokens.SemanticTokensFeature = SemanticTokensFeature;
	class SemanticTokensDiff {
	    constructor(originalSequence, modifiedSequence) {
	        this.originalSequence = originalSequence;
	        this.modifiedSequence = modifiedSequence;
	    }
	    computeDiff() {
	        const originalLength = this.originalSequence.length;
	        const modifiedLength = this.modifiedSequence.length;
	        let startIndex = 0;
	        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
	            startIndex++;
	        }
	        if (startIndex < modifiedLength && startIndex < originalLength) {
	            let originalEndIndex = originalLength - 1;
	            let modifiedEndIndex = modifiedLength - 1;
	            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
	                originalEndIndex--;
	                modifiedEndIndex--;
	            }
	            // if one moved behind the start index move them forward again
	            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
	                originalEndIndex++;
	                modifiedEndIndex++;
	            }
	            const deleteCount = originalEndIndex - startIndex + 1;
	            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
	            // If we moved behind the start index we could have missed a simple delete.
	            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
	                return [
	                    { start: startIndex, deleteCount: deleteCount - 1 }
	                ];
	            }
	            else {
	                return [
	                    { start: startIndex, deleteCount, data: newData }
	                ];
	            }
	        }
	        else if (startIndex < modifiedLength) {
	            return [
	                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
	            ];
	        }
	        else if (startIndex < originalLength) {
	            return [
	                { start: startIndex, deleteCount: originalLength - startIndex }
	            ];
	        }
	        else {
	            // The two arrays are the same.
	            return [];
	        }
	    }
	}
	semanticTokens.SemanticTokensDiff = SemanticTokensDiff;
	class SemanticTokensBuilder {
	    constructor() {
	        this._prevData = undefined;
	        this.initialize();
	    }
	    initialize() {
	        this._id = Date.now();
	        this._prevLine = 0;
	        this._prevChar = 0;
	        this._data = [];
	        this._dataLen = 0;
	    }
	    push(line, char, length, tokenType, tokenModifiers) {
	        let pushLine = line;
	        let pushChar = char;
	        if (this._dataLen > 0) {
	            pushLine -= this._prevLine;
	            if (pushLine === 0) {
	                pushChar -= this._prevChar;
	            }
	        }
	        this._data[this._dataLen++] = pushLine;
	        this._data[this._dataLen++] = pushChar;
	        this._data[this._dataLen++] = length;
	        this._data[this._dataLen++] = tokenType;
	        this._data[this._dataLen++] = tokenModifiers;
	        this._prevLine = line;
	        this._prevChar = char;
	    }
	    get id() {
	        return this._id.toString();
	    }
	    previousResult(id) {
	        if (this.id === id) {
	            this._prevData = this._data;
	        }
	        this.initialize();
	    }
	    build() {
	        this._prevData = undefined;
	        return {
	            resultId: this.id,
	            data: this._data
	        };
	    }
	    canBuildEdits() {
	        return this._prevData !== undefined;
	    }
	    buildEdits() {
	        if (this._prevData !== undefined) {
	            return {
	                resultId: this.id,
	                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()
	            };
	        }
	        else {
	            return this.build();
	        }
	    }
	}
	semanticTokens.SemanticTokensBuilder = SemanticTokensBuilder;
	return semanticTokens;
}

var showDocument = {};

var hasRequiredShowDocument;

function requireShowDocument () {
	if (hasRequiredShowDocument) return showDocument;
	hasRequiredShowDocument = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(showDocument, "__esModule", { value: true });
	showDocument.ShowDocumentFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const ShowDocumentFeature = (Base) => {
	    return class extends Base {
	        showDocument(params) {
	            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
	        }
	    };
	};
	showDocument.ShowDocumentFeature = ShowDocumentFeature;
	return showDocument;
}

var fileOperations = {};

var hasRequiredFileOperations;

function requireFileOperations () {
	if (hasRequiredFileOperations) return fileOperations;
	hasRequiredFileOperations = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(fileOperations, "__esModule", { value: true });
	fileOperations.FileOperationsFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const FileOperationsFeature = (Base) => {
	    return class extends Base {
	        onDidCreateFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onDidRenameFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onDidDeleteFiles(handler) {
	            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
	                handler(params);
	            });
	        }
	        onWillCreateFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	        onWillRenameFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	        onWillDeleteFiles(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
	                return handler(params, cancel);
	            });
	        }
	    };
	};
	fileOperations.FileOperationsFeature = FileOperationsFeature;
	return fileOperations;
}

var linkedEditingRange = {};

var hasRequiredLinkedEditingRange;

function requireLinkedEditingRange () {
	if (hasRequiredLinkedEditingRange) return linkedEditingRange;
	hasRequiredLinkedEditingRange = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(linkedEditingRange, "__esModule", { value: true });
	linkedEditingRange.LinkedEditingRangeFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const LinkedEditingRangeFeature = (Base) => {
	    return class extends Base {
	        onLinkedEditingRange(handler) {
	            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
	                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	            });
	        }
	    };
	};
	linkedEditingRange.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
	return linkedEditingRange;
}

var typeHierarchy = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredTypeHierarchy;

function requireTypeHierarchy () {
	if (hasRequiredTypeHierarchy) return typeHierarchy;
	hasRequiredTypeHierarchy = 1;
	Object.defineProperty(typeHierarchy, "__esModule", { value: true });
	typeHierarchy.TypeHierarchyFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const TypeHierarchyFeature = (Base) => {
	    return class extends Base {
	        get typeHierarchy() {
	            return {
	                onPrepare: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
	                    });
	                },
	                onSupertypes: (handler) => {
	                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	                onSubtypes: (handler) => {
	                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	typeHierarchy.TypeHierarchyFeature = TypeHierarchyFeature;
	return typeHierarchy;
}

var inlineValue = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlineValue;

function requireInlineValue () {
	if (hasRequiredInlineValue) return inlineValue;
	hasRequiredInlineValue = 1;
	Object.defineProperty(inlineValue, "__esModule", { value: true });
	inlineValue.InlineValueFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const InlineValueFeature = (Base) => {
	    return class extends Base {
	        get inlineValue() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                }
	            };
	        }
	    };
	};
	inlineValue.InlineValueFeature = InlineValueFeature;
	return inlineValue;
}

var foldingRange = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredFoldingRange;

function requireFoldingRange () {
	if (hasRequiredFoldingRange) return foldingRange;
	hasRequiredFoldingRange = 1;
	Object.defineProperty(foldingRange, "__esModule", { value: true });
	foldingRange.FoldingRangeFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const FoldingRangeFeature = (Base) => {
	    return class extends Base {
	        get foldingRange() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
	                },
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                }
	            };
	        }
	    };
	};
	foldingRange.FoldingRangeFeature = FoldingRangeFeature;
	return foldingRange;
}

var inlayHint = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlayHint;

function requireInlayHint () {
	if (hasRequiredInlayHint) return inlayHint;
	hasRequiredInlayHint = 1;
	Object.defineProperty(inlayHint, "__esModule", { value: true });
	inlayHint.InlayHintFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const InlayHintFeature = (Base) => {
	    return class extends Base {
	        get inlayHint() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                },
	                resolve: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
	                        return handler(params, cancel);
	                    });
	                }
	            };
	        }
	    };
	};
	inlayHint.InlayHintFeature = InlayHintFeature;
	return inlayHint;
}

var diagnostic = {};

var hasRequiredDiagnostic;

function requireDiagnostic () {
	if (hasRequiredDiagnostic) return diagnostic;
	hasRequiredDiagnostic = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(diagnostic, "__esModule", { value: true });
	diagnostic.DiagnosticFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const DiagnosticFeature = (Base) => {
	    return class extends Base {
	        get diagnostics() {
	            return {
	                refresh: () => {
	                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
	                },
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
	                    });
	                },
	                onWorkspace: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
	                    });
	                }
	            };
	        }
	    };
	};
	diagnostic.DiagnosticFeature = DiagnosticFeature;
	return diagnostic;
}

var notebook = {};

var textDocuments$1 = {};

var hasRequiredTextDocuments$1;

function requireTextDocuments$1 () {
	if (hasRequiredTextDocuments$1) return textDocuments$1;
	hasRequiredTextDocuments$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(textDocuments$1, "__esModule", { value: true });
	textDocuments$1.TextDocuments = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	/**
	 * A manager for simple text documents. The manager requires at a minimum that
	 * the server registered for the following text document sync events in the
	 * initialize handler or via dynamic registration:
	 *
	 * - open and close events.
	 * - change events.
	 *
	 * Registering for save and will save events is optional.
	 */
	class TextDocuments {
	    /**
	     * Create a new text document manager.
	     */
	    constructor(configuration) {
	        this._configuration = configuration;
	        this._syncedDocuments = new Map();
	        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
	        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened.
	     */
	    get onDidOpen() {
	        return this._onDidOpen.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been opened or the content changes.
	     */
	    get onDidChangeContent() {
	        return this._onDidChangeContent.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * will be saved.
	     */
	    get onWillSave() {
	        return this._onWillSave.event;
	    }
	    /**
	     * Sets a handler that will be called if a participant wants to provide
	     * edits during a text document save.
	     */
	    onWillSaveWaitUntil(handler) {
	        this._willSaveWaitUntil = handler;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been saved.
	     */
	    get onDidSave() {
	        return this._onDidSave.event;
	    }
	    /**
	     * An event that fires when a text document managed by this manager
	     * has been closed.
	     */
	    get onDidClose() {
	        return this._onDidClose.event;
	    }
	    /**
	     * Returns the document for the given URI. Returns undefined if
	     * the document is not managed by this instance.
	     *
	     * @param uri The text document's URI to retrieve.
	     * @return the text document or `undefined`.
	     */
	    get(uri) {
	        return this._syncedDocuments.get(uri);
	    }
	    /**
	     * Returns all text documents managed by this instance.
	     *
	     * @return all text documents.
	     */
	    all() {
	        return Array.from(this._syncedDocuments.values());
	    }
	    /**
	     * Returns the URIs of all text documents managed by this instance.
	     *
	     * @return the URI's of all text documents.
	     */
	    keys() {
	        return Array.from(this._syncedDocuments.keys());
	    }
	    /**
	     * Listens for `low level` notification on the given connection to
	     * update the text documents managed by this instance.
	     *
	     * Please note that the connection only provides handlers not an event model. Therefore
	     * listening on a connection will overwrite the following handlers on a connection:
	     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
	     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
	     *
	     * Use the corresponding events on the TextDocuments instance instead.
	     *
	     * @param connection The connection to listen on.
	     */
	    listen(connection) {
	        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
	        const disposables = [];
	        disposables.push(connection.onDidOpenTextDocument((event) => {
	            const td = event.textDocument;
	            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
	            this._syncedDocuments.set(td.uri, document);
	            const toFire = Object.freeze({ document });
	            this._onDidOpen.fire(toFire);
	            this._onDidChangeContent.fire(toFire);
	        }));
	        disposables.push(connection.onDidChangeTextDocument((event) => {
	            const td = event.textDocument;
	            const changes = event.contentChanges;
	            if (changes.length === 0) {
	                return;
	            }
	            const { version } = td;
	            if (version === null || version === undefined) {
	                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
	            }
	            let syncedDocument = this._syncedDocuments.get(td.uri);
	            if (syncedDocument !== undefined) {
	                syncedDocument = this._configuration.update(syncedDocument, changes, version);
	                this._syncedDocuments.set(td.uri, syncedDocument);
	                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        disposables.push(connection.onDidCloseTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._syncedDocuments.delete(event.textDocument.uri);
	                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        disposables.push(connection.onWillSaveTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
	            }
	        }));
	        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined && this._willSaveWaitUntil) {
	                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
	            }
	            else {
	                return [];
	            }
	        }));
	        disposables.push(connection.onDidSaveTextDocument((event) => {
	            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
	            if (syncedDocument !== undefined) {
	                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
	            }
	        }));
	        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
	    }
	}
	textDocuments$1.TextDocuments = TextDocuments;
	return textDocuments$1;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredNotebook;

function requireNotebook () {
	if (hasRequiredNotebook) return notebook;
	hasRequiredNotebook = 1;
	Object.defineProperty(notebook, "__esModule", { value: true });
	notebook.NotebookDocuments = notebook.NotebookSyncFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const textDocuments_1 = requireTextDocuments$1();
	const NotebookSyncFeature = (Base) => {
	    return class extends Base {
	        get synchronization() {
	            return {
	                onDidOpenNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidChangeNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidSaveNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                },
	                onDidCloseNotebookDocument: (handler) => {
	                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
	                        handler(params);
	                    });
	                }
	            };
	        }
	    };
	};
	notebook.NotebookSyncFeature = NotebookSyncFeature;
	class CellTextDocumentConnection {
	    onDidOpenTextDocument(handler) {
	        this.openHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });
	    }
	    openTextDocument(params) {
	        this.openHandler && this.openHandler(params);
	    }
	    onDidChangeTextDocument(handler) {
	        this.changeHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });
	    }
	    changeTextDocument(params) {
	        this.changeHandler && this.changeHandler(params);
	    }
	    onDidCloseTextDocument(handler) {
	        this.closeHandler = handler;
	        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });
	    }
	    closeTextDocument(params) {
	        this.closeHandler && this.closeHandler(params);
	    }
	    onWillSaveTextDocument() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	    onWillSaveTextDocumentWaitUntil() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	    onDidSaveTextDocument() {
	        return CellTextDocumentConnection.NULL_DISPOSE;
	    }
	}
	CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });
	class NotebookDocuments {
	    constructor(configurationOrTextDocuments) {
	        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
	            this._cellTextDocuments = configurationOrTextDocuments;
	        }
	        else {
	            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
	        }
	        this.notebookDocuments = new Map();
	        this.notebookCellMap = new Map();
	        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
	        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
	    }
	    get cellTextDocuments() {
	        return this._cellTextDocuments;
	    }
	    getCellTextDocument(cell) {
	        return this._cellTextDocuments.get(cell.document);
	    }
	    getNotebookDocument(uri) {
	        return this.notebookDocuments.get(uri);
	    }
	    getNotebookCell(uri) {
	        const value = this.notebookCellMap.get(uri);
	        return value && value[0];
	    }
	    findNotebookDocumentForCell(cell) {
	        const key = typeof cell === 'string' ? cell : cell.document;
	        const value = this.notebookCellMap.get(key);
	        return value && value[1];
	    }
	    get onDidOpen() {
	        return this._onDidOpen.event;
	    }
	    get onDidSave() {
	        return this._onDidSave.event;
	    }
	    get onDidChange() {
	        return this._onDidChange.event;
	    }
	    get onDidClose() {
	        return this._onDidClose.event;
	    }
	    /**
	     * Listens for `low level` notification on the given connection to
	     * update the notebook documents managed by this instance.
	     *
	     * Please note that the connection only provides handlers not an event model. Therefore
	     * listening on a connection will overwrite the following handlers on a connection:
	     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
	     *  and `onDidCloseNotebookDocument`.
	     *
	     * @param connection The connection to listen on.
	     */
	    listen(connection) {
	        const cellTextDocumentConnection = new CellTextDocumentConnection();
	        const disposables = [];
	        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
	        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
	            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
	            for (const cellTextDocument of params.cellTextDocuments) {
	                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
	            }
	            this.updateCellMap(params.notebookDocument);
	            this._onDidOpen.fire(params.notebookDocument);
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            notebookDocument.version = params.notebookDocument.version;
	            const oldMetadata = notebookDocument.metadata;
	            let metadataChanged = false;
	            const change = params.change;
	            if (change.metadata !== undefined) {
	                metadataChanged = true;
	                notebookDocument.metadata = change.metadata;
	            }
	            const opened = [];
	            const closed = [];
	            const data = [];
	            const text = [];
	            if (change.cells !== undefined) {
	                const changedCells = change.cells;
	                if (changedCells.structure !== undefined) {
	                    const array = changedCells.structure.array;
	                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));
	                    // Additional open cell text documents.
	                    if (changedCells.structure.didOpen !== undefined) {
	                        for (const open of changedCells.structure.didOpen) {
	                            cellTextDocumentConnection.openTextDocument({ textDocument: open });
	                            opened.push(open.uri);
	                        }
	                    }
	                    // Additional closed cell test documents.
	                    if (changedCells.structure.didClose) {
	                        for (const close of changedCells.structure.didClose) {
	                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });
	                            closed.push(close.uri);
	                        }
	                    }
	                }
	                if (changedCells.data !== undefined) {
	                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));
	                    for (let i = 0; i <= notebookDocument.cells.length; i++) {
	                        const change = cellUpdates.get(notebookDocument.cells[i].document);
	                        if (change !== undefined) {
	                            const old = notebookDocument.cells.splice(i, 1, change);
	                            data.push({ old: old[0], new: change });
	                            cellUpdates.delete(change.document);
	                            if (cellUpdates.size === 0) {
	                                break;
	                            }
	                        }
	                    }
	                }
	                if (changedCells.textContent !== undefined) {
	                    for (const cellTextDocument of changedCells.textContent) {
	                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
	                        text.push(cellTextDocument.document.uri);
	                    }
	                }
	            }
	            // Update internal data structure.
	            this.updateCellMap(notebookDocument);
	            const changeEvent = { notebookDocument };
	            if (metadataChanged) {
	                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
	            }
	            const added = [];
	            for (const open of opened) {
	                added.push(this.getNotebookCell(open));
	            }
	            const removed = [];
	            for (const close of closed) {
	                removed.push(this.getNotebookCell(close));
	            }
	            const textContent = [];
	            for (const change of text) {
	                textContent.push(this.getNotebookCell(change));
	            }
	            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
	                changeEvent.cells = { added, removed, changed: { data, textContent } };
	            }
	            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {
	                this._onDidChange.fire(changeEvent);
	            }
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            this._onDidSave.fire(notebookDocument);
	        }));
	        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
	            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
	            if (notebookDocument === undefined) {
	                return;
	            }
	            this._onDidClose.fire(notebookDocument);
	            for (const cellTextDocument of params.cellTextDocuments) {
	                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
	            }
	            this.notebookDocuments.delete(params.notebookDocument.uri);
	            for (const cell of notebookDocument.cells) {
	                this.notebookCellMap.delete(cell.document);
	            }
	        }));
	        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });
	    }
	    updateCellMap(notebookDocument) {
	        for (const cell of notebookDocument.cells) {
	            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
	        }
	    }
	}
	notebook.NotebookDocuments = NotebookDocuments;
	return notebook;
}

var moniker = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredMoniker;

function requireMoniker () {
	if (hasRequiredMoniker) return moniker;
	hasRequiredMoniker = 1;
	Object.defineProperty(moniker, "__esModule", { value: true });
	moniker.MonikerFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const MonikerFeature = (Base) => {
	    return class extends Base {
	        get moniker() {
	            return {
	                on: (handler) => {
	                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
	                    return this.connection.onRequest(type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
	                    });
	                },
	            };
	        }
	    };
	};
	moniker.MonikerFeature = MonikerFeature;
	return moniker;
}

var hasRequiredServer$1;

function requireServer$1 () {
	if (hasRequiredServer$1) return server$2;
	hasRequiredServer$1 = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(server$2, "__esModule", { value: true });
	server$2.createConnection = server$2.combineFeatures = server$2.combineNotebooksFeatures = server$2.combineLanguagesFeatures = server$2.combineWorkspaceFeatures = server$2.combineWindowFeatures = server$2.combineClientFeatures = server$2.combineTracerFeatures = server$2.combineTelemetryFeatures = server$2.combineConsoleFeatures = server$2._NotebooksImpl = server$2._LanguagesImpl = server$2.BulkUnregistration = server$2.BulkRegistration = server$2.ErrorMessageTracker = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const Is = requireIs$2();
	const UUID = requireUuid();
	const progress_1 = requireProgress();
	const configuration_1 = requireConfiguration();
	const workspaceFolder_1 = requireWorkspaceFolder();
	const callHierarchy_1 = requireCallHierarchy();
	const semanticTokens_1 = requireSemanticTokens();
	const showDocument_1 = requireShowDocument();
	const fileOperations_1 = requireFileOperations();
	const linkedEditingRange_1 = requireLinkedEditingRange();
	const typeHierarchy_1 = requireTypeHierarchy();
	const inlineValue_1 = requireInlineValue();
	const foldingRange_1 = requireFoldingRange();
	// import { InlineCompletionFeatureShape, InlineCompletionFeature } from './inlineCompletion.proposed';
	const inlayHint_1 = requireInlayHint();
	const diagnostic_1 = requireDiagnostic();
	const notebook_1 = requireNotebook();
	const moniker_1 = requireMoniker();
	function null2Undefined(value) {
	    if (value === null) {
	        return undefined;
	    }
	    return value;
	}
	/**
	 * Helps tracking error message. Equal occurrences of the same
	 * message are only stored once. This class is for example
	 * useful if text documents are validated in a loop and equal
	 * error message should be folded into one.
	 */
	class ErrorMessageTracker {
	    constructor() {
	        this._messages = Object.create(null);
	    }
	    /**
	     * Add a message to the tracker.
	     *
	     * @param message The message to add.
	     */
	    add(message) {
	        let count = this._messages[message];
	        if (!count) {
	            count = 0;
	        }
	        count++;
	        this._messages[message] = count;
	    }
	    /**
	     * Send all tracked messages to the connection's window.
	     *
	     * @param connection The connection established between client and server.
	     */
	    sendErrors(connection) {
	        Object.keys(this._messages).forEach(message => {
	            connection.window.showErrorMessage(message);
	        });
	    }
	}
	server$2.ErrorMessageTracker = ErrorMessageTracker;
	class RemoteConsoleImpl {
	    constructor() {
	    }
	    rawAttach(connection) {
	        this._rawConnection = connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    initialize(_capabilities) {
	    }
	    error(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
	    }
	    warn(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
	    }
	    info(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
	    }
	    log(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
	    }
	    debug(message) {
	        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
	    }
	    send(type, message) {
	        if (this._rawConnection) {
	            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
	                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
	            });
	        }
	    }
	}
	class _RemoteWindowImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    showErrorMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showWarningMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	    showInformationMessage(message, ...actions) {
	        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
	    }
	}
	const RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
	var BulkRegistration;
	(function (BulkRegistration) {
	    /**
	     * Creates a new bulk registration.
	     * @return an empty bulk registration.
	     */
	    function create() {
	        return new BulkRegistrationImpl();
	    }
	    BulkRegistration.create = create;
	})(BulkRegistration || (server$2.BulkRegistration = BulkRegistration = {}));
	class BulkRegistrationImpl {
	    constructor() {
	        this._registrations = [];
	        this._registered = new Set();
	    }
	    add(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        if (this._registered.has(method)) {
	            throw new Error(`${method} is already added to this registration`);
	        }
	        const id = UUID.generateUuid();
	        this._registrations.push({
	            id: id,
	            method: method,
	            registerOptions: registerOptions || {}
	        });
	        this._registered.add(method);
	    }
	    asRegistrationParams() {
	        return {
	            registrations: this._registrations
	        };
	    }
	}
	var BulkUnregistration;
	(function (BulkUnregistration) {
	    function create() {
	        return new BulkUnregistrationImpl(undefined, []);
	    }
	    BulkUnregistration.create = create;
	})(BulkUnregistration || (server$2.BulkUnregistration = BulkUnregistration = {}));
	class BulkUnregistrationImpl {
	    constructor(_connection, unregistrations) {
	        this._connection = _connection;
	        this._unregistrations = new Map();
	        unregistrations.forEach(unregistration => {
	            this._unregistrations.set(unregistration.method, unregistration);
	        });
	    }
	    get isAttached() {
	        return !!this._connection;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    add(unregistration) {
	        this._unregistrations.set(unregistration.method, unregistration);
	    }
	    dispose() {
	        let unregistrations = [];
	        for (let unregistration of this._unregistrations.values()) {
	            unregistrations.push(unregistration);
	        }
	        let params = {
	            unregisterations: unregistrations
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
	            this._connection.console.info(`Bulk unregistration failed.`);
	        });
	    }
	    disposeSingle(arg) {
	        const method = Is.string(arg) ? arg : arg.method;
	        const unregistration = this._unregistrations.get(method);
	        if (!unregistration) {
	            return false;
	        }
	        let params = {
	            unregisterations: [unregistration]
	        };
	        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
	            this._unregistrations.delete(method);
	        }, (_error) => {
	            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
	        });
	        return true;
	    }
	}
	class RemoteClientImpl {
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
	        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
	            return this.registerMany(typeOrRegistrations);
	        }
	        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
	            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
	        }
	        else {
	            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
	        }
	    }
	    registerSingle1(unregistration, type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        if (!unregistration.isAttached) {
	            unregistration.attach(this.connection);
	        }
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            unregistration.add({ id: id, method: method });
	            return unregistration;
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    registerSingle2(type, registerOptions) {
	        const method = Is.string(type) ? type : type.method;
	        const id = UUID.generateUuid();
	        let params = {
	            registrations: [{ id, method, registerOptions: registerOptions || {} }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
	            return vscode_languageserver_protocol_1.Disposable.create(() => {
	                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });
	            });
	        }, (_error) => {
	            this.connection.console.info(`Registering request handler for ${method} failed.`);
	            return Promise.reject(_error);
	        });
	    }
	    unregisterSingle(id, method) {
	        let params = {
	            unregisterations: [{ id, method }]
	        };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
	            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
	        });
	    }
	    registerMany(registrations) {
	        let params = registrations.asRegistrationParams();
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
	            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
	        }, (_error) => {
	            this.connection.console.info(`Bulk registration failed.`);
	            return Promise.reject(_error);
	        });
	    }
	}
	class _RemoteWorkspaceImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    applyEdit(paramOrEdit) {
	        function isApplyWorkspaceEditParams(value) {
	            return value && !!value.edit;
	        }
	        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
	        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
	    }
	}
	const RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
	class TracerImpl {
	    constructor() {
	        this._trace = vscode_languageserver_protocol_1.Trace.Off;
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    set trace(value) {
	        this._trace = value;
	    }
	    log(message, verbose) {
	        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
	            return;
	        }
	        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
	            message: message,
	            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
	        }).catch(() => {
	            // Very hard to decide what to do. We tried to send a log
	            // message which failed so we can't simply send another :-(.
	        });
	    }
	}
	class TelemetryImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    logEvent(data) {
	        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
	            this.connection.console.log(`Sending TelemetryEventNotification failed`);
	        });
	    }
	}
	class _LanguagesImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    attachWorkDoneProgress(params) {
	        return (0, progress_1.attachWorkDone)(this.connection, params);
	    }
	    attachPartialResultProgress(_type, params) {
	        return (0, progress_1.attachPartialResult)(this.connection, params);
	    }
	}
	server$2._LanguagesImpl = _LanguagesImpl;
	const LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
	class _NotebooksImpl {
	    constructor() {
	    }
	    attach(connection) {
	        this._connection = connection;
	    }
	    get connection() {
	        if (!this._connection) {
	            throw new Error('Remote is not attached to a connection yet.');
	        }
	        return this._connection;
	    }
	    initialize(_capabilities) {
	    }
	    fillServerCapabilities(_capabilities) {
	    }
	    attachWorkDoneProgress(params) {
	        return (0, progress_1.attachWorkDone)(this.connection, params);
	    }
	    attachPartialResultProgress(_type, params) {
	        return (0, progress_1.attachPartialResult)(this.connection, params);
	    }
	}
	server$2._NotebooksImpl = _NotebooksImpl;
	const NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
	function combineConsoleFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineConsoleFeatures = combineConsoleFeatures;
	function combineTelemetryFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineTelemetryFeatures = combineTelemetryFeatures;
	function combineTracerFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineTracerFeatures = combineTracerFeatures;
	function combineClientFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineClientFeatures = combineClientFeatures;
	function combineWindowFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineWindowFeatures = combineWindowFeatures;
	function combineWorkspaceFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineWorkspaceFeatures = combineWorkspaceFeatures;
	function combineLanguagesFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineLanguagesFeatures = combineLanguagesFeatures;
	function combineNotebooksFeatures(one, two) {
	    return function (Base) {
	        return two(one(Base));
	    };
	}
	server$2.combineNotebooksFeatures = combineNotebooksFeatures;
	function combineFeatures(one, two) {
	    function combine(one, two, func) {
	        if (one && two) {
	            return func(one, two);
	        }
	        else if (one) {
	            return one;
	        }
	        else {
	            return two;
	        }
	    }
	    let result = {
	        __brand: 'features',
	        console: combine(one.console, two.console, combineConsoleFeatures),
	        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
	        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
	        client: combine(one.client, two.client, combineClientFeatures),
	        window: combine(one.window, two.window, combineWindowFeatures),
	        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
	        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
	        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
	    };
	    return result;
	}
	server$2.combineFeatures = combineFeatures;
	function createConnection(connectionFactory, watchDog, factories) {
	    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
	    const connection = connectionFactory(logger);
	    logger.rawAttach(connection);
	    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
	    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
	    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
	    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
	    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
	    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
	    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());
	    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
	    function asPromise(value) {
	        if (value instanceof Promise) {
	            return value;
	        }
	        else if (Is.thenable(value)) {
	            return new Promise((resolve, reject) => {
	                value.then((resolved) => resolve(resolved), (error) => reject(error));
	            });
	        }
	        else {
	            return Promise.resolve(value);
	        }
	    }
	    let shutdownHandler = undefined;
	    let initializeHandler = undefined;
	    let exitHandler = undefined;
	    let protocolConnection = {
	        listen: () => connection.listen(),
	        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
	        onRequest: (type, handler) => connection.onRequest(type, handler),
	        sendNotification: (type, param) => {
	            const method = Is.string(type) ? type : type.method;
	            return connection.sendNotification(method, param);
	        },
	        onNotification: (type, handler) => connection.onNotification(type, handler),
	        onProgress: connection.onProgress,
	        sendProgress: connection.sendProgress,
	        onInitialize: (handler) => {
	            initializeHandler = handler;
	            return {
	                dispose: () => {
	                    initializeHandler = undefined;
	                }
	            };
	        },
	        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
	        onShutdown: (handler) => {
	            shutdownHandler = handler;
	            return {
	                dispose: () => {
	                    shutdownHandler = undefined;
	                }
	            };
	        },
	        onExit: (handler) => {
	            exitHandler = handler;
	            return {
	                dispose: () => {
	                    exitHandler = undefined;
	                }
	            };
	        },
	        get console() { return logger; },
	        get telemetry() { return telemetry; },
	        get tracer() { return tracer; },
	        get client() { return client; },
	        get window() { return remoteWindow; },
	        get workspace() { return workspace; },
	        get languages() { return languages; },
	        get notebooks() { return notebooks; },
	        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
	        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
	        __textDocumentSync: undefined,
	        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
	        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
	        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
	        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
	        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
	        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
	        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
	        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
	        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
	        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
	            return handler(params, cancel);
	        }),
	        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
	        }),
	        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
	            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
	        }),
	        dispose: () => connection.dispose()
	    };
	    for (let remote of allRemotes) {
	        remote.attach(protocolConnection);
	    }
	    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
	        watchDog.initialize(params);
	        if (Is.string(params.trace)) {
	            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
	        }
	        for (let remote of allRemotes) {
	            remote.initialize(params.capabilities);
	        }
	        if (initializeHandler) {
	            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);
	            return asPromise(result).then((value) => {
	                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
	                    return value;
	                }
	                let result = value;
	                if (!result) {
	                    result = { capabilities: {} };
	                }
	                let capabilities = result.capabilities;
	                if (!capabilities) {
	                    capabilities = {};
	                    result.capabilities = capabilities;
	                }
	                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
	                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
	                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
	                }
	                for (let remote of allRemotes) {
	                    remote.fillServerCapabilities(capabilities);
	                }
	                return result;
	            });
	        }
	        else {
	            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
	            for (let remote of allRemotes) {
	                remote.fillServerCapabilities(result.capabilities);
	            }
	            return result;
	        }
	    });
	    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
	        watchDog.shutdownReceived = true;
	        if (shutdownHandler) {
	            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
	        }
	        else {
	            return undefined;
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
	        try {
	            if (exitHandler) {
	                exitHandler();
	            }
	        }
	        finally {
	            if (watchDog.shutdownReceived) {
	                watchDog.exit(0);
	            }
	            else {
	                watchDog.exit(1);
	            }
	        }
	    });
	    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
	        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
	    });
	    return protocolConnection;
	}
	server$2.createConnection = createConnection;
	return server$2;
}

var files = {};

var hasRequiredFiles;

function requireFiles () {
	if (hasRequiredFiles) return files;
	hasRequiredFiles = 1;
	/* --------------------------------------------------------------------------------------------
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License. See License.txt in the project root for license information.
	 * ------------------------------------------------------------------------------------------ */
	Object.defineProperty(files, "__esModule", { value: true });
	files.resolveModulePath = files.FileSystem = files.resolveGlobalYarnPath = files.resolveGlobalNodePath = files.resolve = files.uriToFilePath = void 0;
	const url = require$$0$2;
	const path = path$1;
	const fs$1 = fs;
	const child_process_1 = require$$3$1;
	/**
	 * @deprecated Use the `vscode-uri` npm module which provides a more
	 * complete implementation of handling VS Code URIs.
	 */
	function uriToFilePath(uri) {
	    let parsed = url.parse(uri);
	    if (parsed.protocol !== 'file:' || !parsed.path) {
	        return undefined;
	    }
	    let segments = parsed.path.split('/');
	    for (var i = 0, len = segments.length; i < len; i++) {
	        segments[i] = decodeURIComponent(segments[i]);
	    }
	    if (process.platform === 'win32' && segments.length > 1) {
	        let first = segments[0];
	        let second = segments[1];
	        // Do we have a drive letter and we started with a / which is the
	        // case if the first segement is empty (see split above)
	        if (first.length === 0 && second.length > 1 && second[1] === ':') {
	            // Remove first slash
	            segments.shift();
	        }
	    }
	    return path.normalize(segments.join('/'));
	}
	files.uriToFilePath = uriToFilePath;
	function isWindows() {
	    return process.platform === 'win32';
	}
	function resolve(moduleName, nodePath, cwd, tracer) {
	    const nodePathKey = 'NODE_PATH';
	    const app = [
	        'var p = process;',
	        'p.on(\'message\',function(m){',
	        'if(m.c===\'e\'){',
	        'p.exit(0);',
	        '}',
	        'else if(m.c===\'rs\'){',
	        'try{',
	        'var r=require.resolve(m.a);',
	        'p.send({c:\'r\',s:true,r:r});',
	        '}',
	        'catch(err){',
	        'p.send({c:\'r\',s:false});',
	        '}',
	        '}',
	        '});'
	    ].join('');
	    return new Promise((resolve, reject) => {
	        let env = process.env;
	        let newEnv = Object.create(null);
	        Object.keys(env).forEach(key => newEnv[key] = env[key]);
	        if (nodePath && fs$1.existsSync(nodePath) /* see issue 545 */) {
	            if (newEnv[nodePathKey]) {
	                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
	            }
	            else {
	                newEnv[nodePathKey] = nodePath;
	            }
	            if (tracer) {
	                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
	            }
	        }
	        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
	        try {
	            let cp = (0, child_process_1.fork)('', [], {
	                cwd: cwd,
	                env: newEnv,
	                execArgv: ['-e', app]
	            });
	            if (cp.pid === void 0) {
	                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
	                return;
	            }
	            cp.on('error', (error) => {
	                reject(error);
	            });
	            cp.on('message', (message) => {
	                if (message.c === 'r') {
	                    cp.send({ c: 'e' });
	                    if (message.s) {
	                        resolve(message.r);
	                    }
	                    else {
	                        reject(new Error(`Failed to resolve module: ${moduleName}`));
	                    }
	                }
	            });
	            let message = {
	                c: 'rs',
	                a: moduleName
	            };
	            cp.send(message);
	        }
	        catch (error) {
	            reject(error);
	        }
	    });
	}
	files.resolve = resolve;
	/**
	 * Resolve the global npm package path.
	 * @deprecated Since this depends on the used package manager and their version the best is that servers
	 * implement this themselves since they know best what kind of package managers to support.
	 * @param tracer the tracer to use
	 */
	function resolveGlobalNodePath(tracer) {
	    let npmCommand = 'npm';
	    const env = Object.create(null);
	    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
	    env['NO_UPDATE_NOTIFIER'] = 'true';
	    const options = {
	        encoding: 'utf8',
	        env
	    };
	    if (isWindows()) {
	        npmCommand = 'npm.cmd';
	        options.shell = true;
	    }
	    let handler = () => { };
	    try {
	        process.on('SIGPIPE', handler);
	        let stdout = (0, child_process_1.spawnSync)(npmCommand, ['config', 'get', 'prefix'], options).stdout;
	        if (!stdout) {
	            if (tracer) {
	                tracer(`'npm config get prefix' didn't return a value.`);
	            }
	            return undefined;
	        }
	        let prefix = stdout.trim();
	        if (tracer) {
	            tracer(`'npm config get prefix' value is: ${prefix}`);
	        }
	        if (prefix.length > 0) {
	            if (isWindows()) {
	                return path.join(prefix, 'node_modules');
	            }
	            else {
	                return path.join(prefix, 'lib', 'node_modules');
	            }
	        }
	        return undefined;
	    }
	    catch (err) {
	        return undefined;
	    }
	    finally {
	        process.removeListener('SIGPIPE', handler);
	    }
	}
	files.resolveGlobalNodePath = resolveGlobalNodePath;
	/*
	 * Resolve the global yarn pakage path.
	 * @deprecated Since this depends on the used package manager and their version the best is that servers
	 * implement this themselves since they know best what kind of package managers to support.
	 * @param tracer the tracer to use
	 */
	function resolveGlobalYarnPath(tracer) {
	    let yarnCommand = 'yarn';
	    let options = {
	        encoding: 'utf8'
	    };
	    if (isWindows()) {
	        yarnCommand = 'yarn.cmd';
	        options.shell = true;
	    }
	    let handler = () => { };
	    try {
	        process.on('SIGPIPE', handler);
	        let results = (0, child_process_1.spawnSync)(yarnCommand, ['global', 'dir', '--json'], options);
	        let stdout = results.stdout;
	        if (!stdout) {
	            if (tracer) {
	                tracer(`'yarn global dir' didn't return a value.`);
	                if (results.stderr) {
	                    tracer(results.stderr);
	                }
	            }
	            return undefined;
	        }
	        let lines = stdout.trim().split(/\r?\n/);
	        for (let line of lines) {
	            try {
	                let yarn = JSON.parse(line);
	                if (yarn.type === 'log') {
	                    return path.join(yarn.data, 'node_modules');
	                }
	            }
	            catch (e) {
	                // Do nothing. Ignore the line
	            }
	        }
	        return undefined;
	    }
	    catch (err) {
	        return undefined;
	    }
	    finally {
	        process.removeListener('SIGPIPE', handler);
	    }
	}
	files.resolveGlobalYarnPath = resolveGlobalYarnPath;
	var FileSystem;
	(function (FileSystem) {
	    let _isCaseSensitive = undefined;
	    function isCaseSensitive() {
	        if (_isCaseSensitive !== void 0) {
	            return _isCaseSensitive;
	        }
	        if (process.platform === 'win32') {
	            _isCaseSensitive = false;
	        }
	        else {
	            // convert current file name to upper case / lower case and check if file exists
	            // (guards against cases when name is already all uppercase or lowercase)
	            _isCaseSensitive = !fs$1.existsSync(__filename.toUpperCase()) || !fs$1.existsSync(__filename.toLowerCase());
	        }
	        return _isCaseSensitive;
	    }
	    FileSystem.isCaseSensitive = isCaseSensitive;
	    function isParent(parent, child) {
	        if (isCaseSensitive()) {
	            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
	        }
	        else {
	            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
	        }
	    }
	    FileSystem.isParent = isParent;
	})(FileSystem || (files.FileSystem = FileSystem = {}));
	function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
	    if (nodePath) {
	        if (!path.isAbsolute(nodePath)) {
	            nodePath = path.join(workspaceRoot, nodePath);
	        }
	        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
	            if (FileSystem.isParent(nodePath, value)) {
	                return value;
	            }
	            else {
	                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
	            }
	        }).then(undefined, (_error) => {
	            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
	        });
	    }
	    else {
	        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
	    }
	}
	files.resolveModulePath = resolveModulePath;
	return files;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node$2;
var hasRequiredNode$3;

function requireNode$3 () {
	if (hasRequiredNode$3) return node$2;
	hasRequiredNode$3 = 1;

	node$2 = requireMain$3();
	return node$2;
}

var api = {};

var inlineCompletion_proposed = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var hasRequiredInlineCompletion_proposed;

function requireInlineCompletion_proposed () {
	if (hasRequiredInlineCompletion_proposed) return inlineCompletion_proposed;
	hasRequiredInlineCompletion_proposed = 1;
	Object.defineProperty(inlineCompletion_proposed, "__esModule", { value: true });
	inlineCompletion_proposed.InlineCompletionFeature = void 0;
	const vscode_languageserver_protocol_1 = requireMain$3();
	const InlineCompletionFeature = (Base) => {
	    return class extends Base {
	        get inlineCompletion() {
	            return {
	                on: (handler) => {
	                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
	                        return handler(params, cancel, this.attachWorkDoneProgress(params));
	                    });
	                }
	            };
	        }
	    };
	};
	inlineCompletion_proposed.InlineCompletionFeature = InlineCompletionFeature;
	return inlineCompletion_proposed;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		var __createBinding = (api && api.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (api && api.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.ProposedFeatures = exports$1.NotebookDocuments = exports$1.TextDocuments = exports$1.SemanticTokensBuilder = void 0;
		const semanticTokens_1 = requireSemanticTokens();
		Object.defineProperty(exports$1, "SemanticTokensBuilder", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });
		const ic = requireInlineCompletion_proposed();
		__exportStar(requireMain$3(), exports$1);
		const textDocuments_1 = requireTextDocuments$1();
		Object.defineProperty(exports$1, "TextDocuments", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });
		const notebook_1 = requireNotebook();
		Object.defineProperty(exports$1, "NotebookDocuments", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });
		__exportStar(requireServer$1(), exports$1);
		var ProposedFeatures;
		(function (ProposedFeatures) {
		    ProposedFeatures.all = {
		        __brand: 'features',
		        languages: ic.InlineCompletionFeature
		    };
		})(ProposedFeatures || (exports$1.ProposedFeatures = ProposedFeatures = {})); 
	} (api));
	return api;
}

var hasRequiredMain$2;

function requireMain$2 () {
	if (hasRequiredMain$2) return main$6;
	hasRequiredMain$2 = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		/// <reference path="../../typings/thenable.d.ts" />
		var __createBinding = (main$6 && main$6.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (main$6 && main$6.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createConnection = exports$1.Files = void 0;
		const node_util_1 = __require();
		const Is = requireIs$2();
		const server_1 = requireServer$1();
		const fm = requireFiles();
		const node_1 = requireNode$3();
		__exportStar(requireNode$3(), exports$1);
		__exportStar(requireApi(), exports$1);
		var Files;
		(function (Files) {
		    Files.uriToFilePath = fm.uriToFilePath;
		    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
		    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
		    Files.resolve = fm.resolve;
		    Files.resolveModulePath = fm.resolveModulePath;
		})(Files || (exports$1.Files = Files = {}));
		function endProtocolConnection() {
		    {
		        return;
		    }
		}
		let _shutdownReceived = false;
		let exitTimer = undefined;
		function setupExitTimer() {
		    const argName = '--clientProcessId';
		    function runTimer(value) {
		        try {
		            let processId = parseInt(value);
		            if (!isNaN(processId)) {
		                exitTimer = setInterval(() => {
		                    try {
		                        process.kill(processId, 0);
		                    }
		                    catch (ex) {
		                        // Parent process doesn't exist anymore. Exit the server.
		                        endProtocolConnection();
		                        process.exit(_shutdownReceived ? 0 : 1);
		                    }
		                }, 3000);
		            }
		        }
		        catch (e) {
		            // Ignore errors;
		        }
		    }
		    for (let i = 2; i < process.argv.length; i++) {
		        let arg = process.argv[i];
		        if (arg === argName && i + 1 < process.argv.length) {
		            runTimer(process.argv[i + 1]);
		            return;
		        }
		        else {
		            let args = arg.split('=');
		            if (args[0] === argName) {
		                runTimer(args[1]);
		            }
		        }
		    }
		}
		setupExitTimer();
		const watchDog = {
		    initialize: (params) => {
		        const processId = params.processId;
		        if (Is.number(processId) && exitTimer === undefined) {
		            // We received a parent process id. Set up a timer to periodically check
		            // if the parent is still alive.
		            setInterval(() => {
		                try {
		                    process.kill(processId, 0);
		                }
		                catch (ex) {
		                    // Parent process doesn't exist anymore. Exit the server.
		                    process.exit(_shutdownReceived ? 0 : 1);
		                }
		            }, 3000);
		        }
		    },
		    get shutdownReceived() {
		        return _shutdownReceived;
		    },
		    set shutdownReceived(value) {
		        _shutdownReceived = value;
		    },
		    exit: (code) => {
		        process.exit(code);
		    }
		};
		function createConnection(arg1, arg2, arg3, arg4) {
		    let factories;
		    let input;
		    let output;
		    let options;
		    if (arg1 !== void 0 && arg1.__brand === 'features') {
		        factories = arg1;
		        arg1 = arg2;
		        arg2 = arg3;
		        arg3 = arg4;
		    }
		    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
		        options = arg1;
		    }
		    else {
		        input = arg1;
		        output = arg2;
		        options = arg3;
		    }
		    return _createConnection(input, output, options, factories);
		}
		exports$1.createConnection = createConnection;
		function _createConnection(input, output, options, factories) {
		    let stdio = false;
		    if (!input && !output && process.argv.length > 2) {
		        let port = void 0;
		        let pipeName = void 0;
		        let argv = process.argv.slice(2);
		        for (let i = 0; i < argv.length; i++) {
		            let arg = argv[i];
		            if (arg === '--node-ipc') {
		                input = new node_1.IPCMessageReader(process);
		                output = new node_1.IPCMessageWriter(process);
		                break;
		            }
		            else if (arg === '--stdio') {
		                stdio = true;
		                input = process.stdin;
		                output = process.stdout;
		                break;
		            }
		            else if (arg === '--socket') {
		                port = parseInt(argv[i + 1]);
		                break;
		            }
		            else if (arg === '--pipe') {
		                pipeName = argv[i + 1];
		                break;
		            }
		            else {
		                var args = arg.split('=');
		                if (args[0] === '--socket') {
		                    port = parseInt(args[1]);
		                    break;
		                }
		                else if (args[0] === '--pipe') {
		                    pipeName = args[1];
		                    break;
		                }
		            }
		        }
		        if (port) {
		            let transport = (0, node_1.createServerSocketTransport)(port);
		            input = transport[0];
		            output = transport[1];
		        }
		        else if (pipeName) {
		            let transport = (0, node_1.createServerPipeTransport)(pipeName);
		            input = transport[0];
		            output = transport[1];
		        }
		    }
		    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
		    if (!input) {
		        throw new Error('Connection input stream is not set. ' + commandLineMessage);
		    }
		    if (!output) {
		        throw new Error('Connection output stream is not set. ' + commandLineMessage);
		    }
		    // Backwards compatibility
		    if (Is.func(input.read) && Is.func(input.on)) {
		        let inputStream = input;
		        inputStream.on('end', () => {
		            process.exit(_shutdownReceived ? 0 : 1);
		        });
		        inputStream.on('close', () => {
		            process.exit(_shutdownReceived ? 0 : 1);
		        });
		    }
		    const connectionFactory = (logger) => {
		        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
		        if (stdio) {
		            patchConsole(logger);
		        }
		        return result;
		    };
		    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
		}
		function patchConsole(logger) {
		    function serialize(args) {
		        return args.map(arg => typeof arg === 'string' ? arg : (0, node_util_1.inspect)(arg)).join(' ');
		    }
		    const counters = new Map();
		    console.assert = function assert(assertion, ...args) {
		        if (assertion) {
		            return;
		        }
		        if (args.length === 0) {
		            logger.error('Assertion failed');
		        }
		        else {
		            const [message, ...rest] = args;
		            logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
		        }
		    };
		    console.count = function count(label = 'default') {
		        const message = String(label);
		        let counter = counters.get(message) ?? 0;
		        counter += 1;
		        counters.set(message, counter);
		        logger.log(`${message}: ${message}`);
		    };
		    console.countReset = function countReset(label) {
		        if (label === undefined) {
		            counters.clear();
		        }
		        else {
		            counters.delete(String(label));
		        }
		    };
		    console.debug = function debug(...args) {
		        logger.log(serialize(args));
		    };
		    console.dir = function dir(arg, options) {
		        // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66626
		        logger.log((0, node_util_1.inspect)(arg, options));
		    };
		    console.log = function log(...args) {
		        logger.log(serialize(args));
		    };
		    console.error = function error(...args) {
		        logger.error(serialize(args));
		    };
		    console.trace = function trace(...args) {
		        const stack = new Error().stack.replace(/(.+\n){2}/, '');
		        let message = 'Trace';
		        if (args.length !== 0) {
		            message += `: ${serialize(args)}`;
		        }
		        logger.log(`${message}\n${stack}`);
		    };
		    console.warn = function warn(...args) {
		        logger.warn(serialize(args));
		    };
		} 
	} (main$6));
	return main$6;
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */

var node$1;
var hasRequiredNode$2;

function requireNode$2 () {
	if (hasRequiredNode$2) return node$1;
	hasRequiredNode$2 = 1;

	node$1 = requireMain$2();
	return node$1;
}

var http = {};

var languageService$1 = {};

var languageCore = {};

var sourceMap$1 = {};

var sourceMap = {};

var binarySearch = {};

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	Object.defineProperty(binarySearch, "__esModule", { value: true });
	binarySearch.binarySearch = binarySearch$1;
	function binarySearch$1(values, searchValue) {
	    let low = 0;
	    let high = values.length - 1;
	    let match;
	    while (low <= high) {
	        const mid = Math.floor((low + high) / 2);
	        const midValue = values[mid];
	        if (midValue < searchValue) {
	            low = mid + 1;
	        }
	        else if (midValue > searchValue) {
	            high = mid - 1;
	        }
	        else {
	            low = mid;
	            high = mid;
	            match = mid;
	            break;
	        }
	    }
	    const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);
	    const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);
	    return { low: finalLow, high: finalHigh, match };
	}
	
	return binarySearch;
}

var translateOffset = {};

var hasRequiredTranslateOffset;

function requireTranslateOffset () {
	if (hasRequiredTranslateOffset) return translateOffset;
	hasRequiredTranslateOffset = 1;
	Object.defineProperty(translateOffset, "__esModule", { value: true });
	translateOffset.translateOffset = translateOffset$1;
	let warned = false;
	function translateOffset$1(start, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {
	    const isSorted = fromOffsets.every((value, index) => index === 0 || fromOffsets[index - 1] <= value);
	    if (!isSorted) {
	        for (let i = 0; i < fromOffsets.length; i++) {
	            const fromOffset = fromOffsets[i];
	            const fromLength = fromLengths[i];
	            if (start >= fromOffset && start <= fromOffset + fromLength) {
	                const toLength = toLengths[i];
	                const toOffset = toOffsets[i];
	                let rangeOffset = Math.min(start - fromOffset, toLength);
	                return toOffset + rangeOffset;
	            }
	        }
	        if (!warned) {
	            warned = true;
	            console.warn('fromOffsets should be sorted in ascending order');
	        }
	    }
	    let low = 0;
	    let high = fromOffsets.length - 1;
	    while (low <= high) {
	        const mid = Math.floor((low + high) / 2);
	        const fromOffset = fromOffsets[mid];
	        const fromLength = fromLengths[mid];
	        if (start >= fromOffset && start <= fromOffset + fromLength) {
	            const toLength = toLengths[mid];
	            const toOffset = toOffsets[mid];
	            let rangeOffset = Math.min(start - fromOffset, toLength);
	            return toOffset + rangeOffset;
	        }
	        else if (start < fromOffset) {
	            high = mid - 1;
	        }
	        else {
	            low = mid + 1;
	        }
	    }
	}
	
	return translateOffset;
}

var hasRequiredSourceMap$1;

function requireSourceMap$1 () {
	if (hasRequiredSourceMap$1) return sourceMap;
	hasRequiredSourceMap$1 = 1;
	Object.defineProperty(sourceMap, "__esModule", { value: true });
	sourceMap.SourceMap = void 0;
	const binarySearch_1 = requireBinarySearch();
	const translateOffset_1 = requireTranslateOffset();
	class SourceMap {
	    constructor(mappings) {
	        this.mappings = mappings;
	    }
	    toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {
	        return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, 'generatedOffsets', filter);
	    }
	    toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {
	        return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, 'sourceOffsets', filter);
	    }
	    toSourceLocation(generatedOffset, filter) {
	        return this.findMatchingOffsets(generatedOffset, 'generatedOffsets', filter);
	    }
	    toGeneratedLocation(sourceOffset, filter) {
	        return this.findMatchingOffsets(sourceOffset, 'sourceOffsets', filter);
	    }
	    *findMatchingOffsets(offset, fromRange, filter) {
	        const memo = this.getMemoBasedOnRange(fromRange);
	        if (memo.offsets.length === 0) {
	            return;
	        }
	        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);
	        const skip = new Set();
	        const toRange = fromRange === 'sourceOffsets' ? 'generatedOffsets' : 'sourceOffsets';
	        for (let i = start; i <= end; i++) {
	            for (const mapping of memo.mappings[i]) {
	                if (skip.has(mapping)) {
	                    continue;
	                }
	                skip.add(mapping);
	                if (filter && !filter(mapping.data)) {
	                    continue;
	                }
	                const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
	                if (mapped !== undefined) {
	                    yield [mapped, mapping];
	                }
	            }
	        }
	    }
	    *findMatchingStartEnd(start, end, fallbackToAnyMatch, fromRange, filter) {
	        const toRange = fromRange === 'sourceOffsets' ? 'generatedOffsets' : 'sourceOffsets';
	        const mappedStarts = [];
	        let hadMatch = false;
	        for (const [mappedStart, mapping] of this.findMatchingOffsets(start, fromRange)) {
	            if (filter && !filter(mapping.data)) {
	                continue;
	            }
	            mappedStarts.push([mappedStart, mapping]);
	            const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));
	            if (mappedEnd !== undefined) {
	                hadMatch = true;
	                yield [mappedStart, mappedEnd, mapping, mapping];
	            }
	        }
	        if (!hadMatch && fallbackToAnyMatch) {
	            for (const [mappedStart, mappingStart] of mappedStarts) {
	                for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {
	                    if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) {
	                        continue;
	                    }
	                    yield [mappedStart, mappedEnd, mappingStart, mappingEnd];
	                    break;
	                }
	            }
	        }
	    }
	    getMemoBasedOnRange(fromRange) {
	        return fromRange === 'sourceOffsets'
	            ? this.sourceCodeOffsetsMemo ??= this.createMemo('sourceOffsets')
	            : this.generatedCodeOffsetsMemo ??= this.createMemo('generatedOffsets');
	    }
	    createMemo(key) {
	        const offsetsSet = new Set();
	        for (const mapping of this.mappings) {
	            for (let i = 0; i < mapping[key].length; i++) {
	                offsetsSet.add(mapping[key][i]);
	                offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);
	            }
	        }
	        const offsets = [...offsetsSet].sort((a, b) => a - b);
	        const mappings = offsets.map(() => new Set());
	        for (const mapping of this.mappings) {
	            for (let i = 0; i < mapping[key].length; i++) {
	                const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;
	                const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;
	                for (let i = startIndex; i <= endIndex; i++) {
	                    mappings[i].add(mapping);
	                }
	            }
	        }
	        return { offsets, mappings };
	    }
	}
	sourceMap.SourceMap = SourceMap;
	function getLengths(mapping, key) {
	    return key === 'sourceOffsets' ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;
	}
	
	return sourceMap;
}

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap$1;
	hasRequiredSourceMap = 1;
	(function (exports$1) {
		var __createBinding = (sourceMap$1 && sourceMap$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (sourceMap$1 && sourceMap$1.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		__exportStar(requireSourceMap$1(), exports$1);
		__exportStar(requireTranslateOffset(), exports$1);
		
	} (sourceMap$1));
	return sourceMap$1;
}

var editor = {};

var hasRequiredEditor;

function requireEditor () {
	if (hasRequiredEditor) return editor;
	hasRequiredEditor = 1;
	Object.defineProperty(editor, "__esModule", { value: true });
	editor.isHoverEnabled = isHoverEnabled;
	editor.isInlayHintsEnabled = isInlayHintsEnabled;
	editor.isCodeLensEnabled = isCodeLensEnabled;
	editor.isMonikerEnabled = isMonikerEnabled;
	editor.isInlineValueEnabled = isInlineValueEnabled;
	editor.isSemanticTokensEnabled = isSemanticTokensEnabled;
	editor.isCallHierarchyEnabled = isCallHierarchyEnabled;
	editor.isTypeHierarchyEnabled = isTypeHierarchyEnabled;
	editor.isRenameEnabled = isRenameEnabled;
	editor.isDefinitionEnabled = isDefinitionEnabled;
	editor.isTypeDefinitionEnabled = isTypeDefinitionEnabled;
	editor.isReferencesEnabled = isReferencesEnabled;
	editor.isImplementationEnabled = isImplementationEnabled;
	editor.isHighlightEnabled = isHighlightEnabled;
	editor.isSymbolsEnabled = isSymbolsEnabled;
	editor.isFoldingRangesEnabled = isFoldingRangesEnabled;
	editor.isSelectionRangesEnabled = isSelectionRangesEnabled;
	editor.isLinkedEditingEnabled = isLinkedEditingEnabled;
	editor.isColorEnabled = isColorEnabled;
	editor.isDocumentLinkEnabled = isDocumentLinkEnabled;
	editor.isDiagnosticsEnabled = isDiagnosticsEnabled;
	editor.isCodeActionsEnabled = isCodeActionsEnabled;
	editor.isFormattingEnabled = isFormattingEnabled;
	editor.isCompletionEnabled = isCompletionEnabled;
	editor.isAutoInsertEnabled = isAutoInsertEnabled;
	editor.isSignatureHelpEnabled = isSignatureHelpEnabled;
	editor.shouldReportDiagnostics = shouldReportDiagnostics;
	editor.resolveRenameNewName = resolveRenameNewName;
	editor.resolveRenameEditText = resolveRenameEditText;
	editor.findOverlapCodeRange = findOverlapCodeRange;
	function isHoverEnabled(info) {
	    return !!info.semantic;
	}
	function isInlayHintsEnabled(info) {
	    return !!info.semantic;
	}
	function isCodeLensEnabled(info) {
	    return !!info.semantic;
	}
	function isMonikerEnabled(info) {
	    return !!info.semantic;
	}
	function isInlineValueEnabled(info) {
	    return !!info.semantic;
	}
	function isSemanticTokensEnabled(info) {
	    return typeof info.semantic === 'object'
	        ? info.semantic.shouldHighlight?.() ?? true
	        : !!info.semantic;
	}
	function isCallHierarchyEnabled(info) {
	    return !!info.navigation;
	}
	function isTypeHierarchyEnabled(info) {
	    return !!info.navigation;
	}
	function isRenameEnabled(info) {
	    return typeof info.navigation === 'object'
	        ? info.navigation.shouldRename?.() ?? true
	        : !!info.navigation;
	}
	function isDefinitionEnabled(info) {
	    return !!info.navigation;
	}
	function isTypeDefinitionEnabled(info) {
	    return !!info.navigation;
	}
	function isReferencesEnabled(info) {
	    return !!info.navigation;
	}
	function isImplementationEnabled(info) {
	    return !!info.navigation;
	}
	function isHighlightEnabled(info) {
	    return typeof info.navigation === 'object'
	        ? info.navigation.shouldHighlight?.() ?? true
	        : !!info.navigation;
	}
	function isSymbolsEnabled(info) {
	    return !!info.structure;
	}
	function isFoldingRangesEnabled(info) {
	    return !!info.structure;
	}
	function isSelectionRangesEnabled(info) {
	    return !!info.structure;
	}
	function isLinkedEditingEnabled(info) {
	    return !!info.structure;
	}
	function isColorEnabled(info) {
	    return !!info.structure;
	}
	function isDocumentLinkEnabled(info) {
	    return !!info.structure;
	}
	function isDiagnosticsEnabled(info) {
	    return !!info.verification;
	}
	function isCodeActionsEnabled(info) {
	    return !!info.verification;
	}
	function isFormattingEnabled(info) {
	    return !!info.format;
	}
	function isCompletionEnabled(info) {
	    return !!info.completion;
	}
	function isAutoInsertEnabled(info) {
	    return !!info.completion;
	}
	function isSignatureHelpEnabled(info) {
	    return !!info.completion;
	}
	// should...
	function shouldReportDiagnostics(info, source, code) {
	    return typeof info.verification === 'object'
	        ? info.verification.shouldReport?.(source, code) ?? true
	        : !!info.verification;
	}
	//  resolve...
	function resolveRenameNewName(newName, info) {
	    return typeof info.navigation === 'object'
	        ? info.navigation.resolveRenameNewName?.(newName) ?? newName
	        : newName;
	}
	function resolveRenameEditText(text, info) {
	    return typeof info.navigation === 'object'
	        ? info.navigation.resolveRenameEditText?.(text) ?? text
	        : text;
	}
	function findOverlapCodeRange(start, end, map, filter) {
	    let mappedStart;
	    let mappedEnd;
	    for (const [mapped, mapping] of map.toGeneratedLocation(start)) {
	        if (filter(mapping.data)) {
	            mappedStart = mapped;
	            break;
	        }
	    }
	    for (const [mapped, mapping] of map.toGeneratedLocation(end)) {
	        if (filter(mapping.data)) {
	            mappedEnd = mapped;
	            break;
	        }
	    }
	    if (mappedStart === undefined || mappedEnd === undefined) {
	        for (const mapping of map.mappings) {
	            if (filter(mapping.data)) {
	                const mappingStart = mapping.sourceOffsets[0];
	                const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1]
	                    + mapping.lengths[mapping.lengths.length - 1];
	                const overlap = getOverlapRange(start, end, mappingStart, mappingEnd);
	                if (overlap) {
	                    const curMappedStart = (overlap.start - mappingStart) + mapping.generatedOffsets[0];
	                    const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];
	                    const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);
	                    const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;
	                    mappedStart = mappedStart === undefined ? curMappedStart : Math.min(mappedStart, curMappedStart);
	                    mappedEnd = mappedEnd === undefined ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);
	                }
	            }
	        }
	    }
	    if (mappedStart !== undefined && mappedEnd !== undefined) {
	        return {
	            start: mappedStart,
	            end: mappedEnd,
	        };
	    }
	}
	function getOverlapRange(range1Start, range1End, range2Start, range2End) {
	    const start = Math.max(range1Start, range2Start);
	    const end = Math.min(range1End, range2End);
	    if (start > end) {
	        return undefined;
	    }
	    return {
	        start,
	        end,
	    };
	}
	
	return editor;
}

var linkedCodeMap = {};

var hasRequiredLinkedCodeMap;

function requireLinkedCodeMap () {
	if (hasRequiredLinkedCodeMap) return linkedCodeMap;
	hasRequiredLinkedCodeMap = 1;
	Object.defineProperty(linkedCodeMap, "__esModule", { value: true });
	linkedCodeMap.LinkedCodeMap = void 0;
	const source_map_1 = requireSourceMap();
	class LinkedCodeMap extends source_map_1.SourceMap {
	    *getLinkedOffsets(start) {
	        for (const mapped of this.toGeneratedLocation(start)) {
	            yield mapped[0];
	        }
	        for (const mapped of this.toSourceLocation(start)) {
	            yield mapped[0];
	        }
	    }
	}
	linkedCodeMap.LinkedCodeMap = LinkedCodeMap;
	
	return linkedCodeMap;
}

var types$2 = {};

var hasRequiredTypes$2;

function requireTypes$2 () {
	if (hasRequiredTypes$2) return types$2;
	hasRequiredTypes$2 = 1;
	Object.defineProperty(types$2, "__esModule", { value: true });
	
	return types$2;
}

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.FileMap = void 0;
	class FileMap extends Map {
	    constructor(caseSensitive) {
	        super();
	        this.caseSensitive = caseSensitive;
	        this.originalFileNames = new Map();
	    }
	    keys() {
	        return this.originalFileNames.values();
	    }
	    get(key) {
	        return super.get(this.normalizeId(key));
	    }
	    has(key) {
	        return super.has(this.normalizeId(key));
	    }
	    set(key, value) {
	        this.originalFileNames.set(this.normalizeId(key), key);
	        return super.set(this.normalizeId(key), value);
	    }
	    delete(key) {
	        this.originalFileNames.delete(this.normalizeId(key));
	        return super.delete(this.normalizeId(key));
	    }
	    clear() {
	        this.originalFileNames.clear();
	        return super.clear();
	    }
	    normalizeId(id) {
	        return this.caseSensitive ? id : id.toLowerCase();
	    }
	}
	utils$1.FileMap = FileMap;
	
	return utils$1;
}

var hasRequiredLanguageCore;

function requireLanguageCore () {
	if (hasRequiredLanguageCore) return languageCore;
	hasRequiredLanguageCore = 1;
	(function (exports$1) {
		var __createBinding = (languageCore && languageCore.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (languageCore && languageCore.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.defaultMapperFactory = exports$1.SourceMap = void 0;
		exports$1.createLanguage = createLanguage;
		exports$1.forEachEmbeddedCode = forEachEmbeddedCode;
		var source_map_1 = requireSourceMap();
		Object.defineProperty(exports$1, "SourceMap", { enumerable: true, get: function () { return source_map_1.SourceMap; } });
		__exportStar(requireEditor(), exports$1);
		__exportStar(requireLinkedCodeMap(), exports$1);
		__exportStar(requireTypes$2(), exports$1);
		__exportStar(requireUtils$1(), exports$1);
		const source_map_2 = requireSourceMap();
		const linkedCodeMap_1 = requireLinkedCodeMap();
		const defaultMapperFactory = mappings => new source_map_2.SourceMap(mappings);
		exports$1.defaultMapperFactory = defaultMapperFactory;
		function createLanguage(plugins, scriptRegistry, sync, onAssociationDirty) {
		    const virtualCodeToSourceScriptMap = new WeakMap();
		    const virtualCodeToSourceMap = new WeakMap();
		    const virtualCodeToLinkedCodeMap = new WeakMap();
		    const language = {
		        mapperFactory: exports$1.defaultMapperFactory,
		        plugins,
		        scripts: {
		            fromVirtualCode(virtualCode) {
		                return virtualCodeToSourceScriptMap.get(virtualCode);
		            },
		            get(id, includeFsFiles = true, shouldRegister = false) {
		                sync(id, includeFsFiles, shouldRegister);
		                const result = scriptRegistry.get(id);
		                // The sync function provider may not always call the set function due to caching, so it is necessary to explicitly check isAssociationDirty.
		                if (result?.isAssociationDirty) {
		                    this.set(id, result.snapshot, result.languageId);
		                }
		                return scriptRegistry.get(id);
		            },
		            set(id, snapshot, languageId, _plugins = plugins) {
		                if (!languageId) {
		                    for (const plugin of plugins) {
		                        languageId = plugin.getLanguageId?.(id);
		                        if (languageId) {
		                            break;
		                        }
		                    }
		                }
		                if (!languageId) {
		                    console.warn(`languageId not found for ${String(id)}`);
		                    return;
		                }
		                let associatedOnly = false;
		                for (const plugin of plugins) {
		                    if (plugin.isAssociatedFileOnly?.(id, languageId)) {
		                        associatedOnly = true;
		                        break;
		                    }
		                }
		                if (scriptRegistry.has(id)) {
		                    const sourceScript = scriptRegistry.get(id);
		                    if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {
		                        this.delete(id);
		                        triggerTargetsDirty(sourceScript);
		                        return this.set(id, snapshot, languageId);
		                    }
		                    else if (associatedOnly) {
		                        if (sourceScript.snapshot !== snapshot) {
		                            sourceScript.snapshot = snapshot;
		                            triggerTargetsDirty(sourceScript);
		                        }
		                    }
		                    else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {
		                        if (sourceScript.snapshot !== snapshot) {
		                            sourceScript.snapshot = snapshot;
		                            triggerTargetsDirty(sourceScript);
		                        }
		                        const codegenCtx = prepareCreateVirtualCode(sourceScript);
		                        if (sourceScript.generated) {
		                            const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;
		                            const newVirtualCode = updateVirtualCode
		                                ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx)
		                                : createVirtualCode?.(id, languageId, snapshot, codegenCtx);
		                            if (newVirtualCode) {
		                                sourceScript.generated.root = newVirtualCode;
		                                sourceScript.generated.embeddedCodes.clear();
		                                for (const code of forEachEmbeddedCode(sourceScript.generated.root)) {
		                                    virtualCodeToSourceScriptMap.set(code, sourceScript);
		                                    sourceScript.generated.embeddedCodes.set(code.id, code);
		                                }
		                                return sourceScript;
		                            }
		                            else {
		                                this.delete(id);
		                                return;
		                            }
		                        }
		                    }
		                    else {
		                        // not changed
		                        return sourceScript;
		                    }
		                }
		                else {
		                    // created
		                    const sourceScript = {
		                        id: id,
		                        languageId,
		                        snapshot,
		                        associatedIds: new Set(),
		                        targetIds: new Set(),
		                        associatedOnly,
		                    };
		                    scriptRegistry.set(id, sourceScript);
		                    if (associatedOnly) {
		                        return sourceScript;
		                    }
		                    for (const languagePlugin of _plugins) {
		                        const virtualCode = languagePlugin.createVirtualCode?.(id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));
		                        if (virtualCode) {
		                            sourceScript.generated = {
		                                root: virtualCode,
		                                languagePlugin,
		                                embeddedCodes: new Map(),
		                            };
		                            for (const code of forEachEmbeddedCode(virtualCode)) {
		                                virtualCodeToSourceScriptMap.set(code, sourceScript);
		                                sourceScript.generated.embeddedCodes.set(code.id, code);
		                            }
		                            break;
		                        }
		                    }
		                    return sourceScript;
		                }
		            },
		            delete(id) {
		                const sourceScript = scriptRegistry.get(id);
		                if (sourceScript) {
		                    sourceScript.generated?.languagePlugin.disposeVirtualCode?.(id, sourceScript.generated.root);
		                    scriptRegistry.delete(id);
		                    triggerTargetsDirty(sourceScript);
		                }
		            },
		        },
		        maps: {
		            get(virtualCode, sourceScript) {
		                let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);
		                if (!mapCache) {
		                    virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = new WeakMap());
		                }
		                if (!mapCache.has(sourceScript.snapshot)) {
		                    const mappings = virtualCode.associatedScriptMappings?.get(sourceScript.id) ?? virtualCode.mappings;
		                    mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));
		                }
		                return mapCache.get(sourceScript.snapshot);
		            },
		            *forEach(virtualCode) {
		                const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
		                yield [
		                    sourceScript,
		                    this.get(virtualCode, sourceScript),
		                ];
		                if (virtualCode.associatedScriptMappings) {
		                    for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {
		                        const relatedSourceScript = scriptRegistry.get(relatedScriptId);
		                        if (relatedSourceScript) {
		                            yield [
		                                relatedSourceScript,
		                                this.get(virtualCode, relatedSourceScript),
		                            ];
		                        }
		                    }
		                }
		            },
		        },
		        linkedCodeMaps: {
		            get(virtualCode) {
		                const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);
		                let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);
		                if (mapCache?.[0] !== sourceScript.snapshot) {
		                    virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [
		                        sourceScript.snapshot,
		                        virtualCode.linkedCodeMappings
		                            ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings)
		                            : undefined,
		                    ]);
		                }
		                return mapCache[1];
		            },
		        },
		    };
		    return language;
		    function triggerTargetsDirty(sourceScript) {
		        sourceScript.targetIds.forEach(id => {
		            const sourceScript = scriptRegistry.get(id);
		            if (sourceScript) {
		                sourceScript.isAssociationDirty = true;
		                onAssociationDirty?.(sourceScript.id);
		            }
		        });
		    }
		    function prepareCreateVirtualCode(sourceScript) {
		        for (const id of sourceScript.associatedIds) {
		            scriptRegistry.get(id)?.targetIds.delete(sourceScript.id);
		        }
		        sourceScript.associatedIds.clear();
		        sourceScript.isAssociationDirty = false;
		        return {
		            getAssociatedScript(id) {
		                sync(id, true, true);
		                const relatedSourceScript = scriptRegistry.get(id);
		                if (relatedSourceScript) {
		                    relatedSourceScript.targetIds.add(sourceScript.id);
		                    sourceScript.associatedIds.add(relatedSourceScript.id);
		                }
		                return relatedSourceScript;
		            },
		        };
		    }
		}
		function* forEachEmbeddedCode(virtualCode) {
		    yield virtualCode;
		    if (virtualCode.embeddedCodes) {
		        for (const embeddedCode of virtualCode.embeddedCodes) {
		            yield* forEachEmbeddedCode(embeddedCode);
		        }
		    }
		}
		
	} (languageCore));
	return languageCore;
}

var provideRenameEdits = {};

var umd$1 = {exports: {}};

var umd = umd$1.exports;

var hasRequiredUmd;

function requireUmd () {
	if (hasRequiredUmd) return umd$1.exports;
	hasRequiredUmd = 1;
	(function (module, exports$1) {
		!function(t,e){module.exports=e();}(umd,(()=>(()=>{var t={975:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else {if(47===r)break;r=47;}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){ -1===h?(n="",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=a,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2);}else n.length>0?n+="/"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0;}else 46===r&&-1!==s?++s:s=-1;}return n}var n={resolve:function(){for(var t,n="",i=false,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0));}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return ".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return ".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i);}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return "";if((t=n.resolve(t))===(r=n.resolve(r)))return "";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u);}var d="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+="..":d+="/..");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return ".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=true,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=false;return  -1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=true;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return "";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else  -1===h&&(s=false,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h));}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else  -1===o&&(s=false,o=n+1);return  -1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=true,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h) -1===i&&(o=false,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return  -1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,a=0,h=-1,c=true,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f))) -1===h&&(c=false,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return  -1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n;},70:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:true}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf("Windows")>=0;}},231:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:true}),e.uriToFsPath=e.URI=void 0;const n=r(70),i=/^\w[\w\d+.-]*$/,o=/^\//,s=/^\/\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!i.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const h="",c="/",f=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=false){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case "https":case "http":case "file":e?e[0]!==c&&(e=c+e):e=c;}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o));}get fsPath(){return v(this,false)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=false){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c);}return new d("file",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,true),e}toString(t=false){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,false)),this._fsPath}toString(t=false){return t?y(this,true):(this._formatted||(this._formatted=y(this,false)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s) -1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else { void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o);}}return  -1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r]);}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\//g,"\\")),r}function y(t,e){const r=e?m:g;let n="",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=c,n+=c),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,false,false):(n+=r(e.substr(0,t),false,false),n+=":",n+=r(e.substr(t+1),false,true)),n+="@";}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,false,true):(n+=r(o.substr(0,t),false,true),n+=o.substr(t));}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`);}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`);}n+=r(s,true,false);}return a&&(n+="?",n+=r(a,false,false)),h&&(n+="#",n+=e?h:g(h,false,false)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},552:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){ void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:true,get:function(){return e[r]}}),Object.defineProperty(t,n,i);}:function(t,e,r,n){ void 0===n&&(n=r),t[n]=e[r];}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:true,value:e});}:function(t,e){t.default=e;}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:true}),e.Utils=void 0;const s=o(r(975)),a=s.posix||s,h="/";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=false;r[0]!==h&&(r=h+r,n=true);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)};}(c||(e.Utils=c={}));}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return (()=>{var t=n;Object.defineProperty(t,"__esModule",{value:true}),t.Utils=t.URI=void 0;const e=r(231);Object.defineProperty(t,"URI",{enumerable:true,get:function(){return e.URI}});const i=r(552);Object.defineProperty(t,"Utils",{enumerable:true,get:function(){return i.Utils}});})(),n})()));
		
	} (umd$1));
	return umd$1.exports;
}

var cancellation = {};

var hasRequiredCancellation;

function requireCancellation () {
	if (hasRequiredCancellation) return cancellation;
	hasRequiredCancellation = 1;
	Object.defineProperty(cancellation, "__esModule", { value: true });
	cancellation.NoneCancellationToken = void 0;
	cancellation.NoneCancellationToken = {
	    isCancellationRequested: false,
	    onCancellationRequested: () => ({ dispose: () => { } }),
	};
	
	return cancellation;
}

var dedupe$1 = {};

var hasRequiredDedupe$1;

function requireDedupe$1 () {
	if (hasRequiredDedupe$1) return dedupe$1;
	hasRequiredDedupe$1 = 1;
	Object.defineProperty(dedupe$1, "__esModule", { value: true });
	dedupe$1.createLocationSet = createLocationSet;
	dedupe$1.withCodeAction = withCodeAction;
	dedupe$1.withTextEdits = withTextEdits;
	dedupe$1.withDocumentChanges = withDocumentChanges;
	dedupe$1.withDiagnostics = withDiagnostics;
	dedupe$1.withLocations = withLocations;
	dedupe$1.withLocationLinks = withLocationLinks;
	dedupe$1.withCallHierarchyIncomingCalls = withCallHierarchyIncomingCalls;
	dedupe$1.withCallHierarchyOutgoingCalls = withCallHierarchyOutgoingCalls;
	dedupe$1.withRanges = withRanges;
	function createLocationSet() {
	    const set = new Set();
	    return {
	        add,
	        has,
	    };
	    function add(item) {
	        if (has(item)) {
	            return false;
	        }
	        set.add(getKey(item));
	        return true;
	    }
	    function has(item) {
	        return set.has(getKey(item));
	    }
	    function getKey(item) {
	        return [
	            item.uri,
	            item.range.start.line,
	            item.range.start.character,
	            item.range.end.line,
	            item.range.end.character,
	        ].join(':');
	    }
	}
	function withCodeAction(items) {
	    return dedupe(items, item => [
	        item.title,
	    ].join(':'));
	}
	function withTextEdits(items) {
	    return dedupe(items, item => [
	        item.range.start.line,
	        item.range.start.character,
	        item.range.end.line,
	        item.range.end.character,
	        item.newText,
	    ].join(':'));
	}
	function withDocumentChanges(items) {
	    return dedupe(items, item => JSON.stringify(item)); // TODO: improve this
	}
	function withDiagnostics(items) {
	    return dedupe(items, item => [
	        item.range.start.line,
	        item.range.start.character,
	        item.range.end.line,
	        item.range.end.character,
	        item.source,
	        item.code,
	        item.severity,
	        item.message,
	    ].join(':'));
	}
	function withLocations(items) {
	    return dedupe(items, item => [
	        item.uri,
	        item.range.start.line,
	        item.range.start.character,
	        item.range.end.line,
	        item.range.end.character,
	    ].join(':'));
	}
	function withLocationLinks(items) {
	    return dedupe(items, item => [
	        item.targetUri,
	        item.targetSelectionRange.start.line,
	        item.targetSelectionRange.start.character,
	        item.targetSelectionRange.end.line,
	        item.targetSelectionRange.end.character,
	        // ignore difference targetRange
	    ].join(':'));
	}
	function withCallHierarchyIncomingCalls(items) {
	    return dedupe(items, item => [
	        item.from.uri,
	        item.from.range.start.line,
	        item.from.range.start.character,
	        item.from.range.end.line,
	        item.from.range.end.character,
	    ].join(':'));
	}
	function withCallHierarchyOutgoingCalls(items) {
	    return dedupe(items, item => [
	        item.to.uri,
	        item.to.range.start.line,
	        item.to.range.start.character,
	        item.to.range.end.line,
	        item.to.range.end.character,
	    ].join(':'));
	}
	function withRanges(items) {
	    return dedupe(items, item => [
	        item.start.line,
	        item.start.character,
	        item.end.line,
	        item.end.character,
	    ].join(':'));
	}
	function dedupe(items, getKey) {
	    const map = new Map();
	    for (const item of items.reverse()) {
	        map.set(getKey(item), item);
	    }
	    return [...map.values()];
	}
	
	return dedupe$1;
}

var featureWorkers = {};

var hasRequiredFeatureWorkers;

function requireFeatureWorkers () {
	if (hasRequiredFeatureWorkers) return featureWorkers;
	hasRequiredFeatureWorkers = 1;
	Object.defineProperty(featureWorkers, "__esModule", { value: true });
	featureWorkers.documentFeatureWorker = documentFeatureWorker;
	featureWorkers.languageFeatureWorker = languageFeatureWorker;
	featureWorkers.safeCall = safeCall;
	featureWorkers.forEachEmbeddedDocument = forEachEmbeddedDocument;
	featureWorkers.getSourceRange = getSourceRange;
	featureWorkers.getGeneratedRange = getGeneratedRange;
	featureWorkers.getSourceRanges = getSourceRanges;
	featureWorkers.getGeneratedRanges = getGeneratedRanges;
	featureWorkers.getSourcePositions = getSourcePositions;
	featureWorkers.getGeneratedPositions = getGeneratedPositions;
	featureWorkers.getLinkedCodePositions = getLinkedCodePositions;
	function documentFeatureWorker(context, uri, valid, worker, transformResult, combineResult) {
	    return languageFeatureWorker(context, uri, () => void 0, function* (map) {
	        if (valid(map)) {
	            yield;
	        }
	    }, worker, transformResult, combineResult);
	}
	async function languageFeatureWorker(context, uri, getRealDocParams, eachVirtualDocParams, worker, transformResult, combineResult) {
	    let sourceScript;
	    const decoded = context.decodeEmbeddedDocumentUri(uri);
	    if (decoded) {
	        sourceScript = context.language.scripts.get(decoded[0]);
	    }
	    else {
	        sourceScript = context.language.scripts.get(uri);
	    }
	    if (!sourceScript) {
	        return;
	    }
	    let results = [];
	    if (decoded) {
	        const virtualCode = sourceScript.generated?.embeddedCodes.get(decoded[1]);
	        if (virtualCode) {
	            const docs = [
	                context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
	                context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot),
	                context.language.maps.get(virtualCode, sourceScript),
	            ];
	            await docsWorker(docs, false);
	        }
	    }
	    else if (sourceScript.generated) {
	        for (const docs of forEachEmbeddedDocument(context, sourceScript, sourceScript.generated.root)) {
	            if (results.length && !combineResult) {
	                continue;
	            }
	            await docsWorker(docs, true);
	        }
	    }
	    else {
	        const document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
	        const params = getRealDocParams();
	        for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
	            if (context.disabledServicePlugins.has(plugin[1])) {
	                continue;
	            }
	            const embeddedResult = await safeCall(() => worker(plugin, document, params, undefined), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${document.uri}.`);
	            if (!embeddedResult) {
	                continue;
	            }
	            const result = transformResult(embeddedResult, undefined);
	            if (!result) {
	                continue;
	            }
	            results.push(result);
	            if (!combineResult) {
	                break;
	            }
	        }
	    }
	    if (combineResult && results.length > 0) {
	        const combined = combineResult(results);
	        return combined;
	    }
	    else if (results.length > 0) {
	        return results[0];
	    }
	    async function docsWorker(docs, transform) {
	        for (const mappedArg of eachVirtualDocParams(docs)) {
	            if (results.length && !combineResult) {
	                continue;
	            }
	            for (const [pluginIndex, plugin] of Object.entries(context.plugins)) {
	                if (context.disabledServicePlugins.has(plugin[1])) {
	                    continue;
	                }
	                if (results.length && !combineResult) {
	                    continue;
	                }
	                const embeddedResult = await safeCall(() => worker(plugin, docs[1], mappedArg, docs), `Language service plugin "${plugin[0].name}" (${pluginIndex}) failed to provide document feature for ${docs[1].uri}.`);
	                if (!embeddedResult) {
	                    continue;
	                }
	                if (transform) {
	                    const mappedResult = transformResult(embeddedResult, docs);
	                    if (mappedResult) {
	                        results.push(mappedResult);
	                    }
	                }
	                else {
	                    results.push(embeddedResult);
	                }
	            }
	        }
	    }
	}
	async function safeCall(cb, errorMsg) {
	    try {
	        return await cb();
	    }
	    catch (err) {
	        console.warn(errorMsg, err);
	    }
	}
	function* forEachEmbeddedDocument(context, sourceScript, current) {
	    if (current.embeddedCodes) {
	        for (const embeddedCode of current.embeddedCodes) {
	            yield* forEachEmbeddedDocument(context, sourceScript, embeddedCode);
	        }
	    }
	    const embeddedDocumentUri = context.encodeEmbeddedDocumentUri(sourceScript.id, current.id);
	    if (!context.disabledEmbeddedDocumentUris.get(embeddedDocumentUri)) {
	        yield [
	            context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
	            context.documents.get(embeddedDocumentUri, current.languageId, current.snapshot),
	            context.language.maps.get(current, sourceScript),
	        ];
	    }
	}
	function getSourceRange(docs, range, filter) {
	    for (const result of getSourceRanges(docs, range, filter)) {
	        return result;
	    }
	}
	function getGeneratedRange(docs, range, filter) {
	    for (const result of getGeneratedRanges(docs, range, filter)) {
	        return result;
	    }
	}
	function* getSourceRanges([sourceDocument, embeddedDocument, map], range, filter) {
	    for (const [mappedStart, mappedEnd] of map.toSourceRange(embeddedDocument.offsetAt(range.start), embeddedDocument.offsetAt(range.end), true, filter)) {
	        yield { start: sourceDocument.positionAt(mappedStart), end: sourceDocument.positionAt(mappedEnd) };
	    }
	}
	function* getGeneratedRanges([sourceDocument, embeddedDocument, map], range, filter) {
	    for (const [mappedStart, mappedEnd] of map.toGeneratedRange(sourceDocument.offsetAt(range.start), sourceDocument.offsetAt(range.end), true, filter)) {
	        yield { start: embeddedDocument.positionAt(mappedStart), end: embeddedDocument.positionAt(mappedEnd) };
	    }
	}
	function* getSourcePositions([sourceDocument, embeddedDocument, map], position, filter = () => true) {
	    for (const mapped of map.toSourceLocation(embeddedDocument.offsetAt(position), filter)) {
	        yield sourceDocument.positionAt(mapped[0]);
	    }
	}
	function* getGeneratedPositions([sourceDocument, embeddedDocument, map], position, filter = () => true) {
	    for (const mapped of map.toGeneratedLocation(sourceDocument.offsetAt(position), filter)) {
	        yield embeddedDocument.positionAt(mapped[0]);
	    }
	}
	function* getLinkedCodePositions(document, linkedMap, posotion) {
	    for (const linkedPosition of linkedMap.getLinkedOffsets(document.offsetAt(posotion))) {
	        yield document.positionAt(linkedPosition);
	    }
	}
	
	return featureWorkers;
}

var transform$1 = {};

var hasRequiredTransform$1;

function requireTransform$1 () {
	if (hasRequiredTransform$1) return transform$1;
	hasRequiredTransform$1 = 1;
	Object.defineProperty(transform$1, "__esModule", { value: true });
	transform$1.transformDocumentLinkTarget = transformDocumentLinkTarget;
	transform$1.transformMarkdown = transformMarkdown;
	transform$1.transformCompletionItem = transformCompletionItem;
	transform$1.transformCompletionList = transformCompletionList;
	transform$1.transformDocumentSymbol = transformDocumentSymbol;
	transform$1.transformFoldingRanges = transformFoldingRanges;
	transform$1.transformHover = transformHover;
	transform$1.transformLocation = transformLocation;
	transform$1.transformLocations = transformLocations;
	transform$1.transformSelectionRange = transformSelectionRange;
	transform$1.transformSelectionRanges = transformSelectionRanges;
	transform$1.transformTextEdit = transformTextEdit;
	transform$1.transformWorkspaceSymbol = transformWorkspaceSymbol;
	transform$1.transformWorkspaceEdit = transformWorkspaceEdit;
	transform$1.pushEditToDocumentChanges = pushEditToDocumentChanges;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const featureWorkers_1 = requireFeatureWorkers();
	function transformDocumentLinkTarget(_target, context) {
	    let target = vscode_uri_1.URI.parse(_target);
	    const decoded = context.decodeEmbeddedDocumentUri(target);
	    if (!decoded) {
	        return target;
	    }
	    const embeddedRange = target.fragment.match(/^L(\d+)(,(\d+))?(-L(\d+)(,(\d+))?)?$/);
	    const sourceScript = context.language.scripts.get(decoded[0]);
	    const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	    target = decoded[0];
	    if (embeddedRange && sourceScript && virtualCode) {
	        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	        for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	            if (!map.mappings.some(mapping => (0, language_core_1.isDocumentLinkEnabled)(mapping.data))) {
	                continue;
	            }
	            const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	            const docs = [sourceDocument, embeddedDocument, map];
	            const startLine = Number(embeddedRange[1]) - 1;
	            const startCharacter = Number(embeddedRange[3] ?? 1) - 1;
	            if (embeddedRange[5] !== undefined) {
	                const endLine = Number(embeddedRange[5]) - 1;
	                const endCharacter = Number(embeddedRange[7] ?? 1) - 1;
	                const sourceRange = (0, featureWorkers_1.getSourceRange)(docs, {
	                    start: { line: startLine, character: startCharacter },
	                    end: { line: endLine, character: endCharacter },
	                });
	                if (sourceRange) {
	                    target = target.with({
	                        fragment: 'L' + (sourceRange.start.line + 1) + ',' + (sourceRange.start.character + 1)
	                            + '-L' + (sourceRange.end.line + 1) + ',' + (sourceRange.end.character + 1),
	                    });
	                    break;
	                }
	            }
	            else {
	                let mapped = false;
	                for (const sourcePos of (0, featureWorkers_1.getSourcePositions)(docs, { line: startLine, character: startCharacter })) {
	                    mapped = true;
	                    target = target.with({
	                        fragment: 'L' + (sourcePos.line + 1) + ',' + (sourcePos.character + 1),
	                    });
	                    break;
	                }
	                if (mapped) {
	                    break;
	                }
	            }
	        }
	    }
	    return target;
	}
	function transformMarkdown(content, context) {
	    return content.replace(/(?!\()volar-embedded-content:\/\/\w+\/[^)]+/g, match => {
	        const segments = match.split('|');
	        segments[0] = transformDocumentLinkTarget(segments[0], context).toString();
	        return segments.join('|');
	    });
	}
	function transformCompletionItem(item, getOtherRange, document, context) {
	    return {
	        ...item,
	        additionalTextEdits: item.additionalTextEdits
	            ?.map(edit => transformTextEdit(edit, getOtherRange, document))
	            .filter(edit => !!edit),
	        textEdit: item.textEdit
	            ? transformTextEdit(item.textEdit, getOtherRange, document)
	            : undefined,
	        documentation: item.documentation
	            ? typeof item.documentation === 'string'
	                ? transformMarkdown(item.documentation, context)
	                : item.documentation.kind === 'markdown'
	                    ? { kind: 'markdown', value: transformMarkdown(item.documentation.value, context) }
	                    : item.documentation
	            : undefined,
	    };
	}
	function transformCompletionList(completionList, getOtherRange, document, context) {
	    return {
	        isIncomplete: completionList.isIncomplete,
	        itemDefaults: completionList.itemDefaults
	            ? {
	                ...completionList.itemDefaults,
	                editRange: completionList.itemDefaults.editRange
	                    ? 'replace' in completionList.itemDefaults.editRange
	                        ? {
	                            insert: getOtherRange(completionList.itemDefaults.editRange.insert),
	                            replace: getOtherRange(completionList.itemDefaults.editRange.replace),
	                        }
	                        : getOtherRange(completionList.itemDefaults.editRange)
	                    : undefined,
	            }
	            : undefined,
	        items: completionList.items.map(item => transformCompletionItem(item, getOtherRange, document, context)),
	    };
	}
	function transformDocumentSymbol(symbol, getOtherRange) {
	    const range = getOtherRange(symbol.range);
	    if (!range) {
	        return;
	    }
	    const selectionRange = getOtherRange(symbol.selectionRange);
	    if (!selectionRange) {
	        return;
	    }
	    return {
	        ...symbol,
	        range,
	        selectionRange,
	        children: symbol.children
	            ?.map(child => transformDocumentSymbol(child, getOtherRange))
	            .filter(child => !!child),
	    };
	}
	function transformFoldingRanges(ranges, getOtherRange) {
	    const result = [];
	    for (const range of ranges) {
	        const otherRange = getOtherRange({
	            start: { line: range.startLine, character: range.startCharacter ?? 0 },
	            end: { line: range.endLine, character: range.endCharacter ?? 0 },
	        });
	        if (otherRange) {
	            range.startLine = otherRange.start.line;
	            range.endLine = otherRange.end.line;
	            if (range.startCharacter !== undefined) {
	                range.startCharacter = otherRange.start.character;
	            }
	            if (range.endCharacter !== undefined) {
	                range.endCharacter = otherRange.end.character;
	            }
	            result.push(range);
	        }
	    }
	    return result;
	}
	function transformHover(hover, getOtherRange) {
	    if (!hover?.range) {
	        return hover;
	    }
	    const range = getOtherRange(hover.range);
	    if (!range) {
	        return;
	    }
	    return {
	        ...hover,
	        range,
	    };
	}
	function transformLocation(location, getOtherRange) {
	    const range = getOtherRange(location.range);
	    if (!range) {
	        return;
	    }
	    return {
	        ...location,
	        range,
	    };
	}
	function transformLocations(locations, getOtherRange) {
	    return locations
	        .map(location => transformLocation(location, getOtherRange))
	        .filter(location => !!location);
	}
	function transformSelectionRange(location, getOtherRange) {
	    const range = getOtherRange(location.range);
	    if (!range) {
	        return;
	    }
	    const parent = location.parent ? transformSelectionRange(location.parent, getOtherRange) : undefined;
	    return {
	        range,
	        parent,
	    };
	}
	function transformSelectionRanges(locations, getOtherRange) {
	    return locations
	        .map(location => transformSelectionRange(location, getOtherRange))
	        .filter(location => !!location);
	}
	function transformTextEdit(textEdit, getOtherRange, document) {
	    if ('range' in textEdit) {
	        let range = getOtherRange(textEdit.range);
	        if (range) {
	            return {
	                ...textEdit,
	                range,
	            };
	        }
	        const cover = tryRecoverTextEdit(getOtherRange, textEdit.range, textEdit.newText, document);
	        if (cover) {
	            return {
	                ...textEdit,
	                range: cover.range,
	                newText: cover.newText,
	            };
	        }
	    }
	    else if ('replace' in textEdit && 'insert' in textEdit) {
	        const insert = getOtherRange(textEdit.insert);
	        const replace = insert ? getOtherRange(textEdit.replace) : undefined;
	        if (insert && replace) {
	            return {
	                ...textEdit,
	                insert,
	                replace,
	            };
	        }
	        const recoverInsert = tryRecoverTextEdit(getOtherRange, textEdit.insert, textEdit.newText, document);
	        const recoverReplace = recoverInsert
	            ? tryRecoverTextEdit(getOtherRange, textEdit.replace, textEdit.newText, document)
	            : undefined;
	        if (recoverInsert && recoverReplace && recoverInsert.newText === recoverReplace.newText) {
	            return {
	                ...textEdit,
	                insert: recoverInsert.range,
	                replace: recoverReplace.range,
	                newText: recoverInsert.newText,
	            };
	        }
	    }
	}
	/**
	 * update edit text from ". foo" to " foo"
	 * fix https://github.com/johnsoncodehk/volar/issues/2155
	 */
	function tryRecoverTextEdit(getOtherRange, replaceRange, newText, document) {
	    if (replaceRange.start.line === replaceRange.end.line && replaceRange.end.character > replaceRange.start.character) {
	        let character = replaceRange.start.character;
	        while (newText.length && replaceRange.end.character > character) {
	            const newStart = { line: replaceRange.start.line, character: replaceRange.start.character + 1 };
	            if (document.getText({ start: replaceRange.start, end: newStart }) === newText[0]) {
	                newText = newText.slice(1);
	                character++;
	                const otherRange = getOtherRange({ start: newStart, end: replaceRange.end });
	                if (otherRange) {
	                    return {
	                        newText,
	                        range: otherRange,
	                    };
	                }
	            }
	            else {
	                break;
	            }
	        }
	    }
	}
	function transformWorkspaceSymbol(symbol, getOtherLocation) {
	    if (!('range' in symbol.location)) {
	        return symbol;
	    }
	    const loc = getOtherLocation(symbol.location);
	    if (!loc) {
	        return;
	    }
	    return {
	        ...symbol,
	        location: loc,
	    };
	}
	function transformWorkspaceEdit(edit, context, mode, versions = {}) {
	    const sourceResult = {};
	    let hasResult = false;
	    for (const tsUri in edit.changeAnnotations) {
	        sourceResult.changeAnnotations ??= {};
	        const tsAnno = edit.changeAnnotations[tsUri];
	        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
	        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	        if (sourceScript && virtualCode) {
	            for (const [sourceScript] of context.language.maps.forEach(virtualCode)) {
	                // TODO: check capability?
	                const uri = sourceScript.id.toString();
	                sourceResult.changeAnnotations[uri] = tsAnno;
	                break;
	            }
	        }
	        else {
	            sourceResult.changeAnnotations[tsUri] = tsAnno;
	        }
	    }
	    for (const tsUri in edit.changes) {
	        sourceResult.changes ??= {};
	        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsUri));
	        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	        if (sourceScript && virtualCode) {
	            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	            for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                const docs = [sourceDocument, embeddedDocument, map];
	                const tsEdits = edit.changes[tsUri];
	                for (const tsEdit of tsEdits) {
	                    if (mode === 'rename' || mode === 'fileName' || mode === 'codeAction') {
	                        let _data;
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, data => {
	                            _data = data;
	                            return (0, language_core_1.isRenameEnabled)(data);
	                        });
	                        if (range) {
	                            sourceResult.changes[sourceDocument.uri] ??= [];
	                            sourceResult.changes[sourceDocument.uri].push({
	                                newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
	                                range,
	                            });
	                            hasResult = true;
	                        }
	                    }
	                    else {
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
	                        if (range) {
	                            sourceResult.changes[sourceDocument.uri] ??= [];
	                            sourceResult.changes[sourceDocument.uri].push({ newText: tsEdit.newText, range });
	                            hasResult = true;
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            sourceResult.changes[tsUri] = edit.changes[tsUri];
	            hasResult = true;
	        }
	    }
	    if (edit.documentChanges) {
	        for (const tsDocEdit of edit.documentChanges) {
	            sourceResult.documentChanges ??= [];
	            let sourceEdit;
	            if ('textDocument' in tsDocEdit) {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.textDocument.uri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (sourceScript && virtualCode) {
	                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                    for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                        const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                        const docs = [sourceDocument, embeddedDocument, map];
	                        sourceEdit = {
	                            textDocument: {
	                                uri: sourceDocument.uri,
	                                version: versions[sourceDocument.uri] ?? null,
	                            },
	                            edits: [],
	                        };
	                        for (const tsEdit of tsDocEdit.edits) {
	                            if (mode === 'rename' || mode === 'fileName' || mode === 'codeAction') {
	                                let _data;
	                                const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range, data => {
	                                    _data = data;
	                                    // fix https://github.com/johnsoncodehk/volar/issues/1091
	                                    return (0, language_core_1.isRenameEnabled)(data);
	                                });
	                                if (range) {
	                                    sourceEdit.edits.push({
	                                        annotationId: 'annotationId' in tsEdit ? tsEdit.annotationId : undefined,
	                                        newText: (0, language_core_1.resolveRenameEditText)(tsEdit.newText, _data),
	                                        range,
	                                    });
	                                }
	                            }
	                            else {
	                                const range = (0, featureWorkers_1.getSourceRange)(docs, tsEdit.range);
	                                if (range) {
	                                    sourceEdit.edits.push({
	                                        annotationId: 'annotationId' in tsEdit ? tsEdit.annotationId : undefined,
	                                        newText: tsEdit.newText,
	                                        range,
	                                    });
	                                }
	                            }
	                        }
	                        if (!sourceEdit.edits.length) {
	                            sourceEdit = undefined;
	                        }
	                    }
	                }
	                else {
	                    sourceEdit = tsDocEdit;
	                }
	            }
	            else if (tsDocEdit.kind === 'create') {
	                sourceEdit = tsDocEdit; // TODO: remove .ts?
	            }
	            else if (tsDocEdit.kind === 'rename') {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.oldUri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (virtualCode) {
	                    for (const [sourceScript] of context.language.maps.forEach(virtualCode)) {
	                        // TODO: check capability?
	                        sourceEdit = {
	                            kind: 'rename',
	                            oldUri: sourceScript.id.toString(),
	                            newUri: tsDocEdit.newUri, /* TODO: remove .ts? */
	                            options: tsDocEdit.options,
	                            annotationId: tsDocEdit.annotationId,
	                        };
	                    }
	                }
	                else {
	                    sourceEdit = tsDocEdit;
	                }
	            }
	            else if (tsDocEdit.kind === 'delete') {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsDocEdit.uri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (virtualCode) {
	                    for (const [sourceScript] of context.language.maps.forEach(virtualCode)) {
	                        // TODO: check capability?
	                        sourceEdit = {
	                            kind: 'delete',
	                            uri: sourceScript.id.toString(),
	                            options: tsDocEdit.options,
	                            annotationId: tsDocEdit.annotationId,
	                        };
	                    }
	                }
	                else {
	                    sourceEdit = tsDocEdit;
	                }
	            }
	            if (sourceEdit) {
	                pushEditToDocumentChanges(sourceResult.documentChanges, sourceEdit);
	                hasResult = true;
	            }
	        }
	    }
	    if (hasResult) {
	        return sourceResult;
	    }
	}
	function pushEditToDocumentChanges(arr, item) {
	    const current = arr.find(edit => 'textDocument' in edit
	        && 'textDocument' in item
	        && edit.textDocument.uri === item.textDocument.uri);
	    if (current) {
	        current.edits.push(...item.edits);
	    }
	    else {
	        arr.push(item);
	    }
	}
	
	return transform$1;
}

var hasRequiredProvideRenameEdits;

function requireProvideRenameEdits () {
	if (hasRequiredProvideRenameEdits) return provideRenameEdits;
	hasRequiredProvideRenameEdits = 1;
	Object.defineProperty(provideRenameEdits, "__esModule", { value: true });
	provideRenameEdits.register = register;
	provideRenameEdits.mergeWorkspaceEdits = mergeWorkspaceEdits;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, position, newName, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ position, newName }), function* (docs) {
	            let _data;
	            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, data => {
	                _data = data;
	                return (0, language_core_1.isRenameEnabled)(data);
	            })) {
	                yield {
	                    position: mappedPosition,
	                    newName: (0, language_core_1.resolveRenameNewName)(newName, _data),
	                };
	            }
	        }, async (plugin, document, params) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const recursiveChecker = dedupe.createLocationSet();
	            let result;
	            await withLinkedCode(document, params.position, params.newName);
	            return result;
	            async function withLinkedCode(document, position, newName) {
	                if (!plugin[1].provideRenameEdits) {
	                    return;
	                }
	                if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } })) {
	                    return;
	                }
	                recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
	                const workspaceEdit = await plugin[1].provideRenameEdits(document, position, newName, token);
	                if (!workspaceEdit) {
	                    return;
	                }
	                if (!result) {
	                    result = {};
	                }
	                if (workspaceEdit.changes) {
	                    for (const editUri in workspaceEdit.changes) {
	                        const textEdits = workspaceEdit.changes[editUri];
	                        for (const textEdit of textEdits) {
	                            let foundMirrorPosition = false;
	                            recursiveChecker.add({
	                                uri: editUri,
	                                range: { start: textEdit.range.start, end: textEdit.range.start },
	                            });
	                            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(editUri));
	                            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                            const linkedCodeMap = virtualCode && sourceScript
	                                ? context.language.linkedCodeMaps.get(virtualCode)
	                                : undefined;
	                            if (sourceScript && virtualCode && linkedCodeMap) {
	                                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                                for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, textEdit.range.start)) {
	                                    if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
	                                        continue;
	                                    }
	                                    foundMirrorPosition = true;
	                                    await withLinkedCode(embeddedDocument, linkedPos, newName);
	                                }
	                            }
	                            if (!foundMirrorPosition) {
	                                if (!result.changes) {
	                                    result.changes = {};
	                                }
	                                if (!result.changes[editUri]) {
	                                    result.changes[editUri] = [];
	                                }
	                                result.changes[editUri].push(textEdit);
	                            }
	                        }
	                    }
	                }
	                if (workspaceEdit.changeAnnotations) {
	                    for (const uri in workspaceEdit.changeAnnotations) {
	                        if (!result.changeAnnotations) {
	                            result.changeAnnotations = {};
	                        }
	                        result.changeAnnotations[uri] = workspaceEdit.changeAnnotations[uri];
	                    }
	                }
	                if (workspaceEdit.documentChanges) {
	                    if (!result.documentChanges) {
	                        result.documentChanges = [];
	                    }
	                    result.documentChanges = result.documentChanges.concat(workspaceEdit.documentChanges);
	                }
	            }
	        }, data => {
	            return (0, transform_1.transformWorkspaceEdit)(data, context, 'rename');
	        }, workspaceEdits => {
	            const mainEdit = workspaceEdits[0];
	            const otherEdits = workspaceEdits.slice(1);
	            mergeWorkspaceEdits(mainEdit, ...otherEdits);
	            if (mainEdit.changes) {
	                for (const uri in mainEdit.changes) {
	                    mainEdit.changes[uri] = dedupe.withTextEdits(mainEdit.changes[uri]);
	                }
	            }
	            return workspaceEdits[0];
	        });
	    };
	}
	function mergeWorkspaceEdits(original, ...others) {
	    for (const other of others) {
	        for (const uri in other.changeAnnotations) {
	            if (!original.changeAnnotations) {
	                original.changeAnnotations = {};
	            }
	            original.changeAnnotations[uri] = other.changeAnnotations[uri];
	        }
	        for (const uri in other.changes) {
	            if (!original.changes) {
	                original.changes = {};
	            }
	            if (!original.changes[uri]) {
	                original.changes[uri] = [];
	            }
	            const edits = other.changes[uri];
	            original.changes[uri] = original.changes[uri].concat(edits);
	        }
	        if (other.documentChanges) {
	            if (!original.documentChanges) {
	                original.documentChanges = [];
	            }
	            for (const docChange of other.documentChanges) {
	                (0, transform_1.pushEditToDocumentChanges)(original.documentChanges, docChange);
	            }
	        }
	    }
	}
	
	return provideRenameEdits;
}

var languageService = {};

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (const change of changes) {
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
            return lineOffset;
        }
        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
            offset--;
        }
        return offset;
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            const diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
            const startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        const ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
        const ch = text.charCodeAt(i);
        if (isEOL(ch)) {
            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function isEOL(char) {
    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}

var main$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get TextDocument () { return TextDocument; }
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(main$2);

var provideAutoInsertSnippet = {};

var hasRequiredProvideAutoInsertSnippet;

function requireProvideAutoInsertSnippet () {
	if (hasRequiredProvideAutoInsertSnippet) return provideAutoInsertSnippet;
	hasRequiredProvideAutoInsertSnippet = 1;
	Object.defineProperty(provideAutoInsertSnippet, "__esModule", { value: true });
	provideAutoInsertSnippet.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, selection, change, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ selection, change }), function* (docs) {
	            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, selection, language_core_1.isAutoInsertEnabled)) {
	                for (const mapped of docs[2].toGeneratedLocation(change.rangeOffset)) {
	                    yield {
	                        selection: mappedPosition,
	                        change: {
	                            text: change.text,
	                            rangeOffset: mapped[0],
	                            rangeLength: change.rangeLength,
	                        },
	                    };
	                    break;
	                }
	            }
	        }, (plugin, document, args) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideAutoInsertSnippet?.(document, args.selection, args.change, token);
	        }, snippet => snippet);
	    };
	}
	
	return provideAutoInsertSnippet;
}

var provideCallHierarchyItems = {};

var hasRequiredProvideCallHierarchyItems;

function requireProvideCallHierarchyItems () {
	if (hasRequiredProvideCallHierarchyItems) return provideCallHierarchyItems;
	hasRequiredProvideCallHierarchyItems = 1;
	Object.defineProperty(provideCallHierarchyItems, "__esModule", { value: true });
	provideCallHierarchyItems.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return {
	        getCallHierarchyItems(uri, position, token = cancellation_1.NoneCancellationToken) {
	            return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isCallHierarchyEnabled), async (plugin, document, position, map) => {
	                if (token.isCancellationRequested) {
	                    return;
	                }
	                const items = await plugin[1].provideCallHierarchyItems?.(document, position, token);
	                items?.forEach(item => {
	                    item.data = {
	                        uri: uri.toString(),
	                        original: {
	                            data: item.data,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                        embeddedDocumentUri: map?.[1].uri,
	                    };
	                });
	                return items;
	            }, (data, map) => {
	                if (!map) {
	                    return data;
	                }
	                return data
	                    .map(item => transformHierarchyItem(item, [])?.[0])
	                    .filter(item => !!item);
	            }, arr => dedupe.withLocations(arr.flat()));
	        },
	        getTypeHierarchyItems(uri, position, token = cancellation_1.NoneCancellationToken) {
	            return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isTypeHierarchyEnabled), async (plugin, document, position, map) => {
	                if (token.isCancellationRequested) {
	                    return;
	                }
	                const items = await plugin[1].provideTypeHierarchyItems?.(document, position, token);
	                items?.forEach(item => {
	                    item.data = {
	                        uri: uri.toString(),
	                        original: {
	                            data: item.data,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                        embeddedDocumentUri: map?.[1].uri,
	                    };
	                });
	                return items;
	            }, (data, map) => {
	                if (!map) {
	                    return data;
	                }
	                return data
	                    .map(item => transformHierarchyItem(item, [])?.[0])
	                    .filter(item => !!item);
	            }, arr => dedupe.withLocations(arr.flat()));
	        },
	        async getCallHierarchyIncomingCalls(item, token) {
	            const data = item.data;
	            let incomingItems = [];
	            if (data) {
	                const plugin = context.plugins[data.pluginIndex];
	                if (!plugin[1].provideCallHierarchyIncomingCalls) {
	                    return incomingItems;
	                }
	                Object.assign(item, data.original);
	                if (data.embeddedDocumentUri) {
	                    const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
	                    if (isEmbeddedContent) {
	                        const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
	                        for (const _call of _calls) {
	                            const calls = transformHierarchyItem(_call.from, _call.fromRanges);
	                            if (!calls) {
	                                continue;
	                            }
	                            incomingItems.push({
	                                from: calls[0],
	                                fromRanges: calls[1],
	                            });
	                        }
	                    }
	                }
	                else {
	                    const _calls = await plugin[1].provideCallHierarchyIncomingCalls(item, token);
	                    for (const _call of _calls) {
	                        const calls = transformHierarchyItem(_call.from, _call.fromRanges);
	                        if (!calls) {
	                            continue;
	                        }
	                        incomingItems.push({
	                            from: calls[0],
	                            fromRanges: calls[1],
	                        });
	                    }
	                }
	            }
	            return dedupe.withCallHierarchyIncomingCalls(incomingItems);
	        },
	        async getCallHierarchyOutgoingCalls(item, token) {
	            const data = item.data;
	            let items = [];
	            if (data) {
	                const plugin = context.plugins[data.pluginIndex];
	                if (!plugin[1].provideCallHierarchyOutgoingCalls) {
	                    return items;
	                }
	                Object.assign(item, data.original);
	                if (data.embeddedDocumentUri) {
	                    const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
	                    if (isEmbeddedContent) {
	                        const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
	                        for (const call of _calls) {
	                            const calls = transformHierarchyItem(call.to, call.fromRanges);
	                            if (!calls) {
	                                continue;
	                            }
	                            items.push({
	                                to: calls[0],
	                                fromRanges: calls[1],
	                            });
	                        }
	                    }
	                }
	                else {
	                    const _calls = await plugin[1].provideCallHierarchyOutgoingCalls(item, token);
	                    for (const call of _calls) {
	                        const calls = transformHierarchyItem(call.to, call.fromRanges);
	                        if (!calls) {
	                            continue;
	                        }
	                        items.push({
	                            to: calls[0],
	                            fromRanges: calls[1],
	                        });
	                    }
	                }
	            }
	            return dedupe.withCallHierarchyOutgoingCalls(items);
	        },
	        async getTypeHierarchySupertypes(item, token) {
	            const data = item.data;
	            if (data) {
	                const plugin = context.plugins[data.pluginIndex];
	                if (!plugin[1].provideTypeHierarchySupertypes) {
	                    return [];
	                }
	                Object.assign(item, data.original);
	                if (data.embeddedDocumentUri) {
	                    const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
	                    if (isEmbeddedContent) {
	                        const items = await plugin[1].provideTypeHierarchySupertypes(item, token);
	                        return items
	                            .map(item => transformHierarchyItem(item, [])?.[0])
	                            .filter(item => !!item);
	                    }
	                }
	                else {
	                    const items = await plugin[1].provideTypeHierarchySupertypes(item, token);
	                    return items
	                        .map(item => transformHierarchyItem(item, [])?.[0])
	                        .filter(item => !!item);
	                }
	            }
	        },
	        async getTypeHierarchySubtypes(item, token) {
	            const data = item.data;
	            if (data) {
	                const plugin = context.plugins[data.pluginIndex];
	                if (!plugin[1].provideTypeHierarchySubtypes) {
	                    return [];
	                }
	                Object.assign(item, data.original);
	                if (data.embeddedDocumentUri) {
	                    const isEmbeddedContent = !!context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
	                    if (isEmbeddedContent) {
	                        const items = await plugin[1].provideTypeHierarchySubtypes(item, token);
	                        return items
	                            .map(item => transformHierarchyItem(item, [])?.[0])
	                            .filter(item => !!item);
	                    }
	                }
	                else {
	                    const items = await plugin[1].provideTypeHierarchySubtypes(item, token);
	                    return items
	                        .map(item => transformHierarchyItem(item, [])?.[0])
	                        .filter(item => !!item);
	                }
	            }
	        },
	    };
	    function transformHierarchyItem(tsItem, tsRanges) {
	        const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(tsItem.uri));
	        const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	        const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	        if (!sourceScript || !virtualCode) {
	            return [tsItem, tsRanges];
	        }
	        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	        for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	            const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	            const docs = [sourceDocument, embeddedDocument, map];
	            let range = (0, featureWorkers_1.getSourceRange)(docs, tsItem.range);
	            if (!range) {
	                // TODO: <script> range
	                range = {
	                    start: sourceDocument.positionAt(0),
	                    end: sourceDocument.positionAt(sourceDocument.getText().length),
	                };
	            }
	            const selectionRange = (0, featureWorkers_1.getSourceRange)(docs, tsItem.selectionRange);
	            if (!selectionRange) {
	                continue;
	            }
	            const vueRanges = tsRanges.map(tsRange => (0, featureWorkers_1.getSourceRange)(docs, tsRange)).filter(range => !!range);
	            const vueItem = {
	                ...tsItem,
	                name: tsItem.name === embeddedDocument.uri.substring(embeddedDocument.uri.lastIndexOf('/') + 1)
	                    ? sourceDocument.uri.substring(sourceDocument.uri.lastIndexOf('/') + 1)
	                    : tsItem.name,
	                uri: sourceDocument.uri,
	                // TS Bug: `range: range` not works
	                range: {
	                    start: range.start,
	                    end: range.end,
	                },
	                selectionRange: {
	                    start: selectionRange.start,
	                    end: selectionRange.end,
	                },
	            };
	            return [vueItem, vueRanges];
	        }
	    }
	}
	
	return provideCallHierarchyItems;
}

var provideCodeActions = {};

var hasRequiredProvideCodeActions;

function requireProvideCodeActions () {
	if (hasRequiredProvideCodeActions) return provideCodeActions;
	hasRequiredProvideCodeActions = 1;
	Object.defineProperty(provideCodeActions, "__esModule", { value: true });
	provideCodeActions.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (uri, range, codeActionContext, token = cancellation_1.NoneCancellationToken) => {
	        const sourceScript = context.language.scripts.get(uri);
	        if (!sourceScript) {
	            return;
	        }
	        const transformedCodeActions = new WeakSet();
	        return await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => ({ range, codeActionContext }), function* (docs) {
	            const _codeActionContext = {
	                diagnostics: (0, transform_1.transformLocations)(codeActionContext.diagnostics, range => (0, featureWorkers_1.getGeneratedRange)(docs, range)),
	                only: codeActionContext.only,
	            };
	            const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isCodeActionsEnabled);
	            if (mapped) {
	                yield {
	                    range: {
	                        start: docs[1].positionAt(mapped.start),
	                        end: docs[1].positionAt(mapped.end),
	                    },
	                    codeActionContext: _codeActionContext,
	                };
	            }
	        }, async (plugin, document, { range, codeActionContext }) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const pluginIndex = context.plugins.indexOf(plugin);
	            const diagnostics = codeActionContext.diagnostics.filter(diagnostic => {
	                const data = diagnostic.data;
	                if (data && data.version !== document.version) {
	                    return false;
	                }
	                return data?.pluginIndex === pluginIndex;
	            }).map(diagnostic => {
	                const data = diagnostic.data;
	                return {
	                    ...diagnostic,
	                    ...data.original,
	                };
	            });
	            const codeActions = await plugin[1].provideCodeActions?.(document, range, {
	                ...codeActionContext,
	                diagnostics,
	            }, token);
	            codeActions?.forEach(codeAction => {
	                if (plugin[1].resolveCodeAction) {
	                    codeAction.data = {
	                        uri: uri.toString(),
	                        version: document.version,
	                        original: {
	                            data: codeAction.data,
	                            edit: codeAction.edit,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                    };
	                }
	                else {
	                    delete codeAction.data;
	                }
	            });
	            if (codeActions && plugin[1].transformCodeAction) {
	                for (let i = 0; i < codeActions.length; i++) {
	                    const transformed = plugin[1].transformCodeAction(codeActions[i]);
	                    if (transformed) {
	                        codeActions[i] = transformed;
	                        transformedCodeActions.add(transformed);
	                    }
	                }
	            }
	            return codeActions;
	        }, actions => actions
	            .map(action => {
	            if (transformedCodeActions.has(action)) {
	                return action;
	            }
	            if (action.edit) {
	                const edit = (0, transform_1.transformWorkspaceEdit)(action.edit, context, 'codeAction');
	                if (!edit) {
	                    return;
	                }
	                action.edit = edit;
	            }
	            return action;
	        })
	            .filter(action => !!action), arr => dedupe.withCodeAction(arr.flat()));
	    };
	}
	
	return provideCodeActions;
}

var provideCodeLenses = {};

var hasRequiredProvideCodeLenses;

function requireProvideCodeLenses () {
	if (hasRequiredProvideCodeLenses) return provideCodeLenses;
	hasRequiredProvideCodeLenses = 1;
	Object.defineProperty(provideCodeLenses, "__esModule", { value: true });
	provideCodeLenses.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return async (uri, token = cancellation_1.NoneCancellationToken) => {
	        return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isCodeLensEnabled)(mapping.data)), async (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            let codeLens = await plugin[1].provideCodeLenses?.(document, token);
	            const pluginIndex = context.plugins.indexOf(plugin);
	            codeLens?.forEach(codeLens => {
	                if (plugin[1].resolveCodeLens) {
	                    codeLens.data = {
	                        kind: 'normal',
	                        uri: uri.toString(),
	                        original: {
	                            data: codeLens.data,
	                        },
	                        pluginIndex,
	                    };
	                }
	                else {
	                    delete codeLens.data;
	                }
	            });
	            const ranges = await plugin[1].provideReferencesCodeLensRanges?.(document, token);
	            const referencesCodeLens = ranges?.map(range => ({
	                range,
	                data: {
	                    kind: 'references',
	                    sourceFileUri: uri.toString(),
	                    workerFileUri: document.uri,
	                    workerFileRange: range,
	                    pluginIndex: pluginIndex,
	                },
	            }));
	            codeLens = [
	                ...codeLens ?? [],
	                ...referencesCodeLens ?? [],
	            ];
	            return codeLens;
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return data
	                .map(codeLens => {
	                const range = (0, featureWorkers_1.getSourceRange)(docs, codeLens.range, language_core_1.isCodeLensEnabled);
	                if (range) {
	                    return {
	                        ...codeLens,
	                        range,
	                    };
	                }
	            })
	                .filter(codeLens => !!codeLens);
	        }, arr => arr.flat()) ?? [];
	    };
	}
	
	return provideCodeLenses;
}

var provideColorPresentations = {};

var hasRequiredProvideColorPresentations;

function requireProvideColorPresentations () {
	if (hasRequiredProvideColorPresentations) return provideColorPresentations;
	hasRequiredProvideColorPresentations = 1;
	Object.defineProperty(provideColorPresentations, "__esModule", { value: true });
	provideColorPresentations.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, color, range, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
	            for (const mappedRange of (0, featureWorkers_1.getGeneratedRanges)(docs, range, language_core_1.isColorEnabled)) {
	                yield mappedRange;
	            }
	        }, (plugin, document, range) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideColorPresentations?.(document, color, range, token);
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return data
	                .map(colorPresentation => {
	                if (colorPresentation.textEdit) {
	                    const range = (0, featureWorkers_1.getSourceRange)(docs, colorPresentation.textEdit.range);
	                    if (!range) {
	                        return undefined;
	                    }
	                    colorPresentation.textEdit.range = range;
	                }
	                if (colorPresentation.additionalTextEdits) {
	                    for (const textEdit of colorPresentation.additionalTextEdits) {
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, textEdit.range);
	                        if (!range) {
	                            return undefined;
	                        }
	                        textEdit.range = range;
	                    }
	                }
	                return colorPresentation;
	            })
	                .filter(colorPresentation => !!colorPresentation);
	        });
	    };
	}
	
	return provideColorPresentations;
}

var provideCompletionItems = {};

var hasRequiredProvideCompletionItems;

function requireProvideCompletionItems () {
	if (hasRequiredProvideCompletionItems) return provideCompletionItems;
	hasRequiredProvideCompletionItems = 1;
	Object.defineProperty(provideCompletionItems, "__esModule", { value: true });
	provideCompletionItems.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    let lastResult;
	    return async (uri, position, completionContext = {
	        triggerKind: 1,
	    }, token = cancellation_1.NoneCancellationToken) => {
	        let langaugeIdAndSnapshot;
	        let sourceScript;
	        const decoded = context.decodeEmbeddedDocumentUri(uri);
	        if (decoded) {
	            langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
	        }
	        else {
	            sourceScript = context.language.scripts.get(uri);
	            langaugeIdAndSnapshot = sourceScript;
	        }
	        if (!langaugeIdAndSnapshot) {
	            return {
	                isIncomplete: false,
	                items: [],
	            };
	        }
	        if (completionContext?.triggerKind === 3
	            && lastResult?.uri.toString() === uri.toString()) {
	            for (const cacheData of lastResult.results) {
	                if (!cacheData.list?.isIncomplete) {
	                    continue;
	                }
	                const pluginIndex = context.plugins.findIndex(plugin => plugin[1] === cacheData.plugin);
	                if (cacheData.embeddedDocumentUri) {
	                    const decoded = context.decodeEmbeddedDocumentUri(cacheData.embeddedDocumentUri);
	                    const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                    const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                    if (!sourceScript || !virtualCode) {
	                        continue;
	                    }
	                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                    for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                        const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                        const docs = [sourceDocument, embeddedDocument, map];
	                        for (const mapped of (0, featureWorkers_1.getGeneratedPositions)(docs, position, data => (0, language_core_1.isCompletionEnabled)(data))) {
	                            if (!cacheData.plugin.provideCompletionItems) {
	                                continue;
	                            }
	                            cacheData.list = await cacheData.plugin.provideCompletionItems(embeddedDocument, mapped, completionContext, token);
	                            if (!cacheData.list) {
	                                continue;
	                            }
	                            for (const item of cacheData.list.items) {
	                                if (cacheData.plugin.resolveCompletionItem) {
	                                    item.data = {
	                                        uri: uri.toString(),
	                                        original: {
	                                            additionalTextEdits: item.additionalTextEdits,
	                                            textEdit: item.textEdit,
	                                            data: item.data,
	                                        },
	                                        pluginIndex: pluginIndex,
	                                        embeddedDocumentUri: embeddedDocument.uri,
	                                    };
	                                }
	                                else {
	                                    delete item.data;
	                                }
	                            }
	                            cacheData.list = (0, transform_1.transformCompletionList)(cacheData.list, range => (0, featureWorkers_1.getSourceRange)(docs, range), embeddedDocument, context);
	                        }
	                    }
	                }
	                else {
	                    if (!cacheData.plugin.provideCompletionItems) {
	                        continue;
	                    }
	                    const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
	                    cacheData.list = await cacheData.plugin.provideCompletionItems(document, position, completionContext, token);
	                    if (!cacheData.list) {
	                        continue;
	                    }
	                    for (const item of cacheData.list.items) {
	                        if (cacheData.plugin.resolveCompletionItem) {
	                            item.data = {
	                                uri: uri.toString(),
	                                original: {
	                                    additionalTextEdits: item.additionalTextEdits,
	                                    textEdit: item.textEdit,
	                                    data: item.data,
	                                },
	                                pluginIndex: pluginIndex,
	                                embeddedDocumentUri: undefined,
	                            };
	                        }
	                        else {
	                            delete item.data;
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            lastResult = {
	                uri,
	                results: [],
	            };
	            // monky fix https://github.com/johnsoncodehk/volar/issues/1358
	            let isFirstMapping = true;
	            let mainCompletionUri;
	            const sortedPlugins = [...context.plugins]
	                .filter(plugin => !context.disabledServicePlugins.has(plugin[1]))
	                .sort((a, b) => sortServices(a[1], b[1]));
	            const worker = async (document, position, docs, codeInfo) => {
	                for (const plugin of sortedPlugins) {
	                    if (token.isCancellationRequested) {
	                        break;
	                    }
	                    if (!plugin[1].provideCompletionItems) {
	                        continue;
	                    }
	                    if (plugin[1].isAdditionalCompletion && !isFirstMapping) {
	                        continue;
	                    }
	                    if (completionContext?.triggerCharacter
	                        && !plugin[0].capabilities.completionProvider?.triggerCharacters?.includes(completionContext.triggerCharacter)) {
	                        continue;
	                    }
	                    const isAdditional = (codeInfo && typeof codeInfo.completion === 'object' && codeInfo.completion.isAdditional)
	                        || plugin[1].isAdditionalCompletion;
	                    if (mainCompletionUri && (!isAdditional || mainCompletionUri !== document.uri)) {
	                        continue;
	                    }
	                    // avoid duplicate items with .vue and .vue.html
	                    if (plugin[1].isAdditionalCompletion && lastResult?.results.some(data => data.plugin === plugin[1])) {
	                        continue;
	                    }
	                    let completionList = await plugin[1].provideCompletionItems(document, position, completionContext, token);
	                    if (!completionList || !completionList.items.length) {
	                        continue;
	                    }
	                    if (typeof codeInfo?.completion === 'object' && codeInfo.completion.onlyImport) {
	                        completionList.items = completionList.items.filter(item => !!item.labelDetails);
	                    }
	                    if (!isAdditional) {
	                        mainCompletionUri = document.uri;
	                    }
	                    const pluginIndex = context.plugins.indexOf(plugin);
	                    for (const item of completionList.items) {
	                        if (plugin[1].resolveCompletionItem) {
	                            item.data = {
	                                uri: uri.toString(),
	                                original: {
	                                    additionalTextEdits: item.additionalTextEdits,
	                                    textEdit: item.textEdit,
	                                    data: item.data,
	                                },
	                                pluginIndex,
	                                embeddedDocumentUri: docs ? document.uri : undefined,
	                            };
	                        }
	                        else {
	                            delete item.data;
	                        }
	                    }
	                    if (docs) {
	                        completionList = (0, transform_1.transformCompletionList)(completionList, range => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isCompletionEnabled), document, context);
	                    }
	                    lastResult?.results.push({
	                        embeddedDocumentUri: docs ? vscode_uri_1.URI.parse(document.uri) : undefined,
	                        plugin: plugin[1],
	                        list: completionList,
	                    });
	                }
	                isFirstMapping = false;
	            };
	            if (sourceScript?.generated) {
	                for (const docs of (0, featureWorkers_1.forEachEmbeddedDocument)(context, sourceScript, sourceScript.generated.root)) {
	                    let _data;
	                    for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, data => {
	                        _data = data;
	                        return (0, language_core_1.isCompletionEnabled)(data);
	                    })) {
	                        await worker(docs[1], mappedPosition, docs, _data);
	                    }
	                }
	            }
	            else {
	                const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
	                await worker(document, position);
	            }
	        }
	        return combineCompletionList(lastResult.results.map(cacheData => cacheData.list));
	        function sortServices(a, b) {
	            return (b.isAdditionalCompletion ? -1 : 1) - (a.isAdditionalCompletion ? -1 : 1);
	        }
	        function combineCompletionList(lists) {
	            return {
	                isIncomplete: lists.some(list => list?.isIncomplete),
	                itemDefaults: lists.find(list => list?.itemDefaults)?.itemDefaults,
	                items: lists.map(list => list?.items ?? []).flat(),
	            };
	        }
	    };
	}
	
	return provideCompletionItems;
}

var provideDefinition = {};

var hasRequiredProvideDefinition;

function requireProvideDefinition () {
	if (hasRequiredProvideDefinition) return provideDefinition;
	hasRequiredProvideDefinition = 1;
	Object.defineProperty(provideDefinition, "__esModule", { value: true });
	provideDefinition.register = register;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context, apiName, isValidPosition) {
	    return (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, isValidPosition), async (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const recursiveChecker = dedupe.createLocationSet();
	            const result = [];
	            await withLinkedCode(document, position, undefined);
	            return result;
	            async function withLinkedCode(document, position, originDefinition) {
	                const api = plugin[1][apiName];
	                if (!api) {
	                    return;
	                }
	                if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } })) {
	                    return;
	                }
	                recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
	                const definitions = await api?.(document, position, token) ?? [];
	                for (const definition of definitions) {
	                    let foundMirrorPosition = false;
	                    recursiveChecker.add({
	                        uri: definition.targetUri,
	                        range: { start: definition.targetRange.start, end: definition.targetRange.start },
	                    });
	                    const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(definition.targetUri));
	                    const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                    const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                    const linkedCodeMap = virtualCode && sourceScript
	                        ? context.language.linkedCodeMaps.get(virtualCode)
	                        : undefined;
	                    if (sourceScript && virtualCode && linkedCodeMap) {
	                        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                        for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, definition.targetSelectionRange.start)) {
	                            if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
	                                continue;
	                            }
	                            foundMirrorPosition = true;
	                            await withLinkedCode(embeddedDocument, linkedPos, originDefinition ?? definition);
	                        }
	                    }
	                    if (!foundMirrorPosition) {
	                        if (originDefinition) {
	                            result.push({
	                                ...definition,
	                                originSelectionRange: originDefinition.originSelectionRange,
	                            });
	                        }
	                        else {
	                            result.push(definition);
	                        }
	                    }
	                }
	            }
	        }, (data, map) => data.map(link => {
	            if (link.originSelectionRange && map) {
	                const originSelectionRange = toSourcePositionPreferSurroundedPosition(map, link.originSelectionRange, position);
	                if (!originSelectionRange) {
	                    return;
	                }
	                link.originSelectionRange = originSelectionRange;
	            }
	            let foundTargetSelectionRange = false;
	            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(link.targetUri));
	            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	            const targetVirtualFile = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	            if (sourceScript && targetVirtualFile) {
	                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, targetVirtualFile.id), targetVirtualFile.languageId, targetVirtualFile.snapshot);
	                for (const [targetScript, targetSourceMap] of context.language.maps.forEach(targetVirtualFile)) {
	                    const sourceDocument = context.documents.get(targetScript.id, targetScript.languageId, targetScript.snapshot);
	                    const docs = [sourceDocument, embeddedDocument, targetSourceMap];
	                    const targetSelectionRange = (0, featureWorkers_1.getSourceRange)(docs, link.targetSelectionRange);
	                    if (!targetSelectionRange) {
	                        continue;
	                    }
	                    foundTargetSelectionRange = true;
	                    let targetRange = (0, featureWorkers_1.getSourceRange)(docs, link.targetRange);
	                    link.targetUri = sourceDocument.uri;
	                    // loose range mapping to for template slots, slot properties
	                    link.targetRange = targetRange ?? targetSelectionRange;
	                    link.targetSelectionRange = targetSelectionRange;
	                }
	                if (apiName === 'provideDefinition' && !foundTargetSelectionRange) {
	                    for (const [targetScript] of context.language.maps.forEach(targetVirtualFile)) {
	                        if (targetScript.id.toString() !== uri.toString()) {
	                            return {
	                                ...link,
	                                targetUri: targetScript.id.toString(),
	                                targetRange: {
	                                    start: { line: 0, character: 0 },
	                                    end: { line: 0, character: 0 },
	                                },
	                                targetSelectionRange: {
	                                    start: { line: 0, character: 0 },
	                                    end: { line: 0, character: 0 },
	                                },
	                            };
	                        }
	                    }
	                    return;
	                }
	            }
	            return link;
	        }).filter(link => !!link), arr => dedupe.withLocationLinks(arr.flat()));
	    };
	}
	function toSourcePositionPreferSurroundedPosition(docs, mappedRange, position) {
	    let result;
	    for (const range of (0, featureWorkers_1.getSourceRanges)(docs, mappedRange)) {
	        if (!result) {
	            result = range;
	        }
	        if ((range.start.line < position.line
	            || (range.start.line === position.line && range.start.character <= position.character))
	            && (range.end.line > position.line
	                || (range.end.line === position.line && range.end.character >= position.character))) {
	            return range;
	        }
	    }
	    return result;
	}
	
	return provideDefinition;
}

var provideDiagnostics = {};

var common$2 = {};

var hasRequiredCommon$2;

function requireCommon$2 () {
	if (hasRequiredCommon$2) return common$2;
	hasRequiredCommon$2 = 1;
	Object.defineProperty(common$2, "__esModule", { value: true });
	common$2.isInsideRange = isInsideRange;
	common$2.isEqualRange = isEqualRange;
	common$2.stringToSnapshot = stringToSnapshot;
	common$2.sleep = sleep;
	function isInsideRange(parent, child) {
	    if (child.start.line < parent.start.line) {
	        return false;
	    }
	    if (child.end.line > parent.end.line) {
	        return false;
	    }
	    if (child.start.line === parent.start.line && child.start.character < parent.start.character) {
	        return false;
	    }
	    if (child.end.line === parent.end.line && child.end.character > parent.end.character) {
	        return false;
	    }
	    return true;
	}
	function isEqualRange(a, b) {
	    return a.start.line === b.start.line
	        && a.start.character === b.start.character
	        && a.end.line === b.end.line
	        && a.end.character === b.end.character;
	}
	function stringToSnapshot(str) {
	    return {
	        getText: (start, end) => str.substring(start, end),
	        getLength: () => str.length,
	        getChangeRange: () => undefined,
	    };
	}
	function sleep(ms) {
	    return new Promise(resolve => setTimeout(resolve, ms));
	}
	
	return common$2;
}

var uriMap = {};

var hasRequiredUriMap;

function requireUriMap () {
	if (hasRequiredUriMap) return uriMap;
	hasRequiredUriMap = 1;
	Object.defineProperty(uriMap, "__esModule", { value: true });
	uriMap.createUriMap = createUriMap;
	function createUriMap(caseSensitive = false) {
	    const map = new Map();
	    const rawUriToNormalizedUri = new Map();
	    const normalizedUriToRawUri = new Map();
	    return {
	        get size() {
	            return map.size;
	        },
	        get [Symbol.toStringTag]() {
	            return 'UriMap';
	        },
	        [Symbol.iterator]() {
	            return this.entries();
	        },
	        clear() {
	            rawUriToNormalizedUri.clear();
	            normalizedUriToRawUri.clear();
	            return map.clear();
	        },
	        values() {
	            return map.values();
	        },
	        *keys() {
	            for (const normalizedUri of map.keys()) {
	                yield normalizedUriToRawUri.get(normalizedUri);
	            }
	            return undefined;
	        },
	        *entries() {
	            for (const [normalizedUri, item] of map.entries()) {
	                yield [normalizedUriToRawUri.get(normalizedUri), item];
	            }
	            return undefined;
	        },
	        forEach(callbackfn, thisArg) {
	            for (const [uri, item] of this.entries()) {
	                callbackfn.call(thisArg, item, uri, this);
	            }
	        },
	        delete(uri) {
	            return map.delete(toKey(uri));
	        },
	        get(uri) {
	            return map.get(toKey(uri));
	        },
	        has(uri) {
	            return map.has(toKey(uri));
	        },
	        set(uri, item) {
	            map.set(toKey(uri), item);
	            return this;
	        },
	    };
	    function toKey(uri) {
	        const rawUri = uri.toString();
	        if (!rawUriToNormalizedUri.has(rawUri)) {
	            let normalizedUri = uri.toString();
	            if (!caseSensitive) {
	                normalizedUri = normalizedUri.toLowerCase();
	            }
	            rawUriToNormalizedUri.set(rawUri, normalizedUri);
	            normalizedUriToRawUri.set(normalizedUri, uri);
	        }
	        return rawUriToNormalizedUri.get(rawUri);
	    }
	}
	
	return uriMap;
}

var hasRequiredProvideDiagnostics;

function requireProvideDiagnostics () {
	if (hasRequiredProvideDiagnostics) return provideDiagnostics;
	hasRequiredProvideDiagnostics = 1;
	Object.defineProperty(provideDiagnostics, "__esModule", { value: true });
	provideDiagnostics.errorMarkups = void 0;
	provideDiagnostics.register = register;
	provideDiagnostics.transformDiagnostic = transformDiagnostic;
	provideDiagnostics.updateRange = updateRange;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const common_1 = requireCommon$2();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	const uriMap_1 = requireUriMap();
	provideDiagnostics.errorMarkups = (0, uriMap_1.createUriMap)();
	function register(context) {
	    const lastResponses = (0, uriMap_1.createUriMap)();
	    const cacheMaps = {
	        semantic: new Map(),
	        syntactic: new Map(),
	    };
	    context.env.onDidChangeConfiguration?.(() => {
	        lastResponses.clear();
	        cacheMaps.semantic.clear();
	        cacheMaps.syntactic.clear();
	    });
	    return async (uri, response, token = cancellation_1.NoneCancellationToken) => {
	        let langaugeIdAndSnapshot;
	        const decoded = context.decodeEmbeddedDocumentUri(uri);
	        if (decoded) {
	            langaugeIdAndSnapshot = context.language.scripts.get(decoded[0])?.generated?.embeddedCodes.get(decoded[1]);
	        }
	        else {
	            langaugeIdAndSnapshot = context.language.scripts.get(uri);
	        }
	        if (!langaugeIdAndSnapshot) {
	            return [];
	        }
	        const document = context.documents.get(uri, langaugeIdAndSnapshot.languageId, langaugeIdAndSnapshot.snapshot);
	        const lastResponse = lastResponses.get(uri) ?? lastResponses.set(uri, {
	            semantic: { errors: [] },
	            syntactic: { errors: [] },
	        }).get(uri);
	        let updateCacheRangeFailed = false;
	        let errorsUpdated = false;
	        let lastCheckCancelAt = 0;
	        for (const cache of Object.values(lastResponse)) {
	            const oldSnapshot = cache.snapshot;
	            const oldDocument = cache.document;
	            const change = oldSnapshot ? langaugeIdAndSnapshot.snapshot.getChangeRange(oldSnapshot) : undefined;
	            cache.snapshot = langaugeIdAndSnapshot.snapshot;
	            cache.document = document;
	            if (!updateCacheRangeFailed && oldDocument && change) {
	                const changeRange = {
	                    range: {
	                        start: oldDocument.positionAt(change.span.start),
	                        end: oldDocument.positionAt(change.span.start + change.span.length),
	                    },
	                    newEnd: document.positionAt(change.span.start + change.newLength),
	                };
	                for (const error of cache.errors) {
	                    if (!updateRange(error.range, changeRange)) {
	                        updateCacheRangeFailed = true;
	                        break;
	                    }
	                }
	            }
	        }
	        await worker('syntactic', cacheMaps.syntactic, lastResponse.syntactic);
	        processResponse();
	        await worker('semantic', cacheMaps.semantic, lastResponse.semantic);
	        return collectErrors();
	        function processResponse() {
	            if (errorsUpdated && !updateCacheRangeFailed) {
	                response?.(collectErrors());
	                errorsUpdated = false;
	            }
	        }
	        function collectErrors() {
	            return Object.values(lastResponse).flatMap(({ errors }) => errors);
	        }
	        async function worker(kind, cacheMap, cache) {
	            const result = await (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isDiagnosticsEnabled)(mapping.data)), async (plugin, document) => {
	                const interFileDependencies = plugin[0].capabilities.diagnosticProvider?.interFileDependencies;
	                if (kind === 'semantic' !== interFileDependencies) {
	                    return;
	                }
	                if (Date.now() - lastCheckCancelAt >= 10) {
	                    await (0, common_1.sleep)(10); // waiting LSP event polling
	                    lastCheckCancelAt = Date.now();
	                }
	                if (token.isCancellationRequested) {
	                    return;
	                }
	                const pluginIndex = context.plugins.indexOf(plugin);
	                const pluginCache = cacheMap.get(pluginIndex) ?? cacheMap.set(pluginIndex, new Map()).get(pluginIndex);
	                const cache = pluginCache.get(document.uri);
	                if (!interFileDependencies && cache && cache.documentVersion === document.version) {
	                    return cache.errors;
	                }
	                const errors = await plugin[1].provideDiagnostics?.(document, token) || [];
	                errors.forEach(error => {
	                    error.data = {
	                        uri: uri.toString(),
	                        version: document.version,
	                        pluginIndex: pluginIndex,
	                        isFormat: false,
	                        original: {
	                            data: error.data,
	                        },
	                        documentUri: document.uri,
	                    };
	                });
	                errorsUpdated = true;
	                pluginCache.set(document.uri, {
	                    documentVersion: document.version,
	                    errors,
	                });
	                return errors;
	            }, (errors, map) => {
	                return errors
	                    .map(error => transformDiagnostic(context, error, map))
	                    .filter(error => !!error);
	            }, arr => dedupe.withDiagnostics(arr.flat()));
	            if (result) {
	                cache.errors = result;
	                cache.snapshot = langaugeIdAndSnapshot?.snapshot;
	            }
	        }
	    };
	}
	function transformDiagnostic(context, error, docs) {
	    // clone it to avoid modify cache
	    let _error = { ...error };
	    if (docs) {
	        const range = (0, featureWorkers_1.getSourceRange)(docs, error.range, data => (0, language_core_1.shouldReportDiagnostics)(data, error.source, error.code));
	        if (!range) {
	            return;
	        }
	        _error.range = range;
	    }
	    if (_error.relatedInformation) {
	        const relatedInfos = [];
	        for (const info of _error.relatedInformation) {
	            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(info.location.uri));
	            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	            if (sourceScript && virtualCode) {
	                const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                    const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                    const docs = [sourceDocument, embeddedDocument, map];
	                    const range = (0, featureWorkers_1.getSourceRange)(docs, info.location.range, data => (0, language_core_1.shouldReportDiagnostics)(data, undefined, undefined));
	                    if (range) {
	                        relatedInfos.push({
	                            location: {
	                                uri: sourceDocument.uri,
	                                range,
	                            },
	                            message: info.message,
	                        });
	                    }
	                }
	            }
	            else {
	                relatedInfos.push(info);
	            }
	        }
	        _error.relatedInformation = relatedInfos;
	    }
	    return _error;
	}
	function updateRange(range, change) {
	    if (!updatePosition(range.start, change, false)) {
	        return;
	    }
	    if (!updatePosition(range.end, change, true)) {
	        return;
	    }
	    if (range.end.line === range.start.line && range.end.character <= range.start.character) {
	        range.end.character++;
	    }
	    return range;
	}
	function updatePosition(position, change, isEnd) {
	    if (change.range.end.line > position.line) {
	        if (change.newEnd.line > position.line) {
	            // No change
	            return true;
	        }
	        else if (change.newEnd.line === position.line) {
	            position.character = Math.min(position.character, change.newEnd.character);
	            return true;
	        }
	        else if (change.newEnd.line < position.line) {
	            position.line = change.newEnd.line;
	            position.character = change.newEnd.character;
	            return true;
	        }
	    }
	    else if (change.range.end.line === position.line) {
	        const characterDiff = change.newEnd.character - change.range.end.character;
	        if (position.character >= change.range.end.character) {
	            if (change.newEnd.line !== change.range.end.line) {
	                position.line = change.newEnd.line;
	                position.character = change.newEnd.character + position.character - change.range.end.character;
	            }
	            else {
	                if (isEnd
	                    ? change.range.end.character < position.character
	                    : change.range.end.character <= position.character) {
	                    position.character += characterDiff;
	                }
	                else {
	                    const offset = change.range.end.character - position.character;
	                    if (-characterDiff > offset) {
	                        position.character += characterDiff + offset;
	                    }
	                }
	            }
	            return true;
	        }
	        else {
	            if (change.newEnd.line === change.range.end.line) {
	                const offset = change.range.end.character - position.character;
	                if (-characterDiff > offset) {
	                    position.character += characterDiff + offset;
	                }
	            }
	            else if (change.newEnd.line < change.range.end.line) {
	                position.line = change.newEnd.line;
	                position.character = change.newEnd.character;
	            }
	            else ;
	            return true;
	        }
	    }
	    else if (change.range.end.line < position.line) {
	        position.line += change.newEnd.line - change.range.end.line;
	        return true;
	    }
	    return false;
	}
	
	return provideDiagnostics;
}

var provideDocumentColors = {};

var hasRequiredProvideDocumentColors;

function requireProvideDocumentColors () {
	if (hasRequiredProvideDocumentColors) return provideDocumentColors;
	hasRequiredProvideDocumentColors = 1;
	Object.defineProperty(provideDocumentColors, "__esModule", { value: true });
	provideDocumentColors.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isColorEnabled)(mapping.data)), (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideDocumentColors?.(document, token);
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return data
	                .map(color => {
	                const range = (0, featureWorkers_1.getSourceRange)(docs, color.range, language_core_1.isColorEnabled);
	                if (range) {
	                    return {
	                        range,
	                        color: color.color,
	                    };
	                }
	            })
	                .filter(color => !!color);
	        }, arr => arr.flat());
	    };
	}
	
	return provideDocumentColors;
}

var provideDocumentDropEdits = {};

var hasRequiredProvideDocumentDropEdits;

function requireProvideDocumentDropEdits () {
	if (hasRequiredProvideDocumentDropEdits) return provideDocumentDropEdits;
	hasRequiredProvideDocumentDropEdits = 1;
	Object.defineProperty(provideDocumentDropEdits, "__esModule", { value: true });
	provideDocumentDropEdits.register = register;
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, position, dataTransfer, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, function* (docs) {
	            for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position)) {
	                yield mappedPosition;
	            }
	        }, (plugin, document, arg) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideDocumentDropEdits?.(document, arg, dataTransfer, token);
	        }, edit => {
	            if (edit.additionalEdit) {
	                edit.additionalEdit = (0, transform_1.transformWorkspaceEdit)(edit.additionalEdit, context, undefined);
	            }
	            return edit;
	        });
	    };
	}
	
	return provideDocumentDropEdits;
}

var provideDocumentFormattingEdits = {};

var hasRequiredProvideDocumentFormattingEdits;

function requireProvideDocumentFormattingEdits () {
	if (hasRequiredProvideDocumentFormattingEdits) return provideDocumentFormattingEdits;
	hasRequiredProvideDocumentFormattingEdits = 1;
	Object.defineProperty(provideDocumentFormattingEdits, "__esModule", { value: true });
	provideDocumentFormattingEdits.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_languageserver_textdocument_1 = require$$0;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const common_1 = requireCommon$2();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return async (uri, options, range, onTypeParams, token = cancellation_1.NoneCancellationToken) => {
	        const sourceScript = context.language.scripts.get(uri);
	        if (!sourceScript) {
	            return;
	        }
	        let document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
	        range ??= {
	            start: document.positionAt(0),
	            end: document.positionAt(document.getText().length),
	        };
	        if (!sourceScript.generated) {
	            return onTypeParams
	                ? (await tryFormat(document, document, sourceScript, undefined, 0, onTypeParams.position, onTypeParams.ch))
	                    ?.edits
	                : (await tryFormat(document, document, sourceScript, undefined, 0, range, undefined))?.edits;
	        }
	        const embeddedRanges = new Map(); // TODO: Formatting of upper-level virtual code may cause offset of lower-level selection range
	        const startOffset = document.offsetAt(range.start);
	        const endOffset = document.offsetAt(range.end);
	        for (const code of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
	            const map = context.language.maps.get(code, sourceScript);
	            if (map) {
	                const embeddedRange = (0, language_core_1.findOverlapCodeRange)(startOffset, endOffset, map, language_core_1.isFormattingEnabled);
	                if (embeddedRange) {
	                    if (embeddedRange.start === map.mappings[0].generatedOffsets[0]) {
	                        embeddedRange.start = 0;
	                    }
	                    const lastMapping = map.mappings[map.mappings.length - 1];
	                    if (embeddedRange.end
	                        === lastMapping.generatedOffsets[lastMapping.generatedOffsets.length - 1]
	                            + (lastMapping.generatedLengths ?? lastMapping.lengths)[lastMapping.lengths.length - 1]) {
	                        embeddedRange.end = code.snapshot.getLength();
	                    }
	                    embeddedRanges.set(code.id, embeddedRange);
	                }
	            }
	        }
	        try {
	            const originalDocument = document;
	            let tempSourceSnapshot = sourceScript.snapshot;
	            let tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + '.tmp'), sourceScript.snapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
	            if (!tempVirtualFile) {
	                return;
	            }
	            let currentCodes = [];
	            for (let depth = 0; (currentCodes = getNestedEmbeddedFiles(context, sourceScript.id, tempVirtualFile, depth)).length > 0; depth++) {
	                let edits = [];
	                for (const code of currentCodes) {
	                    if (!code.mappings.some(mapping => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
	                        continue;
	                    }
	                    const currentRange = embeddedRanges.get(code.id);
	                    if (!currentRange) {
	                        continue;
	                    }
	                    const isChildRange = [...(0, language_core_1.forEachEmbeddedCode)(code)].some(child => {
	                        if (child === code) {
	                            return false;
	                        }
	                        const childRange = embeddedRanges.get(child.id);
	                        return childRange && childRange.end - childRange.start >= currentRange.end - currentRange.start;
	                    });
	                    if (isChildRange) {
	                        continue;
	                    }
	                    const docs = [
	                        context.documents.get(uri, sourceScript.languageId, tempSourceSnapshot),
	                        context.documents.get(context.encodeEmbeddedDocumentUri(uri, code.id), code.languageId, code.snapshot),
	                        context.language.mapperFactory(code.mappings),
	                    ];
	                    let embeddedResult;
	                    if (onTypeParams) {
	                        for (const embeddedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, onTypeParams.position)) {
	                            embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code, depth, embeddedPosition, onTypeParams.ch);
	                            break;
	                        }
	                    }
	                    else if (currentRange) {
	                        embeddedResult = await tryFormat(docs[0], docs[1], sourceScript, code, depth, {
	                            start: docs[1].positionAt(currentRange.start),
	                            end: docs[1].positionAt(currentRange.end),
	                        });
	                    }
	                    if (!embeddedResult) {
	                        continue;
	                    }
	                    for (const textEdit of embeddedResult.edits) {
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, textEdit.range);
	                        if (range) {
	                            edits.push({
	                                newText: textEdit.newText,
	                                range,
	                            });
	                        }
	                    }
	                }
	                if (edits.length > 0) {
	                    const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
	                    document = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, document.languageId, document.version + 1, newText);
	                    tempSourceSnapshot = (0, common_1.stringToSnapshot)(newText);
	                    tempVirtualFile = context.language.scripts.set(vscode_uri_1.URI.parse(sourceScript.id.toString() + '.tmp'), tempSourceSnapshot, sourceScript.languageId, [sourceScript.generated.languagePlugin])?.generated?.root;
	                    if (!tempVirtualFile) {
	                        break;
	                    }
	                }
	            }
	            if (document.getText() === originalDocument.getText()) {
	                return;
	            }
	            const editRange = {
	                start: originalDocument.positionAt(0),
	                end: originalDocument.positionAt(originalDocument.getText().length),
	            };
	            const textEdit = {
	                range: editRange,
	                newText: document.getText(),
	            };
	            return [textEdit];
	        }
	        finally {
	            context.language.scripts.delete(vscode_uri_1.URI.parse(sourceScript.id.toString() + '.tmp'));
	        }
	        async function tryFormat(sourceDocument, document, sourceScript, virtualCode, embeddedLevel, rangeOrPosition, ch) {
	            if (context.disabledEmbeddedDocumentUris.get(vscode_uri_1.URI.parse(document.uri))) {
	                return;
	            }
	            let codeOptions;
	            rangeOrPosition ??= {
	                start: document.positionAt(0),
	                end: document.positionAt(document.getText().length),
	            };
	            if (virtualCode) {
	                codeOptions = {
	                    level: embeddedLevel,
	                    initialIndentLevel: 0,
	                };
	                if (virtualCode.mappings.length) {
	                    const firstMapping = virtualCode.mappings[0];
	                    const startOffset = firstMapping.sourceOffsets[0];
	                    const startPosition = sourceDocument.positionAt(startOffset);
	                    codeOptions.initialIndentLevel = computeInitialIndent(sourceDocument.getText(), sourceDocument.offsetAt({ line: startPosition.line, character: 0 }), options);
	                }
	                for (const plugin of context.plugins) {
	                    if (context.disabledServicePlugins.has(plugin[1])) {
	                        continue;
	                    }
	                    codeOptions =
	                        await plugin[1].resolveEmbeddedCodeFormattingOptions?.(sourceScript, virtualCode, codeOptions, token)
	                            ?? codeOptions;
	                }
	            }
	            for (const plugin of context.plugins) {
	                if (context.disabledServicePlugins.has(plugin[1])) {
	                    continue;
	                }
	                if (token.isCancellationRequested) {
	                    break;
	                }
	                let edits;
	                try {
	                    if (ch !== undefined && rangeOrPosition && 'line' in rangeOrPosition && 'character' in rangeOrPosition) {
	                        if (plugin[0].capabilities.documentOnTypeFormattingProvider?.triggerCharacters?.includes(ch)) {
	                            edits = await plugin[1].provideOnTypeFormattingEdits?.(document, rangeOrPosition, ch, options, codeOptions, token);
	                        }
	                    }
	                    else if (ch === undefined && rangeOrPosition && 'start' in rangeOrPosition && 'end' in rangeOrPosition) {
	                        edits = await plugin[1].provideDocumentFormattingEdits?.(document, rangeOrPosition, options, codeOptions, token);
	                    }
	                }
	                catch (err) {
	                    console.warn(err);
	                }
	                if (!edits) {
	                    continue;
	                }
	                return {
	                    plugin,
	                    edits,
	                };
	            }
	        }
	    };
	}
	function getNestedEmbeddedFiles(context, uri, rootCode, depth) {
	    const nestedCodesByLevel = [[rootCode]];
	    while (true) {
	        if (nestedCodesByLevel.length > depth) {
	            return nestedCodesByLevel[depth];
	        }
	        const nestedCodes = [];
	        for (const code of nestedCodesByLevel[nestedCodesByLevel.length - 1]) {
	            if (code.embeddedCodes) {
	                for (const embedded of code.embeddedCodes) {
	                    if (!context.disabledEmbeddedDocumentUris.get(context.encodeEmbeddedDocumentUri(uri, embedded.id))) {
	                        nestedCodes.push(embedded);
	                    }
	                }
	            }
	        }
	        nestedCodesByLevel.push(nestedCodes);
	    }
	}
	function computeInitialIndent(content, i, options) {
	    let nChars = 0;
	    const tabSize = options.tabSize || 4;
	    while (i < content.length) {
	        const ch = content.charAt(i);
	        if (ch === ' ') {
	            nChars++;
	        }
	        else if (ch === '\t') {
	            nChars += tabSize;
	        }
	        else {
	            break;
	        }
	        i++;
	    }
	    return Math.floor(nChars / tabSize);
	}
	
	return provideDocumentFormattingEdits;
}

var provideDocumentHighlights = {};

var hasRequiredProvideDocumentHighlights;

function requireProvideDocumentHighlights () {
	if (hasRequiredProvideDocumentHighlights) return provideDocumentHighlights;
	hasRequiredProvideDocumentHighlights = 1;
	Object.defineProperty(provideDocumentHighlights, "__esModule", { value: true });
	provideDocumentHighlights.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isHighlightEnabled), async (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const recursiveChecker = dedupe.createLocationSet();
	            const result = [];
	            await withLinkedCode(document, position);
	            return result;
	            async function withLinkedCode(document, position) {
	                if (!plugin[1].provideDocumentHighlights) {
	                    return;
	                }
	                if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } })) {
	                    return;
	                }
	                recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
	                const references = await plugin[1].provideDocumentHighlights(document, position, token) ?? [];
	                for (const reference of references) {
	                    let foundMirrorPosition = false;
	                    recursiveChecker.add({
	                        uri: document.uri,
	                        range: { start: reference.range.start, end: reference.range.start },
	                    });
	                    const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(document.uri));
	                    const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                    const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                    const linkedCodeMap = virtualCode && sourceScript
	                        ? context.language.linkedCodeMaps.get(virtualCode)
	                        : undefined;
	                    if (sourceScript && virtualCode && linkedCodeMap) {
	                        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                        for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
	                            if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
	                                continue;
	                            }
	                            foundMirrorPosition = true;
	                            await withLinkedCode(embeddedDocument, linkedPos);
	                        }
	                    }
	                    if (!foundMirrorPosition) {
	                        result.push(reference);
	                    }
	                }
	            }
	        }, (data, docs) => data
	            .map(highlight => {
	            if (!docs) {
	                return highlight;
	            }
	            const range = (0, featureWorkers_1.getSourceRange)(docs, highlight.range, language_core_1.isHighlightEnabled);
	            if (range) {
	                return {
	                    ...highlight,
	                    range,
	                };
	            }
	        })
	            .filter(highlight => !!highlight), arr => arr.flat());
	    };
	}
	
	return provideDocumentHighlights;
}

var provideDocumentLinks = {};

var hasRequiredProvideDocumentLinks;

function requireProvideDocumentLinks () {
	if (hasRequiredProvideDocumentLinks) return provideDocumentLinks;
	hasRequiredProvideDocumentLinks = 1;
	Object.defineProperty(provideDocumentLinks, "__esModule", { value: true });
	provideDocumentLinks.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (uri, token = cancellation_1.NoneCancellationToken) => {
	        return await (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isDocumentLinkEnabled)(mapping.data)), async (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const links = await plugin[1].provideDocumentLinks?.(document, token);
	            for (const link of links ?? []) {
	                if (plugin[1].resolveDocumentLink) {
	                    link.data = {
	                        uri: uri.toString(),
	                        original: {
	                            data: link.data,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                    };
	                }
	                else {
	                    delete link.data;
	                }
	            }
	            return links;
	        }, (links, docs) => {
	            if (!docs) {
	                return links;
	            }
	            return links
	                .map(link => {
	                const range = (0, featureWorkers_1.getSourceRange)(docs, link.range, language_core_1.isDocumentLinkEnabled);
	                if (!range) {
	                    return;
	                }
	                link = {
	                    ...link,
	                    range,
	                };
	                if (link.target) {
	                    link.target = (0, transform_1.transformDocumentLinkTarget)(link.target, context).toString();
	                }
	                return link;
	            })
	                .filter(link => !!link);
	        }, arr => arr.flat()) ?? [];
	    };
	}
	
	return provideDocumentLinks;
}

var provideDocumentSemanticTokens = {};

var SemanticTokensBuilder = {};

var hasRequiredSemanticTokensBuilder;

function requireSemanticTokensBuilder () {
	if (hasRequiredSemanticTokensBuilder) return SemanticTokensBuilder;
	hasRequiredSemanticTokensBuilder = 1;
	Object.defineProperty(SemanticTokensBuilder, "__esModule", { value: true });
	SemanticTokensBuilder.SemanticTokensBuilder = void 0;
	let SemanticTokensBuilder$1 = class SemanticTokensBuilder {
	    constructor() {
	        this.initialize();
	    }
	    initialize() {
	        this._id = Date.now();
	        this._prevLine = 0;
	        this._prevChar = 0;
	        this._data = [];
	        this._dataLen = 0;
	    }
	    push(line, char, length, tokenType, tokenModifiers) {
	        let pushLine = line;
	        let pushChar = char;
	        if (this._dataLen > 0) {
	            pushLine -= this._prevLine;
	            if (pushLine === 0) {
	                pushChar -= this._prevChar;
	            }
	        }
	        this._data[this._dataLen++] = pushLine;
	        this._data[this._dataLen++] = pushChar;
	        this._data[this._dataLen++] = length;
	        this._data[this._dataLen++] = tokenType;
	        this._data[this._dataLen++] = tokenModifiers;
	        this._prevLine = line;
	        this._prevChar = char;
	    }
	    get id() {
	        return this._id.toString();
	    }
	    build() {
	        return {
	            resultId: this.id,
	            data: this._data,
	        };
	    }
	};
	SemanticTokensBuilder.SemanticTokensBuilder = SemanticTokensBuilder$1;
	
	return SemanticTokensBuilder;
}

var hasRequiredProvideDocumentSemanticTokens;

function requireProvideDocumentSemanticTokens () {
	if (hasRequiredProvideDocumentSemanticTokens) return provideDocumentSemanticTokens;
	hasRequiredProvideDocumentSemanticTokens = 1;
	Object.defineProperty(provideDocumentSemanticTokens, "__esModule", { value: true });
	provideDocumentSemanticTokens.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const SemanticTokensBuilder_1 = requireSemanticTokensBuilder();
	function register(context) {
	    return async (uri, range, legend, _reportProgress, // TODO
	    token = cancellation_1.NoneCancellationToken) => {
	        const sourceScript = context.language.scripts.get(uri);
	        if (!sourceScript) {
	            return;
	        }
	        const document = context.documents.get(uri, sourceScript.languageId, sourceScript.snapshot);
	        if (!range) {
	            range = {
	                start: { line: 0, character: 0 },
	                end: { line: document.lineCount - 1, character: document.getText().length },
	            };
	        }
	        const tokens = await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
	            const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isSemanticTokensEnabled);
	            if (mapped) {
	                yield {
	                    start: docs[1].positionAt(mapped.start),
	                    end: docs[1].positionAt(mapped.end),
	                };
	            }
	        }, (plugin, document, range) => {
	            if (token?.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideDocumentSemanticTokens?.(document, range, legend, token);
	        }, (tokens, docs) => {
	            if (!docs) {
	                return tokens;
	            }
	            return tokens
	                .map(_token => {
	                const range = (0, featureWorkers_1.getSourceRange)(docs, {
	                    start: { line: _token[0], character: _token[1] },
	                    end: { line: _token[0], character: _token[1] + _token[2] },
	                }, language_core_1.isSemanticTokensEnabled);
	                if (range) {
	                    return [
	                        range.start.line,
	                        range.start.character,
	                        range.end.character - range.start.character,
	                        _token[3],
	                        _token[4],
	                    ];
	                }
	            })
	                .filter(token => !!token);
	        }, tokens => tokens.flat());
	        if (tokens) {
	            return buildTokens(tokens);
	        }
	    };
	}
	function buildTokens(tokens) {
	    const builder = new SemanticTokensBuilder_1.SemanticTokensBuilder();
	    const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
	    for (const token of sortedTokens) {
	        builder.push(...token);
	    }
	    return builder.build();
	}
	
	return provideDocumentSemanticTokens;
}

var provideDocumentSymbols = {};

var hasRequiredProvideDocumentSymbols;

function requireProvideDocumentSymbols () {
	if (hasRequiredProvideDocumentSymbols) return provideDocumentSymbols;
	hasRequiredProvideDocumentSymbols = 1;
	Object.defineProperty(provideDocumentSymbols, "__esModule", { value: true });
	provideDocumentSymbols.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const common_1 = requireCommon$2();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isSymbolsEnabled)(mapping.data)), (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideDocumentSymbols?.(document, token);
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return data
	                .map(symbol => (0, transform_1.transformDocumentSymbol)(symbol, range => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSymbolsEnabled)))
	                .filter(symbol => !!symbol);
	        }, results => {
	            for (let i = 0; i < results.length; i++) {
	                for (let j = 0; j < results.length; j++) {
	                    if (i === j) {
	                        continue;
	                    }
	                    results[i] = results[i].filter(child => {
	                        for (const parent of forEachSymbol(results[j])) {
	                            if ((0, common_1.isInsideRange)(parent.range, child.range)) {
	                                parent.children ??= [];
	                                parent.children.push(child);
	                                return false;
	                            }
	                        }
	                        return true;
	                    });
	                }
	            }
	            return results.flat();
	        });
	    };
	}
	function* forEachSymbol(symbols) {
	    for (const symbol of symbols) {
	        if (symbol.children) {
	            yield* forEachSymbol(symbol.children);
	        }
	        yield symbol;
	    }
	}
	
	return provideDocumentSymbols;
}

var provideFileReferences = {};

var hasRequiredProvideFileReferences;

function requireProvideFileReferences () {
	if (hasRequiredProvideFileReferences) return provideFileReferences;
	hasRequiredProvideFileReferences = 1;
	Object.defineProperty(provideFileReferences, "__esModule", { value: true });
	provideFileReferences.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, () => true, async (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return await plugin[1].provideFileReferences?.(document, token) ?? [];
	        }, data => data
	            .map(reference => {
	            const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
	            const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	            const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	            if (!sourceScript || !virtualCode) {
	                return reference;
	            }
	            const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	            for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                const docs = [sourceDocument, embeddedDocument, map];
	                const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
	                if (range) {
	                    reference.uri = sourceDocument.uri;
	                    reference.range = range;
	                    return reference;
	                }
	            }
	        })
	            .filter(reference => !!reference), arr => dedupe.withLocations(arr.flat()));
	    };
	}
	
	return provideFileReferences;
}

var provideFileRenameEdits = {};

var hasRequiredProvideFileRenameEdits;

function requireProvideFileRenameEdits () {
	if (hasRequiredProvideFileRenameEdits) return provideFileRenameEdits;
	hasRequiredProvideFileRenameEdits = 1;
	Object.defineProperty(provideFileRenameEdits, "__esModule", { value: true });
	provideFileRenameEdits.register = register;
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (oldUri, newUri, token = cancellation_1.NoneCancellationToken) => {
	        for (const plugin of context.plugins) {
	            if (context.disabledServicePlugins.has(plugin[1])) {
	                continue;
	            }
	            if (token.isCancellationRequested) {
	                break;
	            }
	            if (!plugin[1].provideFileRenameEdits) {
	                continue;
	            }
	            const workspaceEdit = await plugin[1].provideFileRenameEdits(oldUri, newUri, token);
	            if (workspaceEdit) {
	                const result = (0, transform_1.transformWorkspaceEdit)(workspaceEdit, context, 'fileName');
	                if (result?.documentChanges) {
	                    result.documentChanges = dedupe.withDocumentChanges(result.documentChanges);
	                }
	                return result;
	            }
	        }
	    };
	}
	
	return provideFileRenameEdits;
}

var provideFoldingRanges = {};

var hasRequiredProvideFoldingRanges;

function requireProvideFoldingRanges () {
	if (hasRequiredProvideFoldingRanges) return provideFoldingRanges;
	hasRequiredProvideFoldingRanges = 1;
	Object.defineProperty(provideFoldingRanges, "__esModule", { value: true });
	provideFoldingRanges.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.documentFeatureWorker)(context, uri, docs => docs[2].mappings.some(mapping => (0, language_core_1.isFoldingRangesEnabled)(mapping.data)), (plugin, document) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideFoldingRanges?.(document, token);
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return (0, transform_1.transformFoldingRanges)(data, range => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isFoldingRangesEnabled));
	        }, arr => arr.flat());
	    };
	}
	
	return provideFoldingRanges;
}

var provideHover = {};

var hasRequiredProvideHover;

function requireProvideHover () {
	if (hasRequiredProvideHover) return provideHover;
	hasRequiredProvideHover = 1;
	Object.defineProperty(provideHover, "__esModule", { value: true });
	provideHover.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const common_1 = requireCommon$2();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	const provideDiagnostics_1 = requireProvideDiagnostics();
	function register(context) {
	    return async (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        let hover = await (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isHoverEnabled), (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideHover?.(document, position, token);
	        }, (item, docs) => {
	            if (!docs || !item.range) {
	                return item;
	            }
	            item.range = (0, featureWorkers_1.getSourceRange)(docs, item.range, language_core_1.isHoverEnabled);
	            return item;
	        }, (hovers) => ({
	            contents: {
	                kind: 'markdown',
	                value: hovers.map(getHoverTexts).flat().join('\n\n---\n\n'),
	            },
	            range: hovers.find(hover => hover.range && (0, common_1.isInsideRange)(hover.range, { start: position, end: position }))?.range
	                ?? hovers[0].range,
	        }));
	        const markups = provideDiagnostics_1.errorMarkups.get(uri);
	        if (markups) {
	            for (const errorAndMarkup of markups) {
	                if ((0, common_1.isInsideRange)(errorAndMarkup.error.range, { start: position, end: position })) {
	                    hover ??= {
	                        contents: {
	                            kind: 'markdown',
	                            value: '',
	                        },
	                    };
	                    hover.range = errorAndMarkup.error.range;
	                    if (typeof hover.contents !== 'object' || typeof hover.contents !== 'string') {
	                        hover.contents = {
	                            kind: 'markdown',
	                            value: hover.contents,
	                        };
	                    }
	                    if (hover.contents.value) {
	                        hover.contents.value += '\n\n---\n\n';
	                    }
	                    hover.contents.value += errorAndMarkup.markup.value;
	                }
	            }
	        }
	        return hover;
	    };
	    function getHoverTexts(hover) {
	        if (typeof hover.contents === 'string') {
	            return [(0, transform_1.transformMarkdown)(hover.contents, context)];
	        }
	        if (Array.isArray(hover.contents)) {
	            return hover.contents.map(content => {
	                if (typeof content === 'string') {
	                    return (0, transform_1.transformMarkdown)(content, context);
	                }
	                if (content.language === 'md') {
	                    return `\`\`\`${content.language}\n${(0, transform_1.transformMarkdown)(content.value, context)}\n\`\`\``;
	                }
	                else {
	                    return `\`\`\`${content.language}\n${content.value}\n\`\`\``;
	                }
	            });
	        }
	        if ('kind' in hover.contents) {
	            if (hover.contents.kind === 'markdown') {
	                return [(0, transform_1.transformMarkdown)(hover.contents.value, context)];
	            }
	            else {
	                return [hover.contents.value];
	            }
	        }
	        if (hover.contents.language === 'md') {
	            return [`\`\`\`${hover.contents.language}\n${(0, transform_1.transformMarkdown)(hover.contents.value, context)}\n\`\`\``];
	        }
	        else {
	            return [`\`\`\`${hover.contents.language}\n${hover.contents.value}\n\`\`\``];
	        }
	    }
	}
	
	return provideHover;
}

var provideInlayHints = {};

var hasRequiredProvideInlayHints;

function requireProvideInlayHints () {
	if (hasRequiredProvideInlayHints) return provideInlayHints;
	hasRequiredProvideInlayHints = 1;
	Object.defineProperty(provideInlayHints, "__esModule", { value: true });
	provideInlayHints.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, range, token = cancellation_1.NoneCancellationToken) => {
	        const sourceScript = context.language.scripts.get(uri);
	        if (!sourceScript) {
	            return;
	        }
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, function* (docs) {
	            const mapped = (0, language_core_1.findOverlapCodeRange)(docs[0].offsetAt(range.start), docs[0].offsetAt(range.end), docs[2], language_core_1.isInlayHintsEnabled);
	            if (mapped) {
	                yield {
	                    start: docs[1].positionAt(mapped.start),
	                    end: docs[1].positionAt(mapped.end),
	                };
	            }
	        }, async (plugin, document, arg) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const hints = await plugin[1].provideInlayHints?.(document, arg, token);
	            hints?.forEach(link => {
	                if (plugin[1].resolveInlayHint) {
	                    link.data = {
	                        uri: uri.toString(),
	                        original: {
	                            data: link.data,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                    };
	                }
	                else {
	                    delete link.data;
	                }
	            });
	            return hints;
	        }, (inlayHints, docs) => {
	            if (!docs) {
	                return inlayHints;
	            }
	            return inlayHints
	                .map((_inlayHint) => {
	                const edits = _inlayHint.textEdits
	                    ?.map(textEdit => (0, transform_1.transformTextEdit)(textEdit, range => (0, featureWorkers_1.getSourceRange)(docs, range), docs[1]))
	                    .filter(textEdit => !!textEdit);
	                for (const position of (0, featureWorkers_1.getSourcePositions)(docs, _inlayHint.position, language_core_1.isInlayHintsEnabled)) {
	                    return {
	                        ..._inlayHint,
	                        position,
	                        textEdits: edits,
	                    };
	                }
	            })
	                .filter(hint => !!hint);
	        }, arr => arr.flat());
	    };
	}
	
	return provideInlayHints;
}

var provideInlineValue = {};

var hasRequiredProvideInlineValue;

function requireProvideInlineValue () {
	if (hasRequiredProvideInlineValue) return provideInlineValue;
	hasRequiredProvideInlineValue = 1;
	Object.defineProperty(provideInlineValue, "__esModule", { value: true });
	provideInlineValue.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, range, ivContext, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => range, docs => (0, featureWorkers_1.getGeneratedRanges)(docs, range, language_core_1.isInlineValueEnabled), (plugin, document, range) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideInlineValues?.(document, range, ivContext, token);
	        }, (items, docs) => {
	            if (!docs) {
	                return items;
	            }
	            return items
	                .map(item => {
	                const mappedRange = (0, featureWorkers_1.getSourceRange)(docs, item.range, language_core_1.isInlineValueEnabled);
	                if (mappedRange) {
	                    item.range = mappedRange;
	                    return item;
	                }
	            })
	                .filter(item => !!item);
	        }, results => results.flat());
	    };
	}
	
	return provideInlineValue;
}

var provideLinkedEditingRanges = {};

var hasRequiredProvideLinkedEditingRanges;

function requireProvideLinkedEditingRanges () {
	if (hasRequiredProvideLinkedEditingRanges) return provideLinkedEditingRanges;
	hasRequiredProvideLinkedEditingRanges = 1;
	Object.defineProperty(provideLinkedEditingRanges, "__esModule", { value: true });
	provideLinkedEditingRanges.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, function* (docs) {
	            for (const pos of (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isLinkedEditingEnabled)) {
	                yield pos;
	            }
	        }, (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideLinkedEditingRanges?.(document, position, token);
	        }, (ranges, docs) => {
	            if (!docs) {
	                return ranges;
	            }
	            return {
	                wordPattern: ranges.wordPattern,
	                ranges: ranges.ranges
	                    .map(range => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isLinkedEditingEnabled))
	                    .filter(range => !!range),
	            };
	        });
	    };
	}
	
	return provideLinkedEditingRanges;
}

var provideMoniker = {};

var hasRequiredProvideMoniker;

function requireProvideMoniker () {
	if (hasRequiredProvideMoniker) return provideMoniker;
	hasRequiredProvideMoniker = 1;
	Object.defineProperty(provideMoniker, "__esModule", { value: true });
	provideMoniker.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isMonikerEnabled), (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideMoniker?.(document, position, token);
	        }, result => result, results => results.flat());
	    };
	}
	
	return provideMoniker;
}

var provideReferences = {};

var hasRequiredProvideReferences;

function requireProvideReferences () {
	if (hasRequiredProvideReferences) return provideReferences;
	hasRequiredProvideReferences = 1;
	Object.defineProperty(provideReferences, "__esModule", { value: true });
	provideReferences.register = register;
	const language_core_1 = requireLanguageCore();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const dedupe = requireDedupe$1();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, referenceContext, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isReferencesEnabled), async (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const recursiveChecker = dedupe.createLocationSet();
	            const result = [];
	            await withLinkedCode(document, position);
	            return result;
	            async function withLinkedCode(document, position) {
	                if (!plugin[1].provideReferences) {
	                    return;
	                }
	                if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } })) {
	                    return;
	                }
	                recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
	                const references = await plugin[1].provideReferences(document, position, referenceContext, token) ?? [];
	                for (const reference of references) {
	                    let foundMirrorPosition = false;
	                    recursiveChecker.add({
	                        uri: reference.uri,
	                        range: { start: reference.range.start, end: reference.range.start },
	                    });
	                    const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
	                    const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                    const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                    const linkedCodeMap = virtualCode && sourceScript
	                        ? context.language.linkedCodeMaps.get(virtualCode)
	                        : undefined;
	                    if (sourceScript && virtualCode && linkedCodeMap) {
	                        const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                        for (const linkedPos of (0, featureWorkers_1.getLinkedCodePositions)(embeddedDocument, linkedCodeMap, reference.range.start)) {
	                            if (recursiveChecker.has({ uri: embeddedDocument.uri, range: { start: linkedPos, end: linkedPos } })) {
	                                continue;
	                            }
	                            foundMirrorPosition = true;
	                            await withLinkedCode(embeddedDocument, linkedPos);
	                        }
	                    }
	                    if (!foundMirrorPosition) {
	                        result.push(reference);
	                    }
	                }
	            }
	        }, data => {
	            const results = [];
	            for (const reference of data) {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(reference.uri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (sourceScript && virtualCode) {
	                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                    for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                        const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                        const docs = [sourceDocument, embeddedDocument, map];
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, reference.range, language_core_1.isReferencesEnabled);
	                        if (range) {
	                            results.push({
	                                uri: sourceDocument.uri,
	                                range,
	                            });
	                        }
	                    }
	                }
	                else {
	                    results.push(reference);
	                }
	            }
	            return results;
	        }, arr => dedupe.withLocations(arr.flat()));
	    };
	}
	
	return provideReferences;
}

var provideRenameRange = {};

var hasRequiredProvideRenameRange;

function requireProvideRenameRange () {
	if (hasRequiredProvideRenameRange) return provideRenameRange;
	hasRequiredProvideRenameRange = 1;
	Object.defineProperty(provideRenameRange, "__esModule", { value: true });
	provideRenameRange.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isRenameEnabled), (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            return plugin[1].provideRenameRange?.(document, position, token);
	        }, (item, docs) => {
	            if (!docs) {
	                return item;
	            }
	            if ('start' in item && 'end' in item) {
	                return (0, featureWorkers_1.getSourceRange)(docs, item);
	            }
	            return item;
	        }, prepares => {
	            for (const prepare of prepares) {
	                if ('start' in prepare && 'end' in prepare) {
	                    return prepare; // if has any valid range, ignore other errors
	                }
	            }
	            return prepares[0];
	        });
	    };
	}
	
	return provideRenameRange;
}

var provideSelectionRanges = {};

var hasRequiredProvideSelectionRanges;

function requireProvideSelectionRanges () {
	if (hasRequiredProvideSelectionRanges) return provideSelectionRanges;
	hasRequiredProvideSelectionRanges = 1;
	Object.defineProperty(provideSelectionRanges, "__esModule", { value: true });
	provideSelectionRanges.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const common_1 = requireCommon$2();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return (uri, positions, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => positions, function* (docs) {
	            const result = positions
	                .map(position => {
	                for (const mappedPosition of (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isSelectionRangesEnabled)) {
	                    return mappedPosition;
	                }
	            })
	                .filter(position => !!position);
	            if (result.length) {
	                yield result;
	            }
	        }, async (plugin, document, positions) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            const selectionRanges = await plugin[1].provideSelectionRanges?.(document, positions, token);
	            if (selectionRanges && selectionRanges.length !== positions.length) {
	                console.error('Selection ranges count should be equal to positions count:', plugin[0].name, selectionRanges.length, positions.length);
	                return;
	            }
	            return selectionRanges;
	        }, (data, docs) => {
	            if (!docs) {
	                return data;
	            }
	            return (0, transform_1.transformSelectionRanges)(data, range => (0, featureWorkers_1.getSourceRange)(docs, range, language_core_1.isSelectionRangesEnabled));
	        }, results => {
	            const result = [];
	            for (let i = 0; i < positions.length; i++) {
	                let pluginResults = [];
	                for (const ranges of results) {
	                    pluginResults.push(ranges[i]);
	                }
	                pluginResults = pluginResults.sort((a, b) => {
	                    if ((0, common_1.isInsideRange)(a.range, b.range)) {
	                        return 1;
	                    }
	                    if ((0, common_1.isInsideRange)(b.range, a.range)) {
	                        return -1;
	                    }
	                    return 0;
	                });
	                for (let j = 1; j < pluginResults.length; j++) {
	                    let top = pluginResults[j - 1];
	                    const parent = pluginResults[j];
	                    while (top.parent && (0, common_1.isInsideRange)(parent.range, top.parent.range)
	                        && !(0, common_1.isEqualRange)(parent.range, top.parent.range)) {
	                        top = top.parent;
	                    }
	                    if (top) {
	                        top.parent = parent;
	                    }
	                }
	                result.push(pluginResults[0]);
	            }
	            return result;
	        });
	    };
	}
	
	return provideSelectionRanges;
}

var provideSignatureHelp = {};

var hasRequiredProvideSignatureHelp;

function requireProvideSignatureHelp () {
	if (hasRequiredProvideSignatureHelp) return provideSignatureHelp;
	hasRequiredProvideSignatureHelp = 1;
	Object.defineProperty(provideSignatureHelp, "__esModule", { value: true });
	provideSignatureHelp.register = register;
	const language_core_1 = requireLanguageCore();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	function register(context) {
	    return (uri, position, signatureHelpContext = {
	        triggerKind: 1,
	        isRetrigger: false,
	    }, token = cancellation_1.NoneCancellationToken) => {
	        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, () => position, docs => (0, featureWorkers_1.getGeneratedPositions)(docs, position, language_core_1.isSignatureHelpEnabled), (plugin, document, position) => {
	            if (token.isCancellationRequested) {
	                return;
	            }
	            if (signatureHelpContext?.triggerKind === 2
	                && signatureHelpContext.triggerCharacter
	                && !(signatureHelpContext.isRetrigger
	                    ? plugin[0].capabilities.signatureHelpProvider?.retriggerCharacters
	                    : plugin[0].capabilities.signatureHelpProvider?.triggerCharacters)?.includes(signatureHelpContext.triggerCharacter)) {
	                return;
	            }
	            return plugin[1].provideSignatureHelp?.(document, position, signatureHelpContext, token);
	        }, data => data);
	    };
	}
	
	return provideSignatureHelp;
}

var provideWorkspaceDiagnostics = {};

var hasRequiredProvideWorkspaceDiagnostics;

function requireProvideWorkspaceDiagnostics () {
	if (hasRequiredProvideWorkspaceDiagnostics) return provideWorkspaceDiagnostics;
	hasRequiredProvideWorkspaceDiagnostics = 1;
	Object.defineProperty(provideWorkspaceDiagnostics, "__esModule", { value: true });
	provideWorkspaceDiagnostics.register = register;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const provideDiagnostics_1 = requireProvideDiagnostics();
	function register(context) {
	    return async (token = cancellation_1.NoneCancellationToken) => {
	        const allItems = [];
	        for (const plugin of context.plugins) {
	            if (context.disabledServicePlugins.has(plugin[1])) {
	                continue;
	            }
	            if (token.isCancellationRequested) {
	                break;
	            }
	            if (!plugin[1].provideWorkspaceDiagnostics) {
	                continue;
	            }
	            const report = await plugin[1].provideWorkspaceDiagnostics(token);
	            if (!report) {
	                continue;
	            }
	            const items = report
	                .map(item => {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(item.uri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (virtualCode && sourceScript) {
	                    if (item.kind === 'unchanged') {
	                        return {
	                            ...item,
	                            uri: sourceScript.id.toString(),
	                        };
	                    }
	                    else {
	                        const map = context.language.maps.get(virtualCode, sourceScript);
	                        const docs = [
	                            context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot),
	                            context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot),
	                            map,
	                        ];
	                        return {
	                            ...item,
	                            items: item.items
	                                .map(error => (0, provideDiagnostics_1.transformDiagnostic)(context, error, docs))
	                                .filter(error => !!error),
	                        };
	                    }
	                }
	                else {
	                    if (item.kind === 'unchanged') {
	                        return item;
	                    }
	                    return {
	                        ...item,
	                        items: item.items
	                            .map(error => (0, provideDiagnostics_1.transformDiagnostic)(context, error, undefined))
	                            .filter(error => !!error),
	                    };
	                }
	            });
	            allItems.push(...items);
	        }
	        return allItems;
	    };
	}
	
	return provideWorkspaceDiagnostics;
}

var provideWorkspaceSymbols = {};

var hasRequiredProvideWorkspaceSymbols;

function requireProvideWorkspaceSymbols () {
	if (hasRequiredProvideWorkspaceSymbols) return provideWorkspaceSymbols;
	hasRequiredProvideWorkspaceSymbols = 1;
	Object.defineProperty(provideWorkspaceSymbols, "__esModule", { value: true });
	provideWorkspaceSymbols.register = register;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (query, token = cancellation_1.NoneCancellationToken) => {
	        const symbolsList = [];
	        for (const plugin of context.plugins) {
	            if (context.disabledServicePlugins.has(plugin[1])) {
	                continue;
	            }
	            if (token.isCancellationRequested) {
	                break;
	            }
	            if (!plugin[1].provideWorkspaceSymbols) {
	                continue;
	            }
	            const embeddedSymbols = await plugin[1].provideWorkspaceSymbols(query, token);
	            if (!embeddedSymbols) {
	                continue;
	            }
	            const symbols = embeddedSymbols
	                .map(symbol => (0, transform_1.transformWorkspaceSymbol)(symbol, loc => {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(loc.uri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (sourceScript && virtualCode) {
	                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                    for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                        const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                        const docs = [sourceDocument, embeddedDocument, map];
	                        const range = (0, featureWorkers_1.getSourceRange)(docs, loc.range);
	                        if (range) {
	                            return { uri: sourceDocument.uri, range };
	                        }
	                    }
	                }
	                else {
	                    return loc;
	                }
	            }))
	                .filter(symbol => !!symbol);
	            symbols?.forEach(symbol => {
	                if (plugin[1].resolveWorkspaceSymbol) {
	                    symbol.data = {
	                        original: {
	                            data: symbol.data,
	                        },
	                        pluginIndex: context.plugins.indexOf(plugin),
	                    };
	                }
	                else {
	                    delete symbol.data;
	                }
	            });
	            symbolsList.push(symbols);
	        }
	        return symbolsList.flat();
	    };
	}
	
	return provideWorkspaceSymbols;
}

var resolveCodeAction = {};

var hasRequiredResolveCodeAction;

function requireResolveCodeAction () {
	if (hasRequiredResolveCodeAction) return resolveCodeAction;
	hasRequiredResolveCodeAction = 1;
	Object.defineProperty(resolveCodeAction, "__esModule", { value: true });
	resolveCodeAction.register = register;
	const cancellation_1 = requireCancellation();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data) {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveCodeAction) {
	                delete item.data;
	                return item;
	            }
	            Object.assign(item, data.original);
	            item = await plugin[1].resolveCodeAction(item, token);
	            item = plugin[1].transformCodeAction?.(item)
	                ?? (item.edit
	                    ? {
	                        ...item,
	                        edit: (0, transform_1.transformWorkspaceEdit)(item.edit, context, 'codeAction', { [data.uri]: data.version }),
	                    }
	                    : item);
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveCodeAction;
}

var resolveCodeLens = {};

var hasRequiredResolveCodeLens;

function requireResolveCodeLens () {
	if (hasRequiredResolveCodeLens) return resolveCodeLens;
	hasRequiredResolveCodeLens = 1;
	Object.defineProperty(resolveCodeLens, "__esModule", { value: true });
	resolveCodeLens.register = register;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const references = requireProvideReferences();
	function register(context) {
	    const findReferences = references.register(context);
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data?.kind === 'normal') {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveCodeLens) {
	                delete item.data;
	                return item;
	            }
	            Object.assign(item, data.original);
	            item = await plugin[1].resolveCodeLens(item, token);
	            // item.range already transformed in codeLens request
	        }
	        else if (data?.kind === 'references') {
	            const references = await findReferences(vscode_uri_1.URI.parse(data.sourceFileUri), item.range.start, { includeDeclaration: false }, token)
	                ?? [];
	            item.command = context.commands.showReferences.create(data.sourceFileUri, item.range.start, references);
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveCodeLens;
}

var resolveCompletionItem = {};

var hasRequiredResolveCompletionItem;

function requireResolveCompletionItem () {
	if (hasRequiredResolveCompletionItem) return resolveCompletionItem;
	hasRequiredResolveCompletionItem = 1;
	Object.defineProperty(resolveCompletionItem, "__esModule", { value: true });
	resolveCompletionItem.register = register;
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const cancellation_1 = requireCancellation();
	const featureWorkers_1 = requireFeatureWorkers();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data) {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveCompletionItem) {
	                delete item.data;
	                return item;
	            }
	            item = Object.assign(item, data.original);
	            if (data.embeddedDocumentUri) {
	                const decoded = context.decodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(data.embeddedDocumentUri));
	                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
	                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
	                if (sourceScript && virtualCode) {
	                    const embeddedDocument = context.documents.get(context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id), virtualCode.languageId, virtualCode.snapshot);
	                    for (const [sourceScript, map] of context.language.maps.forEach(virtualCode)) {
	                        const sourceDocument = context.documents.get(sourceScript.id, sourceScript.languageId, sourceScript.snapshot);
	                        const docs = [sourceDocument, embeddedDocument, map];
	                        item = await plugin[1].resolveCompletionItem(item, token);
	                        item = plugin[1].transformCompletionItem?.(item) ?? (0, transform_1.transformCompletionItem)(item, embeddedRange => (0, featureWorkers_1.getSourceRange)(docs, embeddedRange), embeddedDocument, context);
	                    }
	                }
	            }
	            else {
	                item = await plugin[1].resolveCompletionItem(item, token);
	            }
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveCompletionItem;
}

var resolveDocumentLink = {};

var hasRequiredResolveDocumentLink;

function requireResolveDocumentLink () {
	if (hasRequiredResolveDocumentLink) return resolveDocumentLink;
	hasRequiredResolveDocumentLink = 1;
	Object.defineProperty(resolveDocumentLink, "__esModule", { value: true });
	resolveDocumentLink.register = register;
	const cancellation_1 = requireCancellation();
	const transform_1 = requireTransform$1();
	function register(context) {
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data) {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveDocumentLink) {
	                delete item.data;
	                return item;
	            }
	            Object.assign(item, data.original);
	            item = await plugin[1].resolveDocumentLink(item, token);
	            if (item.target) {
	                item.target = (0, transform_1.transformDocumentLinkTarget)(item.target, context).toString();
	            }
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveDocumentLink;
}

var resolveInlayHint = {};

var hasRequiredResolveInlayHint;

function requireResolveInlayHint () {
	if (hasRequiredResolveInlayHint) return resolveInlayHint;
	hasRequiredResolveInlayHint = 1;
	Object.defineProperty(resolveInlayHint, "__esModule", { value: true });
	resolveInlayHint.register = register;
	const cancellation_1 = requireCancellation();
	function register(context) {
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data) {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveInlayHint) {
	                delete item.data;
	                return item;
	            }
	            Object.assign(item, data.original);
	            item = await plugin[1].resolveInlayHint(item, token);
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveInlayHint;
}

var resolveWorkspaceSymbol = {};

var hasRequiredResolveWorkspaceSymbol;

function requireResolveWorkspaceSymbol () {
	if (hasRequiredResolveWorkspaceSymbol) return resolveWorkspaceSymbol;
	hasRequiredResolveWorkspaceSymbol = 1;
	Object.defineProperty(resolveWorkspaceSymbol, "__esModule", { value: true });
	resolveWorkspaceSymbol.register = register;
	const cancellation_1 = requireCancellation();
	function register(context) {
	    return async (item, token = cancellation_1.NoneCancellationToken) => {
	        const data = item.data;
	        if (data) {
	            const plugin = context.plugins[data.pluginIndex];
	            if (!plugin[1].resolveWorkspaceSymbol) {
	                delete item.data;
	                return item;
	            }
	            Object.assign(item, data.original);
	            item = await plugin[1].resolveWorkspaceSymbol(item, token);
	        }
	        delete item.data;
	        return item;
	    };
	}
	
	return resolveWorkspaceSymbol;
}

var hasRequiredLanguageService$1;

function requireLanguageService$1 () {
	if (hasRequiredLanguageService$1) return languageService;
	hasRequiredLanguageService$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.embeddedContentScheme = void 0;
		exports$1.createLanguageService = createLanguageService;
		exports$1.decodeEmbeddedDocumentUri = decodeEmbeddedDocumentUri;
		exports$1.encodeEmbeddedDocumentUri = encodeEmbeddedDocumentUri;
		const language_core_1 = requireLanguageCore();
		const vscode_languageserver_textdocument_1 = require$$0;
		const vscode_uri_1 = /*@__PURE__*/ requireUmd();
		const autoInsert = requireProvideAutoInsertSnippet();
		const hierarchy = requireProvideCallHierarchyItems();
		const codeActions = requireProvideCodeActions();
		const codeLens = requireProvideCodeLenses();
		const colorPresentations = requireProvideColorPresentations();
		const completions = requireProvideCompletionItems();
		const definition = requireProvideDefinition();
		const diagnostics = requireProvideDiagnostics();
		const documentColors = requireProvideDocumentColors();
		const documentDrop = requireProvideDocumentDropEdits();
		const format = requireProvideDocumentFormattingEdits();
		const documentHighlight = requireProvideDocumentHighlights();
		const documentLink = requireProvideDocumentLinks();
		const semanticTokens = requireProvideDocumentSemanticTokens();
		const documentSymbols = requireProvideDocumentSymbols();
		const fileReferences = requireProvideFileReferences();
		const fileRename = requireProvideFileRenameEdits();
		const foldingRanges = requireProvideFoldingRanges();
		const hover = requireProvideHover();
		const inlayHints = requireProvideInlayHints();
		const inlineValue = requireProvideInlineValue();
		const linkedEditing = requireProvideLinkedEditingRanges();
		const moniker = requireProvideMoniker();
		const references = requireProvideReferences();
		const rename = requireProvideRenameEdits();
		const renamePrepare = requireProvideRenameRange();
		const selectionRanges = requireProvideSelectionRanges();
		const signatureHelp = requireProvideSignatureHelp();
		const workspaceDiagnostics = requireProvideWorkspaceDiagnostics();
		const workspaceSymbol = requireProvideWorkspaceSymbols();
		const codeActionResolve = requireResolveCodeAction();
		const codeLensResolve = requireResolveCodeLens();
		const completionResolve = requireResolveCompletionItem();
		const documentLinkResolve = requireResolveDocumentLink();
		const inlayHintResolve = requireResolveInlayHint();
		const workspaceSymbolResolve = requireResolveWorkspaceSymbol();
		const cancellation_1 = requireCancellation();
		const uriMap_1 = requireUriMap();
		exports$1.embeddedContentScheme = 'volar-embedded-content';
		function createLanguageService(language, plugins, env, project) {
		    const documentVersions = (0, uriMap_1.createUriMap)();
		    const snapshot2Doc = new WeakMap();
		    const context = {
		        language,
		        project,
		        getLanguageService: () => langaugeService,
		        documents: {
		            get(uri, languageId, snapshot) {
		                if (!snapshot2Doc.has(snapshot)) {
		                    snapshot2Doc.set(snapshot, (0, uriMap_1.createUriMap)());
		                }
		                const map = snapshot2Doc.get(snapshot);
		                if (!map.has(uri)) {
		                    const version = documentVersions.get(uri) ?? 0;
		                    documentVersions.set(uri, version + 1);
		                    map.set(uri, vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), languageId, version, snapshot.getText(0, snapshot.getLength())));
		                }
		                return map.get(uri);
		            },
		        },
		        env,
		        inject: (key, ...args) => {
		            for (const plugin of context.plugins) {
		                if (context.disabledServicePlugins.has(plugin[1])) {
		                    continue;
		                }
		                const provide = plugin[1].provide?.[key];
		                if (provide) {
		                    return provide(...args);
		                }
		            }
		        },
		        plugins: [],
		        commands: {
		            rename: {
		                create(uri, position) {
		                    return {
		                        title: '',
		                        command: 'editor.action.rename',
		                        arguments: [
		                            uri,
		                            position,
		                        ],
		                    };
		                },
		                is(command) {
		                    return command.command === 'editor.action.rename';
		                },
		            },
		            showReferences: {
		                create(uri, position, locations) {
		                    return {
		                        title: locations.length === 1 ? '1 reference' : `${locations.length} references`,
		                        command: 'editor.action.showReferences',
		                        arguments: [
		                            uri,
		                            position,
		                            locations,
		                        ],
		                    };
		                },
		                is(command) {
		                    return command.command === 'editor.action.showReferences';
		                },
		            },
		            setSelection: {
		                create(position) {
		                    return {
		                        title: '',
		                        command: 'setSelection',
		                        arguments: [{
		                                selection: {
		                                    selectionStartLineNumber: position.line + 1,
		                                    positionLineNumber: position.line + 1,
		                                    selectionStartColumn: position.character + 1,
		                                    positionColumn: position.character + 1,
		                                },
		                            }],
		                    };
		                },
		                is(command) {
		                    return command.command === 'setSelection';
		                },
		            },
		        },
		        disabledEmbeddedDocumentUris: (0, uriMap_1.createUriMap)(),
		        disabledServicePlugins: new WeakSet(),
		        decodeEmbeddedDocumentUri,
		        encodeEmbeddedDocumentUri,
		    };
		    for (const plugin of plugins) {
		        context.plugins.push([plugin, plugin.create(context)]);
		    }
		    const langaugeService = createLanguageServiceBase(plugins, context);
		    return langaugeService;
		}
		function decodeEmbeddedDocumentUri(maybeEmbeddedContentUri) {
		    if (maybeEmbeddedContentUri.scheme === exports$1.embeddedContentScheme) {
		        const embeddedCodeId = decodeURIComponent(maybeEmbeddedContentUri.authority);
		        const documentUri = decodeURIComponent(maybeEmbeddedContentUri.path.substring(1));
		        return [
		            vscode_uri_1.URI.parse(documentUri),
		            embeddedCodeId,
		        ];
		    }
		}
		function encodeEmbeddedDocumentUri(documentUri, embeddedContentId) {
		    if (embeddedContentId !== embeddedContentId.toLowerCase()) {
		        console.error(`embeddedContentId must be lowercase: ${embeddedContentId}`);
		    }
		    return vscode_uri_1.URI.from({
		        scheme: exports$1.embeddedContentScheme,
		        authority: encodeURIComponent(embeddedContentId),
		        path: '/' + encodeURIComponent(documentUri.toString()),
		    });
		}
		function createLanguageServiceBase(plugins, context) {
		    const tokenModifiers = plugins.map(plugin => plugin.capabilities.semanticTokensProvider?.legend?.tokenModifiers ?? [])
		        .flat();
		    const tokenTypes = plugins.map(plugin => plugin.capabilities.semanticTokensProvider?.legend?.tokenTypes ?? []).flat();
		    return {
		        semanticTokenLegend: {
		            tokenModifiers: [...new Set(tokenModifiers)],
		            tokenTypes: [...new Set(tokenTypes)],
		        },
		        commands: plugins.map(plugin => plugin.capabilities.executeCommandProvider?.commands ?? []).flat(),
		        triggerCharacters: plugins.map(plugin => plugin.capabilities.completionProvider?.triggerCharacters ?? []).flat(),
		        autoFormatTriggerCharacters: plugins.map(plugin => plugin.capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat(),
		        signatureHelpTriggerCharacters: plugins.map(plugin => plugin.capabilities.signatureHelpProvider?.triggerCharacters ?? []).flat(),
		        signatureHelpRetriggerCharacters: plugins.map(plugin => plugin.capabilities.signatureHelpProvider?.retriggerCharacters ?? []).flat(),
		        executeCommand(command, args, token = cancellation_1.NoneCancellationToken) {
		            for (const plugin of context.plugins) {
		                if (context.disabledServicePlugins.has(plugin[1])) {
		                    continue;
		                }
		                if (!plugin[1].executeCommand || !plugin[0].capabilities.executeCommandProvider?.commands.includes(command)) {
		                    continue;
		                }
		                return plugin[1].executeCommand(command, args, token);
		            }
		        },
		        getDocumentFormattingEdits: format.register(context),
		        getFoldingRanges: foldingRanges.register(context),
		        getSelectionRanges: selectionRanges.register(context),
		        getLinkedEditingRanges: linkedEditing.register(context),
		        getDocumentSymbols: documentSymbols.register(context),
		        getDocumentColors: documentColors.register(context),
		        getColorPresentations: colorPresentations.register(context),
		        getDiagnostics: diagnostics.register(context),
		        getWorkspaceDiagnostics: workspaceDiagnostics.register(context),
		        getReferences: references.register(context),
		        getFileReferences: fileReferences.register(context),
		        getDeclaration: definition.register(context, 'provideDeclaration', language_core_1.isDefinitionEnabled),
		        getDefinition: definition.register(context, 'provideDefinition', language_core_1.isDefinitionEnabled),
		        getTypeDefinition: definition.register(context, 'provideTypeDefinition', language_core_1.isTypeDefinitionEnabled),
		        getImplementations: definition.register(context, 'provideImplementation', language_core_1.isImplementationEnabled),
		        getRenameRange: renamePrepare.register(context),
		        getRenameEdits: rename.register(context),
		        getFileRenameEdits: fileRename.register(context),
		        getSemanticTokens: semanticTokens.register(context),
		        getHover: hover.register(context),
		        getCompletionItems: completions.register(context),
		        getCodeActions: codeActions.register(context),
		        getSignatureHelp: signatureHelp.register(context),
		        getCodeLenses: codeLens.register(context),
		        getDocumentHighlights: documentHighlight.register(context),
		        getDocumentLinks: documentLink.register(context),
		        getWorkspaceSymbols: workspaceSymbol.register(context),
		        getAutoInsertSnippet: autoInsert.register(context),
		        getDocumentDropEdits: documentDrop.register(context),
		        getInlayHints: inlayHints.register(context),
		        getMoniker: moniker.register(context),
		        getInlineValue: inlineValue.register(context),
		        resolveCodeAction: codeActionResolve.register(context),
		        resolveCompletionItem: completionResolve.register(context),
		        resolveCodeLens: codeLensResolve.register(context),
		        resolveDocumentLink: documentLinkResolve.register(context),
		        resolveInlayHint: inlayHintResolve.register(context),
		        resolveWorkspaceSymbol: workspaceSymbolResolve.register(context),
		        ...hierarchy.register(context),
		        dispose: () => context.plugins.forEach(plugin => plugin[1].dispose?.()),
		        context,
		    };
		}
		
	} (languageService));
	return languageService;
}

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.FileType = void 0;
	var FileType;
	(function (FileType) {
	    FileType[FileType["Unknown"] = 0] = "Unknown";
	    FileType[FileType["File"] = 1] = "File";
	    FileType[FileType["Directory"] = 2] = "Directory";
	    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
	})(FileType || (types$1.FileType = FileType = {}));
	
	return types$1;
}

var hasRequiredLanguageService;

function requireLanguageService () {
	if (hasRequiredLanguageService) return languageService$1;
	hasRequiredLanguageService = 1;
	(function (exports$1) {
		var __createBinding = (languageService$1 && languageService$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (languageService$1 && languageService$1.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.mergeWorkspaceEdits = void 0;
		__exportStar(requireLanguageCore(), exports$1);
		var provideRenameEdits_1 = requireProvideRenameEdits();
		Object.defineProperty(exports$1, "mergeWorkspaceEdits", { enumerable: true, get: function () { return provideRenameEdits_1.mergeWorkspaceEdits; } });
		__exportStar(requireLanguageService$1(), exports$1);
		__exportStar(requireTypes$1(), exports$1);
		__exportStar(requireTransform$1(), exports$1);
		__exportStar(requireUriMap(), exports$1);
		
	} (languageService$1));
	return languageService$1;
}

var main$1 = {};

var hasRequiredMain$1;

function requireMain$1 () {
	if (hasRequiredMain$1) return main$1;
	hasRequiredMain$1 = 1;
	(function (exports$1) {
		(()=>{var e={46:(e,t)=>{Object.defineProperty(t,"__esModule",{value:true}),t.default=function(e,t,{signal:r}={}){return new Promise(((o,n)=>{function s(){null==r||r.removeEventListener("abort",s),e.removeListener(t,a),e.removeListener("error",u);}function a(...e){s(),o(e);}function u(e){s(),n(e);}null==r||r.addEventListener("abort",s),e.on(t,a),e.on("error",u);}))};},54:function(e,t,r){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};const n=r(361),s=o(r(374)),a=o(r(304)),u=s.default("agent-base");function i(){const{stack:e}=new Error;return "string"==typeof e&&e.split("\n").some((e=>-1!==e.indexOf("(https.js:")||-1!==e.indexOf("node:https:")))}function c(e,t){return new c.Agent(e,t)}!function(e){class t extends n.EventEmitter{constructor(e,t){super();let r=t;"function"==typeof e?this.callback=e:e&&(r=e),this.timeout=null,r&&"number"==typeof r.timeout&&(this.timeout=r.timeout),this.maxFreeSockets=1,this.maxSockets=1,this.maxTotalSockets=1/0,this.sockets={},this.freeSockets={},this.requests={},this.options={};}get defaultPort(){return "number"==typeof this.explicitDefaultPort?this.explicitDefaultPort:i()?443:80}set defaultPort(e){this.explicitDefaultPort=e;}get protocol(){return "string"==typeof this.explicitProtocol?this.explicitProtocol:i()?"https:":"http:"}set protocol(e){this.explicitProtocol=e;}callback(e,t,r){throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`')}addRequest(e,t){const r=Object.assign({},t);"boolean"!=typeof r.secureEndpoint&&(r.secureEndpoint=i()),null==r.host&&(r.host="localhost"),null==r.port&&(r.port=r.secureEndpoint?443:80),null==r.protocol&&(r.protocol=r.secureEndpoint?"https:":"http:"),r.host&&r.path&&delete r.path,delete r.agent,delete r.hostname,delete r._defaultAgent,delete r.defaultPort,delete r.createConnection,e._last=true,e.shouldKeepAlive=false;let o=false,n=null;const s=r.timeout||this.timeout,c=t=>{e._hadError||(e.emit("error",t),e._hadError=true);},l=()=>{n=null,o=true;const e=new Error(`A "socket" was not created for HTTP request before ${s}ms`);e.code="ETIMEOUT",c(e);},d=e=>{o||(null!==n&&(clearTimeout(n),n=null),c(e));},f=t=>{if(o)return;if(null!=n&&(clearTimeout(n),n=null),s=t,Boolean(s)&&"function"==typeof s.addRequest)return u("Callback returned another Agent instance %o",t.constructor.name),void t.addRequest(e,r);var s;if(t)return t.once("free",(()=>{this.freeSocket(t,r);})),void e.onSocket(t);const a=new Error(`no Duplex stream was returned to agent-base for \`${e.method} ${e.path}\``);c(a);};if("function"==typeof this.callback){this.promisifiedCallback||(this.callback.length>=3?(u("Converting legacy callback function to promise"),this.promisifiedCallback=a.default(this.callback)):this.promisifiedCallback=this.callback),"number"==typeof s&&s>0&&(n=setTimeout(l,s)),"port"in r&&"number"!=typeof r.port&&(r.port=Number(r.port));try{u("Resolving socket for %o request: %o",r.protocol,`${e.method} ${e.path}`),Promise.resolve(this.promisifiedCallback(e,r)).then(f,d);}catch(e){Promise.reject(e).catch(d);}}else c(new Error("`callback` is not defined"));}freeSocket(e,t){u("Freeing socket %o %o",e.constructor.name,t),e.destroy();}destroy(){u("Destroying agent %o",this.constructor.name);}}e.Agent=t,e.prototype=e.Agent.prototype;}(c||(c={})),e.exports=c;},304:(e,t)=>{Object.defineProperty(t,"__esModule",{value:true}),t.default=function(e){return function(t,r){return new Promise(((o,n)=>{e.call(this,t,r,((e,t)=>{e?n(e):o(t);}));}))}};},370:function(e,t,r){var o=this&&this.__awaiter||function(e,t,r,o){return new(r||(r=Promise))((function(n,s){function a(e){try{i(o.next(e));}catch(e){s(e);}}function u(e){try{i(o.throw(e));}catch(e){s(e);}}function i(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t);}))).then(a,u);}i((o=o.apply(e,t||[])).next());}))},n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:true});const s=n(r(808)),a=n(r(404)),u=n(r(310)),i=n(r(374)),c=n(r(46)),l=r(54),d=(0, i.default)("http-proxy-agent");class f extends l.Agent{constructor(e){let t;if(t="string"==typeof e?u.default.parse(e):e,!t)throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");d("Creating new HttpProxyAgent instance: %o",t),super(t);const r=Object.assign({},t);var o;this.secureProxy=t.secureProxy||"string"==typeof(o=r.protocol)&&/^https:?$/i.test(o),r.host=r.hostname||r.host,"string"==typeof r.port&&(r.port=parseInt(r.port,10)),!r.port&&r.host&&(r.port=this.secureProxy?443:80),r.host&&r.path&&(delete r.path,delete r.pathname),this.proxy=r;}callback(e,t){return o(this,void 0,void 0,(function*(){const{proxy:r,secureProxy:o}=this,n=u.default.parse(e.path);let i;if(n.protocol||(n.protocol="http:"),n.hostname||(n.hostname=t.hostname||t.host||null),null==n.port&&(t.port,1)&&(n.port=String(t.port)),"80"===n.port&&(n.port=""),e.path=u.default.format(n),r.auth&&e.setHeader("Proxy-Authorization",`Basic ${Buffer.from(r.auth).toString("base64")}`),o?(d("Creating `tls.Socket`: %o",r),i=a.default.connect(r)):(d("Creating `net.Socket`: %o",r),i=s.default.connect(r)),e._header){let t,r;d("Regenerating stored HTTP header string for request"),e._header=null,e._implicitHeader(),e.output&&e.output.length>0?(d("Patching connection write() output buffer with updated header"),t=e.output[0],r=t.indexOf("\r\n\r\n")+4,e.output[0]=e._header+t.substring(r),d("Output buffer: %o",e.output)):e.outputData&&e.outputData.length>0&&(d("Patching connection write() output buffer with updated header"),t=e.outputData[0].data,r=t.indexOf("\r\n\r\n")+4,e.outputData[0].data=e._header+t.substring(r),d("Output buffer: %o",e.outputData[0].data));}return yield (0, c.default)(i,"connect"),i}))}}t.default=f;},201:function(e,t,r){const o=(this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(r(370));function n(e){return new o.default(e)}!function(e){e.HttpProxyAgent=o.default,e.prototype=o.default.prototype;}(n||(n={})),e.exports=n;},146:function(e,t,r){var o=this&&this.__awaiter||function(e,t,r,o){return new(r||(r=Promise))((function(n,s){function a(e){try{i(o.next(e));}catch(e){s(e);}}function u(e){try{i(o.throw(e));}catch(e){s(e);}}function i(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t);}))).then(a,u);}i((o=o.apply(e,t||[])).next());}))},n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:true});const s=n(r(808)),a=n(r(404)),u=n(r(310)),i=n(r(491)),c=n(r(374)),l=r(54),d=n(r(829)),f=c.default("https-proxy-agent:agent");class p extends l.Agent{constructor(e){let t;if(t="string"==typeof e?u.default.parse(e):e,!t)throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");f("creating new HttpsProxyAgent instance: %o",t),super(t);const r=Object.assign({},t);var o;this.secureProxy=t.secureProxy||"string"==typeof(o=r.protocol)&&/^https:?$/i.test(o),r.host=r.hostname||r.host,"string"==typeof r.port&&(r.port=parseInt(r.port,10)),!r.port&&r.host&&(r.port=this.secureProxy?443:80),this.secureProxy&&!("ALPNProtocols"in r)&&(r.ALPNProtocols=["http 1.1"]),r.host&&r.path&&(delete r.path,delete r.pathname),this.proxy=r;}callback(e,t){return o(this,void 0,void 0,(function*(){const{proxy:r,secureProxy:o}=this;let n;o?(f("Creating `tls.Socket`: %o",r),n=a.default.connect(r)):(f("Creating `net.Socket`: %o",r),n=s.default.connect(r));const u=Object.assign({},r.headers);let c=`CONNECT ${t.host}:${t.port} HTTP/1.1\r\n`;r.auth&&(u["Proxy-Authorization"]=`Basic ${Buffer.from(r.auth).toString("base64")}`);let{host:l,port:p,secureEndpoint:g}=t;((function(e,t){return Boolean(!t&&80===e||t&&443===e)}))(p,g)||(l+=`:${p}`),u.Host=l,u.Connection="close";for(const e of Object.keys(u))c+=`${e}: ${u[e]}\r\n`;const v=d.default(n);n.write(`${c}\r\n`);const{statusCode:m,buffered:y}=yield v;if(200===m){if(e.once("socket",h),t.secureEndpoint){f("Upgrading socket connection to TLS");const e=t.servername||t.host;return a.default.connect(Object.assign(Object.assign({},function(e,...t){const r={};let o;for(o in e)t.includes(o)||(r[o]=e[o]);return r}(t,"host","hostname","path","port")),{socket:n,servername:e}))}return n}n.destroy();const b=new s.default.Socket({writable:false});return b.readable=true,e.once("socket",(e=>{f("replaying proxy buffer for failed request"),i.default(e.listenerCount("data")>0),e.push(y),e.push(null);})),b}))}}function h(e){e.resume();}t.default=p;},18:function(e,t,r){const o=(this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}})(r(146));function n(e){return new o.default(e)}!function(e){e.HttpsProxyAgent=o.default,e.prototype=o.default.prototype;}(n||(n={})),e.exports=n;},829:function(e,t,r){var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:true});const n=o(r(374)).default("https-proxy-agent:parse-proxy-response");t.default=function(e){return new Promise(((t,r)=>{let o=0;const s=[];function a(){const r=e.read();r?function(e){s.push(e),o+=e.length;const r=Buffer.concat(s,o);if(-1===r.indexOf("\r\n\r\n"))return n("have not received end of HTTP headers yet..."),void a();const u=r.toString("ascii",0,r.indexOf("\r\n")),i=+u.split(" ")[1];n("got proxy server response: %o",u),t({statusCode:i,buffered:r});}(r):e.once("readable",a);}function u(e){n("onclose had error %o",e);}function i(){n("onend");}e.on("error",(function t(o){e.removeListener("end",i),e.removeListener("error",t),e.removeListener("close",u),e.removeListener("readable",a),n("onerror %o",o),r(o);})),e.on("close",u),e.on("end",i),a();}))};},539:function(e,t,r){var o,n=this&&this.__extends||(o=function(e,t){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);},o(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function r(){this.constructor=e;}o(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),s=this&&this.__assign||function(){return s=Object.assign||function(e){for(var t,r=1,o=arguments.length;r<o;r++)for(var n in t=arguments[r])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},s.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:true}),t.getErrorStatusDescription=t.xhr=t.configure=void 0;var a=r(685),u=r(687),i=r(310),c=r(472),l=r(796),d=r(201),f=r(18);if(process.env.VSCODE_NLS_CONFIG){var p=process.env.VSCODE_NLS_CONFIG;c.config(JSON.parse(p));}var h=c.loadMessageBundle(),g=void 0,v=true;function m(e){var t;return new Promise((function(r,o){var n=(0, i.parse)(e.url),s={hostname:n.hostname,agent:!!e.agent&&e.agent,port:n.port?parseInt(n.port):"https:"===n.protocol?443:80,path:n.path,method:e.type||"GET",headers:e.headers,rejectUnauthorized:"boolean"!=typeof e.strictSSL||e.strictSSL};e.user&&e.password&&(s.auth=e.user+":"+e.password);var c=function(o){if(o.statusCode>=300&&o.statusCode<400&&e.followRedirects&&e.followRedirects>0&&o.headers.location){var s=o.headers.location;s.startsWith("/")&&(s=(0, i.format)({protocol:n.protocol,hostname:n.hostname,port:n.port,pathname:s})),r(m(function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];return t.forEach((function(t){return Object.keys(t).forEach((function(r){return e[r]=t[r]}))})),e}({},e,{url:s,followRedirects:e.followRedirects-1})));}else r({req:t,res:o});};(t="https:"===n.protocol?u.request(s,c):a.request(s,c)).on("error",o),e.timeout&&t.setTimeout(e.timeout),e.data&&t.write(e.data),t.end(),e.token&&(e.token.isCancellationRequested&&t.destroy(new y),e.token.onCancellationRequested((function(){t.destroy(new y);})));}))}t.configure=function(e,t){g=e,v=t;},t.xhr=function(e){return "boolean"!=typeof(e=s({},e)).strictSSL&&(e.strictSSL=v),e.agent||(e.agent=function(e,t){ void 0===t&&(t={});var r=(0, i.parse)(e),o=t.proxyUrl||function(e){return "http:"===e.protocol?process.env.HTTP_PROXY||process.env.http_proxy||null:"https:"===e.protocol&&(process.env.HTTPS_PROXY||process.env.https_proxy||process.env.HTTP_PROXY||process.env.http_proxy)||null}(r);if(!o)return null;var n=(0, i.parse)(o);if(!/^https?:$/.test(n.protocol))return null;var s={host:n.hostname,port:Number(n.port),auth:n.auth,rejectUnauthorized:"boolean"!=typeof t.strictSSL||t.strictSSL,protocol:n.protocol};return "http:"===r.protocol?d(s):f(s)}(e.url,{proxyUrl:g,strictSSL:v})),"number"!=typeof e.followRedirects&&(e.followRedirects=5),m(e).then((function(r){return new Promise((function(o,n){var s,a,u=r.res,c=u,d=false,f=u.headers&&u.headers["content-encoding"];if(f&&(s=e.type,a=r.res.statusCode,!("HEAD"===s||a>=100&&a<200||204===a||304===a))){var p={flush:l.constants.Z_SYNC_FLUSH,finishFlush:l.constants.Z_SYNC_FLUSH};if("gzip"===f){var g=l.createGunzip(p);u.pipe(g),c=g;}else if("deflate"===f){var v=l.createInflate(p);u.pipe(v),c=v;}}var m=[];c.on("data",(function(e){return m.push(e)})),c.on("end",(function(){if(!d){if(d=true,e.followRedirects>0&&(u.statusCode>=300&&u.statusCode<=303||307===u.statusCode)){var r=u.headers.location;if(r.startsWith("/")){var s=(0, i.parse)(e.url);r=(0, i.format)({protocol:s.protocol,hostname:s.hostname,port:s.port,pathname:r});}if(r){var a={type:e.type,url:r,user:e.user,password:e.password,headers:e.headers,timeout:e.timeout,followRedirects:e.followRedirects-1,data:e.data,token:e.token};return void(0, t.xhr)(a).then(o,n)}}var c=Buffer.concat(m),l={responseText:c.toString(),body:c,status:u.statusCode,headers:u.headers||{}};u.statusCode>=200&&u.statusCode<300||1223===u.statusCode?o(l):n(l);}})),c.on("error",(function(t){var r;r=y.is(t)?t:{responseText:h("error","Unable to access {0}. Error: {1}",e.url,t.message),body:Buffer.concat(m),status:500,headers:{}},d=true,n(r);})),e.token&&(e.token.isCancellationRequested&&c.destroy(new y),e.token.onCancellationRequested((function(){c.destroy(new y);})));}))}),(function(t){var r;return r=y.is(t)?t:{responseText:e.agent?h("error.cannot.connect.proxy","Unable to connect to {0} through a proxy. Error: {1}",e.url,t.message):h("error.cannot.connect","Unable to connect to {0}. Error: {1}",e.url,t.message),body:Buffer.concat([]),status:404,headers:{}},Promise.reject(r)}))},t.getErrorStatusDescription=function(e){if(!(e<400))switch(e){case 400:return h("status.400","Bad request. The request cannot be fulfilled due to bad syntax.");case 401:return h("status.401","Unauthorized. The server is refusing to respond.");case 403:return h("status.403","Forbidden. The server is refusing to respond.");case 404:return h("status.404","Not Found. The requested location could not be found.");case 405:return h("status.405","Method not allowed. A request was made using a request method not supported by that location.");case 406:return h("status.406","Not Acceptable. The server can only generate a response that is not accepted by the client.");case 407:return h("status.407","Proxy Authentication Required. The client must first authenticate itself with the proxy.");case 408:return h("status.408","Request Timeout. The server timed out waiting for the request.");case 409:return h("status.409","Conflict. The request could not be completed because of a conflict in the request.");case 410:return h("status.410","Gone. The requested page is no longer available.");case 411:return h("status.411",'Length Required. The "Content-Length" is not defined.');case 412:return h("status.412","Precondition Failed. The precondition given in the request evaluated to false by the server.");case 413:return h("status.413","Request Entity Too Large. The server will not accept the request, because the request entity is too large.");case 414:return h("status.414","Request-URI Too Long. The server will not accept the request, because the URL is too long.");case 415:return h("status.415","Unsupported Media Type. The server will not accept the request, because the media type is not supported.");case 500:return h("status.500","Internal Server Error.");case 501:return h("status.501","Not Implemented. The server either does not recognize the request method, or it lacks the ability to fulfill the request.");case 502:return h("status.502","Bad Gateway. The upstream server did not respond.");case 503:return h("status.503","Service Unavailable. The server is currently unavailable (overloaded or down).");default:return h("status.416","HTTP status code {0}",e)}};var y=function(e){function t(){var r=e.call(this,"The user aborted a request")||this;return r.name="AbortError",Object.setPrototypeOf(r,t.prototype),r}return n(t,e),t.is=function(e){return e instanceof t},t}(Error);},800:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:true}),t.config=t.loadMessageBundle=t.localize=t.format=t.setPseudo=t.isPseudo=t.isDefined=t.BundleFormat=t.MessageFormat=void 0;var o,n,s,a=r(926);function u(e){return void 0!==e}function i(e,r){return t.isPseudo&&(e=""+e.replace(/[aouei]/g,"$&$&")+""),0===r.length?e:e.replace(/\{(\d+)\}/g,(function(e,t){var o=t[0],n=r[o],s=e;return "string"==typeof n?s=n:"number"!=typeof n&&"boolean"!=typeof n&&null!=n||(s=String(n)),s}))}(s=t.MessageFormat||(t.MessageFormat={})).file="file",s.bundle="bundle",s.both="both",(n=t.BundleFormat||(t.BundleFormat={})).standalone="standalone",n.languagePack="languagePack",function(e){e.is=function(e){var t=e;return t&&u(t.key)&&u(t.comment)};}(o||(o={})),t.isDefined=u,t.isPseudo=false,t.setPseudo=function(e){t.isPseudo=e;},t.format=i,t.localize=function(e,t){for(var r=[],o=2;o<arguments.length;o++)r[o-2]=arguments[o];return i(t,r)},t.loadMessageBundle=function(e){return (0, a.default)().loadMessageBundle(e)},t.config=function(e){return (0, a.default)().config(e)};},926:(e,t)=>{var r;function o(){if(void 0===r)throw new Error("No runtime abstraction layer installed");return r}Object.defineProperty(t,"__esModule",{value:true}),function(e){e.install=function(e){if(void 0===e)throw new Error("No runtime abstraction layer provided");r=e;};}(o||(o={})),t.default=o;},472:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:true}),t.config=t.loadMessageBundle=t.BundleFormat=t.MessageFormat=void 0;var o=r(17),n=r(147),s=r(926),a=r(800),u=r(800);Object.defineProperty(t,"MessageFormat",{enumerable:true,get:function(){return u.MessageFormat}}),Object.defineProperty(t,"BundleFormat",{enumerable:true,get:function(){return u.BundleFormat}});var i,c,l=Object.prototype.toString;function d(e){return "[object Number]"===l.call(e)}function f(e){return "[object String]"===l.call(e)}function p(e){return JSON.parse(n.readFileSync(e,"utf8"))}function h(e){return function(t,r){for(var o=[],n=2;n<arguments.length;n++)o[n-2]=arguments[n];return d(t)?t>=e.length?void console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: ".concat(new Error("").stack)):(0, a.format)(e[t],o):f(r)?(console.warn("Message ".concat(r," didn't get externalized correctly.")),(0, a.format)(r,o)):void console.error("Broken localize call found. Stacktrace is\n: ".concat(new Error("").stack))}}function g(e,t){return i[e]=t,t}function v(e){try{return function(e){var t=p(o.join(e,"nls.metadata.json")),r=Object.create(null);for(var n in t){var s=t[n];r[n]=s.messages;}return r}(e)}catch(e){return void console.log("Generating default bundle from meta data failed.",e)}}function m(e,t){var r;if(true===c.languagePackSupport&&void 0!==c.cacheRoot&&void 0!==c.languagePackId&&void 0!==c.translationsConfigFile&&void 0!==c.translationsConfig)try{r=function(e,t){var r,s,a,u=o.join(c.cacheRoot,"".concat(e.id,"-").concat(e.hash,".json")),i=!1,l=!1;try{return r=JSON.parse(n.readFileSync(u,{encoding:"utf8",flag:"r"})),s=u,a=new Date,n.utimes(s,a,a,(function(){})),r}catch(e){if("ENOENT"===e.code)l=!0;else {if(!(e instanceof SyntaxError))throw e;console.log("Syntax error parsing message bundle: ".concat(e.message,".")),n.unlink(u,(function(e){e&&console.error("Deleting corrupted bundle ".concat(u," failed."));})),i=!0;}}if(r=function(e,t){var r=c.translationsConfig[e.id];if(r){var n=p(r).contents,s=p(o.join(t,"nls.metadata.json")),a=Object.create(null);for(var u in s){var i=s[u],l=n["".concat(e.outDir,"/").concat(u)];if(l){for(var d=[],h=0;h<i.keys.length;h++){var g=i.keys[h],v=l[f(g)?g:g.key];void 0===v&&(v=i.messages[h]),d.push(v);}a[u]=d;}else a[u]=i.messages;}return a}}(e,t),!r||i)return r;if(l)try{n.writeFileSync(u,JSON.stringify(r),{encoding:"utf8",flag:"wx"});}catch(e){if("EEXIST"===e.code)return r;throw e}return r}(e,t);}catch(e){console.log("Load or create bundle failed ",e);}if(!r){if(c.languagePackSupport)return v(t);var s=function(e){for(var t=c.language;t;){var r=o.join(e,"nls.bundle.".concat(t,".json"));if(n.existsSync(r))return r;var s=t.lastIndexOf("-");t=s>0?t.substring(0,s):void 0;}if(void 0===t&&(r=o.join(e,"nls.bundle.json"),n.existsSync(r)))return r}(t);if(s)try{return p(s)}catch(e){console.log("Loading in the box message bundle failed.",e);}r=v(t);}return r}function y(e){if(!e)return a.localize;var t=o.extname(e);if(t&&(e=e.substr(0,e.length-t.length)),c.messageFormat===a.MessageFormat.both||c.messageFormat===a.MessageFormat.bundle){var r=function(e){for(var t,r=o.dirname(e);t=o.join(r,"nls.metadata.header.json"),!n.existsSync(t);){var s=o.dirname(r);if(s===r){t=void 0;break}r=s;}return t}(e);if(r){var s=o.dirname(r),u=i[s];if(void 0===u)try{var l=JSON.parse(n.readFileSync(r,"utf8"));try{var d=m(l,s);u=g(s,d?{header:l,nlsBundle:d}:null);}catch(e){console.error("Failed to load nls bundle",e),u=g(s,null);}}catch(e){console.error("Failed to read header file",e),u=g(s,null);}if(u){var f=e.substr(s.length+1).replace(/\\/g,"/"),v=u.nlsBundle[f];return void 0===v?(console.error("Messages for file ".concat(e," not found. See console for details.")),function(){return "Messages not found."}):h(v)}}}if(c.messageFormat===a.MessageFormat.both||c.messageFormat===a.MessageFormat.file)try{var y=p(function(e){var t;if(c.cacheLanguageResolution&&t);else {if(a.isPseudo||!c.language)t=".nls.json";else for(var r=c.language;r;){var o=".nls."+r+".json";if(n.existsSync(e+o)){t=o;break}var s=r.lastIndexOf("-");s>0?r=r.substring(0,s):(t=".nls.json",r=null);}c.cacheLanguageResolution;}return e+t}(e));return Array.isArray(y)?h(y):(0,a.isDefined)(y.messages)&&(0,a.isDefined)(y.keys)?h(y.messages):(console.error("String bundle '".concat(e,"' uses an unsupported format.")),function(){return "File bundle has unsupported format. See console for details"})}catch(e){"ENOENT"!==e.code&&console.error("Failed to load single file bundle",e);}return console.error("Failed to load message bundle for file ".concat(e)),function(){return "Failed to load message bundle. See console for details."}}function b(e){return e&&(f(e.locale)&&(c.locale=e.locale.toLowerCase(),c.language=c.locale,i=Object.create(null)),void 0!==e.messageFormat&&(c.messageFormat=e.messageFormat),e.bundleFormat===a.BundleFormat.standalone&&true===c.languagePackSupport&&(c.languagePackSupport=false)),(0, a.setPseudo)("pseudo"===c.locale),y}!function(){if(c={locale:void 0,language:void 0,languagePackSupport:false,cacheLanguageResolution:true,messageFormat:a.MessageFormat.bundle},f(process.env.VSCODE_NLS_CONFIG))try{var e=JSON.parse(process.env.VSCODE_NLS_CONFIG),t=void 0;if(e.availableLanguages){var r=e.availableLanguages["*"];f(r)&&(t=r);}if(f(e.locale)&&(c.locale=e.locale.toLowerCase()),void 0===t?c.language=c.locale:"en"!==t&&(c.language=t),function(e){return !0===e||!1===e}(e._languagePackSupport)&&(c.languagePackSupport=e._languagePackSupport),f(e._cacheRoot)&&(c.cacheRoot=e._cacheRoot),f(e._languagePackId)&&(c.languagePackId=e._languagePackId),f(e._translationsConfigFile)){c.translationsConfigFile=e._translationsConfigFile;try{c.translationsConfig=p(c.translationsConfigFile);}catch(t){if(e._corruptedFile){var s=o.dirname(e._corruptedFile);n.exists(s,(function(t){t&&n.writeFile(e._corruptedFile,"corrupted","utf8",(function(e){console.error(e);}));}));}}}}catch(e){}(0, a.setPseudo)("pseudo"===c.locale),i=Object.create(null);}(),t.loadMessageBundle=y,t.config=b,s.default.install(Object.freeze({loadMessageBundle:y,config:b}));},374:(e,t)=>{function r(){}Object.defineProperty(t,"__esModule",{value:true}),t.default=function(e){return r};},491:e=>{e.exports=require$$0$3;},361:e=>{e.exports=require$$1;},147:e=>{e.exports=fs;},685:e=>{e.exports=require$$3$2;},687:e=>{e.exports=require$$4$1;},808:e=>{e.exports=require$$4;},17:e=>{e.exports=path$1;},404:e=>{e.exports=require$$7;},310:e=>{e.exports=require$$0$2;},796:e=>{e.exports=require$$9;}},t={},r=function r(o){var n=t[o];if(void 0!==n)return n.exports;var s=t[o]={exports:{}};return e[o].call(s.exports,s,s.exports,r),s.exports}(539),o=exports$1;for(var n in r)o[n]=r[n];r.__esModule&&Object.defineProperty(o,"__esModule",{value:true});})(); 
	} (main$1));
	return main$1;
}

var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http;
	hasRequiredHttp = 1;
	Object.defineProperty(http, "__esModule", { value: true });
	http.provider = void 0;
	http.listenEditorSettings = listenEditorSettings;
	http.handler = handler;
	const language_service_1 = requireLanguageService();
	const request_light_1 = requireMain$1();
	http.provider = {
	    async stat(uri) {
	        const text = await this.readFile(uri);
	        if (text !== undefined) {
	            return {
	                type: language_service_1.FileType.File,
	                size: text.length,
	                ctime: 0,
	                mtime: 0,
	            };
	        }
	    },
	    readFile(uri) {
	        return handler(uri);
	    },
	    readDirectory() {
	        return [];
	    },
	};
	function listenEditorSettings(server) {
	    server.configurations.onDidChange(updateHttpSettings);
	    updateHttpSettings();
	    async function updateHttpSettings() {
	        const httpSettings = await server.configurations.get('http');
	        (0, request_light_1.configure)(httpSettings?.proxy, httpSettings?.proxyStrictSSL ?? false);
	    }
	}
	function handler(uri) {
	    const headers = { 'Accept-Encoding': 'gzip, deflate' };
	    return (0, request_light_1.xhr)({ url: uri.toString(true), followRedirects: 5, headers }).then(response => {
	        if (response.status !== 200) {
	            return;
	        }
	        return response.responseText;
	    }, (error) => {
	        return Promise.reject(error.responseText || (0, request_light_1.getErrorStatusDescription)(error.status) || error);
	    });
	}
	
	return http;
}

var node = {};

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node;
	hasRequiredNode$1 = 1;
	Object.defineProperty(node, "__esModule", { value: true });
	node.provider = void 0;
	const language_service_1 = requireLanguageService();
	const fs$1 = fs;
	node.provider = {
	    stat(uri) {
	        try {
	            const stats = fs$1.statSync(uri.fsPath, { throwIfNoEntry: false });
	            if (stats) {
	                return {
	                    type: stats.isFile()
	                        ? language_service_1.FileType.File
	                        : stats.isDirectory()
	                            ? language_service_1.FileType.Directory
	                            : stats.isSymbolicLink()
	                                ? language_service_1.FileType.SymbolicLink
	                                : language_service_1.FileType.Unknown,
	                    ctime: stats.ctimeMs,
	                    mtime: stats.mtimeMs,
	                    size: stats.size,
	                };
	            }
	        }
	        catch {
	            return undefined;
	        }
	    },
	    readFile(uri, encoding) {
	        try {
	            return fs$1.readFileSync(uri.fsPath, { encoding: encoding ?? 'utf-8' });
	        }
	        catch {
	            return undefined;
	        }
	    },
	    readDirectory(uri) {
	        try {
	            const files = fs$1.readdirSync(uri.fsPath, { withFileTypes: true });
	            return files.map(file => {
	                return [
	                    file.name,
	                    file.isFile()
	                        ? language_service_1.FileType.File
	                        : file.isDirectory()
	                            ? language_service_1.FileType.Directory
	                            : file.isSymbolicLink()
	                                ? language_service_1.FileType.SymbolicLink
	                                : language_service_1.FileType.Unknown,
	                ];
	            });
	        }
	        catch {
	            return [];
	        }
	    },
	};
	
	return node;
}

var server$1 = {};

var configurations = {};

var hasRequiredConfigurations;

function requireConfigurations () {
	if (hasRequiredConfigurations) return configurations;
	hasRequiredConfigurations = 1;
	Object.defineProperty(configurations, "__esModule", { value: true });
	configurations.register = register;
	const vscode = requireMain$2();
	function register(server) {
	    const configurations = new Map();
	    const didChangeCallbacks = new Set();
	    server.onInitialized(() => {
	        server.connection.onDidChangeConfiguration(params => {
	            configurations.clear(); // TODO: clear only the configurations that changed
	            for (const cb of didChangeCallbacks) {
	                cb(params);
	            }
	        });
	        const didChangeConfiguration = server.initializeParams.capabilities.workspace?.didChangeConfiguration;
	        if (didChangeConfiguration?.dynamicRegistration) {
	            server.connection.client.register(vscode.DidChangeConfigurationNotification.type);
	        }
	    });
	    return {
	        get,
	        onDidChange,
	    };
	    function get(section, scopeUri) {
	        if (!server.initializeParams.capabilities.workspace?.configuration) {
	            return Promise.resolve(undefined);
	        }
	        const didChangeConfiguration = server.initializeParams.capabilities.workspace?.didChangeConfiguration;
	        if (!scopeUri && didChangeConfiguration) {
	            if (!configurations.has(section)) {
	                configurations.set(section, getConfigurationWorker(section, scopeUri));
	            }
	            return configurations.get(section);
	        }
	        return getConfigurationWorker(section, scopeUri);
	    }
	    function onDidChange(cb) {
	        didChangeCallbacks.add(cb);
	        return {
	            dispose() {
	                didChangeCallbacks.delete(cb);
	            },
	        };
	    }
	    async function getConfigurationWorker(section, scopeUri) {
	        return (await server.connection.workspace.getConfiguration({ scopeUri, section }))
	            ?? undefined /* replace null to undefined */;
	    }
	}
	
	return configurations;
}

var editorFeatures = {};

var protocol = {};

var hasRequiredProtocol;

function requireProtocol () {
	if (hasRequiredProtocol) return protocol;
	hasRequiredProtocol = 1;
	(function (exports$1) {
		var __createBinding = (protocol && protocol.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (protocol && protocol.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.GetVirtualCodeRequest = exports$1.GetVirtualFileRequest = exports$1.GetServicePluginsRequest = exports$1.UpdateServicePluginStateNotification = exports$1.UpdateVirtualCodeStateNotification = exports$1.DocumentDrop_DataTransferItemFileDataRequest = exports$1.DocumentDrop_DataTransferItemAsStringRequest = exports$1.DocumentDropRequest = exports$1.ReloadProjectNotification = exports$1.AutoInsertRequest = exports$1.GetMatchTsConfigRequest = exports$1.FindFileReferenceRequest = void 0;
		const protocol$1 = requireMain$3();
		__exportStar(requireMain$3(), exports$1);
		/**
		 * Client request server
		 */
		var FindFileReferenceRequest;
		(function (FindFileReferenceRequest) {
		    FindFileReferenceRequest.type = new protocol$1.RequestType('volar/client/findFileReference');
		})(FindFileReferenceRequest || (exports$1.FindFileReferenceRequest = FindFileReferenceRequest = {}));
		var GetMatchTsConfigRequest;
		(function (GetMatchTsConfigRequest) {
		    GetMatchTsConfigRequest.type = new protocol$1.RequestType('volar/client/tsconfig');
		})(GetMatchTsConfigRequest || (exports$1.GetMatchTsConfigRequest = GetMatchTsConfigRequest = {}));
		var AutoInsertRequest;
		(function (AutoInsertRequest) {
		    AutoInsertRequest.type = new protocol$1.RequestType('volar/client/autoInsert');
		})(AutoInsertRequest || (exports$1.AutoInsertRequest = AutoInsertRequest = {}));
		var ReloadProjectNotification;
		(function (ReloadProjectNotification) {
		    ReloadProjectNotification.type = new protocol$1.NotificationType('volar/client/reloadProject');
		})(ReloadProjectNotification || (exports$1.ReloadProjectNotification = ReloadProjectNotification = {}));
		/**
		 * Document Drop
		 */
		var DocumentDropRequest;
		(function (DocumentDropRequest) {
		    DocumentDropRequest.type = new protocol$1.RequestType('volar/client/documentDrop');
		})(DocumentDropRequest || (exports$1.DocumentDropRequest = DocumentDropRequest = {}));
		var DocumentDrop_DataTransferItemAsStringRequest;
		(function (DocumentDrop_DataTransferItemAsStringRequest) {
		    DocumentDrop_DataTransferItemAsStringRequest.type = new protocol$1.RequestType('volar/client/documentDrop/asString');
		})(DocumentDrop_DataTransferItemAsStringRequest || (exports$1.DocumentDrop_DataTransferItemAsStringRequest = DocumentDrop_DataTransferItemAsStringRequest = {}));
		var DocumentDrop_DataTransferItemFileDataRequest;
		(function (DocumentDrop_DataTransferItemFileDataRequest) {
		    DocumentDrop_DataTransferItemFileDataRequest.type = new protocol$1.RequestType('volar/client/documentDrop/fileData');
		})(DocumentDrop_DataTransferItemFileDataRequest || (exports$1.DocumentDrop_DataTransferItemFileDataRequest = DocumentDrop_DataTransferItemFileDataRequest = {}));
		/**
		 * Labs
		 */
		var UpdateVirtualCodeStateNotification;
		(function (UpdateVirtualCodeStateNotification) {
		    UpdateVirtualCodeStateNotification.type = new protocol$1.NotificationType('volar/client/labs/updateVirtualFileState');
		})(UpdateVirtualCodeStateNotification || (exports$1.UpdateVirtualCodeStateNotification = UpdateVirtualCodeStateNotification = {}));
		var UpdateServicePluginStateNotification;
		(function (UpdateServicePluginStateNotification) {
		    UpdateServicePluginStateNotification.type = new protocol$1.NotificationType('volar/client/labs/updateServicePluginState');
		})(UpdateServicePluginStateNotification || (exports$1.UpdateServicePluginStateNotification = UpdateServicePluginStateNotification = {}));
		var GetServicePluginsRequest;
		(function (GetServicePluginsRequest) {
		    GetServicePluginsRequest.type = new protocol$1.RequestType('volar/client/servicePlugins');
		})(GetServicePluginsRequest || (exports$1.GetServicePluginsRequest = GetServicePluginsRequest = {}));
		var GetVirtualFileRequest;
		(function (GetVirtualFileRequest) {
		    GetVirtualFileRequest.type = new protocol$1.RequestType('volar/client/virtualFiles');
		})(GetVirtualFileRequest || (exports$1.GetVirtualFileRequest = GetVirtualFileRequest = {}));
		var GetVirtualCodeRequest;
		(function (GetVirtualCodeRequest) {
		    GetVirtualCodeRequest.type = new protocol$1.RequestType('volar/client/virtualFile');
		})(GetVirtualCodeRequest || (exports$1.GetVirtualCodeRequest = GetVirtualCodeRequest = {}));
		
	} (protocol));
	return protocol;
}

var hasRequiredEditorFeatures;

function requireEditorFeatures () {
	if (hasRequiredEditorFeatures) return editorFeatures;
	hasRequiredEditorFeatures = 1;
	Object.defineProperty(editorFeatures, "__esModule", { value: true });
	editorFeatures.register = register;
	const language_service_1 = requireLanguageService();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const protocol_1 = requireProtocol();
	function register(server) {
	    server.onInitialize(() => {
	        const { project } = server;
	        const scriptVersions = (0, language_service_1.createUriMap)();
	        const scriptVersionSnapshots = new WeakSet();
	        server.connection.onRequest(protocol_1.GetMatchTsConfigRequest.type, async (params) => {
	            const uri = vscode_uri_1.URI.parse(params.uri);
	            const languageService = await project.getLanguageService(uri);
	            const tsProject = languageService.context.project.typescript;
	            if (tsProject?.configFileName) {
	                const { configFileName, uriConverter } = tsProject;
	                return { uri: uriConverter.asUri(configFileName).toString() };
	            }
	        });
	        server.connection.onRequest(protocol_1.GetVirtualFileRequest.type, async (document) => {
	            const uri = vscode_uri_1.URI.parse(document.uri);
	            const languageService = await project.getLanguageService(uri);
	            const documentUri = vscode_uri_1.URI.parse(document.uri);
	            const sourceScript = languageService.context.language.scripts.get(documentUri);
	            if (sourceScript?.generated) {
	                return prune(sourceScript.generated.root);
	            }
	            function prune(virtualCode) {
	                const uri = languageService.context.encodeEmbeddedDocumentUri(sourceScript.id, virtualCode.id);
	                let version = scriptVersions.get(uri) ?? 0;
	                if (!scriptVersionSnapshots.has(virtualCode.snapshot)) {
	                    version++;
	                    scriptVersions.set(uri, version);
	                    scriptVersionSnapshots.add(virtualCode.snapshot);
	                }
	                return {
	                    fileUri: sourceScript.id.toString(),
	                    virtualCodeId: virtualCode.id,
	                    languageId: virtualCode.languageId,
	                    embeddedCodes: virtualCode.embeddedCodes?.map(prune) || [],
	                    version,
	                    disabled: languageService.context.disabledEmbeddedDocumentUris.has(uri),
	                };
	            }
	        });
	        server.connection.onRequest(protocol_1.GetVirtualCodeRequest.type, async (params) => {
	            const uri = vscode_uri_1.URI.parse(params.fileUri);
	            const languageService = await project.getLanguageService(uri);
	            const sourceScript = languageService.context.language.scripts.get(vscode_uri_1.URI.parse(params.fileUri));
	            const virtualCode = sourceScript?.generated?.embeddedCodes.get(params.virtualCodeId);
	            if (virtualCode) {
	                const mappings = {};
	                for (const [sourceScript, map] of languageService.context.language.maps.forEach(virtualCode)) {
	                    mappings[sourceScript.id.toString()] = map.mappings;
	                }
	                return {
	                    content: virtualCode.snapshot.getText(0, virtualCode.snapshot.getLength()),
	                    mappings,
	                };
	            }
	        });
	        server.connection.onNotification(protocol_1.UpdateVirtualCodeStateNotification.type, async (params) => {
	            const uri = vscode_uri_1.URI.parse(params.fileUri);
	            const languageService = await project.getLanguageService(uri);
	            const virtualFileUri = languageService.context.encodeEmbeddedDocumentUri(vscode_uri_1.URI.parse(params.fileUri), params.virtualCodeId);
	            if (params.disabled) {
	                languageService.context.disabledEmbeddedDocumentUris.set(virtualFileUri, true);
	            }
	            else {
	                languageService.context.disabledEmbeddedDocumentUris.delete(virtualFileUri);
	            }
	        });
	        server.connection.onNotification(protocol_1.UpdateServicePluginStateNotification.type, async (params) => {
	            const uri = vscode_uri_1.URI.parse(params.uri);
	            const languageService = await project.getLanguageService(uri);
	            const plugin = languageService.context.plugins[params.serviceId][1];
	            if (params.disabled) {
	                languageService.context.disabledServicePlugins.add(plugin);
	            }
	            else {
	                languageService.context.disabledServicePlugins.delete(plugin);
	            }
	        });
	        server.connection.onRequest(protocol_1.GetServicePluginsRequest.type, async (params) => {
	            const uri = vscode_uri_1.URI.parse(params.uri);
	            const languageService = await project.getLanguageService(uri);
	            const result = [];
	            for (let pluginIndex = 0; pluginIndex < languageService.context.plugins.length; pluginIndex++) {
	                const plugin = languageService.context.plugins[pluginIndex];
	                result.push({
	                    id: pluginIndex,
	                    name: plugin[0].name,
	                    disabled: languageService.context.disabledServicePlugins.has(plugin[1]),
	                    features: Object.keys(plugin[1]),
	                });
	            }
	            return result;
	        });
	    });
	}
	
	return editorFeatures;
}

var fileSystem = {};

var hasRequiredFileSystem;

function requireFileSystem () {
	if (hasRequiredFileSystem) return fileSystem;
	hasRequiredFileSystem = 1;
	Object.defineProperty(fileSystem, "__esModule", { value: true });
	fileSystem.register = register;
	const language_service_1 = requireLanguageService();
	const vscode = requireMain$2();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	function register(documents, fileWatcher) {
	    const providers = new Map();
	    const readFileCache = (0, language_service_1.createUriMap)();
	    const statCache = (0, language_service_1.createUriMap)();
	    const readDirectoryCache = (0, language_service_1.createUriMap)();
	    documents.onDidSave(({ document }) => {
	        const uri = vscode_uri_1.URI.parse(document.uri);
	        readFileCache.set(uri, document.getText());
	        statCache.delete(uri);
	    });
	    fileWatcher.onDidChangeWatchedFiles(({ changes }) => {
	        for (const change of changes) {
	            const changeUri = vscode_uri_1.URI.parse(change.uri);
	            const dir = vscode_uri_1.URI.parse(change.uri.substring(0, change.uri.lastIndexOf('/')));
	            if (change.type === vscode.FileChangeType.Deleted) {
	                readFileCache.set(changeUri, undefined);
	                statCache.set(changeUri, undefined);
	                readDirectoryCache.delete(dir);
	            }
	            else if (change.type === vscode.FileChangeType.Changed) {
	                readFileCache.delete(changeUri);
	                statCache.delete(changeUri);
	            }
	            else if (change.type === vscode.FileChangeType.Created) {
	                readFileCache.delete(changeUri);
	                statCache.delete(changeUri);
	                readDirectoryCache.delete(dir);
	            }
	        }
	    });
	    return {
	        readFile(uri) {
	            if (!readFileCache.has(uri)) {
	                readFileCache.set(uri, providers.get(uri.scheme)?.readFile(uri));
	            }
	            return readFileCache.get(uri);
	        },
	        stat(uri) {
	            if (!statCache.has(uri)) {
	                statCache.set(uri, providers.get(uri.scheme)?.stat(uri));
	            }
	            return statCache.get(uri);
	        },
	        readDirectory(uri) {
	            if (!readDirectoryCache.has(uri)) {
	                readDirectoryCache.set(uri, providers.get(uri.scheme)?.readDirectory(uri) ?? []);
	            }
	            return readDirectoryCache.get(uri);
	        },
	        install(scheme, provider) {
	            providers.set(scheme, provider);
	        },
	    };
	}
	
	return fileSystem;
}

var fileWatcher = {};

var hasRequiredFileWatcher;

function requireFileWatcher () {
	if (hasRequiredFileWatcher) return fileWatcher;
	hasRequiredFileWatcher = 1;
	Object.defineProperty(fileWatcher, "__esModule", { value: true });
	fileWatcher.register = register;
	const vscode = requireMain$2();
	function register(server) {
	    let watchFilesDisposableCounter = 0;
	    let watchFilesDisposable;
	    const didChangeWatchedFilesCallbacks = new Set();
	    return {
	        watchFiles,
	        onDidChangeWatchedFiles,
	    };
	    async function watchFiles(patterns) {
	        const disposables = [];
	        const didChangeWatchedFiles = server.initializeParams.capabilities.workspace?.didChangeWatchedFiles;
	        const fileOperations = server.initializeParams.capabilities.workspace?.fileOperations;
	        if (didChangeWatchedFiles) {
	            if (watchFilesDisposableCounter === 0) {
	                watchFilesDisposable = server.connection.onDidChangeWatchedFiles(e => {
	                    for (const cb of didChangeWatchedFilesCallbacks) {
	                        cb(e);
	                    }
	                });
	            }
	            watchFilesDisposableCounter++;
	            disposables.push({
	                dispose() {
	                    watchFilesDisposableCounter--;
	                    if (watchFilesDisposableCounter === 0) {
	                        watchFilesDisposable?.dispose();
	                    }
	                },
	            });
	        }
	        if (didChangeWatchedFiles?.dynamicRegistration) {
	            disposables.push(await server.connection.client.register(vscode.DidChangeWatchedFilesNotification.type, {
	                watchers: patterns.map(pattern => ({ globPattern: pattern })),
	            }));
	        }
	        if (fileOperations?.dynamicRegistration && fileOperations.willRename) {
	            disposables.push(await server.connection.client.register(vscode.WillRenameFilesRequest.type, {
	                filters: patterns.map(pattern => ({ pattern: { glob: pattern } })),
	            }));
	        }
	        return {
	            dispose() {
	                for (const disposable of disposables) {
	                    disposable.dispose();
	                }
	                disposables.length = 0;
	            },
	        };
	    }
	    function onDidChangeWatchedFiles(cb) {
	        didChangeWatchedFilesCallbacks.add(cb);
	        return {
	            dispose: () => {
	                didChangeWatchedFilesCallbacks.delete(cb);
	            },
	        };
	    }
	}
	
	return fileWatcher;
}

var languageFeatures = {};

var hasRequiredLanguageFeatures;

function requireLanguageFeatures () {
	if (hasRequiredLanguageFeatures) return languageFeatures;
	hasRequiredLanguageFeatures = 1;
	Object.defineProperty(languageFeatures, "__esModule", { value: true });
	languageFeatures.register = register;
	const language_service_1 = requireLanguageService();
	const vscode = requireMain$2();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const protocol_1 = requireProtocol();
	const reportedCapabilities = new Set();
	function register(server, documents, configurations) {
	    configurations.onDidChange(() => requestRefresh(false));
	    // Diagnostics support
	    let refreshReq = 0;
	    let updateDiagnosticsBatchReq = 0;
	    const refreshHandlers = [];
	    server.onInitialize(serverCapabilities => {
	        let lastCompleteUri;
	        let lastCompleteLs;
	        let lastCodeLensLs;
	        let lastCodeActionLs;
	        let lastCallHierarchyLs;
	        let lastTypeHierarchyLs;
	        let lastDocumentLinkLs;
	        let lastInlayHintLs;
	        let languageServiceToId = new WeakMap();
	        let currentLanguageServiceId = 0;
	        const languageServiceById = new Map();
	        const { languageServicePlugins, project, initializeParams } = server;
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.selectionRangeProvider)) {
	            serverCapabilities.selectionRangeProvider = true;
	            server.connection.onSelectionRanges(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getSelectionRanges(uri, params.positions, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.foldingRangeProvider)) {
	            serverCapabilities.foldingRangeProvider = true;
	            server.connection.onFoldingRanges(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getFoldingRanges(uri, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.linkedEditingRangeProvider)) {
	            serverCapabilities.linkedEditingRangeProvider = true;
	            server.connection.languages.onLinkedEditingRange(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getLinkedEditingRanges(uri, params.position, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.colorProvider)) {
	            serverCapabilities.colorProvider = true;
	            server.connection.onDocumentColor(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentColors(uri, token);
	                });
	            });
	            server.connection.onColorPresentation(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getColorPresentations(uri, params.color, params.range, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentSymbolProvider)) {
	            serverCapabilities.documentSymbolProvider = true;
	            server.connection.onDocumentSymbol(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentSymbols(uri, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentFormattingProvider)) {
	            serverCapabilities.documentFormattingProvider = true;
	            serverCapabilities.documentRangeFormattingProvider = true;
	            server.connection.onDocumentFormatting(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentFormattingEdits(uri, params.options, undefined, undefined, token);
	                });
	            });
	            server.connection.onDocumentRangeFormatting(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentFormattingEdits(uri, params.options, params.range, undefined, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.referencesProvider)) {
	            serverCapabilities.referencesProvider = true;
	            server.connection.onReferences(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getReferences(uri, params.position, { includeDeclaration: true }, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.implementationProvider)) {
	            serverCapabilities.implementationProvider = true;
	            server.connection.onImplementation(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    const definitions = await languageService.getImplementations(uri, params.position, token);
	                    return handleDefinitions(initializeParams, 'implementation', definitions ?? []);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.declarationProvider)) {
	            serverCapabilities.declarationProvider = true;
	            server.connection.onDeclaration(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    const definitions = await languageService.getDeclaration(uri, params.position, token);
	                    return handleDefinitions(initializeParams, 'declaration', definitions ?? []);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.definitionProvider)) {
	            serverCapabilities.definitionProvider = true;
	            server.connection.onDefinition(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    const definitions = await languageService.getDefinition(uri, params.position, token);
	                    return handleDefinitions(initializeParams, 'definition', definitions ?? []);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.typeDefinitionProvider)) {
	            serverCapabilities.typeDefinitionProvider = true;
	            server.connection.onTypeDefinition(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    const definitions = await languageService.getTypeDefinition(uri, params.position, token);
	                    return handleDefinitions(initializeParams, 'typeDefinition', definitions ?? []);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.callHierarchyProvider)) {
	            serverCapabilities.callHierarchyProvider = true;
	            server.connection.languages.callHierarchy.onPrepare(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    lastCallHierarchyLs = languageService;
	                    return languageService.getCallHierarchyItems(uri, params.position, token);
	                }) ?? [];
	            });
	            server.connection.languages.callHierarchy.onIncomingCalls(async (params, token) => {
	                return await lastCallHierarchyLs?.getCallHierarchyIncomingCalls(params.item, token) ?? [];
	            });
	            server.connection.languages.callHierarchy.onOutgoingCalls(async (params, token) => {
	                return await lastCallHierarchyLs?.getCallHierarchyOutgoingCalls(params.item, token) ?? [];
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.typeHierarchyProvider)) {
	            serverCapabilities.typeHierarchyProvider = true;
	            server.connection.languages.typeHierarchy.onPrepare(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    lastTypeHierarchyLs = languageService;
	                    return languageService.getTypeHierarchyItems(uri, params.position, token);
	                }) ?? [];
	            });
	            server.connection.languages.typeHierarchy.onSupertypes(async (params, token) => {
	                return await lastTypeHierarchyLs?.getTypeHierarchySupertypes(params.item, token) ?? [];
	            });
	            server.connection.languages.typeHierarchy.onSubtypes(async (params, token) => {
	                return await lastTypeHierarchyLs?.getTypeHierarchySubtypes(params.item, token) ?? [];
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.hoverProvider)) {
	            serverCapabilities.hoverProvider = true;
	            server.connection.onHover(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getHover(uri, params.position, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentHighlightProvider)) {
	            serverCapabilities.documentHighlightProvider = true;
	            server.connection.onDocumentHighlight(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentHighlights(uri, params.position, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.workspaceSymbolProvider)) {
	            serverCapabilities.workspaceSymbolProvider = {};
	            server.connection.onWorkspaceSymbol(async (params, token) => {
	                let languageServices = await project.getExistingLanguageServices();
	                if (!languageServices.length) {
	                    for (const document of documents.all()) {
	                        await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
	                    }
	                    languageServices = await project.getExistingLanguageServices();
	                }
	                const symbols = [];
	                for (const languageService of languageServices) {
	                    if (token.isCancellationRequested) {
	                        return;
	                    }
	                    let languageServiceId = languageServiceToId.get(languageService);
	                    if (languageServiceId === undefined) {
	                        languageServiceId = currentLanguageServiceId;
	                        languageServiceToId.set(languageService, languageServiceId);
	                        languageServiceById.set(languageServiceId, new WeakRef(languageService));
	                    }
	                    const languageServiceResult = await languageService.getWorkspaceSymbols(params.query, token);
	                    for (const symbol of languageServiceResult) {
	                        symbol.data = {
	                            languageServiceId,
	                            originalData: symbol.data,
	                        };
	                    }
	                    symbols.push(...await languageService.getWorkspaceSymbols(params.query, token));
	                }
	                return symbols;
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.workspaceSymbolProvider?.resolveProvider)) {
	                serverCapabilities.workspaceSymbolProvider.resolveProvider = true;
	                server.connection.onWorkspaceSymbolResolve(async (symbol, token) => {
	                    const languageServiceId = symbol.data?.languageServiceId;
	                    const languageService = languageServiceById.get(languageServiceId)?.deref();
	                    if (!languageService) {
	                        return symbol;
	                    }
	                    symbol.data = symbol.data?.originalData;
	                    return await languageService.resolveWorkspaceSymbol?.(symbol, token);
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.renameProvider)) {
	            serverCapabilities.renameProvider = {};
	            server.connection.onRenameRequest(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getRenameEdits(uri, params.position, params.newName, token);
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.renameProvider?.prepareProvider)) {
	                serverCapabilities.renameProvider.prepareProvider = true;
	                server.connection.onPrepareRename(async (params, token) => {
	                    const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                    return await worker(uri, token, async (languageService) => {
	                        const result = await languageService.getRenameRange(uri, params.position, token);
	                        if (result && 'message' in result) {
	                            return new vscode.ResponseError(0, result.message);
	                        }
	                        return result;
	                    });
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentLinkProvider)) {
	            serverCapabilities.documentLinkProvider = {};
	            server.connection.onDocumentLinks(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    lastDocumentLinkLs = languageService;
	                    return languageService.getDocumentLinks(uri, token);
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.documentLinkProvider?.resolveProvider)) {
	                serverCapabilities.documentLinkProvider.resolveProvider = true;
	                server.connection.onDocumentLinkResolve(async (link, token) => {
	                    return await lastDocumentLinkLs?.resolveDocumentLink(link, token);
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.codeLensProvider)) {
	            serverCapabilities.codeLensProvider = {};
	            server.connection.onCodeLens(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    lastCodeLensLs = languageService;
	                    return languageService.getCodeLenses(uri, token);
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.codeLensProvider?.resolveProvider)) {
	                serverCapabilities.codeLensProvider.resolveProvider = true;
	                server.connection.onCodeLensResolve(async (codeLens, token) => {
	                    return await lastCodeLensLs?.resolveCodeLens(codeLens, token) ?? codeLens;
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.inlayHintProvider)) {
	            serverCapabilities.inlayHintProvider = {};
	            server.connection.languages.inlayHint.on(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    lastInlayHintLs = languageService;
	                    return languageService.getInlayHints(uri, params.range, token);
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.inlayHintProvider?.resolveProvider)) {
	                serverCapabilities.inlayHintProvider.resolveProvider = true;
	                server.connection.languages.inlayHint.resolve(async (hint, token) => {
	                    return await lastInlayHintLs?.resolveInlayHint(hint, token) ?? hint;
	                });
	            }
	            refreshHandlers.push(() => {
	                if (initializeParams.capabilities.workspace?.inlayHint?.refreshSupport) {
	                    server.connection.languages.inlayHint.refresh();
	                }
	                else {
	                    wranCapabilitiesNotSupported('workspace.inlayHint.refreshSupport');
	                }
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.signatureHelpProvider)) {
	            serverCapabilities.signatureHelpProvider = {
	                triggerCharacters: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.signatureHelpProvider?.triggerCharacters ?? []).flat()),
	                ],
	                retriggerCharacters: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.signatureHelpProvider?.retriggerCharacters ?? []).flat()),
	                ],
	            };
	            server.connection.onSignatureHelp(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getSignatureHelp(uri, params.position, params.context, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.completionProvider)) {
	            serverCapabilities.completionProvider = {
	                triggerCharacters: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.completionProvider?.triggerCharacters ?? [])
	                        .flat()),
	                ],
	            };
	            server.connection.onCompletion(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    lastCompleteUri = params.textDocument.uri;
	                    lastCompleteLs = languageService;
	                    const list = await languageService.getCompletionItems(uri, params.position, params.context, token);
	                    list.items = list.items.map(item => handleCompletionItem(initializeParams, item));
	                    return list;
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.completionProvider?.resolveProvider)) {
	                serverCapabilities.completionProvider.resolveProvider = true;
	                server.connection.onCompletionResolve(async (item, token) => {
	                    if (lastCompleteUri && lastCompleteLs) {
	                        item = await lastCompleteLs.resolveCompletionItem(item, token);
	                        item = handleCompletionItem(initializeParams, item);
	                    }
	                    return item;
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.semanticTokensProvider)) {
	            serverCapabilities.semanticTokensProvider = {
	                full: true,
	                range: true,
	                legend: {
	                    tokenTypes: [
	                        ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.semanticTokensProvider?.legend?.tokenTypes ?? []).flat()),
	                    ],
	                    tokenModifiers: [
	                        ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.semanticTokensProvider?.legend?.tokenModifiers ?? []).flat()),
	                    ],
	                },
	            };
	            server.connection.languages.semanticTokens.on(async (params, token, _, resultProgress) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    return await languageService?.getSemanticTokens(uri, undefined, serverCapabilities.semanticTokensProvider.legend, tokens => resultProgress?.report(tokens), token);
	                }) ?? { data: [] };
	            });
	            server.connection.languages.semanticTokens.onRange(async (params, token, _, resultProgress) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    return await languageService?.getSemanticTokens(uri, params.range, serverCapabilities.semanticTokensProvider.legend, tokens => resultProgress?.report(tokens), token);
	                }) ?? { data: [] };
	            });
	            refreshHandlers.push(() => {
	                if (initializeParams.capabilities.workspace?.semanticTokens?.refreshSupport) {
	                    server.connection.languages.semanticTokens.refresh();
	                }
	                else {
	                    wranCapabilitiesNotSupported('workspace.semanticTokens.refreshSupport');
	                }
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider)) {
	            serverCapabilities.codeActionProvider = {
	                codeActionKinds: languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider?.codeActionKinds)
	                    ? [
	                        ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.codeActionProvider?.codeActionKinds ?? [])
	                            .flat()),
	                    ]
	                    : undefined,
	            };
	            server.connection.onCodeAction(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, async (languageService) => {
	                    lastCodeActionLs = languageService;
	                    let codeActions = await languageService.getCodeActions(uri, params.range, params.context, token) ?? [];
	                    for (const codeAction of codeActions) {
	                        if (codeAction.data && typeof codeAction.data === 'object') {
	                            codeAction.data.uri = params.textDocument.uri;
	                        }
	                        else {
	                            codeAction.data = { uri: params.textDocument.uri };
	                        }
	                    }
	                    if (!initializeParams.capabilities.textDocument?.codeAction?.disabledSupport
	                        && codeActions.some(codeAction => !codeAction.disabled)) {
	                        codeActions = codeActions.filter(codeAction => !codeAction.disabled);
	                        wranCapabilitiesNotSupported('textDocument.codeAction.disabledSupport');
	                    }
	                    return codeActions;
	                });
	            });
	            if (languageServicePlugins.some(({ capabilities }) => capabilities.codeActionProvider?.resolveProvider)) {
	                serverCapabilities.codeActionProvider.resolveProvider = true;
	                server.connection.onCodeActionResolve(async (codeAction, token) => {
	                    return await lastCodeActionLs?.resolveCodeAction(codeAction, token) ?? codeAction;
	                });
	            }
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentOnTypeFormattingProvider)) {
	            serverCapabilities.documentOnTypeFormattingProvider = {
	                firstTriggerCharacter: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat()),
	                ][0],
	                moreTriggerCharacter: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.documentOnTypeFormattingProvider?.triggerCharacters ?? []).flat()),
	                ].slice(1),
	            };
	            server.connection.onDocumentOnTypeFormatting(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getDocumentFormattingEdits(uri, params.options, undefined, params, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.executeCommandProvider)) {
	            serverCapabilities.executeCommandProvider = {
	                commands: [
	                    ...new Set(languageServicePlugins.map(({ capabilities }) => capabilities.executeCommandProvider?.commands ?? [])
	                        .flat()),
	                ],
	            };
	            server.connection.onExecuteCommand(async (params, token) => {
	                let languageServices = await project.getExistingLanguageServices();
	                if (!languageServices.length) {
	                    for (const document of documents.all()) {
	                        await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
	                    }
	                    languageServices = await project.getExistingLanguageServices();
	                }
	                for (const languageService of languageServices) {
	                    if (languageService.executeCommand && languageService.commands.includes(params.command)) {
	                        try {
	                            return await languageService.executeCommand(params.command, params.arguments ?? [], token);
	                        }
	                        catch { }
	                    }
	                }
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.monikerProvider)) {
	            serverCapabilities.monikerProvider = true;
	            server.connection.languages.moniker.on(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getMoniker(uri, params.position, token);
	                }) ?? null;
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.inlineValueProvider)) {
	            serverCapabilities.inlineValueProvider = true;
	            server.connection.languages.inlineValue.on(async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getInlineValue(uri, params.range, params.context, token);
	                });
	            });
	            refreshHandlers.push(() => {
	                if (initializeParams.capabilities.workspace?.inlineValue?.refreshSupport) {
	                    server.connection.languages.inlineValue.refresh();
	                }
	                else {
	                    wranCapabilitiesNotSupported('workspace.inlineValue.refreshSupport');
	                }
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.autoInsertionProvider)) {
	            const triggerCharacterToConfigurationSections = new Map();
	            const tryAdd = (char, section) => {
	                let sectionSet = triggerCharacterToConfigurationSections.get(char);
	                if (!sectionSet) {
	                    triggerCharacterToConfigurationSections.set(char, sectionSet = new Set());
	                }
	                if (section) {
	                    sectionSet.add(section);
	                }
	            };
	            for (const { capabilities } of languageServicePlugins) {
	                if (capabilities.autoInsertionProvider) {
	                    const { triggerCharacters, configurationSections } = capabilities.autoInsertionProvider;
	                    if (configurationSections) {
	                        if (configurationSections.length !== triggerCharacters.length) {
	                            throw new Error('configurationSections.length !== triggerCharacters.length');
	                        }
	                        for (let i = 0; i < configurationSections.length; i++) {
	                            tryAdd(triggerCharacters[i], configurationSections[i]);
	                        }
	                    }
	                    else {
	                        for (const char of triggerCharacters) {
	                            tryAdd(char);
	                        }
	                    }
	                }
	            }
	            serverCapabilities.experimental ??= {};
	            serverCapabilities.experimental.autoInsertionProvider = {
	                triggerCharacters: [],
	                configurationSections: [],
	            };
	            for (const [char, sections] of triggerCharacterToConfigurationSections) {
	                if (sections.size) {
	                    serverCapabilities.experimental.autoInsertionProvider.triggerCharacters.push(char);
	                    serverCapabilities.experimental.autoInsertionProvider.configurationSections.push([...sections]);
	                }
	                else {
	                    serverCapabilities.experimental.autoInsertionProvider.triggerCharacters.push(char);
	                    serverCapabilities.experimental.autoInsertionProvider.configurationSections.push(null);
	                }
	            }
	            server.connection.onRequest(protocol_1.AutoInsertRequest.type, async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getAutoInsertSnippet(uri, params.selection, params.change, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.fileRenameEditsProvider)) {
	            serverCapabilities.experimental ??= {};
	            serverCapabilities.experimental.fileRenameEditsProvider = true;
	            server.connection.workspace.onWillRenameFiles(async (params, token) => {
	                const _edits = await Promise.all(params.files.map(async (file) => {
	                    const oldUri = vscode_uri_1.URI.parse(file.oldUri);
	                    const newUri = vscode_uri_1.URI.parse(file.newUri);
	                    return await worker(oldUri, token, languageService => {
	                        return languageService.getFileRenameEdits(oldUri, newUri, token) ?? null;
	                    }) ?? null;
	                }));
	                const edits = _edits.filter((edit) => !!edit);
	                if (edits.length) {
	                    (0, language_service_1.mergeWorkspaceEdits)(edits[0], ...edits.slice(1));
	                    return edits[0];
	                }
	                return null;
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.fileReferencesProvider)) {
	            serverCapabilities.experimental ??= {};
	            serverCapabilities.experimental.fileReferencesProvider = true;
	            server.connection.onRequest(protocol_1.FindFileReferenceRequest.type, async (params, token) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                return await worker(uri, token, languageService => {
	                    return languageService.getFileReferences(uri, token);
	                });
	            });
	        }
	        if (languageServicePlugins.some(({ capabilities }) => capabilities.documentDropEditsProvider)) {
	            serverCapabilities.experimental ??= {};
	            serverCapabilities.experimental.documentDropEditsProvider = true;
	            server.connection.onRequest(protocol_1.DocumentDropRequest.type, async ({ textDocument, position, dataTransfer }, token) => {
	                const dataTransferMap = new Map();
	                for (const item of dataTransfer) {
	                    dataTransferMap.set(item.mimeType, {
	                        value: item.value,
	                        asString() {
	                            return server.connection.sendRequest(protocol_1.DocumentDrop_DataTransferItemAsStringRequest.type, {
	                                mimeType: item.mimeType,
	                            });
	                        },
	                        asFile() {
	                            if (item.file) {
	                                return {
	                                    name: item.file.name,
	                                    uri: item.file.uri,
	                                    data() {
	                                        return server.connection.sendRequest(protocol_1.DocumentDrop_DataTransferItemFileDataRequest.type, {
	                                            mimeType: item.mimeType,
	                                        });
	                                    },
	                                };
	                            }
	                        },
	                    });
	                }
	                const uri = vscode_uri_1.URI.parse(textDocument.uri);
	                const languageService = await project.getLanguageService(uri);
	                return languageService.getDocumentDropEdits(uri, position, dataTransferMap, token);
	            });
	        }
	        // Diagnostic support
	        const supportsDiagnosticPull = !!initializeParams.capabilities.workspace?.diagnostics;
	        const diagnosticProvider = languageServicePlugins.some(({ capabilities }) => !!capabilities.diagnosticProvider);
	        const interFileDependencies = languageServicePlugins.some(({ capabilities }) => capabilities.diagnosticProvider?.interFileDependencies);
	        const workspaceDiagnostics = languageServicePlugins.some(({ capabilities }) => capabilities.diagnosticProvider?.workspaceDiagnostics);
	        if (diagnosticProvider) {
	            if (supportsDiagnosticPull && !interFileDependencies) {
	                serverCapabilities.diagnosticProvider = {
	                    // Unreliable, see https://github.com/microsoft/vscode-languageserver-node/issues/848#issuecomment-2189521060
	                    interFileDependencies: false,
	                    workspaceDiagnostics,
	                };
	                refreshHandlers.push(() => {
	                    if (initializeParams.capabilities.workspace?.diagnostics?.refreshSupport) {
	                        server.connection.languages.diagnostics.refresh();
	                    }
	                    else {
	                        wranCapabilitiesNotSupported('workspace.diagnostics.refreshSupport');
	                    }
	                });
	            }
	            else {
	                documents.onDidChangeContent(({ document }) => {
	                    const changedDocument = documents.get(vscode_uri_1.URI.parse(document.uri));
	                    if (!changedDocument) {
	                        return;
	                    }
	                    if (interFileDependencies) {
	                        const remainingDocuments = [...documents.all()].filter(doc => doc !== changedDocument);
	                        updateDiagnosticsBatch(project, [changedDocument, ...remainingDocuments]);
	                    }
	                    else {
	                        updateDiagnosticsBatch(project, [changedDocument]);
	                    }
	                });
	                documents.onDidClose(({ document }) => {
	                    server.connection.sendDiagnostics({ uri: document.uri, diagnostics: [] });
	                });
	                refreshHandlers.push(async (clearDiagnostics) => {
	                    if (clearDiagnostics) {
	                        for (const document of documents.all()) {
	                            server.connection.sendDiagnostics({ uri: document.uri, diagnostics: [] });
	                        }
	                    }
	                    await updateDiagnosticsBatch(project, [...documents.all()]);
	                });
	            }
	            server.connection.languages.diagnostics.on(async (params, token, _workDoneProgressReporter, resultProgressReporter) => {
	                const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
	                const result = await worker(uri, token, languageService => {
	                    return languageService.getDiagnostics(uri, errors => {
	                        // resultProgressReporter is undefined in vscode
	                        resultProgressReporter?.report({
	                            relatedDocuments: {
	                                [params.textDocument.uri]: {
	                                    kind: vscode.DocumentDiagnosticReportKind.Full,
	                                    items: errors,
	                                },
	                            },
	                        });
	                    }, token);
	                });
	                return {
	                    kind: vscode.DocumentDiagnosticReportKind.Full,
	                    items: result ?? [],
	                };
	            });
	        }
	        if (workspaceDiagnostics) {
	            server.connection.languages.diagnostics.onWorkspace(async (_params, token) => {
	                let languageServices = await project.getExistingLanguageServices();
	                if (!languageServices.length) {
	                    for (const document of documents.all()) {
	                        await project.getLanguageService(vscode_uri_1.URI.parse(document.uri));
	                    }
	                    languageServices = await project.getExistingLanguageServices();
	                }
	                const items = [];
	                for (const languageService of languageServices) {
	                    if (token.isCancellationRequested) {
	                        break;
	                    }
	                    const result = await languageService.getWorkspaceDiagnostics(token);
	                    items.push(...result);
	                }
	                return { items };
	            });
	        }
	    });
	    return { requestRefresh };
	    async function requestRefresh(clearDiagnostics) {
	        const req = ++refreshReq;
	        const delay = 250;
	        await sleep(delay);
	        if (req !== refreshReq) {
	            return;
	        }
	        for (const handler of refreshHandlers) {
	            handler(clearDiagnostics);
	        }
	    }
	    async function updateDiagnosticsBatch(project, documents) {
	        const req = ++updateDiagnosticsBatchReq;
	        const delay = 250;
	        const token = {
	            get isCancellationRequested() {
	                return req !== updateDiagnosticsBatchReq;
	            },
	            onCancellationRequested: vscode.Event.None,
	        };
	        for (const doc of documents) {
	            await sleep(delay);
	            if (token.isCancellationRequested) {
	                break;
	            }
	            await updateDiagnostics(project, vscode_uri_1.URI.parse(doc.uri), doc.version, token);
	        }
	    }
	    async function updateDiagnostics(project, uri, version, token) {
	        const languageService = await project.getLanguageService(uri);
	        const diagnostics = await languageService.getDiagnostics(uri, diagnostics => server.connection.sendDiagnostics({ uri: uri.toString(), diagnostics, version }), token);
	        if (!token.isCancellationRequested) {
	            server.connection.sendDiagnostics({ uri: uri.toString(), diagnostics, version });
	        }
	    }
	    function worker(uri, token, cb) {
	        return new Promise(resolve => {
	            server.env.timer.setImmediate(async () => {
	                if (token.isCancellationRequested) {
	                    resolve(undefined);
	                    return;
	                }
	                const languageService = await server.project.getLanguageService((0, language_service_1.decodeEmbeddedDocumentUri)(uri)?.[0] ?? uri);
	                const result = await cb(languageService);
	                if (token.isCancellationRequested) {
	                    resolve(undefined);
	                    return;
	                }
	                resolve(result);
	            });
	        });
	    }
	    function handleCompletionItem(initializeParams, item) {
	        const snippetSupport = initializeParams.capabilities.textDocument?.completion?.completionItem?.snippetSupport
	            ?? false;
	        const insertReplaceSupport = initializeParams.capabilities.textDocument?.completion?.completionItem?.insertReplaceSupport ?? false;
	        if (!snippetSupport && item.insertTextFormat === vscode.InsertTextFormat.Snippet) {
	            item.insertTextFormat = vscode.InsertTextFormat.PlainText;
	            if (item.insertText) {
	                item.insertText = item.insertText.replace(/\$\d+/g, '');
	                item.insertText = item.insertText.replace(/\${\d+:([^}]*)}/g, '');
	            }
	            wranCapabilitiesNotSupported('textDocument.completion.completionItem.snippetSupport');
	        }
	        if (!insertReplaceSupport && item.textEdit && vscode.InsertReplaceEdit.is(item.textEdit)) {
	            item.textEdit = vscode.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
	            wranCapabilitiesNotSupported('textDocument.completion.completionItem.insertReplaceSupport');
	        }
	        return item;
	    }
	    function handleDefinitions(initializeParams, type, items) {
	        const linkSupport = initializeParams.capabilities.textDocument?.[type]?.linkSupport ?? false;
	        if (!linkSupport) {
	            wranCapabilitiesNotSupported(`textDocument.${type}.linkSupport`);
	            return items.map(item => ({
	                uri: item.targetUri,
	                range: item.targetRange,
	            }));
	        }
	        return items;
	    }
	}
	function wranCapabilitiesNotSupported(path) {
	    if (reportedCapabilities.has(path)) {
	        return;
	    }
	    reportedCapabilities.add(path);
	    console.warn(`${path} is not supported by the client but could be used by the server.`);
	}
	function sleep(ms) {
	    return new Promise(resolve => setTimeout(resolve, ms));
	}
	
	return languageFeatures;
}

var textDocuments = {};

var snapshotDocument = {};

var combineChangeRanges = {};

var hasRequiredCombineChangeRanges;

function requireCombineChangeRanges () {
	if (hasRequiredCombineChangeRanges) return combineChangeRanges;
	hasRequiredCombineChangeRanges = 1;
	Object.defineProperty(combineChangeRanges, "__esModule", { value: true });
	combineChangeRanges.combineChangeRanges = combineChangeRanges$1;
	function combineChangeRanges$1(...changeRanges) {
	    let changeRange = changeRanges[0];
	    for (let i = 1; i < changeRanges.length; i++) {
	        const nextChangeRange = changeRanges[i];
	        changeRange = combineTwoChanges(changeRange, nextChangeRange);
	    }
	    return changeRange;
	}
	// https://tsplay.dev/mMldVN - @browsnet
	function combineTwoChanges(a, b) {
	    const aStart = a.span.start;
	    const aEnd = a.span.start + a.span.length;
	    const aDiff = a.newLength - a.span.length;
	    const changeBegin = aStart + Math.min(a.span.length, a.newLength);
	    const rollback = (start) => start > changeBegin ? Math.max(aStart, start - aDiff) : start;
	    const bStart = rollback(b.span.start);
	    const bEnd = rollback(b.span.start + b.span.length);
	    const bDiff = b.newLength - b.span.length;
	    const start = Math.min(aStart, bStart);
	    const end = Math.max(aEnd, bEnd);
	    const length = end - start;
	    const newLength = aDiff + bDiff + length;
	    return { span: { start, length }, newLength };
	}
	
	return combineChangeRanges;
}

var hasRequiredSnapshotDocument;

function requireSnapshotDocument () {
	if (hasRequiredSnapshotDocument) return snapshotDocument;
	hasRequiredSnapshotDocument = 1;
	Object.defineProperty(snapshotDocument, "__esModule", { value: true });
	snapshotDocument.SnapshotDocument = void 0;
	const vscode_languageserver_textdocument_1 = require$$0;
	const combineChangeRanges_1 = requireCombineChangeRanges();
	class SnapshotDocument {
	    constructor(uri, languageId, version, text) {
	        this.snapshots = [];
	        this.document = vscode_languageserver_textdocument_1.TextDocument.create(uri, languageId, version, text);
	        this.resetChanges();
	    }
	    get uri() {
	        return this.document.uri;
	    }
	    get languageId() {
	        return this.document.languageId;
	    }
	    get version() {
	        return this.document.version;
	    }
	    get lineCount() {
	        return this.document.lineCount;
	    }
	    getText(range) {
	        return this.document.getText(range);
	    }
	    positionAt(offset) {
	        return this.document.positionAt(offset);
	    }
	    offsetAt(position) {
	        return this.document.offsetAt(position);
	    }
	    /**
	     * Update the document with the given content changes and version.
	     * If all changes is incremental, calculate the change range and add a new snapshot.
	     * Otherwise, reset the changes.
	     */
	    update(contentChanges, version) {
	        if (contentChanges.every(change => 'range' in change)) {
	            let changeRanges = [];
	            for (const contentChange of contentChanges) {
	                if (!('range' in contentChange)) {
	                    continue;
	                }
	                const start = this.offsetAt(contentChange.range.start);
	                const length = contentChange.rangeLength ?? this.offsetAt(contentChange.range.end) - start;
	                changeRanges.push({
	                    span: { start, length },
	                    newLength: contentChange.text.length,
	                });
	                vscode_languageserver_textdocument_1.TextDocument.update(this.document, [contentChange], version);
	            }
	            this.snapshots.push({
	                changeRange: (0, combineChangeRanges_1.combineChangeRanges)(...changeRanges),
	                version,
	                ref: undefined,
	            });
	        }
	        else {
	            vscode_languageserver_textdocument_1.TextDocument.update(this.document, contentChanges, version);
	            this.resetChanges();
	        }
	    }
	    getSnapshot() {
	        this.clearUnreferencedVersions();
	        const lastChange = this.snapshots[this.snapshots.length - 1];
	        if (!lastChange.ref) {
	            const text = this.document.getText();
	            const changeRangeCache = new WeakMap();
	            const snapshot = {
	                getText: (start, end) => text.substring(start, end),
	                getLength: () => text.length,
	                getChangeRange: oldSnapshot => {
	                    if (!changeRangeCache.has(oldSnapshot)) {
	                        const oldIndex = this.snapshots.findIndex(change => change.ref?.deref() === oldSnapshot);
	                        if (oldIndex >= 0) {
	                            const start = oldIndex + 1;
	                            const end = this.snapshots.indexOf(lastChange) + 1;
	                            const changeRanges = this.snapshots
	                                .slice(start, end)
	                                .map(change => change.changeRange);
	                            const changeRange = (0, combineChangeRanges_1.combineChangeRanges)(...changeRanges);
	                            changeRangeCache.set(oldSnapshot, changeRange);
	                        }
	                        else {
	                            changeRangeCache.set(oldSnapshot, undefined);
	                        }
	                    }
	                    return changeRangeCache.get(oldSnapshot);
	                },
	            };
	            lastChange.ref = new WeakRef(snapshot);
	        }
	        return lastChange.ref.deref();
	    }
	    resetChanges() {
	        this.snapshots = [
	            {
	                changeRange: {
	                    span: {
	                        start: 0,
	                        length: 0,
	                    },
	                    newLength: this.document.getText().length,
	                },
	                version: this.document.version,
	                ref: undefined,
	            },
	        ];
	    }
	    clearUnreferencedVersions() {
	        let firstReferencedIndex = 0;
	        while (firstReferencedIndex < this.snapshots.length - 1 && !this.snapshots[firstReferencedIndex].ref?.deref()) {
	            firstReferencedIndex++;
	        }
	        this.snapshots = this.snapshots.slice(firstReferencedIndex);
	    }
	}
	snapshotDocument.SnapshotDocument = SnapshotDocument;
	
	return snapshotDocument;
}

var hasRequiredTextDocuments;

function requireTextDocuments () {
	if (hasRequiredTextDocuments) return textDocuments;
	hasRequiredTextDocuments = 1;
	Object.defineProperty(textDocuments, "__esModule", { value: true });
	textDocuments.register = register;
	const vscode = requireMain$2();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const snapshotDocument_1 = requireSnapshotDocument();
	function register(server) {
	    const syncedDocumentParsedUriToUri = new Map();
	    const documentsCache = new Map();
	    const documents = new vscode.TextDocuments({
	        create(uri, languageId, version, text) {
	            const cache = documentsCache.get(uri)?.deref();
	            if (cache && cache.languageId === languageId && cache.version === version && cache.getText() === text) {
	                return cache;
	            }
	            const document = new snapshotDocument_1.SnapshotDocument(uri, languageId, version, text);
	            documentsCache.set(uri, new WeakRef(document));
	            return document;
	        },
	        update(snapshot, contentChanges, version) {
	            snapshot.update(contentChanges, version);
	            return snapshot;
	        },
	    });
	    documents.listen(server.connection);
	    documents.onDidOpen(({ document }) => {
	        const parsedUri = vscode_uri_1.URI.parse(document.uri);
	        syncedDocumentParsedUriToUri.set(parsedUri.toString(), document.uri);
	    });
	    documents.onDidClose(({ document }) => {
	        const parsedUri = vscode_uri_1.URI.parse(document.uri);
	        syncedDocumentParsedUriToUri.delete(parsedUri.toString());
	    });
	    server.onInitialize(serverCapabilities => {
	        serverCapabilities.textDocumentSync = vscode.TextDocumentSyncKind.Incremental;
	    });
	    return {
	        all: documents.all.bind(documents),
	        onDidChangeContent: documents.onDidChangeContent.bind(documents),
	        onDidOpen: documents.onDidOpen.bind(documents),
	        onDidClose: documents.onDidClose.bind(documents),
	        onDidSave: documents.onDidSave.bind(documents),
	        get(uri) {
	            return documents.get(getSyncedDocumentKey(uri) ?? uri.toString());
	        },
	    };
	    function getSyncedDocumentKey(uri) {
	        const originalUri = syncedDocumentParsedUriToUri.get(uri.toString());
	        if (originalUri) {
	            return originalUri;
	        }
	    }
	}
	
	return textDocuments;
}

var workspaceFolders = {};

var hasRequiredWorkspaceFolders;

function requireWorkspaceFolders () {
	if (hasRequiredWorkspaceFolders) return workspaceFolders;
	hasRequiredWorkspaceFolders = 1;
	Object.defineProperty(workspaceFolders, "__esModule", { value: true });
	workspaceFolders.register = register;
	const language_service_1 = requireLanguageService();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	function register(server) {
	    const folders = (0, language_service_1.createUriMap)();
	    const didChangeCallbacks = new Set();
	    server.onInitialize(serverCapabilities => {
	        const { initializeParams } = server;
	        if (initializeParams.workspaceFolders?.length) {
	            for (const folder of initializeParams.workspaceFolders) {
	                folders.set(vscode_uri_1.URI.parse(folder.uri), true);
	            }
	        }
	        else if (initializeParams.rootUri) {
	            folders.set(vscode_uri_1.URI.parse(initializeParams.rootUri), true);
	        }
	        else if (initializeParams.rootPath) {
	            folders.set(vscode_uri_1.URI.file(initializeParams.rootPath), true);
	        }
	        // #18
	        serverCapabilities.workspace ??= {};
	        serverCapabilities.workspace.workspaceFolders = {
	            supported: true,
	            changeNotifications: true,
	        };
	    });
	    server.onInitialized(() => {
	        if (server.initializeParams.capabilities.workspace?.workspaceFolders) {
	            server.connection.workspace.onDidChangeWorkspaceFolders(e => {
	                e.added = e.added.filter(folder => !folders.has(vscode_uri_1.URI.parse(folder.uri)));
	                e.removed = e.removed.filter(folder => folders.has(vscode_uri_1.URI.parse(folder.uri)));
	                if (e.added.length || e.removed.length) {
	                    for (const folder of e.added) {
	                        folders.set(vscode_uri_1.URI.parse(folder.uri), true);
	                    }
	                    for (const folder of e.removed) {
	                        folders.delete(vscode_uri_1.URI.parse(folder.uri));
	                    }
	                    server.project.reload();
	                    for (const cb of didChangeCallbacks) {
	                        cb(e);
	                    }
	                }
	            });
	        }
	    });
	    return {
	        get all() {
	            return [...folders.keys()];
	        },
	        has(uri) {
	            return folders.has(uri);
	        },
	        onDidChange,
	    };
	    function onDidChange(cb) {
	        didChangeCallbacks.add(cb);
	        return {
	            dispose() {
	                didChangeCallbacks.delete(cb);
	            },
	        };
	    }
	}
	
	return workspaceFolders;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server$1;
	hasRequiredServer = 1;
	Object.defineProperty(server$1, "__esModule", { value: true });
	server$1.createServerBase = createServerBase;
	const configurations_js_1 = requireConfigurations();
	const editorFeatures_js_1 = requireEditorFeatures();
	const fileSystem_js_1 = requireFileSystem();
	const fileWatcher_js_1 = requireFileWatcher();
	const languageFeatures_js_1 = requireLanguageFeatures();
	const textDocuments_js_1 = requireTextDocuments();
	const workspaceFolders_js_1 = requireWorkspaceFolders();
	function createServerBase(connection, env) {
	    const onInitializeCallbacks = [];
	    const onInitializedCallbacks = [];
	    const state = {
	        env,
	        connection,
	        initializeParams: undefined,
	        project: undefined,
	        languageServicePlugins: undefined,
	        onInitialize(callback) {
	            onInitializeCallbacks.push(callback);
	        },
	        onInitialized(callback) {
	            onInitializedCallbacks.push(callback);
	        },
	    };
	    const configurations = (0, configurations_js_1.register)(state);
	    const editorFeatures = (0, editorFeatures_js_1.register)(state);
	    const documents = (0, textDocuments_js_1.register)(state);
	    const workspaceFolders = (0, workspaceFolders_js_1.register)(state);
	    const fileWatcher = (0, fileWatcher_js_1.register)(state);
	    const languageFeatures = (0, languageFeatures_js_1.register)(state, documents, configurations);
	    const fileSystem = (0, fileSystem_js_1.register)(documents, fileWatcher);
	    const server = {
	        ...state,
	        get initializeParams() {
	            return state.initializeParams;
	        },
	        get project() {
	            return state.project;
	        },
	        get languageServicePlugins() {
	            return state.languageServicePlugins;
	        },
	        initialize(params, project, languageServicePlugins) {
	            state.initializeParams = params;
	            state.project = project;
	            state.languageServicePlugins = languageServicePlugins;
	            const serverCapabilities = {};
	            onInitializeCallbacks.forEach(cb => cb(serverCapabilities));
	            return { capabilities: serverCapabilities };
	        },
	        initialized() {
	            onInitializedCallbacks.forEach(cb => cb());
	            state.project.setup(server);
	        },
	        shutdown() {
	            state.project.reload();
	        },
	        configurations,
	        editorFeatures,
	        documents,
	        workspaceFolders,
	        fileWatcher,
	        languageFeatures,
	        fileSystem,
	    };
	    return server;
	}
	
	return server$1;
}

var languageServer = {};

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	
	return types;
}

var hasRequiredLanguageServer;

function requireLanguageServer () {
	if (hasRequiredLanguageServer) return languageServer;
	hasRequiredLanguageServer = 1;
	(function (exports$1) {
		var __createBinding = (languageServer && languageServer.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (languageServer && languageServer.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		__exportStar(requireTypes(), exports$1);
		__exportStar(requireProtocol(), exports$1);
		// only export types of depend packages
		__exportStar(requireTypes$2(), exports$1);
		__exportStar(requireTypes$1(), exports$1);
		__exportStar(requireMain$2(), exports$1);
		
	} (languageServer));
	return languageServer;
}

var simpleProject = {};

var hasRequiredSimpleProject;

function requireSimpleProject () {
	if (hasRequiredSimpleProject) return simpleProject;
	hasRequiredSimpleProject = 1;
	Object.defineProperty(simpleProject, "__esModule", { value: true });
	simpleProject.createSimpleProject = createSimpleProject;
	simpleProject.createLanguageServiceEnvironment = createLanguageServiceEnvironment;
	const language_service_1 = requireLanguageService();
	function createSimpleProject(languagePlugins) {
	    let server;
	    let languageService;
	    return {
	        setup(_server) {
	            server = _server;
	            const language = (0, language_service_1.createLanguage)([
	                { getLanguageId: uri => server.documents.get(uri)?.languageId },
	                ...languagePlugins,
	            ], (0, language_service_1.createUriMap)(false), uri => {
	                const document = server.documents.get(uri);
	                if (document) {
	                    language.scripts.set(uri, document.getSnapshot(), document.languageId);
	                }
	                else {
	                    language.scripts.delete(uri);
	                }
	            });
	            languageService = (0, language_service_1.createLanguageService)(language, server.languageServicePlugins, createLanguageServiceEnvironment(server, server.workspaceFolders.all), {});
	        },
	        getLanguageService() {
	            return languageService;
	        },
	        getExistingLanguageServices() {
	            return [languageService];
	        },
	        reload() {
	            languageService.dispose();
	            this.setup(server);
	        },
	    };
	}
	function createLanguageServiceEnvironment(server, workspaceFolders) {
	    return {
	        workspaceFolders,
	        fs: server.fileSystem,
	        locale: server.initializeParams?.locale,
	        clientCapabilities: server.initializeParams?.capabilities,
	        getConfiguration: server.configurations.get,
	        onDidChangeConfiguration: server.configurations.onDidChange,
	        onDidChangeWatchedFiles: server.fileWatcher.onDidChangeWatchedFiles,
	    };
	}
	
	return simpleProject;
}

var typescriptProject = {};

var pathBrowserify;
var hasRequiredPathBrowserify;

function requirePathBrowserify () {
	if (hasRequiredPathBrowserify) return pathBrowserify;
	hasRequiredPathBrowserify = 1;

	function assertPath(path) {
	  if (typeof path !== 'string') {
	    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
	  }
	}

	// Resolves . and .. elements in a path with directory names
	function normalizeStringPosix(path, allowAboveRoot) {
	  var res = '';
	  var lastSegmentLength = 0;
	  var lastSlash = -1;
	  var dots = 0;
	  var code;
	  for (var i = 0; i <= path.length; ++i) {
	    if (i < path.length)
	      code = path.charCodeAt(i);
	    else if (code === 47 /*/*/)
	      break;
	    else
	      code = 47 /*/*/;
	    if (code === 47 /*/*/) {
	      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
	          if (res.length > 2) {
	            var lastSlashIndex = res.lastIndexOf('/');
	            if (lastSlashIndex !== res.length - 1) {
	              if (lastSlashIndex === -1) {
	                res = '';
	                lastSegmentLength = 0;
	              } else {
	                res = res.slice(0, lastSlashIndex);
	                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
	              }
	              lastSlash = i;
	              dots = 0;
	              continue;
	            }
	          } else if (res.length === 2 || res.length === 1) {
	            res = '';
	            lastSegmentLength = 0;
	            lastSlash = i;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          if (res.length > 0)
	            res += '/..';
	          else
	            res = '..';
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0)
	          res += '/' + path.slice(lastSlash + 1, i);
	        else
	          res = path.slice(lastSlash + 1, i);
	        lastSegmentLength = i - lastSlash - 1;
	      }
	      lastSlash = i;
	      dots = 0;
	    } else if (code === 46 /*.*/ && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}

	function _format(sep, pathObject) {
	  var dir = pathObject.dir || pathObject.root;
	  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
	  if (!dir) {
	    return base;
	  }
	  if (dir === pathObject.root) {
	    return dir + base;
	  }
	  return dir + sep + base;
	}

	var posix = {
	  // path.resolve([from ...], to)
	  resolve: function resolve() {
	    var resolvedPath = '';
	    var resolvedAbsolute = false;
	    var cwd;

	    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	      var path;
	      if (i >= 0)
	        path = arguments[i];
	      else {
	        if (cwd === undefined)
	          cwd = process.cwd();
	        path = cwd;
	      }

	      assertPath(path);

	      // Skip empty entries
	      if (path.length === 0) {
	        continue;
	      }

	      resolvedPath = path + '/' + resolvedPath;
	      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    }

	    // At this point the path should be resolved to a full absolute path, but
	    // handle relative paths to be safe (might happen when process.cwd() fails)

	    // Normalize the path
	    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

	    if (resolvedAbsolute) {
	      if (resolvedPath.length > 0)
	        return '/' + resolvedPath;
	      else
	        return '/';
	    } else if (resolvedPath.length > 0) {
	      return resolvedPath;
	    } else {
	      return '.';
	    }
	  },

	  normalize: function normalize(path) {
	    assertPath(path);

	    if (path.length === 0) return '.';

	    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

	    // Normalize the path
	    path = normalizeStringPosix(path, !isAbsolute);

	    if (path.length === 0 && !isAbsolute) path = '.';
	    if (path.length > 0 && trailingSeparator) path += '/';

	    if (isAbsolute) return '/' + path;
	    return path;
	  },

	  isAbsolute: function isAbsolute(path) {
	    assertPath(path);
	    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
	  },

	  join: function join() {
	    if (arguments.length === 0)
	      return '.';
	    var joined;
	    for (var i = 0; i < arguments.length; ++i) {
	      var arg = arguments[i];
	      assertPath(arg);
	      if (arg.length > 0) {
	        if (joined === undefined)
	          joined = arg;
	        else
	          joined += '/' + arg;
	      }
	    }
	    if (joined === undefined)
	      return '.';
	    return posix.normalize(joined);
	  },

	  relative: function relative(from, to) {
	    assertPath(from);
	    assertPath(to);

	    if (from === to) return '';

	    from = posix.resolve(from);
	    to = posix.resolve(to);

	    if (from === to) return '';

	    // Trim any leading backslashes
	    var fromStart = 1;
	    for (; fromStart < from.length; ++fromStart) {
	      if (from.charCodeAt(fromStart) !== 47 /*/*/)
	        break;
	    }
	    var fromEnd = from.length;
	    var fromLen = fromEnd - fromStart;

	    // Trim any leading backslashes
	    var toStart = 1;
	    for (; toStart < to.length; ++toStart) {
	      if (to.charCodeAt(toStart) !== 47 /*/*/)
	        break;
	    }
	    var toEnd = to.length;
	    var toLen = toEnd - toStart;

	    // Compare paths to find the longest common path from root
	    var length = fromLen < toLen ? fromLen : toLen;
	    var lastCommonSep = -1;
	    var i = 0;
	    for (; i <= length; ++i) {
	      if (i === length) {
	        if (toLen > length) {
	          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
	            // We get here if `from` is the exact base path for `to`.
	            // For example: from='/foo/bar'; to='/foo/bar/baz'
	            return to.slice(toStart + i + 1);
	          } else if (i === 0) {
	            // We get here if `from` is the root
	            // For example: from='/'; to='/foo'
	            return to.slice(toStart + i);
	          }
	        } else if (fromLen > length) {
	          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
	            // We get here if `to` is the exact base path for `from`.
	            // For example: from='/foo/bar/baz'; to='/foo/bar'
	            lastCommonSep = i;
	          } else if (i === 0) {
	            // We get here if `to` is the root.
	            // For example: from='/foo'; to='/'
	            lastCommonSep = 0;
	          }
	        }
	        break;
	      }
	      var fromCode = from.charCodeAt(fromStart + i);
	      var toCode = to.charCodeAt(toStart + i);
	      if (fromCode !== toCode)
	        break;
	      else if (fromCode === 47 /*/*/)
	        lastCommonSep = i;
	    }

	    var out = '';
	    // Generate the relative path based on the path difference between `to`
	    // and `from`
	    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
	      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
	        if (out.length === 0)
	          out += '..';
	        else
	          out += '/..';
	      }
	    }

	    // Lastly, append the rest of the destination (`to`) path that comes after
	    // the common path parts
	    if (out.length > 0)
	      return out + to.slice(toStart + lastCommonSep);
	    else {
	      toStart += lastCommonSep;
	      if (to.charCodeAt(toStart) === 47 /*/*/)
	        ++toStart;
	      return to.slice(toStart);
	    }
	  },

	  _makeLong: function _makeLong(path) {
	    return path;
	  },

	  dirname: function dirname(path) {
	    assertPath(path);
	    if (path.length === 0) return '.';
	    var code = path.charCodeAt(0);
	    var hasRoot = code === 47 /*/*/;
	    var end = -1;
	    var matchedSlash = true;
	    for (var i = path.length - 1; i >= 1; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          if (!matchedSlash) {
	            end = i;
	            break;
	          }
	        } else {
	        // We saw the first non-path separator
	        matchedSlash = false;
	      }
	    }

	    if (end === -1) return hasRoot ? '/' : '.';
	    if (hasRoot && end === 1) return '//';
	    return path.slice(0, end);
	  },

	  basename: function basename(path, ext) {
	    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
	    assertPath(path);

	    var start = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i;

	    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
	      if (ext.length === path.length && ext === path) return '';
	      var extIdx = ext.length - 1;
	      var firstNonSlashEnd = -1;
	      for (i = path.length - 1; i >= 0; --i) {
	        var code = path.charCodeAt(i);
	        if (code === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else {
	          if (firstNonSlashEnd === -1) {
	            // We saw the first non-path separator, remember this index in case
	            // we need it if the extension ends up not matching
	            matchedSlash = false;
	            firstNonSlashEnd = i + 1;
	          }
	          if (extIdx >= 0) {
	            // Try to match the explicit extension
	            if (code === ext.charCodeAt(extIdx)) {
	              if (--extIdx === -1) {
	                // We matched the extension, so mark this as the end of our path
	                // component
	                end = i;
	              }
	            } else {
	              // Extension does not match, so our result is the entire path
	              // component
	              extIdx = -1;
	              end = firstNonSlashEnd;
	            }
	          }
	        }
	      }

	      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
	      return path.slice(start, end);
	    } else {
	      for (i = path.length - 1; i >= 0; --i) {
	        if (path.charCodeAt(i) === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else if (end === -1) {
	          // We saw the first non-path separator, mark this as the end of our
	          // path component
	          matchedSlash = false;
	          end = i + 1;
	        }
	      }

	      if (end === -1) return '';
	      return path.slice(start, end);
	    }
	  },

	  extname: function extname(path) {
	    assertPath(path);
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;
	    for (var i = path.length - 1; i >= 0; --i) {
	      var code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1)
	            startDot = i;
	          else if (preDotState !== 1)
	            preDotState = 1;
	      } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	        // We saw a non-dot character immediately before the dot
	        preDotState === 0 ||
	        // The (right-most) trimmed path component is exactly '..'
	        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      return '';
	    }
	    return path.slice(startDot, end);
	  },

	  format: function format(pathObject) {
	    if (pathObject === null || typeof pathObject !== 'object') {
	      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
	    }
	    return _format('/', pathObject);
	  },

	  parse: function parse(path) {
	    assertPath(path);

	    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
	    if (path.length === 0) return ret;
	    var code = path.charCodeAt(0);
	    var isAbsolute = code === 47 /*/*/;
	    var start;
	    if (isAbsolute) {
	      ret.root = '/';
	      start = 1;
	    } else {
	      start = 0;
	    }
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i = path.length - 1;

	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;

	    // Get non-dir info
	    for (; i >= start; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
	        } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	    // We saw a non-dot character immediately before the dot
	    preDotState === 0 ||
	    // The (right-most) trimmed path component is exactly '..'
	    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      if (end !== -1) {
	        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
	      }
	    } else {
	      if (startPart === 0 && isAbsolute) {
	        ret.name = path.slice(1, startDot);
	        ret.base = path.slice(1, end);
	      } else {
	        ret.name = path.slice(startPart, startDot);
	        ret.base = path.slice(startPart, end);
	      }
	      ret.ext = path.slice(startDot, end);
	    }

	    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

	    return ret;
	  },

	  sep: '/',
	  delimiter: ':',
	  win32: null,
	  posix: null
	};

	posix.posix = posix;

	pathBrowserify = posix;
	return pathBrowserify;
}

var inferredCompilerOptions = {};

var hasRequiredInferredCompilerOptions;

function requireInferredCompilerOptions () {
	if (hasRequiredInferredCompilerOptions) return inferredCompilerOptions;
	hasRequiredInferredCompilerOptions = 1;
	Object.defineProperty(inferredCompilerOptions, "__esModule", { value: true });
	inferredCompilerOptions.getInferredCompilerOptions = getInferredCompilerOptions;
	async function getInferredCompilerOptions(server) {
	    const [implicitProjectConfig_1 = {}, implicitProjectConfig_2 = {},] = await Promise.all([
	        server.configurations.get('js/ts.implicitProjectConfig'),
	        server.configurations.get('javascript.implicitProjectConfig'),
	    ]);
	    const checkJs = readCheckJs();
	    const experimentalDecorators = readExperimentalDecorators();
	    const strictNullChecks = readImplicitStrictNullChecks();
	    const strictFunctionTypes = readImplicitStrictFunctionTypes();
	    const options = {
	        ...inferredProjectCompilerOptions(),
	        allowJs: true,
	        allowSyntheticDefaultImports: true,
	        allowNonTsExtensions: true,
	        resolveJsonModule: true,
	        jsx: 1,
	    };
	    return options;
	    function readCheckJs() {
	        return implicitProjectConfig_1['checkJs']
	            ?? implicitProjectConfig_2['checkJs']
	            ?? false;
	    }
	    function readExperimentalDecorators() {
	        return implicitProjectConfig_1['experimentalDecorators']
	            ?? implicitProjectConfig_2['experimentalDecorators']
	            ?? false;
	    }
	    function readImplicitStrictNullChecks() {
	        return implicitProjectConfig_1['strictNullChecks'] ?? false;
	    }
	    function readImplicitStrictFunctionTypes() {
	        return implicitProjectConfig_1['strictFunctionTypes'] ?? true;
	    }
	    function inferredProjectCompilerOptions(projectType) {
	        const projectConfig = {
	            module: 1,
	            target: 7,
	            jsx: 1,
	        };
	        if (checkJs) {
	            projectConfig.checkJs = true;
	            {
	                projectConfig.allowJs = true;
	            }
	        }
	        if (experimentalDecorators) {
	            projectConfig.experimentalDecorators = true;
	        }
	        if (strictNullChecks) {
	            projectConfig.strictNullChecks = true;
	        }
	        if (strictFunctionTypes) {
	            projectConfig.strictFunctionTypes = true;
	        }
	        {
	            projectConfig.sourceMap = true;
	        }
	        return projectConfig;
	    }
	}
	
	return inferredCompilerOptions;
}

var typescriptProjectLs = {};

var typescript = {};

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	Object.defineProperty(common$1, "__esModule", { value: true });
	common$1.resolveFileLanguageId = resolveFileLanguageId;
	function resolveFileLanguageId(path) {
	    const ext = path.split('.').pop();
	    switch (ext) {
	        case 'js':
	            return 'javascript';
	        case 'cjs':
	            return 'javascript';
	        case 'mjs':
	            return 'javascript';
	        case 'ts':
	            return 'typescript';
	        case 'cts':
	            return 'typescript';
	        case 'mts':
	            return 'typescript';
	        case 'jsx':
	            return 'javascriptreact';
	        case 'tsx':
	            return 'typescriptreact';
	        case 'json':
	            return 'json';
	    }
	}
	
	return common$1;
}

var decorateLanguageServiceHost = {};

var resolveModuleName = {};

var hasRequiredResolveModuleName;

function requireResolveModuleName () {
	if (hasRequiredResolveModuleName) return resolveModuleName;
	hasRequiredResolveModuleName = 1;
	Object.defineProperty(resolveModuleName, "__esModule", { value: true });
	resolveModuleName.createResolveModuleName = createResolveModuleName;
	function createResolveModuleName(ts, getFileSize, host, languagePlugins, getSourceScript) {
	    const toSourceFileInfo = new Map();
	    const moduleResolutionHost = {
	        readFile: host.readFile.bind(host),
	        directoryExists: host.directoryExists?.bind(host),
	        realpath: host.realpath?.bind(host),
	        getCurrentDirectory: host.getCurrentDirectory?.bind(host),
	        getDirectories: host.getDirectories?.bind(host),
	        useCaseSensitiveFileNames: typeof host.useCaseSensitiveFileNames === 'function'
	            ? host.useCaseSensitiveFileNames.bind(host)
	            : host.useCaseSensitiveFileNames,
	        fileExists(fileName) {
	            const result = host.fileExists(fileName);
	            for (const { typescript } of languagePlugins) {
	                if (!typescript) {
	                    continue;
	                }
	                if (!result) {
	                    for (const { extension } of typescript.extraFileExtensions) {
	                        if (!fileName.endsWith(`.d.${extension}.ts`)) {
	                            continue;
	                        }
	                        const sourceFileName = fileName.slice(0, -`.d.${extension}.ts`.length) + `.${extension}`;
	                        if (fileExists(sourceFileName)) {
	                            const sourceScript = getSourceScript(sourceFileName);
	                            if (sourceScript?.generated) {
	                                const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	                                if (serviceScript) {
	                                    const dtsPath = sourceFileName + '.d.ts';
	                                    if ((serviceScript.extension === '.js' || serviceScript.extension === '.jsx') && fileExists(dtsPath)) {
	                                        toSourceFileInfo.set(fileName, {
	                                            sourceFileName: dtsPath,
	                                            extension: '.ts',
	                                        });
	                                    }
	                                    else {
	                                        toSourceFileInfo.set(fileName, {
	                                            sourceFileName,
	                                            extension: serviceScript.extension,
	                                        });
	                                    }
	                                    return true;
	                                }
	                            }
	                        }
	                    }
	                }
	                if (typescript.resolveHiddenExtensions && fileName.endsWith(`.d.ts`)) {
	                    for (const { extension } of typescript.extraFileExtensions) {
	                        const sourceFileName = fileName.slice(0, -`.d.ts`.length) + `.${extension}`;
	                        if (fileExists(sourceFileName)) {
	                            const sourceScript = getSourceScript(sourceFileName);
	                            if (sourceScript?.generated) {
	                                const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	                                if (serviceScript) {
	                                    toSourceFileInfo.set(fileName, {
	                                        sourceFileName,
	                                        extension: serviceScript.extension,
	                                    });
	                                    return true;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return result;
	        },
	    };
	    return (moduleName, containingFile, compilerOptions, cache, redirectedReference, resolutionMode) => {
	        const result = ts.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost, cache, redirectedReference, resolutionMode);
	        if (result.resolvedModule) {
	            const sourceFileInfo = toSourceFileInfo.get(result.resolvedModule.resolvedFileName);
	            if (sourceFileInfo) {
	                result.resolvedModule.resolvedFileName = sourceFileInfo.sourceFileName;
	                result.resolvedModule.extension = sourceFileInfo.extension;
	            }
	        }
	        toSourceFileInfo.clear();
	        return result;
	    };
	    // fix https://github.com/vuejs/language-tools/issues/3332
	    function fileExists(fileName) {
	        if (host.fileExists(fileName)) {
	            const fileSize = getFileSize?.(fileName) ?? host.readFile(fileName)?.length ?? 0;
	            return fileSize < 4 * 1024 * 1024;
	        }
	        return false;
	    }
	}
	
	return resolveModuleName;
}

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.getServiceScript = getServiceScript;
	utils.fixupImpliedNodeFormatForFile = fixupImpliedNodeFormatForFile;
	function getServiceScript(language, fileName) {
	    const sourceScript = language.scripts.get(fileName);
	    if (sourceScript?.targetIds.size) {
	        for (const targetId of sourceScript.targetIds) {
	            const targetScript = language.scripts.get(targetId);
	            if (targetScript?.generated) {
	                const serviceScript = targetScript.generated.languagePlugin.typescript?.getServiceScript(targetScript.generated.root);
	                if (serviceScript) {
	                    return [serviceScript, targetScript, sourceScript];
	                }
	            }
	        }
	    }
	    if (sourceScript?.associatedOnly) {
	        return [undefined, sourceScript, sourceScript];
	    }
	    if (sourceScript?.generated) {
	        const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	        if (serviceScript) {
	            return [serviceScript, sourceScript, sourceScript];
	        }
	    }
	    return [undefined, undefined, undefined];
	}
	function fixupImpliedNodeFormatForFile(ts, pluginExtensions, sourceFile, packageJsonInfoCache, host, options) {
	    if (sourceFile.impliedNodeFormat !== undefined || !pluginExtensions.some(ext => sourceFile.fileName.endsWith(ext))) {
	        return;
	    }
	    // https://github.com/microsoft/TypeScript/blob/669c25c091ad4d32298d0f33b0e4e681d46de3ea/src/compiler/program.ts#L1354
	    const validExts = ['.d.ts', '.ts', '.tsx', '.js', '.jsx'];
	    if (validExts.some(ext => sourceFile.fileName.endsWith(ext))) {
	        return;
	    }
	    const asTs = sourceFile.fileName + '.ts';
	    // Use getImpliedNodeFormatForFileWorker instead of getImpliedNodeFormatForFile for runTsc() compatibility
	    const impliedNodeFormat = ts.getImpliedNodeFormatForFileWorker?.(asTs, packageJsonInfoCache, host, options)?.impliedNodeFormat;
	    if (impliedNodeFormat === undefined) {
	        return;
	    }
	    sourceFile.impliedNodeFormat = impliedNodeFormat;
	    return () => sourceFile.impliedNodeFormat = undefined;
	}
	
	return utils;
}

var hasRequiredDecorateLanguageServiceHost;

function requireDecorateLanguageServiceHost () {
	if (hasRequiredDecorateLanguageServiceHost) return decorateLanguageServiceHost;
	hasRequiredDecorateLanguageServiceHost = 1;
	Object.defineProperty(decorateLanguageServiceHost, "__esModule", { value: true });
	decorateLanguageServiceHost.decorateLanguageServiceHost = decorateLanguageServiceHost$1;
	decorateLanguageServiceHost.searchExternalFiles = searchExternalFiles;
	const resolveModuleName_1 = requireResolveModuleName();
	const utils_1 = requireUtils();
	function decorateLanguageServiceHost$1(ts, language, languageServiceHost) {
	    const pluginExtensions = language.plugins
	        .map(plugin => plugin.typescript?.extraFileExtensions.map(ext => '.' + ext.extension) ?? [])
	        .flat();
	    const scripts = new Map();
	    const crashFileNames = new Set();
	    const readDirectory = languageServiceHost.readDirectory?.bind(languageServiceHost);
	    const resolveModuleNameLiterals = languageServiceHost.resolveModuleNameLiterals?.bind(languageServiceHost);
	    const resolveModuleNames = languageServiceHost.resolveModuleNames?.bind(languageServiceHost);
	    const getScriptSnapshot = languageServiceHost.getScriptSnapshot.bind(languageServiceHost);
	    const getScriptKind = languageServiceHost.getScriptKind?.bind(languageServiceHost);
	    // path completion
	    if (readDirectory) {
	        languageServiceHost.readDirectory = (path, extensions, exclude, include, depth) => {
	            if (extensions) {
	                for (const ext of pluginExtensions) {
	                    if (!extensions.includes(ext)) {
	                        extensions = [...extensions, ext];
	                    }
	                }
	            }
	            return readDirectory(path, extensions, exclude, include, depth);
	        };
	    }
	    if (pluginExtensions.length) {
	        const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, ts.sys.getFileSize, languageServiceHost, language.plugins, fileName => language.scripts.get(fileName));
	        const getCanonicalFileName = languageServiceHost.useCaseSensitiveFileNames?.()
	            ? (fileName) => fileName
	            : (fileName) => fileName.toLowerCase();
	        const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), getCanonicalFileName, languageServiceHost.getCompilationSettings());
	        if (resolveModuleNameLiterals) {
	            languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest) => {
	                const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), languageServiceHost, options);
	                try {
	                    if (moduleLiterals.every(name => !pluginExtensions.some(ext => name.text.endsWith(ext)))) {
	                        return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, ...rest);
	                    }
	                    return moduleLiterals.map(moduleLiteral => {
	                        const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, options);
	                        return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference, mode);
	                    });
	                }
	                finally {
	                    disposeFixup?.();
	                }
	            };
	        }
	        if (resolveModuleNames) {
	            languageServiceHost.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile) => {
	                if (moduleNames.every(name => !pluginExtensions.some(ext => name.endsWith(ext)))) {
	                    return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile);
	                }
	                return moduleNames.map(moduleName => {
	                    return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference)
	                        .resolvedModule;
	                });
	            };
	        }
	    }
	    languageServiceHost.getScriptSnapshot = fileName => {
	        const virtualScript = updateVirtualScript(fileName, true);
	        if (virtualScript) {
	            return virtualScript.snapshot;
	        }
	        return getScriptSnapshot(fileName);
	    };
	    if (getScriptKind) {
	        languageServiceHost.getScriptKind = fileName => {
	            const virtualScript = updateVirtualScript(fileName, false);
	            if (virtualScript) {
	                return virtualScript.scriptKind;
	            }
	            return getScriptKind(fileName);
	        };
	    }
	    function updateVirtualScript(fileName, shouldRegister) {
	        if (crashFileNames.has(fileName)) {
	            return;
	        }
	        let version;
	        try {
	            version = languageServiceHost.getScriptVersion(fileName);
	        }
	        catch {
	            // fix https://github.com/vuejs/language-tools/issues/4278
	            crashFileNames.add(fileName);
	        }
	        if (version === undefined) {
	            // somehow getScriptVersion returns undefined
	            return;
	        }
	        let script = scripts.get(fileName);
	        if (!script || script[0] !== version) {
	            script = [version];
	            const sourceScript = language.scripts.get(fileName, undefined, shouldRegister);
	            if (sourceScript?.generated) {
	                const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	                if (serviceScript) {
	                    if (serviceScript.preventLeadingOffset) {
	                        script[1] = {
	                            extension: serviceScript.extension,
	                            scriptKind: serviceScript.scriptKind,
	                            snapshot: serviceScript.code.snapshot,
	                        };
	                    }
	                    else {
	                        const sourceContents = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength());
	                        const virtualContents = sourceContents.split('\n').map(line => ' '.repeat(line.length)).join('\n')
	                            + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
	                        script[1] = {
	                            extension: serviceScript.extension,
	                            scriptKind: serviceScript.scriptKind,
	                            snapshot: ts.ScriptSnapshot.fromString(virtualContents),
	                        };
	                    }
	                }
	                if (sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts) {
	                    console.warn('getExtraServiceScripts() is not available in TS plugin.');
	                }
	            }
	            scripts.set(fileName, script);
	        }
	        return script[1];
	    }
	}
	function searchExternalFiles(ts, project, exts) {
	    if (project.projectKind !== ts.server.ProjectKind.Configured) {
	        return [];
	    }
	    const configFile = project.getProjectName();
	    const config = ts.readJsonConfigFile(configFile, project.readFile.bind(project));
	    const parseHost = {
	        useCaseSensitiveFileNames: project.useCaseSensitiveFileNames(),
	        fileExists: project.fileExists.bind(project),
	        readFile: project.readFile.bind(project),
	        readDirectory: (...args) => {
	            args[1] = exts;
	            return project.readDirectory(...args);
	        },
	    };
	    const parsed = ts.parseJsonSourceFileConfigFileContent(config, parseHost, project.getCurrentDirectory());
	    return parsed.fileNames;
	}
	
	return decorateLanguageServiceHost;
}

var decorateProgram = {};

var transform = {};

var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return transform;
	hasRequiredTransform = 1;
	Object.defineProperty(transform, "__esModule", { value: true });
	transform.transformCallHierarchyItem = transformCallHierarchyItem;
	transform.transformDiagnostic = transformDiagnostic;
	transform.fillSourceFileText = fillSourceFileText;
	transform.transformFileTextChanges = transformFileTextChanges;
	transform.transformDocumentSpan = transformDocumentSpan;
	transform.transformSpan = transformSpan;
	transform.transformTextChange = transformTextChange;
	transform.transformTextSpan = transformTextSpan;
	transform.toSourceOffset = toSourceOffset;
	transform.toSourceRanges = toSourceRanges;
	transform.toSourceOffsets = toSourceOffsets;
	transform.toGeneratedRange = toGeneratedRange;
	transform.toGeneratedRanges = toGeneratedRanges;
	transform.toGeneratedOffset = toGeneratedOffset;
	transform.toGeneratedOffsets = toGeneratedOffsets;
	transform.getMappingOffset = getMappingOffset;
	const language_core_1 = requireLanguageCore();
	const utils_1 = requireUtils();
	const transformedDiagnostics = new WeakMap();
	const transformedSourceFile = new WeakSet();
	/**
	 * This file contains a number of facilities for transforming `ts.Diagnostic`s returned
	 * from the  base TypeScript LanguageService, which reference locations in generated
	 * TS code (e.g. the TypeScript codegen'd from the script portion of a .vue file) into locations
	 * in the script portion of the .vue file.
	 */
	function transformCallHierarchyItem(language, item, fallbackToAnyMatch, filter) {
	    const span = transformSpan(language, item.file, item.span, fallbackToAnyMatch, filter);
	    const selectionSpan = transformSpan(language, item.file, item.selectionSpan, fallbackToAnyMatch, filter);
	    return {
	        ...item,
	        file: span?.fileName ?? item.file,
	        span: span?.textSpan ?? { start: 0, length: 0 },
	        selectionSpan: selectionSpan?.textSpan ?? { start: 0, length: 0 },
	    };
	}
	function transformDiagnostic(language, diagnostic, program, isTsc) {
	    if (!transformedDiagnostics.has(diagnostic)) {
	        transformedDiagnostics.set(diagnostic, undefined);
	        const { relatedInformation } = diagnostic;
	        if (relatedInformation) {
	            diagnostic.relatedInformation = relatedInformation
	                .map(d => transformDiagnostic(language, d, program, isTsc))
	                .filter(d => !!d);
	        }
	        if (diagnostic.file !== undefined
	            && diagnostic.start !== undefined
	            && diagnostic.length !== undefined) {
	            const [serviceScript] = (0, utils_1.getServiceScript)(language, diagnostic.file.fileName);
	            if (serviceScript) {
	                const [sourceSpanFileName, sourceSpan] = transformTextSpan(undefined, language, serviceScript, {
	                    start: diagnostic.start,
	                    length: diagnostic.length,
	                }, true, data => (0, language_core_1.shouldReportDiagnostics)(data, String(diagnostic.source), String(diagnostic.code))) ?? [];
	                const actualDiagnosticFile = sourceSpanFileName
	                    ? diagnostic.file.fileName === sourceSpanFileName
	                        ? diagnostic.file
	                        : program?.getSourceFile(sourceSpanFileName)
	                    : undefined;
	                if (sourceSpan && actualDiagnosticFile) {
	                    if (isTsc) {
	                        fillSourceFileText(language, diagnostic.file);
	                    }
	                    transformedDiagnostics.set(diagnostic, {
	                        ...diagnostic,
	                        file: actualDiagnosticFile,
	                        start: sourceSpan.start,
	                        length: sourceSpan.length,
	                    });
	                }
	            }
	            else {
	                transformedDiagnostics.set(diagnostic, diagnostic);
	            }
	        }
	        else {
	            transformedDiagnostics.set(diagnostic, diagnostic);
	        }
	    }
	    return transformedDiagnostics.get(diagnostic);
	}
	// fix https://github.com/vuejs/language-tools/issues/4099 without `incremental`
	function fillSourceFileText(language, sourceFile) {
	    if (transformedSourceFile.has(sourceFile)) {
	        return;
	    }
	    transformedSourceFile.add(sourceFile);
	    const [serviceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
	    if (serviceScript && !serviceScript.preventLeadingOffset) {
	        const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
	        sourceFile.text = sourceScript.snapshot.getText(0, sourceScript.snapshot.getLength())
	            + sourceFile.text.substring(sourceScript.snapshot.getLength());
	    }
	}
	function transformFileTextChanges(language, changes, fallbackToAnyMatch, filter) {
	    const changesPerFile = {};
	    const newFiles = new Set();
	    for (const fileChanges of changes) {
	        const [_, source] = (0, utils_1.getServiceScript)(language, fileChanges.fileName);
	        if (source) {
	            fileChanges.textChanges.forEach(c => {
	                const { fileName, textSpan } = transformSpan(language, fileChanges.fileName, c.span, fallbackToAnyMatch, filter)
	                    ?? {};
	                if (fileName && textSpan) {
	                    (changesPerFile[fileName] ?? (changesPerFile[fileName] = [])).push({ ...c, span: textSpan });
	                }
	            });
	        }
	        else {
	            const list = changesPerFile[fileChanges.fileName] ?? (changesPerFile[fileChanges.fileName] = []);
	            fileChanges.textChanges.forEach(c => {
	                list.push(c);
	            });
	            if (fileChanges.isNewFile) {
	                newFiles.add(fileChanges.fileName);
	            }
	        }
	    }
	    const result = [];
	    for (const fileName in changesPerFile) {
	        result.push({
	            fileName,
	            isNewFile: newFiles.has(fileName),
	            textChanges: changesPerFile[fileName],
	        });
	    }
	    return result;
	}
	function transformDocumentSpan(language, documentSpan, fallbackToAnyMatch, filter, shouldFallback) {
	    let textSpan = transformSpan(language, documentSpan.fileName, documentSpan.textSpan, fallbackToAnyMatch, filter);
	    if (!textSpan && shouldFallback) {
	        textSpan = {
	            fileName: documentSpan.fileName,
	            textSpan: { start: 0, length: 0 },
	        };
	    }
	    if (!textSpan) {
	        return;
	    }
	    const contextSpan = transformSpan(language, documentSpan.fileName, documentSpan.contextSpan, fallbackToAnyMatch, filter);
	    const originalTextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalTextSpan, fallbackToAnyMatch, filter);
	    const originalContextSpan = transformSpan(language, documentSpan.originalFileName, documentSpan.originalContextSpan, fallbackToAnyMatch, filter);
	    return {
	        ...documentSpan,
	        fileName: textSpan.fileName,
	        textSpan: textSpan.textSpan,
	        contextSpan: contextSpan?.textSpan,
	        originalFileName: originalTextSpan?.fileName,
	        originalTextSpan: originalTextSpan?.textSpan,
	        originalContextSpan: originalContextSpan?.textSpan,
	    };
	}
	function transformSpan(language, fileName, textSpan, fallbackToAnyMatch, filter) {
	    if (!fileName || !textSpan) {
	        return;
	    }
	    const [serviceScript] = (0, utils_1.getServiceScript)(language, fileName);
	    if (serviceScript) {
	        const [sourceSpanFileName, sourceSpan] = transformTextSpan(undefined, language, serviceScript, textSpan, fallbackToAnyMatch, filter) ?? [];
	        if (sourceSpan && sourceSpanFileName) {
	            return {
	                fileName: sourceSpanFileName,
	                textSpan: sourceSpan,
	            };
	        }
	    }
	    else {
	        return {
	            fileName,
	            textSpan,
	        };
	    }
	}
	function transformTextChange(sourceScript, language, serviceScript, textChange, fallbackToAnyMatch, filter) {
	    const [sourceSpanFileName, sourceSpan] = transformTextSpan(sourceScript, language, serviceScript, textChange.span, fallbackToAnyMatch, filter) ?? [];
	    if (sourceSpan && sourceSpanFileName) {
	        return [sourceSpanFileName, {
	                newText: textChange.newText,
	                span: sourceSpan,
	            }];
	    }
	    return undefined;
	}
	function transformTextSpan(sourceScript, language, serviceScript, textSpan, fallbackToAnyMatch, filter) {
	    const start = textSpan.start;
	    const end = textSpan.start + textSpan.length;
	    for (const [fileName, sourceStart, sourceEnd] of toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter)) {
	        return [fileName, {
	                start: sourceStart,
	                length: sourceEnd - sourceStart,
	            }];
	    }
	}
	function toSourceOffset(sourceScript, language, serviceScript, position, filter) {
	    for (const source of toSourceOffsets(sourceScript, language, serviceScript, position, filter)) {
	        return source;
	    }
	}
	function* toSourceRanges(sourceScript, language, serviceScript, start, end, fallbackToAnyMatch, filter) {
	    if (sourceScript) {
	        const map = language.maps.get(serviceScript.code, sourceScript);
	        for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) {
	            yield [sourceScript.id, sourceStart, sourceEnd];
	        }
	    }
	    else {
	        for (const [sourceScript, map] of language.maps.forEach(serviceScript.code)) {
	            for (const [sourceStart, sourceEnd] of map.toSourceRange(start - getMappingOffset(language, serviceScript), end - getMappingOffset(language, serviceScript), fallbackToAnyMatch, filter)) {
	                yield [sourceScript.id, sourceStart, sourceEnd];
	            }
	        }
	    }
	}
	function* toSourceOffsets(sourceScript, language, serviceScript, position, filter) {
	    if (sourceScript) {
	        const map = language.maps.get(serviceScript.code, sourceScript);
	        for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) {
	            if (filter(mapping.data)) {
	                yield [sourceScript.id, sourceOffset];
	            }
	        }
	    }
	    else {
	        for (const [sourceScript, map] of language.maps.forEach(serviceScript.code)) {
	            for (const [sourceOffset, mapping] of map.toSourceLocation(position - getMappingOffset(language, serviceScript))) {
	                if (filter(mapping.data)) {
	                    yield [sourceScript.id, sourceOffset];
	                }
	            }
	        }
	    }
	}
	function toGeneratedRange(language, serviceScript, sourceScript, start, end, filter) {
	    for (const result of toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter)) {
	        return result;
	    }
	}
	function* toGeneratedRanges(language, serviceScript, sourceScript, start, end, filter) {
	    const map = language.maps.get(serviceScript.code, sourceScript);
	    for (const [generateStart, generateEnd] of map.toGeneratedRange(start, end, true, filter)) {
	        yield [
	            generateStart + getMappingOffset(language, serviceScript),
	            generateEnd + getMappingOffset(language, serviceScript),
	        ];
	    }
	}
	function toGeneratedOffset(language, serviceScript, sourceScript, position, filter) {
	    for (const [generateOffset] of toGeneratedOffsets(language, serviceScript, sourceScript, position, filter)) {
	        return generateOffset;
	    }
	}
	function* toGeneratedOffsets(language, serviceScript, sourceScript, position, filter) {
	    const map = language.maps.get(serviceScript.code, sourceScript);
	    for (const [generateOffset, mapping] of map.toGeneratedLocation(position)) {
	        if (filter(mapping.data)) {
	            yield [generateOffset + getMappingOffset(language, serviceScript), mapping];
	        }
	    }
	}
	function getMappingOffset(language, serviceScript) {
	    if (serviceScript.preventLeadingOffset) {
	        return 0;
	    }
	    const sourceScript = language.scripts.fromVirtualCode(serviceScript.code);
	    return sourceScript.snapshot.getLength();
	}
	
	return transform;
}

var hasRequiredDecorateProgram;

function requireDecorateProgram () {
	if (hasRequiredDecorateProgram) return decorateProgram;
	hasRequiredDecorateProgram = 1;
	Object.defineProperty(decorateProgram, "__esModule", { value: true });
	decorateProgram.decorateProgram = decorateProgram$1;
	const transform_1 = requireTransform();
	const utils_1 = requireUtils();
	function decorateProgram$1(language, program) {
	    const emit = program.emit;
	    // for tsc --noEmit
	    const getSyntacticDiagnostics = program.getSyntacticDiagnostics;
	    const getSemanticDiagnostics = program.getSemanticDiagnostics;
	    const getGlobalDiagnostics = program.getGlobalDiagnostics;
	    const getSourceFileByPath = program.getSourceFileByPath;
	    // for tsc --noEmit --watch
	    // @ts-ignore
	    const getBindAndCheckDiagnostics = program.getBindAndCheckDiagnostics;
	    program.emit = (...args) => {
	        const result = emit(...args);
	        return {
	            ...result,
	            diagnostics: result.diagnostics
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d),
	        };
	    };
	    program.getSyntacticDiagnostics = (sourceFile, cancellationToken) => {
	        if (!sourceFile) {
	            return getSyntacticDiagnostics(undefined, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d);
	        }
	        else {
	            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
	            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
	            return getSyntacticDiagnostics(actualSourceFile, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d)
	                .filter(d => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
	        }
	    };
	    program.getSemanticDiagnostics = (sourceFile, cancellationToken) => {
	        if (!sourceFile) {
	            return getSemanticDiagnostics(undefined, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d);
	        }
	        else {
	            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
	            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
	            return getSemanticDiagnostics(actualSourceFile, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d)
	                .filter(d => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
	        }
	    };
	    program.getGlobalDiagnostics = cancellationToken => {
	        return getGlobalDiagnostics(cancellationToken)
	            .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	            .filter(d => !!d);
	    };
	    // @ts-ignore
	    program.getBindAndCheckDiagnostics = (sourceFile, cancellationToken) => {
	        if (!sourceFile) {
	            return getBindAndCheckDiagnostics(undefined, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d);
	        }
	        else {
	            const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
	            const actualSourceFile = targetScript ? program.getSourceFile(targetScript.id) : sourceFile;
	            return getBindAndCheckDiagnostics(actualSourceFile, cancellationToken)
	                .map(d => (0, transform_1.transformDiagnostic)(language, d, program, true))
	                .filter(d => !!d)
	                .filter(d => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
	        }
	    };
	    // fix https://github.com/vuejs/language-tools/issues/4099 with `incremental`
	    program.getSourceFileByPath = path => {
	        const sourceFile = getSourceFileByPath(path);
	        if (sourceFile) {
	            (0, transform_1.fillSourceFileText)(language, sourceFile);
	        }
	        return sourceFile;
	    };
	}
	
	return decorateProgram;
}

var proxyCreateProgram = {};

var hasRequiredProxyCreateProgram;

function requireProxyCreateProgram () {
	if (hasRequiredProxyCreateProgram) return proxyCreateProgram;
	hasRequiredProxyCreateProgram = 1;
	Object.defineProperty(proxyCreateProgram, "__esModule", { value: true });
	proxyCreateProgram.proxyCreateProgram = proxyCreateProgram$1;
	const language_core_1 = requireLanguageCore();
	const common_1 = requireCommon$1();
	const resolveModuleName_1 = requireResolveModuleName();
	const decorateProgram_1 = requireDecorateProgram();
	const utils_1 = requireUtils();
	const arrayEqual = (a, b) => {
	    if (a.length !== b.length) {
	        return false;
	    }
	    for (let i = 0; i < a.length; i++) {
	        if (a[i] !== b[i]) {
	            return false;
	        }
	    }
	    return true;
	};
	const objectEqual = (a, b) => {
	    const keysA = Object.keys(a);
	    const keysB = Object.keys(b);
	    if (keysA.length !== keysB.length) {
	        return false;
	    }
	    for (const key of keysA) {
	        if (a[key] !== b[key]) {
	            return false;
	        }
	    }
	    return true;
	};
	function proxyCreateProgram$1(ts, original, create) {
	    const sourceFileSnapshots = new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames);
	    const parsedSourceFiles = new WeakMap();
	    let lastOptions;
	    let languagePlugins;
	    let language;
	    let moduleResolutionCache;
	    return new Proxy(original, {
	        apply: (target, thisArg, args) => {
	            const options = args[0];
	            assert(!!options.host, '!!options.host');
	            if (!lastOptions
	                || !languagePlugins
	                || !language
	                || !arrayEqual(options.rootNames, lastOptions.rootNames)
	                || !objectEqual(options.options, lastOptions.options)) {
	                moduleResolutionCache = ts.createModuleResolutionCache(options.host.getCurrentDirectory(), options.host.getCanonicalFileName, options.options);
	                lastOptions = options;
	                const created = create(ts, options);
	                if (Array.isArray(created)) {
	                    languagePlugins = created;
	                }
	                else {
	                    languagePlugins = created.languagePlugins;
	                }
	                language = (0, language_core_1.createLanguage)([
	                    ...languagePlugins,
	                    { getLanguageId: common_1.resolveFileLanguageId },
	                ], new language_core_1.FileMap(ts.sys.useCaseSensitiveFileNames), (fileName, includeFsFiles) => {
	                    if (includeFsFiles && !sourceFileSnapshots.has(fileName)) {
	                        const sourceFileText = originalHost.readFile(fileName);
	                        if (sourceFileText !== undefined) {
	                            sourceFileSnapshots.set(fileName, [undefined, {
	                                    getChangeRange() {
	                                        return undefined;
	                                    },
	                                    getLength() {
	                                        return sourceFileText.length;
	                                    },
	                                    getText(start, end) {
	                                        return sourceFileText.substring(start, end);
	                                    },
	                                }]);
	                        }
	                        else {
	                            sourceFileSnapshots.set(fileName, [undefined, undefined]);
	                        }
	                    }
	                    const snapshot = sourceFileSnapshots.get(fileName)?.[1];
	                    if (snapshot) {
	                        language.scripts.set(fileName, snapshot);
	                    }
	                    else {
	                        language.scripts.delete(fileName);
	                    }
	                });
	                if ('setup' in created) {
	                    created.setup?.(language);
	                }
	            }
	            const originalHost = options.host;
	            const pluginExtensions = languagePlugins
	                .map(plugin => plugin.typescript?.extraFileExtensions.map(({ extension }) => `.${extension}`) ?? [])
	                .flat();
	            options.host = { ...originalHost };
	            options.host.getSourceFile = (fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile) => {
	                const originalSourceFile = originalHost.getSourceFile(fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile);
	                if (!sourceFileSnapshots.has(fileName)
	                    || sourceFileSnapshots.get(fileName)?.[0] !== originalSourceFile) {
	                    if (originalSourceFile) {
	                        sourceFileSnapshots.set(fileName, [originalSourceFile, {
	                                getChangeRange() {
	                                    return undefined;
	                                },
	                                getLength() {
	                                    return originalSourceFile.text.length;
	                                },
	                                getText(start, end) {
	                                    return originalSourceFile.text.substring(start, end);
	                                },
	                            }]);
	                    }
	                    else {
	                        sourceFileSnapshots.set(fileName, [undefined, undefined]);
	                    }
	                }
	                if (!originalSourceFile) {
	                    return;
	                }
	                if (!parsedSourceFiles.has(originalSourceFile)) {
	                    const sourceScript = language.scripts.get(fileName);
	                    assert(!!sourceScript, '!!sourceScript');
	                    parsedSourceFiles.set(originalSourceFile, undefined);
	                    if (sourceScript.generated?.languagePlugin.typescript) {
	                        const { getServiceScript, getExtraServiceScripts } = sourceScript.generated.languagePlugin.typescript;
	                        const serviceScript = getServiceScript(sourceScript.generated.root);
	                        if (serviceScript) {
	                            let virtualContents;
	                            if (!serviceScript.preventLeadingOffset) {
	                                virtualContents = originalSourceFile.text.split('\n').map(line => ' '.repeat(line.length)).join('\n')
	                                    + serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
	                            }
	                            else {
	                                virtualContents = serviceScript.code.snapshot.getText(0, serviceScript.code.snapshot.getLength());
	                            }
	                            const parsedSourceFile = ts.createSourceFile(fileName, virtualContents, languageVersionOrOptions, undefined, serviceScript.scriptKind);
	                            // @ts-expect-error
	                            parsedSourceFile.version = originalSourceFile.version;
	                            parsedSourceFiles.set(originalSourceFile, parsedSourceFile);
	                        }
	                        if (getExtraServiceScripts) {
	                            console.warn('getExtraServiceScripts() is not available in this use case.');
	                        }
	                    }
	                }
	                return parsedSourceFiles.get(originalSourceFile) ?? originalSourceFile;
	            };
	            if (pluginExtensions.length) {
	                options.options.allowArbitraryExtensions = true;
	                const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, ts.sys.getFileSize, originalHost, language.plugins, fileName => language.scripts.get(fileName));
	                const resolveModuleNameLiterals = originalHost.resolveModuleNameLiterals;
	                const resolveModuleNames = originalHost.resolveModuleNames;
	                options.host.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, compilerOptions, containingSourceFile, ...rest) => {
	                    const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), originalHost, compilerOptions);
	                    try {
	                        if (resolveModuleNameLiterals
	                            && moduleLiterals.every(name => !pluginExtensions.some(ext => name.text.endsWith(ext)))) {
	                            return resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, compilerOptions, containingSourceFile, ...rest);
	                        }
	                        return moduleLiterals.map(moduleLiteral => {
	                            const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, compilerOptions);
	                            return resolveModuleName(moduleLiteral.text, containingFile, compilerOptions, moduleResolutionCache, redirectedReference, mode);
	                        });
	                    }
	                    finally {
	                        disposeFixup?.();
	                    }
	                };
	                options.host.resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile) => {
	                    if (resolveModuleNames && moduleNames.every(name => !pluginExtensions.some(ext => name.endsWith(ext)))) {
	                        return resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, compilerOptions, containingSourceFile);
	                    }
	                    return moduleNames.map(moduleName => {
	                        return resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionCache, redirectedReference, containingSourceFile?.impliedNodeFormat).resolvedModule;
	                    });
	                };
	            }
	            const program = Reflect.apply(target, thisArg, args);
	            (0, decorateProgram_1.decorateProgram)(language, program);
	            return program;
	        },
	    });
	}
	function assert(condition, message) {
	    if (!condition) {
	        console.error(message);
	        throw new Error(message);
	    }
	}
	
	return proxyCreateProgram;
}

var proxyLanguageService = {};

var dedupe = {};

var hasRequiredDedupe;

function requireDedupe () {
	if (hasRequiredDedupe) return dedupe;
	hasRequiredDedupe = 1;
	Object.defineProperty(dedupe, "__esModule", { value: true });
	dedupe.dedupeDocumentSpans = dedupeDocumentSpans;
	function dedupeDocumentSpans(items) {
	    return dedupe$1(items, item => [
	        item.fileName,
	        item.textSpan.start,
	        item.textSpan.length,
	    ].join(':'));
	}
	function dedupe$1(items, getKey) {
	    const map = new Map();
	    for (const item of items.reverse()) {
	        map.set(getKey(item), item);
	    }
	    return [...map.values()];
	}
	
	return dedupe;
}

var hasRequiredProxyLanguageService;

function requireProxyLanguageService () {
	if (hasRequiredProxyLanguageService) return proxyLanguageService;
	hasRequiredProxyLanguageService = 1;
	Object.defineProperty(proxyLanguageService, "__esModule", { value: true });
	proxyLanguageService.createProxyLanguageService = createProxyLanguageService;
	const language_core_1 = requireLanguageCore();
	const dedupe_1 = requireDedupe();
	const transform_1 = requireTransform();
	const utils_1 = requireUtils();
	const windowsPathReg = /\\/g;
	/**
	 * Creates and returns a Proxy around the base TypeScript LanguageService.
	 *
	 * This is used by the Volar TypeScript Plugin (which can be created by `createLanguageServicePlugin`
	 * and `createAsyncLanguageServicePlugin`) as an adapter layer between the TypeScript Language Service
	 * plugin API (see https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin)
	 * and a Volar `Language`.
	 *
	 * Once the `initialize` method is called, the proxy will begin intercepting requests and
	 * enhancing the default behavior of the LanguageService with enhancements based on
	 * the Volar `Language` that has been passed to `initialize`.
	 */
	function createProxyLanguageService(languageService) {
	    const proxyCache = new Map();
	    let getProxyMethod;
	    return {
	        initialize(language) {
	            getProxyMethod = (target, p) => {
	                switch (p) {
	                    case 'getNavigationTree':
	                        return getNavigationTree(language, target[p]);
	                    case 'getOutliningSpans':
	                        return getOutliningSpans(language, target[p]);
	                    case 'getFormattingEditsForDocument':
	                        return getFormattingEditsForDocument(language, target[p]);
	                    case 'getFormattingEditsForRange':
	                        return getFormattingEditsForRange(language, target[p]);
	                    case 'getFormattingEditsAfterKeystroke':
	                        return getFormattingEditsAfterKeystroke(language, target[p]);
	                    case 'getEditsForFileRename':
	                        return getEditsForFileRename(language, target[p]);
	                    case 'getLinkedEditingRangeAtPosition':
	                        return getLinkedEditingRangeAtPosition(language, target[p]);
	                    case 'prepareCallHierarchy':
	                        return prepareCallHierarchy(language, target[p]);
	                    case 'provideCallHierarchyIncomingCalls':
	                        return provideCallHierarchyIncomingCalls(language, target[p]);
	                    case 'provideCallHierarchyOutgoingCalls':
	                        return provideCallHierarchyOutgoingCalls(language, target[p]);
	                    case 'organizeImports':
	                        return organizeImports(language, target[p]);
	                    case 'getQuickInfoAtPosition':
	                        return getQuickInfoAtPosition(language, target[p]);
	                    case 'getSignatureHelpItems':
	                        return getSignatureHelpItems(language, target[p]);
	                    case 'getDocumentHighlights':
	                        return getDocumentHighlights(language, target[p]);
	                    case 'getApplicableRefactors':
	                        return getApplicableRefactors(language, target[p]);
	                    case 'getEditsForRefactor':
	                        return getEditsForRefactor(language, target[p]);
	                    case 'getCombinedCodeFix':
	                        return getCombinedCodeFix(language, target[p]);
	                    case 'getRenameInfo':
	                        return getRenameInfo(language, target[p]);
	                    case 'getCodeFixesAtPosition':
	                        return getCodeFixesAtPosition(language, target[p]);
	                    case 'getEncodedSemanticClassifications':
	                        return getEncodedSemanticClassifications(language, target[p]);
	                    case 'getSyntacticDiagnostics':
	                        return getSyntacticDiagnostics(language, languageService, target[p]);
	                    case 'getSemanticDiagnostics':
	                        return getSemanticDiagnostics(language, languageService, target[p]);
	                    case 'getSuggestionDiagnostics':
	                        return getSuggestionDiagnostics(language, languageService, target[p]);
	                    case 'getDefinitionAndBoundSpan':
	                        return getDefinitionAndBoundSpan(language, target[p]);
	                    case 'findReferences':
	                        return findReferences(language, target[p]);
	                    case 'getDefinitionAtPosition':
	                        return getDefinitionAtPosition(language, target[p]);
	                    case 'getTypeDefinitionAtPosition':
	                        return getTypeDefinitionAtPosition(language, target[p]);
	                    case 'getImplementationAtPosition':
	                        return getImplementationAtPosition(language, target[p]);
	                    case 'findRenameLocations':
	                        return findRenameLocations(language, target[p]);
	                    case 'getReferencesAtPosition':
	                        return getReferencesAtPosition(language, target[p]);
	                    case 'getCompletionsAtPosition':
	                        return getCompletionsAtPosition(language, target[p]);
	                    case 'getCompletionEntryDetails':
	                        return getCompletionEntryDetails(language, target[p]);
	                    case 'provideInlayHints':
	                        return provideInlayHints(language, target[p]);
	                    case 'getFileReferences':
	                        return getFileReferences(language, target[p]);
	                    case 'getNavigateToItems':
	                        return getNavigateToItems(language, target[p]);
	                }
	            };
	        },
	        proxy: new Proxy(languageService, {
	            get(target, p, receiver) {
	                if (getProxyMethod) {
	                    if (!proxyCache.has(p)) {
	                        proxyCache.set(p, getProxyMethod(target, p));
	                    }
	                    const proxyMethod = proxyCache.get(p);
	                    if (proxyMethod) {
	                        return proxyMethod;
	                    }
	                }
	                return Reflect.get(target, p, receiver);
	            },
	            set(target, p, value, receiver) {
	                return Reflect.set(target, p, value, receiver);
	            },
	        }),
	    };
	}
	// ignored methods
	function getNavigationTree(language, getNavigationTree) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (serviceScript || targetScript?.associatedOnly) {
	            const tree = getNavigationTree(targetScript.id);
	            tree.childItems = undefined;
	            return tree;
	        }
	        else {
	            return getNavigationTree(fileName);
	        }
	    };
	}
	function getOutliningSpans(language, getOutliningSpans) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (serviceScript || targetScript?.associatedOnly) {
	            return [];
	        }
	        else {
	            return getOutliningSpans(fileName);
	        }
	    };
	}
	// proxy methods
	function getFormattingEditsForDocument(language, getFormattingEditsForDocument) {
	    return (filePath, options) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const map = language.maps.get(serviceScript.code, targetScript);
	            if (!map.mappings.some(mapping => (0, language_core_1.isFormattingEnabled)(mapping.data))) {
	                return [];
	            }
	            const edits = getFormattingEditsForDocument(targetScript.id, options);
	            return edits
	                .map(edit => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1])
	                .filter(edit => !!edit);
	        }
	        else {
	            return getFormattingEditsForDocument(fileName, options);
	        }
	    };
	}
	function getFormattingEditsForRange(language, getFormattingEditsForRange) {
	    return (filePath, start, end, options) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1.isFormattingEnabled);
	            if (generatedRange !== undefined) {
	                const edits = getFormattingEditsForRange(targetScript.id, generatedRange[0], generatedRange[1], options);
	                return edits
	                    .map(edit => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1])
	                    .filter(edit => !!edit);
	            }
	            return [];
	        }
	        else {
	            return getFormattingEditsForRange(fileName, start, end, options);
	        }
	    };
	}
	function getFormattingEditsAfterKeystroke(language, getFormattingEditsAfterKeystroke) {
	    return (filePath, position, key, options) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isFormattingEnabled);
	            if (generatePosition !== undefined) {
	                const edits = getFormattingEditsAfterKeystroke(targetScript.id, generatePosition, key, options);
	                return edits
	                    .map(edit => (0, transform_1.transformTextChange)(sourceScript, language, serviceScript, edit, false, language_core_1.isFormattingEnabled)?.[1])
	                    .filter(edit => !!edit);
	            }
	            return [];
	        }
	        else {
	            return getFormattingEditsAfterKeystroke(fileName, position, key, options);
	        }
	    };
	}
	function getEditsForFileRename(language, getEditsForFileRename) {
	    return (oldFilePath, newFilePath, formatOptions, preferences) => {
	        const edits = getEditsForFileRename(oldFilePath, newFilePath, formatOptions, preferences);
	        return (0, transform_1.transformFileTextChanges)(language, edits, false, language_core_1.isRenameEnabled);
	    };
	}
	function getLinkedEditingRangeAtPosition(language, getLinkedEditingRangeAtPosition) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isLinkedEditingEnabled);
	            if (generatePosition !== undefined) {
	                const info = getLinkedEditingRangeAtPosition(targetScript.id, generatePosition);
	                if (info) {
	                    return {
	                        ranges: info.ranges
	                            .map(span => (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, false, language_core_1.isLinkedEditingEnabled)?.[1])
	                            .filter(span => !!span),
	                        wordPattern: info.wordPattern,
	                    };
	                }
	            }
	        }
	        else {
	            return getLinkedEditingRangeAtPosition(fileName, position);
	        }
	    };
	}
	function prepareCallHierarchy(language, prepareCallHierarchy) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
	            if (generatePosition !== undefined) {
	                const item = prepareCallHierarchy(targetScript.id, generatePosition);
	                if (Array.isArray(item)) {
	                    return item.map(item => (0, transform_1.transformCallHierarchyItem)(language, item, true, language_core_1.isCallHierarchyEnabled));
	                }
	                else if (item) {
	                    return (0, transform_1.transformCallHierarchyItem)(language, item, true, language_core_1.isCallHierarchyEnabled);
	                }
	            }
	        }
	        else {
	            return prepareCallHierarchy(fileName, position);
	        }
	    };
	}
	function provideCallHierarchyIncomingCalls(language, provideCallHierarchyIncomingCalls) {
	    return (filePath, position) => {
	        let calls = [];
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
	            if (generatePosition !== undefined) {
	                calls = provideCallHierarchyIncomingCalls(targetScript.id, generatePosition);
	            }
	        }
	        else {
	            calls = provideCallHierarchyIncomingCalls(fileName, position);
	        }
	        return calls
	            .map(call => {
	            const from = (0, transform_1.transformCallHierarchyItem)(language, call.from, true, language_core_1.isCallHierarchyEnabled);
	            const fromSpans = call.fromSpans
	                .map(span => (0, transform_1.transformSpan)(language, call.from.file, span, true, language_core_1.isCallHierarchyEnabled)?.textSpan)
	                .filter(span => !!span);
	            return {
	                from,
	                fromSpans,
	            };
	        });
	    };
	}
	function provideCallHierarchyOutgoingCalls(language, provideCallHierarchyOutgoingCalls) {
	    return (filePath, position) => {
	        let calls = [];
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCallHierarchyEnabled);
	            if (generatePosition !== undefined) {
	                calls = provideCallHierarchyOutgoingCalls(targetScript.id, generatePosition);
	            }
	        }
	        else {
	            calls = provideCallHierarchyOutgoingCalls(fileName, position);
	        }
	        return calls
	            .map(call => {
	            const to = (0, transform_1.transformCallHierarchyItem)(language, call.to, true, language_core_1.isCallHierarchyEnabled);
	            const fromSpans = call.fromSpans
	                .map(span => serviceScript
	                ? (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, span, true, language_core_1.isCallHierarchyEnabled)?.[1]
	                : span)
	                .filter(span => !!span);
	            return {
	                to,
	                fromSpans,
	            };
	        });
	    };
	}
	function organizeImports(language, organizeImports) {
	    return (args, formatOptions, preferences) => {
	        const unresolved = organizeImports(args, formatOptions, preferences);
	        return (0, transform_1.transformFileTextChanges)(language, unresolved, false, language_core_1.isCodeActionsEnabled);
	    };
	}
	function getQuickInfoAtPosition(language, getQuickInfoAtPosition) {
	    /**
	     * Using `...args` for pass through rest params (including internal `verbosityLevel` param).
	     * https://github.com/microsoft/TypeScript/blob/dd830711041b7b0cfd3da7937755996b1e1b1c7e/src/services/types.ts#L588
	     */
	    return (filePath, position, ...args) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            const infos = [];
	            for (const [generatePosition] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isHoverEnabled)) {
	                const info = getQuickInfoAtPosition(targetScript.id, generatePosition, ...args);
	                if (info) {
	                    const textSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.textSpan, true, language_core_1.isHoverEnabled)?.[1];
	                    if (textSpan) {
	                        infos.push({
	                            ...info,
	                            textSpan: textSpan,
	                        });
	                    }
	                }
	            }
	            if (infos.length === 1) {
	                return infos[0];
	            }
	            else if (infos.length >= 2) {
	                const combine = { ...infos[0] };
	                combine.displayParts = combine.displayParts?.slice();
	                combine.documentation = combine.documentation?.slice();
	                combine.tags = combine.tags?.slice();
	                const displayPartsStrs = new Set([displayPartsToString(infos[0].displayParts)]);
	                const documentationStrs = new Set([displayPartsToString(infos[0].documentation)]);
	                const tagsStrs = new Set();
	                for (const tag of infos[0].tags ?? []) {
	                    tagsStrs.add(tag.name + '__volar__' + displayPartsToString(tag.text));
	                }
	                for (let i = 1; i < infos.length; i++) {
	                    const { displayParts, documentation, tags } = infos[i];
	                    if (displayParts?.length && !displayPartsStrs.has(displayPartsToString(displayParts))) {
	                        displayPartsStrs.add(displayPartsToString(displayParts));
	                        combine.displayParts ??= [];
	                        combine.displayParts.push({ ...displayParts[0], text: '\n\n' + displayParts[0].text });
	                        combine.displayParts.push(...displayParts.slice(1));
	                    }
	                    if (documentation?.length && !documentationStrs.has(displayPartsToString(documentation))) {
	                        documentationStrs.add(displayPartsToString(documentation));
	                        combine.documentation ??= [];
	                        combine.documentation.push({ ...documentation[0], text: '\n\n' + documentation[0].text });
	                        combine.documentation.push(...documentation.slice(1));
	                    }
	                    for (const tag of tags ?? []) {
	                        if (!tagsStrs.has(tag.name + '__volar__' + displayPartsToString(tag.text))) {
	                            tagsStrs.add(tag.name + '__volar__' + displayPartsToString(tag.text));
	                            combine.tags ??= [];
	                            combine.tags.push(tag);
	                        }
	                    }
	                }
	                return combine;
	            }
	        }
	        else {
	            return getQuickInfoAtPosition(fileName, position, ...args);
	        }
	    };
	}
	function getSignatureHelpItems(language, getSignatureHelpItems) {
	    return (filePath, position, options) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isSignatureHelpEnabled);
	            if (generatePosition !== undefined) {
	                const result = getSignatureHelpItems(targetScript.id, generatePosition, options);
	                if (result) {
	                    const applicableSpan = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.applicableSpan, true, language_core_1.isSignatureHelpEnabled)?.[1];
	                    if (applicableSpan) {
	                        return {
	                            ...result,
	                            applicableSpan,
	                        };
	                    }
	                }
	            }
	        }
	        else {
	            return getSignatureHelpItems(fileName, position, options);
	        }
	    };
	}
	function getDocumentHighlights(language, getDocumentHighlights) {
	    return (filePath, position, filesToSearch) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isHighlightEnabled, (fileName, position) => getDocumentHighlights(fileName, position, filesToSearch), function* (result) {
	            for (const ref of result) {
	                for (const reference of ref.highlightSpans) {
	                    yield [reference.fileName ?? ref.fileName, reference.textSpan.start];
	                }
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(highlights => {
	            return {
	                ...highlights,
	                highlightSpans: highlights.highlightSpans
	                    .map(span => {
	                    const { textSpan } = (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.textSpan, false, language_core_1.isHighlightEnabled)
	                        ?? {};
	                    if (textSpan) {
	                        return {
	                            ...span,
	                            contextSpan: (0, transform_1.transformSpan)(language, span.fileName ?? highlights.fileName, span.contextSpan, false, language_core_1.isHighlightEnabled)?.textSpan,
	                            textSpan,
	                        };
	                    }
	                })
	                    .filter(span => !!span),
	            };
	        });
	        return resolved;
	    };
	}
	function getApplicableRefactors(language, getApplicableRefactors) {
	    return (filePath, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            if (typeof positionOrRange === 'number') {
	                const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
	                if (generatePosition !== undefined) {
	                    return getApplicableRefactors(targetScript.id, generatePosition, preferences, triggerReason, kind, includeInteractiveActions);
	                }
	            }
	            else {
	                for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
	                    return getApplicableRefactors(targetScript.id, { pos: generatedStart, end: generatedEnd }, preferences, triggerReason, kind, includeInteractiveActions);
	                }
	            }
	            return [];
	        }
	        else {
	            return getApplicableRefactors(fileName, positionOrRange, preferences, triggerReason, kind, includeInteractiveActions);
	        }
	    };
	}
	function getEditsForRefactor(language, getEditsForRefactor) {
	    return (filePath, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments) => {
	        let edits;
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            if (typeof positionOrRange === 'number') {
	                const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, positionOrRange, language_core_1.isCodeActionsEnabled);
	                if (generatePosition !== undefined) {
	                    edits = getEditsForRefactor(targetScript.id, formatOptions, generatePosition, refactorName, actionName, preferences, interactiveRefactorArguments);
	                }
	            }
	            else {
	                for (const [generatedStart, generatedEnd] of (0, transform_1.toGeneratedRanges)(language, serviceScript, sourceScript, positionOrRange.pos, positionOrRange.end, language_core_1.isCodeActionsEnabled)) {
	                    edits = getEditsForRefactor(targetScript.id, formatOptions, { pos: generatedStart, end: generatedEnd }, refactorName, actionName, preferences, interactiveRefactorArguments);
	                }
	            }
	        }
	        else {
	            edits = getEditsForRefactor(fileName, formatOptions, positionOrRange, refactorName, actionName, preferences, interactiveRefactorArguments);
	        }
	        if (edits) {
	            edits.edits = (0, transform_1.transformFileTextChanges)(language, edits.edits, false, language_core_1.isCodeActionsEnabled);
	            return edits;
	        }
	    };
	}
	function getCombinedCodeFix(language, getCombinedCodeFix) {
	    return (...args) => {
	        const codeActions = getCombinedCodeFix(...args);
	        codeActions.changes = (0, transform_1.transformFileTextChanges)(language, codeActions.changes, false, language_core_1.isCodeActionsEnabled);
	        return codeActions;
	    };
	}
	function getRenameInfo(language, getRenameInfo) {
	    return (filePath, position, options) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return {
	                canRename: false,
	                localizedErrorMessage: 'Cannot rename',
	            };
	        }
	        if (serviceScript) {
	            let failed;
	            for (const [generateOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isRenameEnabled)) {
	                const info = getRenameInfo(targetScript.id, generateOffset, options);
	                if (info.canRename) {
	                    const span = (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, info.triggerSpan, false, language_core_1.isRenameEnabled)?.[1];
	                    if (span) {
	                        info.triggerSpan = span;
	                        return info;
	                    }
	                }
	                else {
	                    failed = info;
	                }
	            }
	            if (failed) {
	                return failed;
	            }
	            return {
	                canRename: false,
	                localizedErrorMessage: 'Failed to get rename locations',
	            };
	        }
	        else {
	            return getRenameInfo(fileName, position, options);
	        }
	    };
	}
	function getCodeFixesAtPosition(language, getCodeFixesAtPosition) {
	    return (filePath, start, end, errorCodes, formatOptions, preferences) => {
	        let fixes = [];
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const generateRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, start, end, language_core_1.isCodeActionsEnabled);
	            if (generateRange !== undefined) {
	                fixes = getCodeFixesAtPosition(targetScript.id, generateRange[0], generateRange[1], errorCodes, formatOptions, preferences);
	            }
	        }
	        else {
	            fixes = getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions, preferences);
	        }
	        fixes = fixes.map(fix => {
	            fix.changes = (0, transform_1.transformFileTextChanges)(language, fix.changes, false, language_core_1.isCodeActionsEnabled);
	            return fix;
	        });
	        return fixes;
	    };
	}
	function getEncodedSemanticClassifications(language, getEncodedSemanticClassifications) {
	    return (filePath, span, format) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return {
	                spans: [],
	                endOfLineState: 0,
	            };
	        }
	        if (serviceScript) {
	            const map = language.maps.get(serviceScript.code, targetScript);
	            const mapped = (0, language_core_1.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1.isSemanticTokensEnabled);
	            if (!mapped) {
	                return {
	                    spans: [],
	                    endOfLineState: 0,
	                };
	            }
	            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
	            const start = mapped.start + mappingOffset;
	            const end = mapped.end + mappingOffset;
	            const result = getEncodedSemanticClassifications(targetScript.id, { start, length: end - start }, format);
	            const spans = [];
	            for (let i = 0; i < result.spans.length; i += 3) {
	                for (const [_, sourceStart, sourceEnd] of (0, transform_1.toSourceRanges)(sourceScript, language, serviceScript, result.spans[i], result.spans[i] + result.spans[i + 1], false, language_core_1.isSemanticTokensEnabled)) {
	                    spans.push(sourceStart, sourceEnd - sourceStart, result.spans[i + 2]);
	                    break;
	                }
	            }
	            result.spans = spans;
	            return result;
	        }
	        else {
	            return getEncodedSemanticClassifications(fileName, span, format);
	        }
	    };
	}
	function getSyntacticDiagnostics(language, languageService, getSyntacticDiagnostics) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        return getSyntacticDiagnostics(targetScript?.id ?? fileName)
	            .map(d => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false))
	            .filter(d => !!d)
	            .filter(d => !serviceScript || language.scripts.get(d.file.fileName) === sourceScript);
	    };
	}
	function getSemanticDiagnostics(language, languageService, getSemanticDiagnostics) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        return getSemanticDiagnostics(targetScript?.id ?? fileName)
	            .map(d => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false))
	            .filter(d => !!d)
	            .filter(d => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
	    };
	}
	function getSuggestionDiagnostics(language, languageService, getSuggestionDiagnostics) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        return getSuggestionDiagnostics(targetScript?.id ?? fileName)
	            .map(d => (0, transform_1.transformDiagnostic)(language, d, languageService.getProgram(), false))
	            .filter(d => !!d)
	            .filter(d => !serviceScript || !d.file || language.scripts.get(d.file.fileName) === sourceScript);
	    };
	}
	function getDefinitionAndBoundSpan(language, getDefinitionAndBoundSpan) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isDefinitionEnabled, (fileName, position) => getDefinitionAndBoundSpan(fileName, position), function* (result) {
	            for (const ref of result.definitions ?? []) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const textSpan = unresolved
	            .map(s => (0, transform_1.transformSpan)(language, fileName, s.textSpan, true, language_core_1.isDefinitionEnabled)?.textSpan)
	            .filter(s => !!s)[0];
	        if (!textSpan) {
	            return;
	        }
	        const definitions = unresolved
	            .map(s => s.definitions
	            ?.map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isDefinitionEnabled, s.fileName !== fileName))
	            .filter(s => !!s)
	            ?? [])
	            .flat();
	        return {
	            textSpan,
	            definitions: (0, dedupe_1.dedupeDocumentSpans)(definitions),
	        };
	    };
	}
	function findReferences(language, findReferences) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isReferencesEnabled, (fileName, position) => findReferences(fileName, position), function* (result) {
	            for (const ref of result) {
	                for (const reference of ref.references) {
	                    yield [reference.fileName, reference.textSpan.start];
	                }
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(symbol => {
	            const definition = (0, transform_1.transformDocumentSpan)(language, symbol.definition, true, language_core_1.isDefinitionEnabled, true);
	            return {
	                definition,
	                references: symbol.references
	                    .map(r => (0, transform_1.transformDocumentSpan)(language, r, true, language_core_1.isReferencesEnabled))
	                    .filter(r => !!r),
	            };
	        });
	        return resolved;
	    };
	}
	function getDefinitionAtPosition(language, getDefinitionAtPosition) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isDefinitionEnabled, (fileName, position) => getDefinitionAtPosition(fileName, position), function* (result) {
	            for (const ref of result) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isDefinitionEnabled, s.fileName !== fileName))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function getTypeDefinitionAtPosition(language, getTypeDefinitionAtPosition) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isTypeDefinitionEnabled, (fileName, position) => getTypeDefinitionAtPosition(fileName, position), function* (result) {
	            for (const ref of result) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isTypeDefinitionEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function getImplementationAtPosition(language, getImplementationAtPosition) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isImplementationEnabled, (fileName, position) => getImplementationAtPosition(fileName, position), function* (result) {
	            for (const ref of result) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isImplementationEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function findRenameLocations(language, findRenameLocations) {
	    return (filePath, position, findInStrings, findInComments, preferences) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isRenameEnabled, (fileName, position) => findRenameLocations(fileName, position, findInStrings, findInComments, preferences), function* (result) {
	            for (const ref of result) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, false, language_core_1.isRenameEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function getReferencesAtPosition(language, getReferencesAtPosition) {
	    return (filePath, position) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = linkedCodeFeatureWorker(language, fileName, position, language_core_1.isReferencesEnabled, (fileName, position) => getReferencesAtPosition(fileName, position), function* (result) {
	            for (const ref of result) {
	                yield [ref.fileName, ref.textSpan.start];
	            }
	        });
	        const resolved = unresolved
	            .flat()
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function getCompletionsAtPosition(language, getCompletionsAtPosition) {
	    return (filePath, position, options, formattingSettings) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            let mainResult;
	            const additionalResults = [];
	            for (const [generatedOffset, mapping] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled)) {
	                const isAdditional = typeof mapping.data.completion === 'object' && mapping.data.completion.isAdditional;
	                if (!isAdditional && mainResult?.entries.length) {
	                    continue;
	                }
	                const result = getCompletionsAtPosition(targetScript.id, generatedOffset, options, formattingSettings);
	                if (!result) {
	                    continue;
	                }
	                if (typeof mapping.data.completion === 'object' && mapping.data.completion.onlyImport) {
	                    result.entries = result.entries.filter(entry => !!entry.sourceDisplay);
	                }
	                for (const entry of result.entries) {
	                    entry.replacementSpan = entry.replacementSpan
	                        && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, entry.replacementSpan, false, language_core_1.isCompletionEnabled)?.[1];
	                }
	                result.optionalReplacementSpan = result.optionalReplacementSpan
	                    && (0, transform_1.transformTextSpan)(sourceScript, language, serviceScript, result.optionalReplacementSpan, false, language_core_1.isCompletionEnabled)?.[1];
	                if (isAdditional) {
	                    additionalResults.push(result);
	                }
	                else {
	                    mainResult = result;
	                }
	            }
	            const results = additionalResults;
	            if (mainResult) {
	                results.unshift(mainResult);
	            }
	            if (results.length) {
	                return {
	                    ...results[0],
	                    entries: results
	                        .map(additionalResult => additionalResult.entries)
	                        .flat(),
	                };
	            }
	        }
	        else {
	            return getCompletionsAtPosition(fileName, position, options, formattingSettings);
	        }
	    };
	}
	function getCompletionEntryDetails(language, getCompletionEntryDetails) {
	    return (filePath, position, entryName, formatOptions, source, preferences, data) => {
	        let details;
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return undefined;
	        }
	        if (serviceScript) {
	            const generatePosition = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, position, language_core_1.isCompletionEnabled);
	            if (generatePosition !== undefined) {
	                details = getCompletionEntryDetails(targetScript.id, generatePosition, entryName, formatOptions, source, preferences, data);
	            }
	        }
	        else {
	            return getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);
	        }
	        if (details?.codeActions) {
	            for (const codeAction of details.codeActions) {
	                codeAction.changes = (0, transform_1.transformFileTextChanges)(language, codeAction.changes, false, language_core_1.isCompletionEnabled);
	            }
	        }
	        return details;
	    };
	}
	function provideInlayHints(language, provideInlayHints) {
	    return (filePath, span, preferences) => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	        if (targetScript?.associatedOnly) {
	            return [];
	        }
	        if (serviceScript) {
	            const map = language.maps.get(serviceScript.code, sourceScript);
	            const mapped = (0, language_core_1.findOverlapCodeRange)(span.start, span.start + span.length, map, language_core_1.isSemanticTokensEnabled);
	            if (!mapped) {
	                return [];
	            }
	            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
	            const start = mapped.start + mappingOffset;
	            const end = mapped.end + mappingOffset;
	            const result = provideInlayHints(targetScript.id, { start, length: end - start }, preferences);
	            const hints = [];
	            for (const hint of result) {
	                const sourcePosition = (0, transform_1.toSourceOffset)(sourceScript, language, serviceScript, hint.position, language_core_1.isInlayHintsEnabled);
	                if (sourcePosition !== undefined) {
	                    hints.push({
	                        ...hint,
	                        position: sourcePosition[1],
	                    });
	                }
	            }
	            return hints;
	        }
	        else {
	            return provideInlayHints(fileName, span, preferences);
	        }
	    };
	}
	function getFileReferences(language, getFileReferences) {
	    return filePath => {
	        const fileName = filePath.replace(windowsPathReg, '/');
	        const unresolved = getFileReferences(fileName);
	        const resolved = unresolved
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function getNavigateToItems(language, getNavigateToItems) {
	    return (...args) => {
	        const unresolved = getNavigateToItems(...args);
	        const resolved = unresolved
	            .map(s => (0, transform_1.transformDocumentSpan)(language, s, true, language_core_1.isReferencesEnabled))
	            .filter(s => !!s);
	        return (0, dedupe_1.dedupeDocumentSpans)(resolved);
	    };
	}
	function linkedCodeFeatureWorker(language, fileName, position, filter, worker, getLinkedCodes) {
	    const results = [];
	    const processedFilePositions = new Set();
	    const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
	    if (serviceScript) {
	        for (const [generatedOffset] of (0, transform_1.toGeneratedOffsets)(language, serviceScript, sourceScript, position, filter)) {
	            process(targetScript.id, generatedOffset);
	        }
	    }
	    else {
	        process(fileName, position);
	    }
	    return results;
	    function process(fileName, position) {
	        if (processedFilePositions.has(fileName + ':' + position)) {
	            return;
	        }
	        processedFilePositions.add(fileName + ':' + position);
	        const result = worker(fileName, position);
	        if (!result) {
	            return;
	        }
	        results.push(result);
	        for (const ref of getLinkedCodes(result)) {
	            processedFilePositions.add(ref[0] + ':' + ref[1]);
	            const [serviceScript] = (0, utils_1.getServiceScript)(language, ref[0]);
	            if (!serviceScript) {
	                continue;
	            }
	            const linkedCodeMap = language.linkedCodeMaps.get(serviceScript.code);
	            if (!linkedCodeMap) {
	                continue;
	            }
	            const mappingOffset = (0, transform_1.getMappingOffset)(language, serviceScript);
	            for (const linkedCodeOffset of linkedCodeMap.getLinkedOffsets(ref[1] - mappingOffset)) {
	                process(ref[0], linkedCodeOffset + mappingOffset);
	            }
	        }
	    }
	}
	function displayPartsToString(displayParts) {
	    if (displayParts) {
	        return displayParts.map(displayPart => displayPart.text).join('');
	    }
	    return '';
	}
	
	return proxyLanguageService;
}

var createProject = {};

var hasRequiredCreateProject;

function requireCreateProject () {
	if (hasRequiredCreateProject) return createProject;
	hasRequiredCreateProject = 1;
	Object.defineProperty(createProject, "__esModule", { value: true });
	createProject.createLanguageServiceHost = createLanguageServiceHost;
	const language_core_1 = requireLanguageCore();
	const path = requirePathBrowserify();
	const utils_1 = requireUtils();
	const resolveModuleName_1 = requireResolveModuleName();
	function createLanguageServiceHost(ts, sys, language, asScriptId, projectHost) {
	    const pluginExtensions = language.plugins
	        .map(plugin => plugin.typescript?.extraFileExtensions.map(ext => '.' + ext.extension) ?? [])
	        .flat();
	    const scriptVersions = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
	    let lastProjectVersion;
	    let tsProjectVersion = 0;
	    let tsFileRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
	    let tsFileDirRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
	    let extraScriptRegistry = new language_core_1.FileMap(sys.useCaseSensitiveFileNames);
	    let lastTsVirtualFileSnapshots = new Set();
	    let lastOtherVirtualFileSnapshots = new Set();
	    let languageServiceHost = {
	        ...sys,
	        getCurrentDirectory() {
	            return projectHost.getCurrentDirectory();
	        },
	        useCaseSensitiveFileNames() {
	            return sys.useCaseSensitiveFileNames;
	        },
	        getNewLine() {
	            return sys.newLine;
	        },
	        getTypeRootsVersion: () => {
	            return 'version' in sys ? sys.version : -1; // TODO: only update for /node_modules changes?
	        },
	        getDirectories(dirName) {
	            return sys.getDirectories(dirName);
	        },
	        readDirectory(dirName, extensions, excludes, includes, depth) {
	            const exts = new Set(extensions);
	            for (const ext of pluginExtensions) {
	                exts.add(ext);
	            }
	            extensions = [...exts];
	            return sys.readDirectory(dirName, extensions, excludes, includes, depth);
	        },
	        getCompilationSettings() {
	            const options = projectHost.getCompilationSettings();
	            if (pluginExtensions.length) {
	                options.allowNonTsExtensions ??= true;
	                if (!options.allowNonTsExtensions) {
	                    console.warn('`allowNonTsExtensions` must be `true`.');
	                }
	            }
	            return options;
	        },
	        getLocalizedDiagnosticMessages: projectHost.getLocalizedDiagnosticMessages,
	        getProjectReferences: projectHost.getProjectReferences,
	        getDefaultLibFileName: options => {
	            try {
	                return ts.getDefaultLibFilePath(options);
	            }
	            catch {
	                // web
	                return `/node_modules/typescript/lib/${ts.getDefaultLibFileName(options)}`;
	            }
	        },
	        readFile(fileName) {
	            const snapshot = getScriptSnapshot(fileName);
	            if (snapshot) {
	                return snapshot.getText(0, snapshot.getLength());
	            }
	        },
	        directoryExists(directoryName) {
	            sync();
	            if (tsFileDirRegistry.has(directoryName)) {
	                return true;
	            }
	            return sys.directoryExists(directoryName);
	        },
	        fileExists(fileName) {
	            return getScriptVersion(fileName) !== '';
	        },
	        getProjectVersion() {
	            sync();
	            return tsProjectVersion + ('version' in sys ? `:${sys.version}` : '');
	        },
	        getScriptFileNames() {
	            sync();
	            return [...tsFileRegistry.keys()];
	        },
	        getScriptKind(fileName) {
	            sync();
	            if (extraScriptRegistry.has(fileName)) {
	                return extraScriptRegistry.get(fileName).scriptKind;
	            }
	            const sourceScript = language.scripts.get(asScriptId(fileName));
	            if (sourceScript?.generated) {
	                const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	                if (serviceScript) {
	                    return serviceScript.scriptKind;
	                }
	            }
	            switch (path.extname(fileName)) {
	                case '.js':
	                case '.cjs':
	                case '.mjs':
	                    return ts.ScriptKind.JS;
	                case '.jsx':
	                    return ts.ScriptKind.JSX;
	                case '.ts':
	                case '.cts':
	                case '.mts':
	                    return ts.ScriptKind.TS;
	                case '.tsx':
	                    return ts.ScriptKind.TSX;
	                case '.json':
	                    return ts.ScriptKind.JSON;
	                default:
	                    return ts.ScriptKind.Unknown;
	            }
	        },
	        getScriptVersion,
	        getScriptSnapshot,
	    };
	    for (const plugin of language.plugins) {
	        if (plugin.typescript?.resolveLanguageServiceHost) {
	            languageServiceHost = plugin.typescript.resolveLanguageServiceHost(languageServiceHost);
	        }
	    }
	    if (pluginExtensions.length) {
	        // TODO: can this share between monorepo packages?
	        const moduleResolutionCache = ts.createModuleResolutionCache(languageServiceHost.getCurrentDirectory(), languageServiceHost.useCaseSensitiveFileNames?.() ? s => s : s => s.toLowerCase(), languageServiceHost.getCompilationSettings());
	        const resolveModuleName = (0, resolveModuleName_1.createResolveModuleName)(ts, sys.getFileSize, languageServiceHost, language.plugins, fileName => language.scripts.get(asScriptId(fileName)));
	        let lastSysVersion = 'version' in sys ? sys.version : undefined;
	        languageServiceHost.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile) => {
	            const disposeFixup = (0, utils_1.fixupImpliedNodeFormatForFile)(ts, pluginExtensions, containingSourceFile, moduleResolutionCache.getPackageJsonInfoCache(), languageServiceHost, options);
	            try {
	                if ('version' in sys && lastSysVersion !== sys.version) {
	                    lastSysVersion = sys.version;
	                    moduleResolutionCache.clear();
	                }
	                return moduleLiterals.map(moduleLiteral => {
	                    const mode = ts.getModeForUsageLocation(containingSourceFile, moduleLiteral, options);
	                    return resolveModuleName(moduleLiteral.text, containingFile, options, moduleResolutionCache, redirectedReference, mode);
	                });
	            }
	            finally {
	                disposeFixup?.();
	            }
	        };
	        languageServiceHost.resolveModuleNames = (moduleNames, containingFile, _reusedNames, redirectedReference, options) => {
	            if ('version' in sys && lastSysVersion !== sys.version) {
	                lastSysVersion = sys.version;
	                moduleResolutionCache.clear();
	            }
	            return moduleNames.map(moduleName => {
	                return resolveModuleName(moduleName, containingFile, options, moduleResolutionCache, redirectedReference)
	                    .resolvedModule;
	            });
	        };
	        languageServiceHost.getModuleResolutionCache = () => moduleResolutionCache;
	    }
	    return {
	        languageServiceHost,
	        getExtraServiceScript,
	    };
	    function getExtraServiceScript(fileName) {
	        sync();
	        return extraScriptRegistry.get(fileName);
	    }
	    function sync() {
	        const newProjectVersion = projectHost.getProjectVersion?.();
	        const shouldUpdate = newProjectVersion === undefined || newProjectVersion !== lastProjectVersion;
	        if (!shouldUpdate) {
	            return;
	        }
	        lastProjectVersion = newProjectVersion;
	        extraScriptRegistry.clear();
	        const newTsVirtualFileSnapshots = new Set();
	        const newOtherVirtualFileSnapshots = new Set();
	        const tsFileNamesSet = new Set();
	        for (const fileName of projectHost.getScriptFileNames()) {
	            const sourceScript = language.scripts.get(asScriptId(fileName));
	            if (sourceScript?.generated) {
	                const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	                if (serviceScript) {
	                    newTsVirtualFileSnapshots.add(serviceScript.code.snapshot);
	                    tsFileNamesSet.add(fileName);
	                }
	                for (const extraServiceScript of sourceScript.generated.languagePlugin.typescript?.getExtraServiceScripts?.(fileName, sourceScript.generated.root) ?? []) {
	                    newTsVirtualFileSnapshots.add(extraServiceScript.code.snapshot);
	                    tsFileNamesSet.add(extraServiceScript.fileName);
	                    extraScriptRegistry.set(extraServiceScript.fileName, extraServiceScript);
	                }
	                for (const code of (0, language_core_1.forEachEmbeddedCode)(sourceScript.generated.root)) {
	                    newOtherVirtualFileSnapshots.add(code.snapshot);
	                }
	            }
	            else {
	                tsFileNamesSet.add(fileName);
	            }
	        }
	        if (!setEquals(lastTsVirtualFileSnapshots, newTsVirtualFileSnapshots)) {
	            tsProjectVersion++;
	        }
	        else if (setEquals(lastOtherVirtualFileSnapshots, newOtherVirtualFileSnapshots)) {
	            // no any meta language files update, it mean project version was update by source files this time
	            tsProjectVersion++;
	        }
	        lastTsVirtualFileSnapshots = newTsVirtualFileSnapshots;
	        lastOtherVirtualFileSnapshots = newOtherVirtualFileSnapshots;
	        tsFileRegistry.clear();
	        tsFileDirRegistry.clear();
	        for (const fileName of tsFileNamesSet) {
	            tsFileRegistry.set(fileName, true);
	            const parts = fileName.split('/');
	            for (let i = 1; i < parts.length; i++) {
	                const dirName = parts.slice(0, i).join('/');
	                tsFileDirRegistry.set(dirName, true);
	            }
	        }
	    }
	    function getScriptSnapshot(fileName) {
	        sync();
	        if (extraScriptRegistry.has(fileName)) {
	            return extraScriptRegistry.get(fileName).code.snapshot;
	        }
	        const sourceScript = language.scripts.get(asScriptId(fileName));
	        if (sourceScript?.generated) {
	            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	            if (serviceScript) {
	                return serviceScript.code.snapshot;
	            }
	        }
	        else if (sourceScript) {
	            return sourceScript.snapshot;
	        }
	    }
	    function getScriptVersion(fileName) {
	        sync();
	        if (!scriptVersions.has(fileName)) {
	            scriptVersions.set(fileName, { lastVersion: 0, map: new WeakMap() });
	        }
	        const version = scriptVersions.get(fileName);
	        if (extraScriptRegistry.has(fileName)) {
	            const snapshot = extraScriptRegistry.get(fileName).code.snapshot;
	            if (!version.map.has(snapshot)) {
	                version.map.set(snapshot, version.lastVersion++);
	            }
	            return version.map.get(snapshot).toString();
	        }
	        const sourceScript = language.scripts.get(asScriptId(fileName));
	        if (sourceScript?.generated) {
	            const serviceScript = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
	            if (serviceScript) {
	                if (!version.map.has(serviceScript.code.snapshot)) {
	                    version.map.set(serviceScript.code.snapshot, version.lastVersion++);
	                }
	                return version.map.get(serviceScript.code.snapshot).toString();
	            }
	        }
	        const openedFile = language.scripts.get(asScriptId(fileName), false);
	        if (openedFile && !openedFile.generated) {
	            if (!version.map.has(openedFile.snapshot)) {
	                version.map.set(openedFile.snapshot, version.lastVersion++);
	            }
	            return version.map.get(openedFile.snapshot).toString();
	        }
	        if (sys.fileExists(fileName)) {
	            return sys.getModifiedTime?.(fileName)?.valueOf().toString() ?? '0';
	        }
	        return '';
	    }
	}
	function setEquals(a, b) {
	    if (a.size !== b.size) {
	        return false;
	    }
	    for (const item of a) {
	        if (!b.has(item)) {
	            return false;
	        }
	    }
	    return true;
	}
	
	return createProject;
}

var createSys = {};

var utilities = {};

var core = {};

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	core.every = every;
	core.findIndex = findIndex;
	core.indexOfAnyCharCode = indexOfAnyCharCode;
	core.map = map;
	core.flatten = flatten;
	core.flatMap = flatMap;
	core.some = some;
	core.sort = sort;
	core.lastOrUndefined = lastOrUndefined;
	core.last = last;
	core.equateStringsCaseInsensitive = equateStringsCaseInsensitive;
	core.equateStringsCaseSensitive = equateStringsCaseSensitive;
	core.compareStringsCaseSensitive = compareStringsCaseSensitive;
	core.getStringComparer = getStringComparer;
	core.endsWith = endsWith;
	core.stringContains = stringContains;
	core.createGetCanonicalFileName = createGetCanonicalFileName;
	core.startsWith = startsWith;
	const emptyArray = [];
	/**
	 * Iterates through `array` by index and performs the callback on each element of array until the callback
	 * returns a falsey value, then returns false.
	 * If no such value is found, the callback is applied to each element of array and `true` is returned.
	 */
	function every(array, callback) {
	    if (array) {
	        for (let i = 0; i < array.length; i++) {
	            if (!callback(array[i], i)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	/** Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found. */
	function findIndex(array, predicate, startIndex) {
	    if (array === undefined) {
	        return -1;
	    }
	    for (let i = startIndex ?? 0; i < array.length; i++) {
	        if (predicate(array[i], i)) {
	            return i;
	        }
	    }
	    return -1;
	}
	function contains(array, value, equalityComparer = equateValues) {
	    if (array) {
	        for (const v of array) {
	            if (equalityComparer(v, value)) {
	                return true;
	            }
	        }
	    }
	    return false;
	}
	function indexOfAnyCharCode(text, charCodes, start) {
	    for (let i = start || 0; i < text.length; i++) {
	        if (contains(charCodes, text.charCodeAt(i))) {
	            return i;
	        }
	    }
	    return -1;
	}
	function map(array, f) {
	    let result;
	    if (array) {
	        result = [];
	        for (let i = 0; i < array.length; i++) {
	            result.push(f(array[i], i));
	        }
	    }
	    return result;
	}
	/**
	 * Flattens an array containing a mix of array or non-array elements.
	 *
	 * @param array The array to flatten.
	 */
	function flatten(array) {
	    const result = [];
	    for (const v of array) {
	        if (v) {
	            if (isArray(v)) {
	                addRange(result, v);
	            }
	            else {
	                result.push(v);
	            }
	        }
	    }
	    return result;
	}
	/**
	 * Maps an array. If the mapped value is an array, it is spread into the result.
	 *
	 * @param array The array to map.
	 * @param mapfn The callback used to map the result into one or more values.
	 */
	function flatMap(array, mapfn) {
	    let result;
	    if (array) {
	        for (let i = 0; i < array.length; i++) {
	            const v = mapfn(array[i], i);
	            if (v) {
	                if (isArray(v)) {
	                    result = addRange(result, v);
	                }
	                else {
	                    result = append(result, v);
	                }
	            }
	        }
	    }
	    return result || emptyArray;
	}
	function some(array, predicate) {
	    if (array) {
	        if (predicate) {
	            for (const v of array) {
	                if (predicate(v)) {
	                    return true;
	                }
	            }
	        }
	        else {
	            return array.length > 0;
	        }
	    }
	    return false;
	}
	// function append<T>(to: T[] | undefined, value: T): T[];
	// function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined;
	// function append<T>(to: Push<T>, value: T | undefined): void;
	function append(to, value) {
	    if (value === undefined) {
	        return to;
	    }
	    if (to === undefined) {
	        return [value];
	    }
	    to.push(value);
	    return to;
	}
	/**
	 * Gets the actual offset into an array for a relative offset. Negative offsets indicate a
	 * position offset from the end of the array.
	 */
	function toOffset(array, offset) {
	    return offset < 0 ? array.length + offset : offset;
	}
	function addRange(to, from, start, end) {
	    if (from === undefined || from.length === 0) {
	        return to;
	    }
	    if (to === undefined) {
	        return from.slice(start, end);
	    }
	    start = start === undefined ? 0 : toOffset(from, start);
	    end = end === undefined ? from.length : toOffset(from, end);
	    for (let i = start; i < end && i < from.length; i++) {
	        if (from[i] !== undefined) {
	            to.push(from[i]);
	        }
	    }
	    return to;
	}
	/**
	 * Returns a new sorted array.
	 */
	function sort(array, comparer) {
	    return (array.length === 0 ? array : array.slice().sort(comparer));
	}
	/**
	 * Returns the last element of an array if non-empty, `undefined` otherwise.
	 */
	function lastOrUndefined(array) {
	    return array === undefined || array.length === 0 ? undefined : array[array.length - 1];
	}
	function last(array) {
	    // Debug.assert(array.length !== 0);
	    return array[array.length - 1];
	}
	/**
	 * Tests whether a value is an array.
	 */
	function isArray(value) {
	    return Array.isArray ? Array.isArray(value) : value instanceof Array;
	}
	/** Returns its argument. */
	function identity(x) {
	    return x;
	}
	/** Returns lower case string */
	function toLowerCase(x) {
	    return x.toLowerCase();
	}
	// We convert the file names to lower case as key for file name on case insensitive file system
	// While doing so we need to handle special characters (eg \u0130) to ensure that we dont convert
	// it to lower case, fileName with its lowercase form can exist along side it.
	// Handle special characters and make those case sensitive instead
	//
	// |-#--|-Unicode--|-Char code-|-Desc-------------------------------------------------------------------|
	// | 1. | i        | 105       | Ascii i                                                                |
	// | 2. | I        | 73        | Ascii I                                                                |
	// |-------- Special characters ------------------------------------------------------------------------|
	// | 3. | \u0130   | 304       | Upper case I with dot above                                            |
	// | 4. | i,\u0307 | 105,775   | i, followed by 775: Lower case of (3rd item)                           |
	// | 5. | I,\u0307 | 73,775    | I, followed by 775: Upper case of (4th item), lower case is (4th item) |
	// | 6. | \u0131   | 305       | Lower case i without dot, upper case is I (2nd item)                   |
	// | 7. | \u00DF   | 223       | Lower case sharp s                                                     |
	//
	// Because item 3 is special where in its lowercase character has its own
	// upper case form we cant convert its case.
	// Rest special characters are either already in lower case format or
	// they have corresponding upper case character so they dont need special handling
	//
	// But to avoid having to do string building for most common cases, also ignore
	// a-z, 0-9, \u0131, \u00DF, \, /, ., : and space
	const fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
	/**
	 * Case insensitive file systems have descripencies in how they handle some characters (eg. turkish Upper case I with dot on top - \u0130)
	 * This function is used in places where we want to make file name as a key on these systems
	 * It is possible on mac to be able to refer to file name with I with dot on top as a fileName with its lower case form
	 * But on windows we cannot. Windows can have fileName with I with dot on top next to its lower case and they can not each be referred with the lowercase forms
	 * Technically we would want this function to be platform sepcific as well but
	 * our api has till now only taken caseSensitive as the only input and just for some characters we dont want to update API and ensure all customers use those api
	 * We could use upper case and we would still need to deal with the descripencies but
	 * we want to continue using lower case since in most cases filenames are lowercasewe and wont need any case changes and avoid having to store another string for the key
	 * So for this function purpose, we go ahead and assume character I with dot on top it as case sensitive since its very unlikely to use lower case form of that special character
	 */
	function toFileNameLowerCase(x) {
	    return fileNameLowerCaseRegExp.test(x)
	        ? x.replace(fileNameLowerCaseRegExp, toLowerCase)
	        : x;
	}
	function equateValues(a, b) {
	    return a === b;
	}
	/**
	 * Compare the equality of two strings using a case-sensitive ordinal comparison.
	 *
	 * Case-sensitive comparisons compare both strings one code-point at a time using the integer
	 * value of each code-point after applying `toUpperCase` to each string. We always map both
	 * strings to their upper-case form as some unicode characters do not properly round-trip to
	 * lowercase (such as `` (German sharp capital s)).
	 */
	function equateStringsCaseInsensitive(a, b) {
	    return a === b
	        || a !== undefined
	            && b !== undefined
	            && a.toUpperCase() === b.toUpperCase();
	}
	/**
	 * Compare the equality of two strings using a case-sensitive ordinal comparison.
	 *
	 * Case-sensitive comparisons compare both strings one code-point at a time using the
	 * integer value of each code-point.
	 */
	function equateStringsCaseSensitive(a, b) {
	    return equateValues(a, b);
	}
	function compareComparableValues(a, b) {
	    return a === b
	        ? 0 /* Comparison.EqualTo */
	        : a === undefined
	            ? -1 /* Comparison.LessThan */
	            : b === undefined
	                ? 1 /* Comparison.GreaterThan */
	                : a < b
	                    ? -1 /* Comparison.LessThan */
	                    : 1 /* Comparison.GreaterThan */;
	}
	/**
	 * Compare two strings using a case-insensitive ordinal comparison.
	 *
	 * Ordinal comparisons are based on the difference between the unicode code points of both
	 * strings. Characters with multiple unicode representations are considered unequal. Ordinal
	 * comparisons provide predictable ordering, but place "a" after "B".
	 *
	 * Case-insensitive comparisons compare both strings one code-point at a time using the integer
	 * value of each code-point after applying `toUpperCase` to each string. We always map both
	 * strings to their upper-case form as some unicode characters do not properly round-trip to
	 * lowercase (such as `` (German sharp capital s)).
	 */
	function compareStringsCaseInsensitive(a, b) {
	    if (a === b) {
	        return 0 /* Comparison.EqualTo */;
	    }
	    if (a === undefined) {
	        return -1 /* Comparison.LessThan */;
	    }
	    if (b === undefined) {
	        return 1 /* Comparison.GreaterThan */;
	    }
	    a = a.toUpperCase();
	    b = b.toUpperCase();
	    return a < b ? -1 /* Comparison.LessThan */ : a > b ? 1 /* Comparison.GreaterThan */ : 0 /* Comparison.EqualTo */;
	}
	/**
	 * Compare two strings using a case-sensitive ordinal comparison.
	 *
	 * Ordinal comparisons are based on the difference between the unicode code points of both
	 * strings. Characters with multiple unicode representations are considered unequal. Ordinal
	 * comparisons provide predictable ordering, but place "a" after "B".
	 *
	 * Case-sensitive comparisons compare both strings one code-point at a time using the integer
	 * value of each code-point.
	 */
	function compareStringsCaseSensitive(a, b) {
	    return compareComparableValues(a, b);
	}
	function getStringComparer(ignoreCase) {
	    return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;
	}
	function endsWith(str, suffix) {
	    const expectedPos = str.length - suffix.length;
	    return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
	}
	function stringContains(str, substring) {
	    return str.indexOf(substring) !== -1;
	}
	function createGetCanonicalFileName(useCaseSensitiveFileNames) {
	    return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
	}
	function startsWith(str, prefix) {
	    return str.lastIndexOf(prefix, 0) === 0;
	}
	
	return core;
}

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.directorySeparator = void 0;
		exports$1.isRootedDiskPath = isRootedDiskPath;
		exports$1.hasExtension = hasExtension;
		exports$1.fileExtensionIsOneOf = fileExtensionIsOneOf;
		exports$1.getDirectoryPath = getDirectoryPath;
		exports$1.combinePaths = combinePaths;
		exports$1.getNormalizedPathComponents = getNormalizedPathComponents;
		exports$1.normalizePath = normalizePath;
		exports$1.removeTrailingDirectorySeparator = removeTrailingDirectorySeparator;
		exports$1.containsPath = containsPath;
		const core_1 = requireCore();
		/**
		 * Internally, we represent paths as strings with '/' as the directory separator.
		 * When we make system calls (eg: LanguageServiceHost.getDirectory()),
		 * we expect the host to correctly handle paths in our specified format.
		 */
		exports$1.directorySeparator = '/';
		const altDirectorySeparator = '\\';
		const urlSchemeSeparator = '://';
		const backslashRegExp = /\\/g;
		//// Path Tests
		/**
		 * Determines whether a charCode corresponds to `/` or `\`.
		 */
		function isAnyDirectorySeparator(charCode) {
		    return charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */;
		}
		/**
		 * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path
		 * like `c:`, `c:\` or `c:/`).
		 */
		function isRootedDiskPath(path) {
		    return getEncodedRootLength(path) > 0;
		}
		function hasExtension(fileName) {
		    return (0, core_1.stringContains)(getBaseFileName(fileName), '.');
		}
		function fileExtensionIs(path, extension) {
		    return path.length > extension.length && (0, core_1.endsWith)(path, extension);
		}
		function fileExtensionIsOneOf(path, extensions) {
		    for (const extension of extensions) {
		        if (fileExtensionIs(path, extension)) {
		            return true;
		        }
		    }
		    return false;
		}
		/**
		 * Determines whether a path has a trailing separator (`/` or `\\`).
		 */
		function hasTrailingDirectorySeparator(path) {
		    return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
		}
		//// Path Parsing
		function isVolumeCharacter(charCode) {
		    return (charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */)
		        || (charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */);
		}
		function getFileUrlVolumeSeparatorEnd(url, start) {
		    const ch0 = url.charCodeAt(start);
		    if (ch0 === 58 /* CharacterCodes.colon */) {
		        return start + 1;
		    }
		    if (ch0 === 37 /* CharacterCodes.percent */ && url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {
		        const ch2 = url.charCodeAt(start + 2);
		        if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */) {
		            return start + 3;
		        }
		    }
		    return -1;
		}
		/**
		 * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
		 * If the root is part of a URL, the twos-complement of the root length is returned.
		 */
		function getEncodedRootLength(path) {
		    if (!path) {
		        return 0;
		    }
		    const ch0 = path.charCodeAt(0);
		    // POSIX or UNC
		    if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {
		        if (path.charCodeAt(1) !== ch0) {
		            return 1; // POSIX: "/" (or non-normalized "\")
		        }
		        const p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? exports$1.directorySeparator : altDirectorySeparator, 2);
		        if (p1 < 0) {
		            return path.length; // UNC: "//server" or "\\server"
		        }
		        return p1 + 1; // UNC: "//server/" or "\\server\"
		    }
		    // DOS
		    if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {
		        const ch2 = path.charCodeAt(2);
		        if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */) {
		            return 3; // DOS: "c:/" or "c:\"
		        }
		        if (path.length === 2) {
		            return 2; // DOS: "c:" (but not "c:d")
		        }
		    }
		    // URL
		    const schemeEnd = path.indexOf(urlSchemeSeparator);
		    if (schemeEnd !== -1) {
		        const authorityStart = schemeEnd + urlSchemeSeparator.length;
		        const authorityEnd = path.indexOf(exports$1.directorySeparator, authorityStart);
		        if (authorityEnd !== -1) { // URL: "file:///", "file://server/", "file://server/path"
		            // For local "file" URLs, include the leading DOS volume (if present).
		            // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
		            // special case interpreted as "the machine from which the URL is being interpreted".
		            const scheme = path.slice(0, schemeEnd);
		            const authority = path.slice(authorityStart, authorityEnd);
		            if (scheme === 'file' && (authority === '' || authority === 'localhost')
		                && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
		                const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
		                if (volumeSeparatorEnd !== -1) {
		                    if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {
		                        // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
		                        return ~(volumeSeparatorEnd + 1);
		                    }
		                    if (volumeSeparatorEnd === path.length) {
		                        // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
		                        // but not "file:///c:d" or "file:///c%3ad"
		                        return ~volumeSeparatorEnd;
		                    }
		                }
		            }
		            return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
		        }
		        return ~path.length; // URL: "file://server", "http://server"
		    }
		    // relative
		    return 0;
		}
		/**
		 * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
		 *
		 * For example:
		 * ```ts
		 * getRootLength("a") === 0                   // ""
		 * getRootLength("/") === 1                   // "/"
		 * getRootLength("c:") === 2                  // "c:"
		 * getRootLength("c:d") === 0                 // ""
		 * getRootLength("c:/") === 3                 // "c:/"
		 * getRootLength("c:\\") === 3                // "c:\\"
		 * getRootLength("//server") === 7            // "//server"
		 * getRootLength("//server/share") === 8      // "//server/"
		 * getRootLength("\\\\server") === 7          // "\\\\server"
		 * getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
		 * getRootLength("file:///path") === 8        // "file:///"
		 * getRootLength("file:///c:") === 10         // "file:///c:"
		 * getRootLength("file:///c:d") === 8         // "file:///"
		 * getRootLength("file:///c:/path") === 11    // "file:///c:/"
		 * getRootLength("file://server") === 13      // "file://server"
		 * getRootLength("file://server/path") === 14 // "file://server/"
		 * getRootLength("http://server") === 13      // "http://server"
		 * getRootLength("http://server/path") === 14 // "http://server/"
		 * ```
		 */
		function getRootLength(path) {
		    const rootLength = getEncodedRootLength(path);
		    return rootLength < 0 ? ~rootLength : rootLength;
		}
		function getDirectoryPath(path) {
		    path = normalizeSlashes(path);
		    // If the path provided is itself the root, then return it.
		    const rootLength = getRootLength(path);
		    if (rootLength === path.length) {
		        return path;
		    }
		    // return the leading portion of the path up to the last (non-terminal) directory separator
		    // but not including any trailing directory separator.
		    path = removeTrailingDirectorySeparator(path);
		    return path.slice(0, Math.max(rootLength, path.lastIndexOf(exports$1.directorySeparator)));
		}
		function getBaseFileName(path, extensions, ignoreCase) {
		    path = normalizeSlashes(path);
		    // if the path provided is itself the root, then it has not file name.
		    const rootLength = getRootLength(path);
		    if (rootLength === path.length) {
		        return '';
		    }
		    // return the trailing portion of the path starting after the last (non-terminal) directory
		    // separator but not including any trailing directory separator.
		    path = removeTrailingDirectorySeparator(path);
		    const name = path.slice(Math.max(getRootLength(path), path.lastIndexOf(exports$1.directorySeparator) + 1));
		    const extension = undefined;
		    return extension ? name.slice(0, name.length - extension.length) : name;
		}
		function pathComponents(path, rootLength) {
		    const root = path.substring(0, rootLength);
		    const rest = path.substring(rootLength).split(exports$1.directorySeparator);
		    if (rest.length && !(0, core_1.lastOrUndefined)(rest)) {
		        rest.pop();
		    }
		    return [root, ...rest];
		}
		/**
		 * Parse a path into an array containing a root component (at index 0) and zero or more path
		 * components (at indices > 0). The result is not normalized.
		 * If the path is relative, the root component is `""`.
		 * If the path is absolute, the root component includes the first path separator (`/`).
		 *
		 * ```ts
		 * // POSIX
		 * getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
		 * getPathComponents("/path/to/") === ["/", "path", "to"]
		 * getPathComponents("/") === ["/"]
		 * // DOS
		 * getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
		 * getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
		 * getPathComponents("c:/") === ["c:/"]
		 * getPathComponents("c:") === ["c:"]
		 * // URL
		 * getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
		 * getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
		 * getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
		 * getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
		 * getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
		 * getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
		 * getPathComponents("file://server/") === ["file://server/"]
		 * getPathComponents("file://server") === ["file://server"]
		 * getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
		 * getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
		 * getPathComponents("file:///") === ["file:///"]
		 * getPathComponents("file://") === ["file://"]
		 */
		function getPathComponents(path, currentDirectory = '') {
		    path = combinePaths(currentDirectory, path);
		    return pathComponents(path, getRootLength(path));
		}
		//// Path Formatting
		/**
		 * Formats a parsed path consisting of a root component (at index 0) and zero or more path
		 * segments (at indices > 0).
		 *
		 * ```ts
		 * getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
		 * ```
		 */
		function getPathFromPathComponents(pathComponents) {
		    if (pathComponents.length === 0) {
		        return '';
		    }
		    const root = pathComponents[0] && ensureTrailingDirectorySeparator(pathComponents[0]);
		    return root + pathComponents.slice(1).join(exports$1.directorySeparator);
		}
		//// Path Normalization
		/**
		 * Normalize path separators, converting `\` into `/`.
		 */
		function normalizeSlashes(path) {
		    return path.indexOf('\\') !== -1
		        ? path.replace(backslashRegExp, exports$1.directorySeparator)
		        : path;
		}
		/**
		 * Reduce an array of path components to a more simplified path by navigating any
		 * `"."` or `".."` entries in the path.
		 */
		function reducePathComponents(components) {
		    if (!(0, core_1.some)(components)) {
		        return [];
		    }
		    const reduced = [components[0]];
		    for (let i = 1; i < components.length; i++) {
		        const component = components[i];
		        if (!component) {
		            continue;
		        }
		        if (component === '.') {
		            continue;
		        }
		        if (component === '..') {
		            if (reduced.length > 1) {
		                if (reduced[reduced.length - 1] !== '..') {
		                    reduced.pop();
		                    continue;
		                }
		            }
		            else if (reduced[0]) {
		                continue;
		            }
		        }
		        reduced.push(component);
		    }
		    return reduced;
		}
		/**
		 * Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.
		 *
		 * ```ts
		 * // Non-rooted
		 * combinePaths("path", "to", "file.ext") === "path/to/file.ext"
		 * combinePaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
		 * // POSIX
		 * combinePaths("/path", "to", "file.ext") === "/path/to/file.ext"
		 * combinePaths("/path", "/to", "file.ext") === "/to/file.ext"
		 * // DOS
		 * combinePaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
		 * combinePaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
		 * // URL
		 * combinePaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
		 * combinePaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
		 * ```
		 */
		function combinePaths(path, ...paths) {
		    if (path) {
		        path = normalizeSlashes(path);
		    }
		    for (let relativePath of paths) {
		        if (!relativePath) {
		            continue;
		        }
		        relativePath = normalizeSlashes(relativePath);
		        if (!path || getRootLength(relativePath) !== 0) {
		            path = relativePath;
		        }
		        else {
		            path = ensureTrailingDirectorySeparator(path) + relativePath;
		        }
		    }
		    return path;
		}
		/**
		 * Parse a path into an array containing a root component (at index 0) and zero or more path
		 * components (at indices > 0). The result is normalized.
		 * If the path is relative, the root component is `""`.
		 * If the path is absolute, the root component includes the first path separator (`/`).
		 *
		 * ```ts
		 * getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
		 * ```
		 */
		function getNormalizedPathComponents(path, currentDirectory) {
		    return reducePathComponents(getPathComponents(path, currentDirectory));
		}
		function normalizePath(path) {
		    path = normalizeSlashes(path);
		    // Most paths don't require normalization
		    if (!relativePathSegmentRegExp.test(path)) {
		        return path;
		    }
		    // Some paths only require cleanup of `/./` or leading `./`
		    const simplified = path.replace(/\/\.\//g, '/').replace(/^\.\//, '');
		    if (simplified !== path) {
		        path = simplified;
		        if (!relativePathSegmentRegExp.test(path)) {
		            return path;
		        }
		    }
		    // Other paths require full normalization
		    const normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path)));
		    return normalized && hasTrailingDirectorySeparator(path) ? ensureTrailingDirectorySeparator(normalized) : normalized;
		}
		function removeTrailingDirectorySeparator(path) {
		    if (hasTrailingDirectorySeparator(path)) {
		        return path.substr(0, path.length - 1);
		    }
		    return path;
		}
		function ensureTrailingDirectorySeparator(path) {
		    if (!hasTrailingDirectorySeparator(path)) {
		        return path + exports$1.directorySeparator;
		    }
		    return path;
		}
		//// Path Comparisons
		// check path for these segments: '', '.'. '..'
		const relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
		function containsPath(parent, child, currentDirectory, ignoreCase) {
		    if (typeof currentDirectory === 'string') {
		        parent = combinePaths(currentDirectory, parent);
		        child = combinePaths(currentDirectory, child);
		    }
		    else if (typeof currentDirectory === 'boolean') {
		        ignoreCase = currentDirectory;
		    }
		    if (parent === undefined || child === undefined) {
		        return false;
		    }
		    if (parent === child) {
		        return true;
		    }
		    const parentComponents = reducePathComponents(getPathComponents(parent));
		    const childComponents = reducePathComponents(getPathComponents(child));
		    if (childComponents.length < parentComponents.length) {
		        return false;
		    }
		    const componentEqualityComparer = ignoreCase ? core_1.equateStringsCaseInsensitive : core_1.equateStringsCaseSensitive;
		    for (let i = 0; i < parentComponents.length; i++) {
		        const equalityComparer = i === 0 ? core_1.equateStringsCaseInsensitive : componentEqualityComparer;
		        if (!equalityComparer(parentComponents[i], childComponents[i])) {
		            return false;
		        }
		    }
		    return true;
		}
		
	} (path));
	return path;
}

var hasRequiredUtilities;

function requireUtilities () {
	if (hasRequiredUtilities) return utilities;
	hasRequiredUtilities = 1;
	Object.defineProperty(utilities, "__esModule", { value: true });
	utilities.matchFiles = matchFiles;
	const core_1 = requireCore();
	const path_1 = requirePath();
	// KLUDGE: Don't assume one 'node_modules' links to another. More likely a single directory inside the node_modules is the symlink.
	// ALso, don't assume that an `@foo` directory is linked. More likely the contents of that are linked.
	// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
	// It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
	// proof.
	const reservedCharacterPattern = /[^\w\s\/]/g;
	const wildcardCharCodes = [42 /* CharacterCodes.asterisk */, 63 /* CharacterCodes.question */];
	const commonPackageFolders = ['node_modules', 'bower_components', 'jspm_packages'];
	const implicitExcludePathRegexPattern = `(?!(${commonPackageFolders.join('|')})(/|$))`;
	const filesMatcher = {
	    /**
	     * Matches any single directory segment unless it is the last segment and a .min.js file
	     * Breakdown:
	     *  [^./]                   # matches everything up to the first . character (excluding directory separators)
	     *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
	     */
	    singleAsteriskRegexFragment: '([^./]|(\\.(?!min\\.js$))?)*',
	    /**
	     * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	     * files or directories, does not match subdirectories that start with a . character
	     */
	    doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
	    replaceWildcardCharacter: match => replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment),
	};
	const directoriesMatcher = {
	    singleAsteriskRegexFragment: '[^/]*',
	    /**
	     * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	     * files or directories, does not match subdirectories that start with a . character
	     */
	    doubleAsteriskRegexFragment: `(/${implicitExcludePathRegexPattern}[^/.][^/]*)*?`,
	    replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment),
	};
	const excludeMatcher = {
	    singleAsteriskRegexFragment: '[^/]*',
	    doubleAsteriskRegexFragment: '(/.+?)?',
	    replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment),
	};
	const wildcardMatchers = {
	    files: filesMatcher,
	    directories: directoriesMatcher,
	    exclude: excludeMatcher,
	};
	function getRegularExpressionForWildcard(specs, basePath, usage) {
	    const patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
	    if (!patterns || !patterns.length) {
	        return undefined;
	    }
	    const pattern = patterns.map(pattern => `(${pattern})`).join('|');
	    // If excluding, match "foo/bar/baz...", but if including, only allow "foo".
	    const terminator = usage === 'exclude' ? '($|/)' : '$';
	    return `^(${pattern})${terminator}`;
	}
	function getRegularExpressionsForWildcards(specs, basePath, usage) {
	    if (specs === undefined || specs.length === 0) {
	        return undefined;
	    }
	    return (0, core_1.flatMap)(specs, spec => spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));
	}
	/**
	 * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
	 * and does not contain any glob characters itself.
	 */
	function isImplicitGlob(lastPathComponent) {
	    return !/[.*?]/.test(lastPathComponent);
	}
	function getSubPatternFromSpec(spec, basePath, usage, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter }) {
	    let subpattern = '';
	    let hasWrittenComponent = false;
	    const components = (0, path_1.getNormalizedPathComponents)(spec, basePath);
	    const lastComponent = (0, core_1.last)(components);
	    if (usage !== 'exclude' && lastComponent === '**') {
	        return undefined;
	    }
	    // getNormalizedPathComponents includes the separator for the root component.
	    // We need to remove to create our regex correctly.
	    components[0] = (0, path_1.removeTrailingDirectorySeparator)(components[0]);
	    if (isImplicitGlob(lastComponent)) {
	        components.push('**', '*');
	    }
	    let optionalCount = 0;
	    for (let component of components) {
	        if (component === '**') {
	            subpattern += doubleAsteriskRegexFragment;
	        }
	        else {
	            if (usage === 'directories') {
	                subpattern += '(';
	                optionalCount++;
	            }
	            if (hasWrittenComponent) {
	                subpattern += path_1.directorySeparator;
	            }
	            if (usage !== 'exclude') {
	                let componentPattern = '';
	                // The * and ? wildcards should not match directories or files that start with . if they
	                // appear first in a component. Dotted directories and files can be included explicitly
	                // like so: **/.*/.*
	                if (component.charCodeAt(0) === 42 /* CharacterCodes.asterisk */) {
	                    componentPattern += '([^./]' + singleAsteriskRegexFragment + ')?';
	                    component = component.substr(1);
	                }
	                else if (component.charCodeAt(0) === 63 /* CharacterCodes.question */) {
	                    componentPattern += '[^./]';
	                    component = component.substr(1);
	                }
	                componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
	                // Patterns should not include subfolders like node_modules unless they are
	                // explicitly included as part of the path.
	                //
	                // As an optimization, if the component pattern is the same as the component,
	                // then there definitely were no wildcard characters and we do not need to
	                // add the exclusion pattern.
	                if (componentPattern !== component) {
	                    subpattern += implicitExcludePathRegexPattern;
	                }
	                subpattern += componentPattern;
	            }
	            else {
	                subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
	            }
	        }
	        hasWrittenComponent = true;
	    }
	    while (optionalCount > 0) {
	        subpattern += ')?';
	        optionalCount--;
	    }
	    return subpattern;
	}
	function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
	    return match === '*' ? singleAsteriskRegexFragment : match === '?' ? '[^/]' : '\\' + match;
	}
	/** @param path directory of the tsconfig.json */
	function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
	    path = (0, path_1.normalizePath)(path);
	    currentDirectory = (0, path_1.normalizePath)(currentDirectory);
	    const absolutePath = (0, path_1.combinePaths)(currentDirectory, path);
	    return {
	        includeFilePatterns: (0, core_1.map)(getRegularExpressionsForWildcards(includes, absolutePath, 'files'), pattern => `^${pattern}$`),
	        includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, 'files'),
	        includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, 'directories'),
	        excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, 'exclude'),
	        basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames),
	    };
	}
	function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
	    return new RegExp(pattern, useCaseSensitiveFileNames ? '' : 'i');
	}
	/** @param path directory of the tsconfig.json */
	function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
	    path = (0, path_1.normalizePath)(path);
	    currentDirectory = (0, path_1.normalizePath)(currentDirectory);
	    const patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
	    const includeFileRegexes = patterns.includeFilePatterns
	        && patterns.includeFilePatterns.map(pattern => getRegexFromPattern(pattern, useCaseSensitiveFileNames));
	    const includeDirectoryRegex = patterns.includeDirectoryPattern
	        && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
	    const excludeRegex = patterns.excludePattern
	        && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
	    // Associate an array of results with each include regex. This keeps results in order of the "include" order.
	    // If there are no "includes", then just put everything in results[0].
	    const results = includeFileRegexes ? includeFileRegexes.map(() => []) : [[]];
	    const visited = new Map();
	    const toCanonical = (0, core_1.createGetCanonicalFileName)(useCaseSensitiveFileNames);
	    for (const basePath of patterns.basePaths) {
	        visitDirectory(basePath, (0, path_1.combinePaths)(currentDirectory, basePath), depth);
	    }
	    return (0, core_1.flatten)(results);
	    function visitDirectory(path, absolutePath, depth) {
	        const canonicalPath = toCanonical(realpath(absolutePath));
	        if (visited.has(canonicalPath)) {
	            return;
	        }
	        visited.set(canonicalPath, true);
	        const { files, directories } = getFileSystemEntries(path);
	        for (const current of (0, core_1.sort)(files, core_1.compareStringsCaseSensitive)) {
	            const name = (0, path_1.combinePaths)(path, current);
	            const absoluteName = (0, path_1.combinePaths)(absolutePath, current);
	            if (extensions && !(0, path_1.fileExtensionIsOneOf)(name, extensions)) {
	                continue;
	            }
	            if (excludeRegex && excludeRegex.test(absoluteName)) {
	                continue;
	            }
	            if (!includeFileRegexes) {
	                results[0].push(name);
	            }
	            else {
	                const includeIndex = (0, core_1.findIndex)(includeFileRegexes, re => re.test(absoluteName));
	                if (includeIndex !== -1) {
	                    results[includeIndex].push(name);
	                }
	            }
	        }
	        if (depth !== undefined) {
	            depth--;
	            if (depth === 0) {
	                return;
	            }
	        }
	        for (const current of (0, core_1.sort)(directories, core_1.compareStringsCaseSensitive)) {
	            const name = (0, path_1.combinePaths)(path, current);
	            const absoluteName = (0, path_1.combinePaths)(absolutePath, current);
	            if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName))
	                && (!excludeRegex || !excludeRegex.test(absoluteName))) {
	                visitDirectory(name, absoluteName, depth);
	            }
	        }
	    }
	}
	/**
	 * Computes the unique non-wildcard base paths amongst the provided include patterns.
	 */
	function getBasePaths(path, includes, useCaseSensitiveFileNames) {
	    // Storage for our results in the form of literal paths (e.g. the paths as written by the user).
	    const basePaths = [path];
	    if (includes) {
	        // Storage for literal base paths amongst the include patterns.
	        const includeBasePaths = [];
	        for (const include of includes) {
	            // We also need to check the relative paths by converting them to absolute and normalizing
	            // in case they escape the base path (e.g "..\somedirectory")
	            const absolute = (0, path_1.isRootedDiskPath)(include) ? include : (0, path_1.normalizePath)((0, path_1.combinePaths)(path, include));
	            // Append the literal and canonical candidate base paths.
	            includeBasePaths.push(getIncludeBasePath(absolute));
	        }
	        // Sort the offsets array using either the literal or canonical path representations.
	        includeBasePaths.sort((0, core_1.getStringComparer)(!useCaseSensitiveFileNames));
	        // Iterate over each include base path and include unique base paths that are not a
	        // subpath of an existing base path
	        for (const includeBasePath of includeBasePaths) {
	            if ((0, core_1.every)(basePaths, basePath => !(0, path_1.containsPath)(basePath, includeBasePath, path, !useCaseSensitiveFileNames))) {
	                basePaths.push(includeBasePath);
	            }
	        }
	    }
	    return basePaths;
	}
	function getIncludeBasePath(absolute) {
	    const wildcardOffset = (0, core_1.indexOfAnyCharCode)(absolute, wildcardCharCodes);
	    if (wildcardOffset < 0) {
	        // No "*" or "?" in the path
	        return !(0, path_1.hasExtension)(absolute)
	            ? absolute
	            : (0, path_1.removeTrailingDirectorySeparator)((0, path_1.getDirectoryPath)(absolute));
	    }
	    return absolute.substring(0, absolute.lastIndexOf(path_1.directorySeparator, wildcardOffset));
	}
	
	return utilities;
}

var hasRequiredCreateSys;

function requireCreateSys () {
	if (hasRequiredCreateSys) return createSys;
	hasRequiredCreateSys = 1;
	Object.defineProperty(createSys, "__esModule", { value: true });
	createSys.createSys = createSys$1;
	const path = requirePathBrowserify();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const utilities_1 = requireUtilities();
	let currentCwd = '';
	function createSys$1(sys, env, getCurrentDirectory, uriConverter) {
	    let version = 0;
	    const caseSensitive = sys?.useCaseSensitiveFileNames ?? false;
	    const root = {
	        name: '',
	        dirs: new Map(),
	        files: new Map(),
	        requestedRead: false,
	    };
	    const promises = new Set();
	    const fileWatcher = env.onDidChangeWatchedFiles?.(({ changes }) => {
	        version++;
	        for (const change of changes) {
	            const changeUri = vscode_uri_1.URI.parse(change.uri);
	            const fileName = uriConverter.asFileName(changeUri);
	            const dirName = path.dirname(fileName);
	            const baseName = path.basename(fileName);
	            const fileExists = change.type === 1
	                || change.type === 2;
	            const dir = getDir(dirName, fileExists);
	            dir.files.set(normalizeFileId(baseName), fileExists
	                ? {
	                    name: baseName,
	                    stat: {
	                        type: 1,
	                        ctime: Date.now(),
	                        mtime: Date.now(),
	                        size: -1,
	                    },
	                    requestedStat: false,
	                    requestedText: false,
	                }
	                : {
	                    name: baseName,
	                    stat: undefined,
	                    text: undefined,
	                    requestedStat: true,
	                    requestedText: true,
	                });
	        }
	    });
	    return {
	        dispose() {
	            fileWatcher?.dispose();
	        },
	        args: sys?.args ?? [],
	        newLine: sys?.newLine ?? '\n',
	        useCaseSensitiveFileNames: caseSensitive,
	        realpath: sys?.realpath,
	        write: sys?.write ?? (() => { }),
	        writeFile: sys?.writeFile ?? (() => { }),
	        createDirectory: sys?.createDirectory ?? (() => { }),
	        exit: sys?.exit ?? (() => { }),
	        getExecutingFilePath: sys?.getExecutingFilePath ?? (() => getCurrentDirectory + '/__fake__.js'),
	        getCurrentDirectory,
	        getModifiedTime,
	        readFile,
	        readDirectory,
	        getDirectories,
	        resolvePath,
	        fileExists,
	        directoryExists,
	        get version() {
	            return version;
	        },
	        async sync() {
	            while (promises.size) {
	                await Promise.all(promises);
	            }
	            return version;
	        },
	    };
	    function resolvePath(fsPath) {
	        if (sys) {
	            const currentDirectory = getCurrentDirectory();
	            if (currentCwd !== currentDirectory) {
	                currentCwd = currentDirectory;
	                // https://github.com/vuejs/language-tools/issues/2039
	                // https://github.com/vuejs/language-tools/issues/2234
	                if (sys.directoryExists(currentDirectory)) {
	                    // https://github.com/vuejs/language-tools/issues/2480
	                    try {
	                        // @ts-ignore
	                        process.chdir(currentDirectory);
	                    }
	                    catch { }
	                }
	            }
	            return sys.resolvePath(fsPath).replace(/\\/g, '/');
	        }
	        return path.resolve(fsPath).replace(/\\/g, '/');
	    }
	    function readFile(fileName, encoding) {
	        fileName = resolvePath(fileName);
	        const dirPath = path.dirname(fileName);
	        const dir = getDir(dirPath);
	        const name = path.basename(fileName);
	        readFileWorker(fileName, encoding, dir);
	        return dir.files.get(normalizeFileId(name))?.text;
	    }
	    function directoryExists(dirName) {
	        dirName = resolvePath(dirName);
	        const dir = getDir(dirName);
	        if (dir.exists === undefined) {
	            dir.exists = false;
	            const result = env.fs?.stat(uriConverter.asUri(dirName));
	            if (typeof result === 'object' && 'then' in result) {
	                const promise = result;
	                promises.add(promise);
	                result.then(result => {
	                    promises.delete(promise);
	                    dir.exists = result?.type === 2;
	                    if (dir.exists) {
	                        version++;
	                    }
	                });
	            }
	            else {
	                dir.exists = result?.type === 2;
	            }
	        }
	        return dir.exists;
	    }
	    function getModifiedTime(fileName) {
	        fileName = resolvePath(fileName);
	        const file = getFile(fileName);
	        if (!file.requestedStat) {
	            file.requestedStat = true;
	            handleStat(fileName, file);
	        }
	        return file.stat ? new Date(file.stat.mtime) : new Date(-1);
	    }
	    function fileExists(fileName) {
	        fileName = resolvePath(fileName);
	        const file = getFile(fileName);
	        const exists = () => file.text !== undefined || file.stat?.type === 1;
	        if (exists()) {
	            return true;
	        }
	        if (!file.requestedStat) {
	            file.requestedStat = true;
	            handleStat(fileName, file);
	        }
	        return exists();
	    }
	    function handleStat(fileName, file) {
	        const result = env.fs?.stat(uriConverter.asUri(fileName));
	        if (typeof result === 'object' && 'then' in result) {
	            const promise = result;
	            promises.add(promise);
	            result.then(result => {
	                promises.delete(promise);
	                if (file.stat?.type !== result?.type || file.stat?.mtime !== result?.mtime) {
	                    version++;
	                }
	                file.stat = result;
	            });
	        }
	        else {
	            file.stat = result;
	        }
	    }
	    function getFile(fileName) {
	        fileName = resolvePath(fileName);
	        const dirPath = path.dirname(fileName);
	        const baseName = path.basename(fileName);
	        const dir = getDir(dirPath);
	        let file = dir.files.get(normalizeFileId(baseName));
	        if (!file) {
	            dir.files.set(normalizeFileId(baseName), file = {
	                name: baseName,
	                requestedStat: false,
	                requestedText: false,
	            });
	        }
	        return file;
	    }
	    // for import path completion
	    function getDirectories(dirName) {
	        dirName = resolvePath(dirName);
	        readDirectoryWorker(dirName);
	        const dir = getDir(dirName);
	        return [...dir.dirs.values()]
	            .filter(dir => dir.exists)
	            .map(dir => dir.name);
	    }
	    function readDirectory(dirName, extensions, excludes, includes, depth) {
	        dirName = resolvePath(dirName);
	        const currentDirectory = getCurrentDirectory();
	        const matches = (0, utilities_1.matchFiles)(dirName, extensions, excludes, includes, caseSensitive, currentDirectory, depth, dirPath => {
	            dirPath = resolvePath(dirPath);
	            readDirectoryWorker(dirPath);
	            const dir = getDir(dirPath);
	            return {
	                files: [...dir.files.values()]
	                    .filter(file => file.stat?.type === 1)
	                    .map(file => file.name),
	                directories: [...dir.dirs.values()]
	                    .filter(dir => dir.exists)
	                    .map(dir => dir.name),
	            };
	        }, sys?.realpath ? (path => sys.realpath(path)) : (path => path));
	        return [...new Set(matches)];
	    }
	    function readFileWorker(fileName, encoding, dir) {
	        const name = path.basename(fileName);
	        let file = dir.files.get(normalizeFileId(name));
	        if (!file) {
	            dir.files.set(normalizeFileId(name), file = {
	                name,
	                requestedStat: false,
	                requestedText: false,
	            });
	        }
	        if (file.requestedText) {
	            return;
	        }
	        file.requestedText = true;
	        const uri = uriConverter.asUri(fileName);
	        const result = env.fs?.readFile(uri, encoding);
	        if (typeof result === 'object' && 'then' in result) {
	            const promise = result;
	            promises.add(promise);
	            result.then(result => {
	                promises.delete(promise);
	                if (result !== undefined) {
	                    file.text = result;
	                    if (file.stat) {
	                        file.stat.mtime++;
	                    }
	                    version++;
	                }
	            });
	        }
	        else if (result !== undefined) {
	            file.text = result;
	        }
	    }
	    function readDirectoryWorker(dirName) {
	        const dir = getDir(dirName);
	        if (dir.requestedRead) {
	            return;
	        }
	        dir.requestedRead = true;
	        const result = env.fs?.readDirectory(uriConverter.asUri(dirName || '.'));
	        if (typeof result === 'object' && 'then' in result) {
	            const promise = result;
	            promises.add(promise);
	            result.then(result => {
	                promises.delete(promise);
	                if (onReadDirectoryResult(dirName, dir, result)) {
	                    version++;
	                }
	            });
	        }
	        else {
	            onReadDirectoryResult(dirName, dir, result ?? []);
	        }
	    }
	    function onReadDirectoryResult(dirName, dir, result) {
	        // See https://github.com/microsoft/TypeScript/blob/e1a9290051a3b0cbdfbadc3adbcc155a4641522a/src/compiler/sys.ts#L1853-L1857
	        result = result.filter(([name]) => name !== '.' && name !== '..');
	        let updated = false;
	        for (const [name, _fileType] of result) {
	            let fileType = _fileType;
	            if (fileType === 64) {
	                const stat = env.fs?.stat(uriConverter.asUri(dirName + '/' + name));
	                if (typeof stat === 'object' && 'then' in stat) {
	                    const promise = stat;
	                    promises.add(promise);
	                    stat.then(stat => {
	                        promises.delete(promise);
	                        if (stat?.type === 1) {
	                            let file = dir.files.get(normalizeFileId(name));
	                            if (!file) {
	                                dir.files.set(normalizeFileId(name), file = {
	                                    name,
	                                    requestedStat: false,
	                                    requestedText: false,
	                                });
	                            }
	                            if (stat.type !== file.stat?.type || stat.mtime !== file.stat?.mtime) {
	                                version++;
	                            }
	                            file.stat = stat;
	                            file.requestedStat = true;
	                        }
	                        else if (stat?.type === 2) {
	                            const childDir = getDirFromDir(dir, name);
	                            if (!childDir.exists) {
	                                childDir.exists = true;
	                                version++;
	                            }
	                        }
	                    });
	                }
	                else if (stat) {
	                    fileType = stat.type;
	                }
	            }
	            if (fileType === 1) {
	                let file = dir.files.get(normalizeFileId(name));
	                if (!file) {
	                    dir.files.set(normalizeFileId(name), file = {
	                        name,
	                        requestedStat: false,
	                        requestedText: false,
	                    });
	                }
	                if (!file.stat) {
	                    file.stat = {
	                        type: 1,
	                        mtime: 0,
	                        ctime: 0,
	                        size: 0,
	                    };
	                    updated = true;
	                }
	            }
	            else if (fileType === 2) {
	                const childDir = getDirFromDir(dir, name);
	                if (!childDir.exists) {
	                    childDir.exists = true;
	                    updated = true;
	                }
	            }
	        }
	        return updated;
	    }
	    function getDir(dirName, markExists = false) {
	        const dirNames = [];
	        let currentDirPath = dirName;
	        let currentDirName = path.basename(currentDirPath);
	        let lastDirPath;
	        while (lastDirPath !== currentDirPath) {
	            lastDirPath = currentDirPath;
	            dirNames.push(currentDirName);
	            currentDirPath = path.dirname(currentDirPath);
	            currentDirName = path.basename(currentDirPath);
	        }
	        let currentDir = root;
	        for (let i = dirNames.length - 1; i >= 0; i--) {
	            const nextDirName = dirNames[i];
	            currentDir = getDirFromDir(currentDir, nextDirName);
	            if (markExists && !currentDir.exists) {
	                currentDir.exists = true;
	                version++;
	            }
	        }
	        return currentDir;
	    }
	    function getDirFromDir(dir, name) {
	        let target = dir.dirs.get(normalizeFileId(name));
	        if (!target) {
	            dir.dirs.set(normalizeFileId(name), target = {
	                name,
	                dirs: new Map(),
	                files: new Map(),
	            });
	        }
	        return target;
	    }
	    function normalizeFileId(fileName) {
	        return caseSensitive ? fileName : fileName.toLowerCase();
	    }
	}
	
	return createSys;
}

var hasRequiredTypescript;

function requireTypescript () {
	if (hasRequiredTypescript) return typescript;
	hasRequiredTypescript = 1;
	(function (exports$1) {
		var __createBinding = (typescript && typescript.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (typescript && typescript.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		__exportStar(requireCommon$1(), exports$1);
		__exportStar(requireDecorateLanguageServiceHost(), exports$1);
		__exportStar(requireDecorateProgram(), exports$1);
		__exportStar(requireProxyCreateProgram(), exports$1);
		__exportStar(requireProxyLanguageService(), exports$1);
		__exportStar(requireCreateProject(), exports$1);
		__exportStar(requireCreateSys(), exports$1);
		
	} (typescript));
	return typescript;
}

var hasRequiredTypescriptProjectLs;

function requireTypescriptProjectLs () {
	if (hasRequiredTypescriptProjectLs) return typescriptProjectLs;
	hasRequiredTypescriptProjectLs = 1;
	Object.defineProperty(typescriptProjectLs, "__esModule", { value: true });
	typescriptProjectLs.createTypeScriptLS = createTypeScriptLS;
	const language_service_1 = requireLanguageService();
	const typescript_1 = requireTypescript();
	const utilities_1 = requireUtilities();
	const path = requirePathBrowserify();
	const vscode = requireMain$2();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const fsFileSnapshots = (0, language_service_1.createUriMap)();
	async function createTypeScriptLS(ts, tsLocalized, tsconfig, server, serviceEnv, workspaceFolder, uriConverter, create) {
	    let commandLine;
	    let projectVersion = 0;
	    const getCurrentDirectory = () => uriConverter.asFileName(workspaceFolder);
	    const sys = (0, typescript_1.createSys)(ts.sys, serviceEnv, getCurrentDirectory, uriConverter);
	    const projectHost = {
	        getCurrentDirectory,
	        getProjectVersion() {
	            return projectVersion.toString();
	        },
	        getScriptFileNames() {
	            return commandLine.fileNames;
	        },
	        getCompilationSettings() {
	            return commandLine.options;
	        },
	        getLocalizedDiagnosticMessages: tsLocalized ? () => tsLocalized : undefined,
	        getProjectReferences() {
	            return commandLine.projectReferences;
	        },
	    };
	    const { languagePlugins, setup } = await create({
	        env: serviceEnv,
	        configFileName: typeof tsconfig === 'string' ? tsconfig : undefined,
	        projectHost,
	        sys,
	        uriConverter,
	    });
	    const unsavedRootFileUris = (0, language_service_1.createUriMap)();
	    const disposables = [
	        server.documents.onDidOpen(({ document }) => updateFsCacheFromSyncedDocument(document)),
	        server.documents.onDidSave(({ document }) => updateFsCacheFromSyncedDocument(document)),
	        server.documents.onDidChangeContent(() => projectVersion++),
	        serviceEnv.onDidChangeWatchedFiles?.(async ({ changes }) => {
	            const createdOrDeleted = changes.some(change => change.type !== vscode.FileChangeType.Changed);
	            if (createdOrDeleted) {
	                await updateCommandLine();
	            }
	            projectVersion++;
	        }),
	        server.documents.onDidOpen(async ({ document }) => {
	            const uri = vscode_uri_1.URI.parse(document.uri);
	            const isWorkspaceFile = workspaceFolder.scheme === uri.scheme;
	            if (!isWorkspaceFile) {
	                return;
	            }
	            const stat = await serviceEnv.fs?.stat(uri);
	            const isUnsaved = stat?.type !== 1;
	            if (isUnsaved) {
	                const lastProjectVersion = projectVersion;
	                await updateCommandLine();
	                if (lastProjectVersion !== projectVersion) {
	                    unsavedRootFileUris.set(uri, true);
	                }
	            }
	        }),
	        server.documents.onDidClose(async ({ document }) => {
	            const uri = vscode_uri_1.URI.parse(document.uri);
	            if (unsavedRootFileUris.has(uri)) {
	                unsavedRootFileUris.delete(uri);
	                await updateCommandLine();
	            }
	        }),
	    ].filter(d => !!d);
	    await updateCommandLine();
	    const language = (0, language_service_1.createLanguage)([
	        { getLanguageId: uri => server.documents.get(uri)?.languageId },
	        ...languagePlugins,
	        { getLanguageId: uri => (0, typescript_1.resolveFileLanguageId)(uri.path) },
	    ], (0, language_service_1.createUriMap)(sys.useCaseSensitiveFileNames), (uri, includeFsFiles) => {
	        const syncedDocument = server.documents.get(uri);
	        let snapshot;
	        if (syncedDocument) {
	            snapshot = syncedDocument.getSnapshot();
	        }
	        else if (includeFsFiles) {
	            const cache = fsFileSnapshots.get(uri);
	            const fileName = uriConverter.asFileName(uri);
	            const modifiedTime = sys.getModifiedTime?.(fileName)?.valueOf();
	            if (!cache || cache[0] !== modifiedTime) {
	                if (sys.fileExists(fileName)) {
	                    const text = sys.readFile(fileName);
	                    const snapshot = text !== undefined ? ts.ScriptSnapshot.fromString(text) : undefined;
	                    fsFileSnapshots.set(uri, [modifiedTime, snapshot]);
	                }
	                else {
	                    fsFileSnapshots.set(uri, [modifiedTime, undefined]);
	                }
	            }
	            snapshot = fsFileSnapshots.get(uri)?.[1];
	        }
	        if (snapshot) {
	            language.scripts.set(uri, snapshot);
	        }
	        else {
	            language.scripts.delete(uri);
	        }
	    });
	    const project = {
	        typescript: {
	            configFileName: typeof tsconfig === 'string' ? tsconfig : undefined,
	            sys,
	            uriConverter,
	            ...(0, typescript_1.createLanguageServiceHost)(ts, sys, language, s => uriConverter.asUri(s), projectHost),
	        },
	    };
	    setup?.({ language, project });
	    const languageService = (0, language_service_1.createLanguageService)(language, server.languageServicePlugins, serviceEnv, project);
	    return {
	        languageService,
	        tryAddFile(fileName) {
	            if (!commandLine.fileNames.includes(fileName)) {
	                commandLine.fileNames.push(fileName);
	                projectVersion++;
	            }
	        },
	        dispose: () => {
	            sys.dispose();
	            languageService?.dispose();
	            disposables.forEach(({ dispose }) => dispose());
	            disposables.length = 0;
	        },
	        getCommandLine: () => commandLine,
	    };
	    function updateFsCacheFromSyncedDocument(document) {
	        const uri = vscode_uri_1.URI.parse(document.uri);
	        const fileName = uriConverter.asFileName(uri);
	        if (fsFileSnapshots.has(uri) || sys.fileExists(fileName)) {
	            const modifiedTime = sys.getModifiedTime?.(fileName);
	            fsFileSnapshots.set(uri, [modifiedTime?.valueOf(), document.getSnapshot()]);
	        }
	    }
	    async function updateCommandLine() {
	        const oldFileNames = new Set(commandLine?.fileNames ?? []);
	        commandLine = await parseConfig(ts, sys, uriConverter.asFileName(workspaceFolder), tsconfig, languagePlugins.map(plugin => plugin.typescript?.extraFileExtensions ?? []).flat());
	        const newFileNames = new Set(commandLine.fileNames);
	        if (oldFileNames.size !== newFileNames.size || [...oldFileNames].some(fileName => !newFileNames.has(fileName))) {
	            projectVersion++;
	        }
	    }
	    async function parseConfig(ts, sys, workspacePath, tsconfig, extraFileExtensions) {
	        let commandLine = {
	            errors: [],
	            fileNames: [],
	            options: {},
	        };
	        let sysVersion;
	        let newSysVersion = await sys.sync();
	        while (sysVersion !== newSysVersion) {
	            sysVersion = newSysVersion;
	            try {
	                commandLine = parseConfigWorker(ts, sys, workspacePath, tsconfig, extraFileExtensions);
	            }
	            catch {
	                // will be failed if web fs host first result not ready
	            }
	            newSysVersion = await sys.sync();
	        }
	        return commandLine;
	    }
	    function parseConfigWorker(ts, _host, workspacePath, tsconfig, extraFileExtensions) {
	        let content = {
	            errors: [],
	            fileNames: [],
	            options: {},
	        };
	        const maybeUnsavedFileNames = server.documents.all()
	            .map(document => vscode_uri_1.URI.parse(document.uri))
	            .filter(uri => uri.scheme === workspaceFolder.scheme)
	            .map(uri => uriConverter.asFileName(uri));
	        const host = {
	            ..._host,
	            readDirectory(rootDir, extensions, excludes, includes, depth) {
	                const fsFiles = _host.readDirectory(rootDir, extensions, excludes, includes, depth);
	                const unsavedFiles = (0, utilities_1.matchFiles)(rootDir, extensions, excludes, includes, sys.useCaseSensitiveFileNames, getCurrentDirectory(), depth, dirPath => {
	                    dirPath = dirPath.replace(/\\/g, '/');
	                    const files = [];
	                    const dirs = [];
	                    for (const fileName of maybeUnsavedFileNames) {
	                        const match = sys.useCaseSensitiveFileNames
	                            ? fileName.startsWith(dirPath + '/')
	                            : fileName.toLowerCase().startsWith(dirPath.toLowerCase() + '/');
	                        if (match) {
	                            const name = fileName.slice(dirPath.length + 1);
	                            if (name.includes('/')) {
	                                const dir = name.split('/')[0];
	                                if (!dirs.includes(dir)) {
	                                    dirs.push(dir);
	                                }
	                            }
	                            else {
	                                files.push(name);
	                            }
	                        }
	                    }
	                    return {
	                        files,
	                        directories: dirs,
	                    };
	                }, path => path);
	                if (!unsavedFiles.length) {
	                    return fsFiles;
	                }
	                return [...new Set([...fsFiles, ...unsavedFiles])];
	            },
	        };
	        if (typeof tsconfig === 'string') {
	            const config = ts.readJsonConfigFile(tsconfig, host.readFile);
	            content = ts.parseJsonSourceFileConfigFileContent(config, host, path.dirname(tsconfig), {}, tsconfig, undefined, extraFileExtensions);
	        }
	        else {
	            content = ts.parseJsonConfigFileContent({ files: [] }, host, workspacePath, tsconfig, workspacePath + '/jsconfig.json', undefined, extraFileExtensions);
	        }
	        // fix https://github.com/johnsoncodehk/volar/issues/1786
	        // https://github.com/microsoft/TypeScript/issues/30457
	        // patching ts server broke with outDir + rootDir + composite/incremental
	        content.options.outDir = undefined;
	        content.fileNames = content.fileNames.map(fileName => fileName.replace(/\\/g, '/'));
	        return content;
	    }
	}
	
	return typescriptProjectLs;
}

var hasRequiredTypescriptProject;

function requireTypescriptProject () {
	if (hasRequiredTypescriptProject) return typescriptProject;
	hasRequiredTypescriptProject = 1;
	Object.defineProperty(typescriptProject, "__esModule", { value: true });
	typescriptProject.createTypeScriptProject = createTypeScriptProject;
	typescriptProject.createUriConverter = createUriConverter;
	typescriptProject.sortTSConfigs = sortTSConfigs;
	typescriptProject.isFileInDir = isFileInDir;
	typescriptProject.getWorkspaceFolder = getWorkspaceFolder;
	const language_service_1 = requireLanguageService();
	const path = requirePathBrowserify();
	const vscode = requireMain$2();
	const vscode_uri_1 = /*@__PURE__*/ requireUmd();
	const inferredCompilerOptions_1 = requireInferredCompilerOptions();
	const simpleProject_1 = requireSimpleProject();
	const typescriptProjectLs_1 = requireTypescriptProjectLs();
	const rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
	function createTypeScriptProject(ts, tsLocalized, create) {
	    let server;
	    let uriConverter;
	    const configProjects = (0, language_service_1.createUriMap)();
	    const inferredProjects = (0, language_service_1.createUriMap)();
	    const rootTsConfigs = new Set();
	    const searchedDirs = new Set();
	    return {
	        setup(_server) {
	            uriConverter = createUriConverter(_server.workspaceFolders.all);
	            server = _server;
	            server.fileWatcher.onDidChangeWatchedFiles(({ changes }) => {
	                const tsConfigChanges = changes.filter(change => rootTsConfigNames.includes(change.uri.substring(change.uri.lastIndexOf('/') + 1)));
	                for (const change of tsConfigChanges) {
	                    const changeUri = vscode_uri_1.URI.parse(change.uri);
	                    const changeFileName = uriConverter.asFileName(changeUri);
	                    if (change.type === vscode.FileChangeType.Created) {
	                        rootTsConfigs.add(changeFileName);
	                    }
	                    else if ((change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Deleted)
	                        && configProjects.has(changeUri)) {
	                        if (change.type === vscode.FileChangeType.Deleted) {
	                            rootTsConfigs.delete(changeFileName);
	                        }
	                        const project = configProjects.get(changeUri);
	                        configProjects.delete(changeUri);
	                        project?.then(project => project.dispose());
	                    }
	                }
	                server.languageFeatures.requestRefresh(!!tsConfigChanges.length);
	            });
	        },
	        async getLanguageService(uri) {
	            const tsconfig = await findMatchTSConfig(server, uri);
	            if (tsconfig) {
	                const project = await getOrCreateConfiguredProject(server, tsconfig);
	                return project.languageService;
	            }
	            const workspaceFolder = getWorkspaceFolder(uri, server.workspaceFolders);
	            const project = await getOrCreateInferredProject(server, uri, workspaceFolder);
	            return project.languageService;
	        },
	        async getExistingLanguageServices() {
	            const projects = await Promise.all([
	                ...configProjects.values() ?? [],
	                ...inferredProjects.values() ?? [],
	            ]);
	            return projects.map(project => project.languageService);
	        },
	        reload() {
	            for (const project of [
	                ...configProjects.values() ?? [],
	                ...inferredProjects.values() ?? [],
	            ]) {
	                project.then(p => p.dispose());
	            }
	            configProjects.clear();
	            inferredProjects.clear();
	        },
	    };
	    async function findMatchTSConfig(server, uri) {
	        const fileName = uriConverter.asFileName(uri);
	        let dir = path.dirname(fileName);
	        while (true) {
	            if (searchedDirs.has(dir)) {
	                break;
	            }
	            searchedDirs.add(dir);
	            for (const tsConfigName of rootTsConfigNames) {
	                const tsconfigPath = path.join(dir, tsConfigName);
	                if ((await server.fileSystem.stat?.(uriConverter.asUri(tsconfigPath)))?.type === language_service_1.FileType.File) {
	                    rootTsConfigs.add(tsconfigPath);
	                }
	            }
	            dir = path.dirname(dir);
	        }
	        await prepareClosestootCommandLine();
	        return await findDirectIncludeTsconfig() ?? await findIndirectReferenceTsconfig();
	        async function prepareClosestootCommandLine() {
	            let matches = [];
	            for (const rootTsConfig of rootTsConfigs) {
	                if (isFileInDir(fileName, path.dirname(rootTsConfig))) {
	                    matches.push(rootTsConfig);
	                }
	            }
	            matches = matches.sort((a, b) => sortTSConfigs(fileName, a, b));
	            if (matches.length) {
	                await getCommandLine(matches[0]);
	            }
	        }
	        function findIndirectReferenceTsconfig() {
	            return findTSConfig(async (tsconfig) => {
	                const tsconfigUri = uriConverter.asUri(tsconfig);
	                const project = await configProjects.get(tsconfigUri);
	                const languageService = project?.languageService.context.inject('typescript/languageService');
	                return !!languageService?.getProgram()?.getSourceFile(fileName);
	            });
	        }
	        function findDirectIncludeTsconfig() {
	            return findTSConfig(async (tsconfig) => {
	                const map = (0, language_service_1.createUriMap)();
	                const commandLine = await getCommandLine(tsconfig);
	                for (const fileName of commandLine?.fileNames ?? []) {
	                    const uri = uriConverter.asUri(fileName);
	                    map.set(uri, true);
	                }
	                return map.has(uri);
	            });
	        }
	        async function findTSConfig(match) {
	            const checked = new Set();
	            for (const rootTsConfig of [...rootTsConfigs].sort((a, b) => sortTSConfigs(fileName, a, b))) {
	                const tsconfigUri = uriConverter.asUri(rootTsConfig);
	                const project = await configProjects.get(tsconfigUri);
	                if (project) {
	                    let chains = await getReferencesChains(project.getCommandLine(), rootTsConfig, []);
	                    // This is to be consistent with tsserver behavior
	                    chains = chains.reverse();
	                    for (const chain of chains) {
	                        for (let i = chain.length - 1; i >= 0; i--) {
	                            const tsconfig = chain[i];
	                            if (checked.has(tsconfig)) {
	                                continue;
	                            }
	                            checked.add(tsconfig);
	                            if (await match(tsconfig)) {
	                                return tsconfig;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        async function getReferencesChains(commandLine, tsConfig, before) {
	            if (commandLine.projectReferences?.length) {
	                const newChains = [];
	                for (const projectReference of commandLine.projectReferences) {
	                    let tsConfigPath = projectReference.path.replace(/\\/g, '/');
	                    // fix https://github.com/johnsoncodehk/volar/issues/712
	                    if ((await server.fileSystem.stat?.(uriConverter.asUri(tsConfigPath)))?.type === language_service_1.FileType.File) {
	                        const newTsConfigPath = path.join(tsConfigPath, 'tsconfig.json');
	                        const newJsConfigPath = path.join(tsConfigPath, 'jsconfig.json');
	                        if ((await server.fileSystem.stat?.(uriConverter.asUri(newTsConfigPath)))?.type === language_service_1.FileType.File) {
	                            tsConfigPath = newTsConfigPath;
	                        }
	                        else if ((await server.fileSystem.stat?.(uriConverter.asUri(newJsConfigPath)))?.type === language_service_1.FileType.File) {
	                            tsConfigPath = newJsConfigPath;
	                        }
	                    }
	                    const beforeIndex = before.indexOf(tsConfigPath); // cycle
	                    if (beforeIndex >= 0) {
	                        newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
	                    }
	                    else {
	                        const referenceCommandLine = await getCommandLine(tsConfigPath);
	                        if (referenceCommandLine) {
	                            for (const chain of await getReferencesChains(referenceCommandLine, tsConfigPath, [...before, tsConfig])) {
	                                newChains.push(chain);
	                            }
	                        }
	                    }
	                }
	                return newChains;
	            }
	            else {
	                return [[...before, tsConfig]];
	            }
	        }
	        async function getCommandLine(tsConfig) {
	            const project = await getOrCreateConfiguredProject(server, tsConfig);
	            return project?.getCommandLine();
	        }
	    }
	    function getOrCreateConfiguredProject(server, tsconfig) {
	        tsconfig = tsconfig.replace(/\\/g, '/');
	        const tsconfigUri = uriConverter.asUri(tsconfig);
	        let projectPromise = configProjects.get(tsconfigUri);
	        if (!projectPromise) {
	            const workspaceFolder = getWorkspaceFolder(tsconfigUri, server.workspaceFolders);
	            const serviceEnv = (0, simpleProject_1.createLanguageServiceEnvironment)(server, [workspaceFolder]);
	            projectPromise = (0, typescriptProjectLs_1.createTypeScriptLS)(ts, tsLocalized, tsconfig, server, serviceEnv, workspaceFolder, uriConverter, create);
	            configProjects.set(tsconfigUri, projectPromise);
	        }
	        return projectPromise;
	    }
	    async function getOrCreateInferredProject(server, uri, workspaceFolder) {
	        if (!inferredProjects.has(workspaceFolder)) {
	            inferredProjects.set(workspaceFolder, (async () => {
	                const inferOptions = await (0, inferredCompilerOptions_1.getInferredCompilerOptions)(server);
	                const serviceEnv = (0, simpleProject_1.createLanguageServiceEnvironment)(server, [workspaceFolder]);
	                return (0, typescriptProjectLs_1.createTypeScriptLS)(ts, tsLocalized, inferOptions, server, serviceEnv, workspaceFolder, uriConverter, create);
	            })());
	        }
	        const project = await inferredProjects.get(workspaceFolder);
	        project.tryAddFile(uriConverter.asFileName(uri));
	        return project;
	    }
	}
	function createUriConverter(rootFolders) {
	    const encodeds = new Map();
	    const isFileScheme = rootFolders.every(folder => folder.scheme === 'file');
	    const fragmentPrefix = '/' + encodeURIComponent('#');
	    return {
	        asFileName,
	        asUri,
	    };
	    function asFileName(parsed) {
	        if (rootFolders.every(folder => folder.scheme === parsed.scheme && folder.authority === parsed.authority)) {
	            if (isFileScheme) {
	                return parsed.fsPath.replace(/\\/g, '/');
	            }
	            else {
	                return parsed.path;
	            }
	        }
	        const encoded = encodeURIComponent(`${parsed.scheme}://${parsed.authority}`);
	        encodeds.set(encoded, parsed);
	        const fragment = parsed.fragment ? fragmentPrefix + encodeURIComponent(parsed.fragment) : '';
	        return `/${encoded}${parsed.path}${fragment}`;
	    }
	    function asUri(fileName) {
	        for (const [encoded, uri] of encodeds) {
	            const prefix = `/${encoded}`;
	            if (fileName === prefix) {
	                return vscode_uri_1.URI.from({
	                    scheme: uri.scheme,
	                    authority: uri.authority,
	                });
	            }
	            if (uri.authority) {
	                if (fileName.startsWith(prefix + '/')) {
	                    return vscode_uri_1.URI.from({
	                        scheme: uri.scheme,
	                        authority: uri.authority,
	                        ...getComponents(fileName, prefix.length),
	                    });
	                }
	            }
	            else {
	                if (fileName.startsWith(prefix)) {
	                    return vscode_uri_1.URI.from({
	                        scheme: uri.scheme,
	                        authority: uri.authority,
	                        ...getComponents(fileName, prefix.length),
	                    });
	                }
	            }
	        }
	        if (!isFileScheme) {
	            for (const folder of rootFolders) {
	                return vscode_uri_1.URI.parse(`${folder.scheme}://${folder.authority}${fileName}`);
	            }
	        }
	        return vscode_uri_1.URI.file(fileName);
	    }
	    function getComponents(fileName, prefixLength) {
	        // Fragment is present when the fileName contains the fragment prefix and is not followed by a slash.
	        const fragmentPosition = fileName.lastIndexOf(fragmentPrefix);
	        if (fragmentPosition >= prefixLength) {
	            if (fileName.indexOf('/', fragmentPosition + fragmentPrefix.length) < 0) {
	                return {
	                    path: fileName.substring(prefixLength, fragmentPosition),
	                    fragment: decodeURIComponent(fileName.substring(fragmentPosition + fragmentPrefix.length)),
	                };
	            }
	        }
	        return {
	            path: fileName.substring(prefixLength),
	        };
	    }
	}
	function sortTSConfigs(file, a, b) {
	    const inA = isFileInDir(file, path.dirname(a));
	    const inB = isFileInDir(file, path.dirname(b));
	    if (inA !== inB) {
	        const aWeight = inA ? 1 : 0;
	        const bWeight = inB ? 1 : 0;
	        return bWeight - aWeight;
	    }
	    const aLength = a.split('/').length;
	    const bLength = b.split('/').length;
	    if (aLength === bLength) {
	        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
	        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
	        return bWeight - aWeight;
	    }
	    return bLength - aLength;
	}
	function isFileInDir(fileName, dir) {
	    const relative = path.relative(dir, fileName);
	    return !!relative && !relative.startsWith('..') && !path.isAbsolute(relative);
	}
	function getWorkspaceFolder(uri, workspaceFolders) {
	    while (true) {
	        if (workspaceFolders.has(uri)) {
	            return uri;
	        }
	        const next = uri.with({ path: uri.path.substring(0, uri.path.lastIndexOf('/')) });
	        if (next.path === uri.path) {
	            break;
	        }
	        uri = next;
	    }
	    for (const folder of workspaceFolders.all) {
	        return folder;
	    }
	    return uri.with({ path: '/' });
	}
	
	return typescriptProject;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node$4;
	hasRequiredNode = 1;
	(function (exports$1) {
		var __createBinding = (node$4 && node$4.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (node$4 && node$4.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createConnection = createConnection;
		exports$1.createServer = createServer;
		exports$1.loadTsdkByPath = loadTsdkByPath;
		const vscode = requireNode$2();
		const http_1 = requireHttp();
		const node_1 = requireNode$1();
		const server_1 = requireServer();
		__exportStar(requireNode$2(), exports$1);
		__exportStar(requireLanguageServer(), exports$1);
		__exportStar(requireSimpleProject(), exports$1);
		__exportStar(requireTypescriptProject(), exports$1);
		__exportStar(requireServer(), exports$1);
		function createConnection() {
		    return vscode.createConnection(vscode.ProposedFeatures.all);
		}
		function createServer(connection) {
		    const server = (0, server_1.createServerBase)(connection, {
		        timer: {
		            setImmediate: setImmediate,
		        },
		    });
		    server.fileSystem.install('file', node_1.provider);
		    server.fileSystem.install('http', http_1.provider);
		    server.fileSystem.install('https', http_1.provider);
		    server.onInitialized(() => (0, http_1.listenEditorSettings)(server));
		    return server;
		}
		function loadTsdkByPath(tsdk, locale) {
		    locale = locale?.toLowerCase();
		    // webpack compatibility
		    const _require = eval('require');
		    return {
		        typescript: loadLib(),
		        diagnosticMessages: loadLocalizedDiagnosticMessages(),
		    };
		    function loadLib() {
		        for (const name of ['./typescript.js', './tsserverlibrary.js']) {
		            try {
		                return _require(_require.resolve(name, { paths: [tsdk] }));
		            }
		            catch { }
		        }
		        // for bun
		        for (const name of ['typescript.js', 'tsserverlibrary.js']) {
		            try {
		                return _require(tsdk + '/' + name);
		            }
		            catch { }
		        }
		        throw new Error(`Can't find typescript.js or tsserverlibrary.js in ${JSON.stringify(tsdk)}`);
		    }
		    function loadLocalizedDiagnosticMessages() {
		        if (locale === 'en') {
		            return;
		        }
		        try {
		            const path = _require.resolve(`./${locale}/diagnosticMessages.generated.json`, { paths: [tsdk] });
		            return _require(path);
		        }
		        catch { }
		    }
		}
		
	} (node$4));
	return node$4;
}

var nodeExports = requireNode();

function _define_property$j(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class LogUtil {
    static log(...datas) {
        // JsonUtil.log(data)
        try {
            const timestamp = new Date().toISOString();
            let logMessage = `\n[${timestamp}]`;
            for (const data of datas){
                if (data !== undefined) {
                    if (typeof data === 'object') {
                        logMessage += '\n' + JSON.stringify(data, null, 2);
                    } else {
                        logMessage += '\n' + String(data);
                    }
                }
            }
            logMessage += '\n' + '='.repeat(80) + '\n';
            fs__namespace.appendFileSync(this.logFilePath, logMessage);
        } catch (error) {
            console.error('Failed to write log:', error);
        }
    }
    static clear() {
        try {
            fs__namespace.writeFileSync(this.logFilePath, '=== Log Cleared ===\n');
        } catch (error) {
            console.error('Failed to clear log:', error);
        }
    }
}
_define_property$j(LogUtil, "logFilePath", void 0);
(()=>{
    //  CJS  ESM __dirnameCJS 
    // @ts-ignore - __dirname  CJS 
    const dir = typeof __dirname !== 'undefined' ? __dirname : process.cwd();
    LogUtil.logFilePath = path__namespace.join(dir, 'templog.txt');
    // 
    if (!fs__namespace.existsSync(LogUtil.logFilePath)) {
        fs__namespace.writeFileSync(LogUtil.logFilePath, '=== Log Started ===\n');
    }
})();

var main = {};

var ral = {};

var hasRequiredRal;

function requireRal () {
	if (hasRequiredRal) return ral;
	hasRequiredRal = 1;
	Object.defineProperty(ral, "__esModule", { value: true });
	var _ral;
	function RAL() {
	    if (_ral === undefined) {
	        throw new Error("No runtime abstraction layer installed");
	    }
	    return _ral;
	}
	(function (RAL) {
	    function install(ral) {
	        if (ral === undefined) {
	            throw new Error("No runtime abstraction layer provided");
	        }
	        _ral = ral;
	    }
	    RAL.install = install;
	})(RAL || (RAL = {}));
	ral.default = RAL;
	
	return ral;
}

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.config = exports$1.loadMessageBundle = exports$1.localize = exports$1.format = exports$1.setPseudo = exports$1.isPseudo = exports$1.isDefined = exports$1.BundleFormat = exports$1.MessageFormat = void 0;
		var ral_1 = requireRal();
		(function (MessageFormat) {
		    MessageFormat["file"] = "file";
		    MessageFormat["bundle"] = "bundle";
		    MessageFormat["both"] = "both";
		})(exports$1.MessageFormat || (exports$1.MessageFormat = {}));
		(function (BundleFormat) {
		    // the nls.bundle format
		    BundleFormat["standalone"] = "standalone";
		    BundleFormat["languagePack"] = "languagePack";
		})(exports$1.BundleFormat || (exports$1.BundleFormat = {}));
		var LocalizeInfo;
		(function (LocalizeInfo) {
		    function is(value) {
		        var candidate = value;
		        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
		    }
		    LocalizeInfo.is = is;
		})(LocalizeInfo || (LocalizeInfo = {}));
		function isDefined(value) {
		    return typeof value !== 'undefined';
		}
		exports$1.isDefined = isDefined;
		exports$1.isPseudo = false;
		function setPseudo(pseudo) {
		    exports$1.isPseudo = pseudo;
		}
		exports$1.setPseudo = setPseudo;
		function format(message, args) {
		    var result;
		    if (exports$1.isPseudo) {
		        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
		        message = '\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\uFF3D';
		    }
		    if (args.length === 0) {
		        result = message;
		    }
		    else {
		        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
		            var index = rest[0];
		            var arg = args[index];
		            var replacement = match;
		            if (typeof arg === 'string') {
		                replacement = arg;
		            }
		            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {
		                replacement = String(arg);
		            }
		            return replacement;
		        });
		    }
		    return result;
		}
		exports$1.format = format;
		function localize(_key, message) {
		    var args = [];
		    for (var _i = 2; _i < arguments.length; _i++) {
		        args[_i - 2] = arguments[_i];
		    }
		    return format(message, args);
		}
		exports$1.localize = localize;
		function loadMessageBundle(file) {
		    return (0, ral_1.default)().loadMessageBundle(file);
		}
		exports$1.loadMessageBundle = loadMessageBundle;
		function config(opts) {
		    return (0, ral_1.default)().config(opts);
		}
		exports$1.config = config;
		
	} (common));
	return common;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main;
	hasRequiredMain = 1;
	(function (exports$1) {
		/* --------------------------------------------------------------------------------------------
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License. See License.txt in the project root for license information.
		 * ------------------------------------------------------------------------------------------ */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.config = exports$1.loadMessageBundle = exports$1.BundleFormat = exports$1.MessageFormat = void 0;
		var path = path$1;
		var fs$1 = fs;
		var ral_1 = requireRal();
		var common_1 = requireCommon();
		var common_2 = requireCommon();
		Object.defineProperty(exports$1, "MessageFormat", { enumerable: true, get: function () { return common_2.MessageFormat; } });
		Object.defineProperty(exports$1, "BundleFormat", { enumerable: true, get: function () { return common_2.BundleFormat; } });
		var toString = Object.prototype.toString;
		function isNumber(value) {
		    return toString.call(value) === '[object Number]';
		}
		function isString(value) {
		    return toString.call(value) === '[object String]';
		}
		function isBoolean(value) {
		    return value === true || value === false;
		}
		function readJsonFileSync(filename) {
		    return JSON.parse(fs$1.readFileSync(filename, 'utf8'));
		}
		var resolvedBundles;
		var options;
		function initializeSettings() {
		    options = { locale: undefined, language: undefined, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_1.MessageFormat.bundle };
		    if (isString(process.env.VSCODE_NLS_CONFIG)) {
		        try {
		            var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);
		            var language = void 0;
		            if (vscodeOptions_1.availableLanguages) {
		                var value = vscodeOptions_1.availableLanguages['*'];
		                if (isString(value)) {
		                    language = value;
		                }
		            }
		            if (isString(vscodeOptions_1.locale)) {
		                options.locale = vscodeOptions_1.locale.toLowerCase();
		            }
		            if (language === undefined) {
		                options.language = options.locale;
		            }
		            else if (language !== 'en') {
		                options.language = language;
		            }
		            if (isBoolean(vscodeOptions_1._languagePackSupport)) {
		                options.languagePackSupport = vscodeOptions_1._languagePackSupport;
		            }
		            if (isString(vscodeOptions_1._cacheRoot)) {
		                options.cacheRoot = vscodeOptions_1._cacheRoot;
		            }
		            if (isString(vscodeOptions_1._languagePackId)) {
		                options.languagePackId = vscodeOptions_1._languagePackId;
		            }
		            if (isString(vscodeOptions_1._translationsConfigFile)) {
		                options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;
		                try {
		                    options.translationsConfig = readJsonFileSync(options.translationsConfigFile);
		                }
		                catch (error) {
		                    // We can't read the translation config file. Mark the cache as corrupted.
		                    if (vscodeOptions_1._corruptedFile) {
		                        var dirname = path.dirname(vscodeOptions_1._corruptedFile);
		                        fs$1.exists(dirname, function (exists) {
		                            if (exists) {
		                                fs$1.writeFile(vscodeOptions_1._corruptedFile, 'corrupted', 'utf8', function (err) {
		                                    console.error(err);
		                                });
		                            }
		                        });
		                    }
		                }
		            }
		        }
		        catch (_a) {
		            // Do nothing.
		        }
		    }
		    (0, common_1.setPseudo)(options.locale === 'pseudo');
		    resolvedBundles = Object.create(null);
		}
		initializeSettings();
		function supportsLanguagePack() {
		    return options.languagePackSupport === true && options.cacheRoot !== undefined && options.languagePackId !== undefined && options.translationsConfigFile !== undefined
		        && options.translationsConfig !== undefined;
		}
		function createScopedLocalizeFunction(messages) {
		    return function (key, message) {
		        var args = [];
		        for (var _i = 2; _i < arguments.length; _i++) {
		            args[_i - 2] = arguments[_i];
		        }
		        if (isNumber(key)) {
		            if (key >= messages.length) {
		                console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: ".concat(new Error('').stack));
		                return;
		            }
		            return (0, common_1.format)(messages[key], args);
		        }
		        else {
		            if (isString(message)) {
		                console.warn("Message ".concat(message, " didn't get externalized correctly."));
		                return (0, common_1.format)(message, args);
		            }
		            else {
		                console.error("Broken localize call found. Stacktrace is\n: ".concat(new Error('').stack));
		            }
		        }
		    };
		}
		function resolveLanguage(file) {
		    var resolvedLanguage;
		    if (options.cacheLanguageResolution && resolvedLanguage) {
		        resolvedLanguage = resolvedLanguage;
		    }
		    else {
		        if (common_1.isPseudo || !options.language) {
		            resolvedLanguage = '.nls.json';
		        }
		        else {
		            var locale = options.language;
		            while (locale) {
		                var candidate = '.nls.' + locale + '.json';
		                if (fs$1.existsSync(file + candidate)) {
		                    resolvedLanguage = candidate;
		                    break;
		                }
		                else {
		                    var index = locale.lastIndexOf('-');
		                    if (index > 0) {
		                        locale = locale.substring(0, index);
		                    }
		                    else {
		                        resolvedLanguage = '.nls.json';
		                        locale = null;
		                    }
		                }
		            }
		        }
		        if (options.cacheLanguageResolution) {
		            resolvedLanguage = resolvedLanguage;
		        }
		    }
		    return file + resolvedLanguage;
		}
		function findInTheBoxBundle(root) {
		    var language = options.language;
		    while (language) {
		        var candidate = path.join(root, "nls.bundle.".concat(language, ".json"));
		        if (fs$1.existsSync(candidate)) {
		            return candidate;
		        }
		        else {
		            var index = language.lastIndexOf('-');
		            if (index > 0) {
		                language = language.substring(0, index);
		            }
		            else {
		                language = undefined;
		            }
		        }
		    }
		    // Test if we can reslove the default bundle.
		    if (language === undefined) {
		        var candidate = path.join(root, 'nls.bundle.json');
		        if (fs$1.existsSync(candidate)) {
		            return candidate;
		        }
		    }
		    return undefined;
		}
		function createDefaultNlsBundle(folder) {
		    var metaData = readJsonFileSync(path.join(folder, 'nls.metadata.json'));
		    var result = Object.create(null);
		    for (var module_1 in metaData) {
		        var entry = metaData[module_1];
		        result[module_1] = entry.messages;
		    }
		    return result;
		}
		function createNLSBundle(header, metaDataPath) {
		    var languagePackLocation = options.translationsConfig[header.id];
		    if (!languagePackLocation) {
		        return undefined;
		    }
		    var languagePack = readJsonFileSync(languagePackLocation).contents;
		    var metaData = readJsonFileSync(path.join(metaDataPath, 'nls.metadata.json'));
		    var result = Object.create(null);
		    for (var module_2 in metaData) {
		        var entry = metaData[module_2];
		        var translations = languagePack["".concat(header.outDir, "/").concat(module_2)];
		        if (translations) {
		            var resultMessages = [];
		            for (var i = 0; i < entry.keys.length; i++) {
		                var messageKey = entry.keys[i];
		                var key = isString(messageKey) ? messageKey : messageKey.key;
		                var translatedMessage = translations[key];
		                if (translatedMessage === undefined) {
		                    translatedMessage = entry.messages[i];
		                }
		                resultMessages.push(translatedMessage);
		            }
		            result[module_2] = resultMessages;
		        }
		        else {
		            result[module_2] = entry.messages;
		        }
		    }
		    return result;
		}
		function touch(file) {
		    var d = new Date();
		    fs$1.utimes(file, d, d, function () {
		        // Do nothing. Ignore
		    });
		}
		function cacheBundle(key, bundle) {
		    resolvedBundles[key] = bundle;
		    return bundle;
		}
		function loadNlsBundleOrCreateFromI18n(header, bundlePath) {
		    var result;
		    var bundle = path.join(options.cacheRoot, "".concat(header.id, "-").concat(header.hash, ".json"));
		    var useMemoryOnly = false;
		    var writeBundle = false;
		    try {
		        result = JSON.parse(fs$1.readFileSync(bundle, { encoding: 'utf8', flag: 'r' }));
		        touch(bundle);
		        return result;
		    }
		    catch (err) {
		        if (err.code === 'ENOENT') {
		            writeBundle = true;
		        }
		        else if (err instanceof SyntaxError) {
		            // We have a syntax error. So no valid JSON. Use
		            console.log("Syntax error parsing message bundle: ".concat(err.message, "."));
		            fs$1.unlink(bundle, function (err) {
		                if (err) {
		                    console.error("Deleting corrupted bundle ".concat(bundle, " failed."));
		                }
		            });
		            useMemoryOnly = true;
		        }
		        else {
		            throw err;
		        }
		    }
		    result = createNLSBundle(header, bundlePath);
		    if (!result || useMemoryOnly) {
		        return result;
		    }
		    if (writeBundle) {
		        try {
		            fs$1.writeFileSync(bundle, JSON.stringify(result), { encoding: 'utf8', flag: 'wx' });
		        }
		        catch (err) {
		            if (err.code === 'EEXIST') {
		                return result;
		            }
		            throw err;
		        }
		    }
		    return result;
		}
		function loadDefaultNlsBundle(bundlePath) {
		    try {
		        return createDefaultNlsBundle(bundlePath);
		    }
		    catch (err) {
		        console.log("Generating default bundle from meta data failed.", err);
		        return undefined;
		    }
		}
		function loadNlsBundle(header, bundlePath) {
		    var result;
		    // Core decided to use a language pack. Do the same in the extension
		    if (supportsLanguagePack()) {
		        try {
		            result = loadNlsBundleOrCreateFromI18n(header, bundlePath);
		        }
		        catch (err) {
		            console.log("Load or create bundle failed ", err);
		        }
		    }
		    if (!result) {
		        // No language pack found, but core is running in language pack mode
		        // Don't try to use old in the box bundles since the might be stale
		        // Fall right back to the default bundle.
		        if (options.languagePackSupport) {
		            return loadDefaultNlsBundle(bundlePath);
		        }
		        var candidate = findInTheBoxBundle(bundlePath);
		        if (candidate) {
		            try {
		                return readJsonFileSync(candidate);
		            }
		            catch (err) {
		                console.log("Loading in the box message bundle failed.", err);
		            }
		        }
		        result = loadDefaultNlsBundle(bundlePath);
		    }
		    return result;
		}
		function tryFindMetaDataHeaderFile(file) {
		    var result;
		    var dirname = path.dirname(file);
		    while (true) {
		        result = path.join(dirname, 'nls.metadata.header.json');
		        if (fs$1.existsSync(result)) {
		            break;
		        }
		        var parent = path.dirname(dirname);
		        if (parent === dirname) {
		            result = undefined;
		            break;
		        }
		        else {
		            dirname = parent;
		        }
		    }
		    return result;
		}
		function loadMessageBundle(file) {
		    if (!file) {
		        // No file. We are in dev mode. Return the default
		        // localize function.
		        return common_1.localize;
		    }
		    // Remove extension since we load json files.
		    var ext = path.extname(file);
		    if (ext) {
		        file = file.substr(0, file.length - ext.length);
		    }
		    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.bundle) {
		        var headerFile = tryFindMetaDataHeaderFile(file);
		        if (headerFile) {
		            var bundlePath = path.dirname(headerFile);
		            var bundle = resolvedBundles[bundlePath];
		            if (bundle === undefined) {
		                try {
		                    var header = JSON.parse(fs$1.readFileSync(headerFile, 'utf8'));
		                    try {
		                        var nlsBundle = loadNlsBundle(header, bundlePath);
		                        bundle = cacheBundle(bundlePath, nlsBundle ? { header: header, nlsBundle: nlsBundle } : null);
		                    }
		                    catch (err) {
		                        console.error('Failed to load nls bundle', err);
		                        bundle = cacheBundle(bundlePath, null);
		                    }
		                }
		                catch (err) {
		                    console.error('Failed to read header file', err);
		                    bundle = cacheBundle(bundlePath, null);
		                }
		            }
		            if (bundle) {
		                var module_3 = file.substr(bundlePath.length + 1).replace(/\\/g, '/');
		                var messages = bundle.nlsBundle[module_3];
		                if (messages === undefined) {
		                    console.error("Messages for file ".concat(file, " not found. See console for details."));
		                    return function () {
		                        return 'Messages not found.';
		                    };
		                }
		                return createScopedLocalizeFunction(messages);
		            }
		        }
		    }
		    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.file) {
		        // Try to load a single file bundle
		        try {
		            var json = readJsonFileSync(resolveLanguage(file));
		            if (Array.isArray(json)) {
		                return createScopedLocalizeFunction(json);
		            }
		            else {
		                if ((0, common_1.isDefined)(json.messages) && (0, common_1.isDefined)(json.keys)) {
		                    return createScopedLocalizeFunction(json.messages);
		                }
		                else {
		                    console.error("String bundle '".concat(file, "' uses an unsupported format."));
		                    return function () {
		                        return 'File bundle has unsupported format. See console for details';
		                    };
		                }
		            }
		        }
		        catch (err) {
		            if (err.code !== 'ENOENT') {
		                console.error('Failed to load single file bundle', err);
		            }
		        }
		    }
		    console.error("Failed to load message bundle for file ".concat(file));
		    return function () {
		        return 'Failed to load message bundle. See console for details.';
		    };
		}
		exports$1.loadMessageBundle = loadMessageBundle;
		function config(opts) {
		    if (opts) {
		        if (isString(opts.locale)) {
		            options.locale = opts.locale.toLowerCase();
		            options.language = options.locale;
		            resolvedBundles = Object.create(null);
		        }
		        if (opts.messageFormat !== undefined) {
		            options.messageFormat = opts.messageFormat;
		        }
		        if (opts.bundleFormat === common_1.BundleFormat.standalone && options.languagePackSupport === true) {
		            options.languagePackSupport = false;
		        }
		    }
		    (0, common_1.setPseudo)(options.locale === 'pseudo');
		    return loadMessageBundle;
		}
		exports$1.config = config;
		ral_1.default.install(Object.freeze({
		    loadMessageBundle: loadMessageBundle,
		    config: config
		}));
		
	} (main));
	return main;
}

var mainExports = requireMain();

function getConfigTitle(document) {
    if (document.languageId === 'javascriptreact') {
        return 'javascript';
    }
    if (document.languageId === 'typescriptreact') {
        return 'typescript';
    }
    return document.languageId;
}
function isTsDocument(document) {
    return document.languageId === 'javascript' || document.languageId === 'typescript' || document.languageId === 'javascriptreact' || document.languageId === 'typescriptreact';
}
function isJsonDocument(document) {
    return document.languageId === 'json' || document.languageId === 'jsonc';
}
function safeCall(cb) {
    try {
        return cb();
    } catch  {}
}

const localize$1 = mainExports.loadMessageBundle(); // TODO: not working
const directives = [
    {
        value: '@ts-check',
        description: localize$1('ts-check', "Enables semantic checking in a JavaScript file. Must be at the top of a file.")
    },
    {
        value: '@ts-nocheck',
        description: localize$1('ts-nocheck', "Disables semantic checking in a JavaScript file. Must be at the top of a file.")
    },
    {
        value: '@ts-ignore',
        description: localize$1('ts-ignore', "Suppresses @ts-check errors on the next line of a file.")
    },
    {
        value: '@ts-expect-error',
        description: localize$1('ts-expect-error', "Suppresses @ts-check errors on the next line of a file, expecting at least one to exist.")
    }
];
function create$3() {
    return {
        name: 'typescript-directive-comment',
        capabilities: {
            completionProvider: {
                triggerCharacters: [
                    '@'
                ]
            }
        },
        create () {
            return {
                provideCompletionItems (document, position) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    const prefix = document.getText({
                        start: {
                            line: position.line,
                            character: 0
                        },
                        end: position
                    });
                    const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
                    if (match) {
                        const items = directives.map((directive)=>{
                            const item = {
                                label: directive.value
                            };
                            item.insertTextFormat = 2;
                            item.detail = directive.description;
                            const range = {
                                start: {
                                    line: position.line,
                                    character: Math.max(0, position.character - (match[1] ? match[1].length : 0))
                                },
                                end: position
                            };
                            item.textEdit = {
                                range,
                                newText: directive.value
                            };
                            return item;
                        });
                        return {
                            isIncomplete: false,
                            items
                        };
                    }
                }
            };
        }
    };
}

var pathBrowserifyExports = requirePathBrowserify();

var re = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	const SEMVER_SPEC_VERSION = '2.0.0';

	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	/* istanbul ignore next */ 9007199254740991;

	// Max safe segment length for coercion.
	const MAX_SAFE_COMPONENT_LENGTH = 16;

	// Max safe length for a build identifier. The max length minus 6 characters for
	// the shortest version with a build 0.0.0+BUILD.
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];

	constants = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;

	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};

	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports$1) {

		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants();
		const debug = requireDebug();
		exports$1 = module.exports = {};

		// The actual regexps go on exports.re
		const re = exports$1.re = [];
		const safeRe = exports$1.safeRe = [];
		const src = exports$1.src = [];
		const safeSrc = exports$1.safeSrc = [];
		const t = exports$1.t = {};
		let R = 0;

		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
		// used internally via the safeRe object since all inputs in this library get
		// normalized first to trim and collapse all extra whitespace. The original
		// regexes are exported for userland consumption and lower level usage. A
		// future breaking change could export the safer regex only with a note that
		// all input should have extra whitespace removed.
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];

		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};

		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};

		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.

		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.

		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.

		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

		// ## Main Version
		// Three dot-separated numeric identifiers.

		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);

		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		// Non-numberic identifiers include numberic identifiers but can be longer.
		// Therefore non-numberic identifiers must go first.

		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);

		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.

		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.

		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.

		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.

		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.

		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

		createToken('GTLT', '((?:<|>)?=?)');

		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);

		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);

		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

		// Coercion.
		// Extract anything that could conceivably be a part of a valid semver
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		createToken('LONETILDE', '(?:~>?)');

		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports$1.tildeTrimReplace = '$1~';

		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		createToken('LONECARET', '(?:\\^)');

		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports$1.caretTrimReplace = '$1^';

		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports$1.comparatorTrimReplace = '$1$2$3';

		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);

		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);

		// Star ranges basically just allow anything at all.
		createToken('STAR', '(<|>)?=?\\s*\\*');
		// >=0.0.0 is like a star
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;

	// parse out just the options we care about
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }

	  if (typeof options !== 'object') {
	    return looseOption
	  }

	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;

	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a === b ? 0 : a < b ? -1 : 1
	  }

	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};

	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$1;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$1;
	hasRequiredSemver$1 = 1;

	const debug = requireDebug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
	const { safeRe: re, t } = requireRe();

	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    // this isn't actually relevant for versions, but keep it so that we
	    // don't run into trouble passing this.options around.
	    this.includePrerelease = !!options.includePrerelease;

	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }

	    // numberify any prerelease numeric ids
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }

	  toString () {
	    return this.version
	  }

	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0
	    }

	    return this.compareMain(other) || this.comparePre(other)
	  }

	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.major < other.major) {
	      return -1
	    }
	    if (this.major > other.major) {
	      return 1
	    }
	    if (this.minor < other.minor) {
	      return -1
	    }
	    if (this.minor > other.minor) {
	      return 1
	    }
	    if (this.patch < other.patch) {
	      return -1
	    }
	    if (this.patch > other.patch) {
	      return 1
	    }
	    return 0
	  }

	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }

	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      // Avoid an invalid semver results
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }

	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      // This probably shouldn't be used publicly.
	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;

	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            // didn't increment anything
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}

	semver$1 = SemVer;
	return semver$1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};

	parse_1 = parse;
	return parse_1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;

	const parse = requireParse();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;

	const parse = requireParse();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;

	const SemVer = requireSemver$1();

	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	const parse = requireParse();

	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);

	  if (comparison === 0) {
	    return null
	  }

	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;

	  if (lowHasPre && !highHasPre) {
	    // Going from prerelease -> no prerelease requires some special casing

	    // If the low version has only a major, then it will always be a major
	    // Some examples:
	    // 1.0.0-1 -> 1.0.0
	    // 1.0.0-1 -> 1.1.1
	    // 1.0.0-1 -> 2.0.0
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }

	    // If the main part has no difference
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }

	  // add the `pre` prefix if we are going to a prerelease version
	  const prefix = highHasPre ? 'pre' : '';

	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }

	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }

	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }

	  // high and low are preleases
	  return 'prerelease'
	};

	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;

	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;

	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;

	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;

	const parse = requireParse();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;

	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));

	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;

	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;

	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;

	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;

	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;

	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;

	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;

	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;

	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;

	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;

	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;

	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;

	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();

	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b

	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b

	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)

	    case '!=':
	      return neq(a, b, loose)

	    case '>':
	      return gt(a, b, loose)

	    case '>=':
	      return gte(a, b, loose)

	    case '<':
	      return lt(a, b, loose)

	    case '<=':
	      return lte(a, b, loose)

	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;

	const SemVer = requireSemver$1();
	const parse = requireParse();
	const { safeRe: re, t } = requireRe();

	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null
	  }

	  options = options || {};

	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    // Find the right-most coercible string that does not share
	    // a terminus with a more left-ward coercible string.
	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
	    //
	    // Walk through the string checking with a /g regexp
	    // Manually set the index so as to pick up overlapping matches.
	    // Stop when we get a match that ends at the string end, since no
	    // coercible string can be more right-ward without the same terminus.
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    // leave it in a clean state
	    coerceRtlRegex.lastIndex = -1;
	  }

	  if (match === null) {
	    return null
	  }

	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLrucache();
	const cache = new LRU();

	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  comp = comp.replace(re[t.BUILD], '');
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;

	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;

	const Range = requireRange();

	// Mostly just for testing and legacy API reasons
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();

	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!max || maxSV.compare(v) === -1) {
	        // compare(max, v, true)
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!min || minSV.compare(v) === 1) {
	        // compare(min, v, true)
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();

	const minVersion = (range, loose) => {
	  range = new Range(range, loose);

	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let setMin = null;
	    comparators.forEach((comparator) => {
	      // Clone to avoid manipulating the comparator's semver object.
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	          /* fallthrough */
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          /* Ignore maximum versions */
	          break
	        /* istanbul ignore next */
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }

	  if (minver && range.test(minver)) {
	    return minver
	  }

	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;

	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;

	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();

	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);

	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }

	  // If it satisfies the range it is not outside
	  if (satisfies(version, range, options)) {
	    return false
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let high = null;
	    let low = null;

	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};

	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;

	// Determine if version is greater than all the versions possible in the range.
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;

	const outside = requireOutside();
	// Determine if version is less than all the versions possible in the range
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;

	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;

	// given a set of versions and a range, create a "simplified" range
	// that includes the same versions that the original range does
	// If the original range is shorter than the simplified one, return that.
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }

	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;

	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();

	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
	// - Every simple range `r1, r2, ...` is a null set, OR
	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
	//   some `R1, R2, ...`
	//
	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
	// - If c is only the ANY comparator
	//   - If C is only the ANY comparator, return true
	//   - Else if in prerelease mode, return false
	//   - else replace c with `[>=0.0.0]`
	// - If C is only the ANY comparator
	//   - if in prerelease mode, return true
	//   - else replace C with `[>=0.0.0]`
	// - Let EQ be the set of = comparators in c
	// - If EQ is more than one, return true (null set)
	// - Let GT be the highest > or >= comparator in c
	// - Let LT be the lowest < or <= comparator in c
	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
	// - If any C is a = range, and GT or LT are set, return false
	// - If EQ
	//   - If GT, and EQ does not satisfy GT, return true (null set)
	//   - If LT, and EQ does not satisfy LT, return true (null set)
	//   - If EQ satisfies every C, return true
	//   - Else return false
	// - If GT
	//   - If GT.semver is lower than any > or >= comp in C, return false
	//   - If GT is >=, and GT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the GT.semver tuple, return false
	// - If LT
	//   - If LT.semver is greater than any < or <= comp in C, return false
	//   - If LT is <=, and LT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the LT.semver tuple, return false
	// - Else return true

	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }

	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;

	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    // the null set is a subset of everything, but null simple ranges in
	    // a complex range should be ignored.  so if we saw a non-null range,
	    // then we know this isn't a subset, but if EVERY simple range was null,
	    // then it is a subset.
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};

	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];

	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }

	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }

	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }

	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }

	  if (eqSet.size > 1) {
	    return null
	  }

	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }

	  // will iterate one or zero times
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }

	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }

	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }

	    return true
	  }

	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  // if the subset has a prerelease, we need a comparator in the superset
	  // with the same tuple and a prerelease, or it's not a subset
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  // exception: <1.2.3-0 is the same as <1.2.3
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }

	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }

	  // if there was a < or >, and nothing in the dom, then must be false
	  // UNLESS it was limited by another range in the other direction.
	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }

	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }

	  // we needed a prerelease range in a specific tuple, but didn't get one
	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
	  // because it includes prereleases in the 1.2.3 tuple
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }

	  return true
	};

	// >=1.2.3 is lower than >1.2.3
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};

	// <=1.2.3 is higher than <1.2.3
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};

	subset_1 = subset;
	return subset_1;
}

var semver;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;

	// just pre-load all the stuff that index.js lazily exports
	const internalRe = requireRe();
	const constants = requireConstants();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver;
}

var semverExports = requireSemver();

function _define_property$i(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class Kind {
}
_define_property$i(Kind, "alias", 'alias');
_define_property$i(Kind, "callSignature", 'call');
_define_property$i(Kind, "class", 'class');
_define_property$i(Kind, "const", 'const');
_define_property$i(Kind, "constructorImplementation", 'constructor');
_define_property$i(Kind, "constructSignature", 'construct');
_define_property$i(Kind, "directory", 'directory');
_define_property$i(Kind, "enum", 'enum');
_define_property$i(Kind, "enumMember", 'enum member');
_define_property$i(Kind, "externalModuleName", 'external module name');
_define_property$i(Kind, "function", 'function');
_define_property$i(Kind, "indexSignature", 'index');
_define_property$i(Kind, "interface", 'interface');
_define_property$i(Kind, "keyword", 'keyword');
_define_property$i(Kind, "let", 'let');
_define_property$i(Kind, "localFunction", 'local function');
_define_property$i(Kind, "localVariable", 'local var');
_define_property$i(Kind, "method", 'method');
_define_property$i(Kind, "memberGetAccessor", 'getter');
_define_property$i(Kind, "memberSetAccessor", 'setter');
_define_property$i(Kind, "memberVariable", 'property');
_define_property$i(Kind, "module", 'module');
_define_property$i(Kind, "primitiveType", 'primitive type');
_define_property$i(Kind, "script", 'script');
_define_property$i(Kind, "type", 'type');
_define_property$i(Kind, "variable", 'var');
_define_property$i(Kind, "warning", 'warning');
_define_property$i(Kind, "string", 'string');
_define_property$i(Kind, "parameter", 'parameter');
_define_property$i(Kind, "typeParameter", 'type parameter');
class DiagnosticCategory {
}
_define_property$i(DiagnosticCategory, "error", 'error');
_define_property$i(DiagnosticCategory, "warning", 'warning');
_define_property$i(DiagnosticCategory, "suggestion", 'suggestion');
class KindModifiers {
}
_define_property$i(KindModifiers, "optional", 'optional');
_define_property$i(KindModifiers, "deprecated", 'deprecated');
_define_property$i(KindModifiers, "color", 'color');
_define_property$i(KindModifiers, "dtsFile", '.d.ts');
_define_property$i(KindModifiers, "tsFile", '.ts');
_define_property$i(KindModifiers, "tsxFile", '.tsx');
_define_property$i(KindModifiers, "jsFile", '.js');
_define_property$i(KindModifiers, "jsxFile", '.jsx');
_define_property$i(KindModifiers, "jsonFile", '.json');
_define_property$i(KindModifiers, "fileExtensionKindModifiers", [
    KindModifiers.dtsFile,
    KindModifiers.tsFile,
    KindModifiers.tsxFile,
    KindModifiers.jsFile,
    KindModifiers.jsxFile,
    KindModifiers.jsonFile
]);
class DisplayPartKind {
}
_define_property$i(DisplayPartKind, "functionName", 'functionName');
_define_property$i(DisplayPartKind, "methodName", 'methodName');
_define_property$i(DisplayPartKind, "parameterName", 'parameterName');
_define_property$i(DisplayPartKind, "propertyName", 'propertyName');
_define_property$i(DisplayPartKind, "punctuation", 'punctuation');
_define_property$i(DisplayPartKind, "text", 'text');

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function parseKindModifier(kindModifiers) {
    return new Set(kindModifiers.split(/,|\s+/g));
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function replaceLinks(text) {
    return text// Http(s) links
    .replace(/\{@(link|linkplain|linkcode) (https?:\/\/[^ |}]+?)(?:[| ]([^{}\n]+?))?\}/gi, (_, tag, link, text)=>{
        switch(tag){
            case 'linkcode':
                return `[\`${text ? text.trim() : link}\`](${link})`;
            default:
                return `[${text ? text.trim() : link}](${link})`;
        }
    });
}
function processInlineTags(text) {
    return replaceLinks(text);
}
function getTagBodyText(tag, fileNameToUri, getTextDocument) {
    if (!tag.text) {
        return undefined;
    }
    // Convert to markdown code block if it is not already one
    function makeCodeblock(text) {
        if (text.match(/^\s*[~`]{3}/g)) {
            return text;
        }
        return '```\n' + text + '\n```';
    }
    const text = convertLinkTags(tag.text, fileNameToUri, getTextDocument);
    switch(tag.name){
        case 'example':
            // check for caption tags, fix for #79704
            const captionTagMatches = text.match(/<caption>(.*?)<\/caption>\s*(\r\n|\n)/);
            if (captionTagMatches && captionTagMatches.index === 0) {
                return captionTagMatches[1] + '\n\n' + makeCodeblock(text.slice(captionTagMatches[0].length));
            } else {
                return makeCodeblock(text);
            }
        case 'author':
            // fix obfuscated email address, #80898
            const emailMatch = text.match(/(.+)\s<([-.\w]+@[-.\w]+)>/);
            if (emailMatch === null) {
                return text;
            } else {
                return `${emailMatch[1]} ${emailMatch[2]}`;
            }
        case 'default':
            return makeCodeblock(text);
    }
    return processInlineTags(text);
}
function getTagDocumentation(tag, fileNameToUri, getTextDocument) {
    switch(tag.name){
        case 'augments':
        case 'extends':
        case 'param':
        case 'template':
            const body = convertLinkTags(tag.text, fileNameToUri, getTextDocument).split(/^(\S+)\s*-?\s*/);
            if (body?.length === 3) {
                const param = body[1];
                const doc = body[2];
                const label = `*@${tag.name}* \`${param}\``;
                if (!doc) {
                    return label;
                }
                return label + (doc.match(/\r\n|\n/g) ? '  \n' + processInlineTags(doc) : `  ${processInlineTags(doc)}`);
            }
    }
    // Generic tag
    const label = `*@${tag.name}*`;
    const text = getTagBodyText(tag, fileNameToUri, getTextDocument);
    if (!text) {
        return label;
    }
    return label + (text.match(/\r\n|\n/g) ? '  \n' + text : `  ${text}`);
}
function plainWithLinks(parts, fileNameToUri, getTextDocument) {
    return processInlineTags(convertLinkTags(parts, fileNameToUri, getTextDocument));
}
/**
 * Convert `@link` inline tags to markdown links
 */ function convertLinkTags(parts, fileNameToUri, getTextDocument) {
    if (!parts) {
        return '';
    }
    if (typeof parts === 'string') {
        return parts;
    }
    const out = [];
    let currentLink;
    for (const part of parts){
        switch(part.kind){
            case 'link':
                if (currentLink) {
                    const text = currentLink.text ?? currentLink.name;
                    let target = currentLink.target;
                    if (typeof currentLink.target === 'object' && 'fileName' in currentLink.target) {
                        const _target = currentLink.target;
                        const fileDoc = getTextDocument(fileNameToUri(_target.fileName));
                        if (fileDoc) {
                            const start = fileDoc.positionAt(_target.textSpan.start);
                            const end = fileDoc.positionAt(_target.textSpan.start + _target.textSpan.length);
                            target = {
                                file: _target.fileName,
                                start: {
                                    line: start.line + 1,
                                    offset: start.character + 1
                                },
                                end: {
                                    line: end.line + 1,
                                    offset: end.character + 1
                                }
                            };
                        } else {
                            target = {
                                file: _target.fileName,
                                start: {
                                    line: 1,
                                    offset: 1
                                },
                                end: {
                                    line: 1,
                                    offset: 1
                                }
                            };
                        }
                    }
                    if (target) {
                        const link = fileNameToUri(target.file) + '#' + `L${target.start.line},${target.start.offset}`;
                        out.push(`[${text}](${link})`);
                    } else {
                        if (text) {
                            out.push(text);
                        }
                    }
                    currentLink = undefined;
                } else {
                    currentLink = {};
                }
                break;
            case 'linkName':
                if (currentLink) {
                    currentLink.name = part.text;
                    currentLink.target = part.target;
                }
                break;
            case 'linkText':
                if (currentLink) {
                    currentLink.text = part.text;
                }
                break;
            default:
                out.push(part.text);
                break;
        }
    }
    return processInlineTags(out.join(''));
}
function tagsMarkdownPreview(tags, fileNameToUri, getTextDocument) {
    return tags.map((tag)=>getTagDocumentation(tag, fileNameToUri, getTextDocument)).join('  \n\n');
}
function markdownDocumentation(documentation, tags, fileNameToUri, getTextDocument) {
    return addMarkdownDocumentation('', documentation, tags, fileNameToUri, getTextDocument);
}
function addMarkdownDocumentation(out, documentation, tags, fileNameToUri, getTextDocument) {
    if (documentation) {
        out += plainWithLinks(documentation, fileNameToUri, getTextDocument);
    }
    if (tags) {
        const tagsPreview = tagsMarkdownPreview(tags, fileNameToUri, getTextDocument);
        if (tagsPreview) {
            out += '\n\n' + tagsPreview;
        }
    }
    return out;
}

(function(SymbolKind) {
    function fromProtocolScriptElementKind(kind) {
        switch(kind){
            case Kind.module:
                return 2;
            case Kind.class:
                return 5;
            case Kind.enum:
                return 10;
            case Kind.enumMember:
                return 22;
            case Kind.interface:
                return 11;
            case Kind.indexSignature:
                return 6;
            case Kind.callSignature:
                return 6;
            case Kind.method:
                return 6;
            case Kind.memberVariable:
                return 7;
            case Kind.memberGetAccessor:
                return 7;
            case Kind.memberSetAccessor:
                return 7;
            case Kind.variable:
                return 13;
            case Kind.let:
                return 13;
            case Kind.const:
                return 13;
            case Kind.localVariable:
                return 13;
            case Kind.alias:
                return 13;
            case Kind.function:
                return 12;
            case Kind.localFunction:
                return 12;
            case Kind.constructSignature:
                return 9;
            case Kind.constructorImplementation:
                return 9;
            case Kind.typeParameter:
                return 26;
            case Kind.string:
                return 15;
            default:
                return 13;
        }
    }
    SymbolKind.fromProtocolScriptElementKind = fromProtocolScriptElementKind;
})(SymbolKind || (SymbolKind = {}));
var SymbolKind;

// diagnostics
function convertDiagnostic(diag, document, fileNameToUri, getTextDocument) {
    if (diag.start === undefined) {
        return;
    }
    if (diag.length === undefined) {
        return;
    }
    const diagnostic = {
        range: {
            start: document.positionAt(diag.start),
            end: document.positionAt(diag.start + diag.length)
        },
        severity: convertDiagnosticCategory(diag.category),
        source: 'ts',
        code: diag.code,
        message: getMessageText(diag)
    };
    if (diag.relatedInformation) {
        diagnostic.relatedInformation = diag.relatedInformation.map((rErr)=>convertDiagnosticRelatedInformation(rErr, fileNameToUri, getTextDocument)).filter((v)=>!!v);
    }
    if (diag.reportsUnnecessary) {
        if (diagnostic.tags === undefined) {
            diagnostic.tags = [];
        }
        diagnostic.tags.push(1);
    }
    if (diag.reportsDeprecated) {
        if (diagnostic.tags === undefined) {
            diagnostic.tags = [];
        }
        diagnostic.tags.push(2);
    }
    return diagnostic;
}
function convertDiagnosticRelatedInformation(diag, fileNameToUri, getTextDocument) {
    if (diag.start === undefined) {
        return;
    }
    if (diag.length === undefined) {
        return;
    }
    let document;
    if (diag.file) {
        document = getTextDocument(fileNameToUri(diag.file.fileName));
    }
    if (!document) {
        return;
    }
    const diagnostic = {
        location: {
            uri: document.uri,
            range: {
                start: document.positionAt(diag.start),
                end: document.positionAt(diag.start + diag.length)
            }
        },
        message: getMessageText(diag)
    };
    return diagnostic;
}
function convertDiagnosticCategory(input) {
    switch(input){
        case 0:
            return 2;
        case 1:
            return 1;
        case 2:
            return 4;
        case 3:
            return 3;
    }
    return 1;
}
function getMessageText(diag, level = 0) {
    let messageText = '  '.repeat(level);
    if (typeof diag.messageText === 'string') {
        messageText += diag.messageText;
    } else {
        messageText += diag.messageText.messageText;
        if (diag.messageText.next) {
            for (const info of diag.messageText.next){
                messageText += '\n' + getMessageText(info, level + 1);
            }
        }
    }
    return messageText;
}
// completion resolve
function applyCompletionEntryDetails(ts, item, data, document, fileNameToUri, getTextDocument) {
    const { sourceDisplay } = data;
    if (sourceDisplay) {
        var _item;
        (_item = item).labelDetails ?? (_item.labelDetails = {});
        item.labelDetails.description = ts.displayPartsToString(sourceDisplay);
    }
    const detailTexts = [];
    if (data.codeActions) {
        var _item1;
        (_item1 = item).additionalTextEdits ?? (_item1.additionalTextEdits = []);
        for (const action of data.codeActions){
            detailTexts.push(action.description);
            for (const changes of action.changes){
                const ranges = changes.textChanges.map((change)=>convertTextSpan(change.span, document));
                ranges.forEach((range, index)=>{
                    item.additionalTextEdits?.push({
                        range,
                        newText: changes.textChanges[index].newText
                    });
                });
            }
        }
    }
    if (data.displayParts) {
        detailTexts.push(plainWithLinks(data.displayParts, fileNameToUri, getTextDocument));
    }
    if (detailTexts.length) {
        item.detail = detailTexts.join('\n');
    }
    item.documentation = {
        kind: 'markdown',
        value: markdownDocumentation(data.documentation, data.tags, fileNameToUri, getTextDocument)
    };
    if (data) {
        handleKindModifiers(item, data);
    }
}
// completion
function convertCompletionInfo(ts, completionContext, document, position, createData) {
    const lt_320 = semverExports.lt(ts.version, '3.2.0');
    const gte_300 = semverExports.gte(ts.version, '3.0.0');
    const wordRange = completionContext.optionalReplacementSpan ? convertTextSpan(completionContext.optionalReplacementSpan, document) : undefined;
    const line = getLineText(document, position.line);
    const dotAccessorContext = getDotAccessorContext(document);
    const entries = completionContext.entries.map((tsEntry)=>({
            ...convertCompletionEntry(tsEntry, document),
            data: createData(tsEntry)
        }));
    return {
        isIncomplete: !!completionContext.isIncomplete,
        items: entries
    };
    function convertCompletionEntry(tsEntry, document) {
        const item = {
            label: tsEntry.name
        };
        item.kind = convertCompletionItemKind(tsEntry.kind);
        if (tsEntry.source && tsEntry.hasAction) {
            // De-prioritize auto-imports
            // https://github.com/microsoft/vscode/issues/40311
            item.sortText = '\uffff' + tsEntry.sortText;
        } else {
            item.sortText = tsEntry.sortText;
        }
        const { sourceDisplay, isSnippet, labelDetails } = tsEntry;
        if (sourceDisplay) {
            var _item;
            (_item = item).labelDetails ?? (_item.labelDetails = {});
            item.labelDetails.description = ts.displayPartsToString(sourceDisplay);
        }
        if (labelDetails) {
            var _item1;
            (_item1 = item).labelDetails ?? (_item1.labelDetails = {});
            Object.assign(item.labelDetails, labelDetails);
        }
        item.preselect = tsEntry.isRecommended;
        let range = getRangeFromReplacementSpan(tsEntry, document);
        item.commitCharacters = getCommitCharacters(tsEntry, {
            isNewIdentifierLocation: completionContext.isNewIdentifierLocation,
            isInValidCommitCharacterContext: isInValidCommitCharacterContext(document, position)});
        item.insertText = tsEntry.insertText;
        item.insertTextFormat = isSnippet ? 2 : 1;
        item.filterText = getFilterText(tsEntry, wordRange, line, tsEntry.insertText);
        if (completionContext?.isMemberCompletion && dotAccessorContext && !isSnippet) {
            item.filterText = dotAccessorContext.text + (item.insertText || item.label);
            if (!range) {
                const replacementRange = wordRange;
                if (replacementRange) {
                    range = {
                        inserting: dotAccessorContext.range,
                        replacing: rangeUnion(dotAccessorContext.range, replacementRange)
                    };
                } else {
                    range = dotAccessorContext.range;
                }
                item.insertText = item.filterText;
            }
        }
        handleKindModifiers(item, tsEntry);
        if (!range && wordRange) {
            range = {
                inserting: {
                    start: wordRange.start,
                    end: position
                },
                replacing: wordRange
            };
        }
        if (range) {
            if ('start' in range) {
                item.textEdit = {
                    range,
                    newText: item.insertText || item.label
                };
            } else {
                item.textEdit = {
                    insert: range.inserting,
                    replace: range.replacing,
                    newText: item.insertText || item.label
                };
            }
        }
        return item;
    }
    function getDotAccessorContext(document) {
        let dotAccessorContext;
        if (gte_300) {
            if (!completionContext) {
                return;
            }
            const isMemberCompletion = completionContext.isMemberCompletion;
            if (isMemberCompletion) {
                const dotMatch = line.slice(0, position.character).match(/\??\.\s*$/) || undefined;
                if (dotMatch) {
                    const range = {
                        start: {
                            line: position.line,
                            character: position.character - dotMatch[0].length
                        },
                        end: position
                    };
                    const text = document.getText(range);
                    dotAccessorContext = {
                        range,
                        text
                    };
                }
            }
        }
        return dotAccessorContext;
    }
    // from vscode typescript
    function getRangeFromReplacementSpan(tsEntry, document) {
        if (!tsEntry.replacementSpan) {
            return;
        }
        let replaceRange = {
            start: document.positionAt(tsEntry.replacementSpan.start),
            end: document.positionAt(tsEntry.replacementSpan.start + tsEntry.replacementSpan.length)
        };
        // Make sure we only replace a single line at most
        if (replaceRange.start.line !== replaceRange.end.line) {
            replaceRange = {
                start: {
                    line: replaceRange.start.line,
                    character: replaceRange.start.character
                },
                end: {
                    line: replaceRange.start.line,
                    character: document.positionAt(document.offsetAt({
                        line: replaceRange.start.line + 1,
                        character: 0
                    }) - 1).character
                }
            };
        }
        // If TS returns an explicit replacement range, we should use it for both types of completion
        return {
            inserting: replaceRange,
            replacing: replaceRange
        };
    }
    function getFilterText(tsEntry, wordRange, line, insertText) {
        // Handle private field completions
        if (tsEntry.name.startsWith('#')) {
            const wordStart = wordRange ? line.charAt(wordRange.start.character) : undefined;
            if (insertText) {
                if (insertText.startsWith('this.#')) {
                    return wordStart === '#' ? insertText : insertText.replace(/^this\.#/, '');
                } else {
                    return insertText;
                }
            } else {
                return wordStart === '#' ? undefined : tsEntry.name.replace(/^#/, '');
            }
        }
        // For `this.` completions, generally don't set the filter text since we don't want them to be overly prioritized. #74164
        if (insertText?.startsWith('this.')) {
            return undefined;
        } else if (insertText?.startsWith('[')) {
            return insertText.replace(/^\[['"](.+)[['"]\]$/, '.$1');
        }
        // In all other cases, fallback to using the insertText
        return insertText;
    }
    function getCommitCharacters(entry, context) {
        if (entry.kind === Kind.warning) {
            return undefined;
        }
        if (context.isNewIdentifierLocation || !context.isInValidCommitCharacterContext) {
            return undefined;
        }
        const commitCharacters = [
            '.',
            ',',
            ';'
        ];
        {
            commitCharacters.push('(');
        }
        return commitCharacters;
    }
    function isInValidCommitCharacterContext(document, position) {
        if (lt_320) {
            // Workaround for https://github.com/microsoft/TypeScript/issues/27742
            // Only enable dot completions when the previous character is not a dot preceded by whitespace.
            // Prevents incorrectly completing while typing spread operators.
            if (position.character > 1) {
                const preText = document.getText({
                    start: {
                        line: position.line,
                        character: 0
                    },
                    end: position
                });
                return preText.match(/(\s|^)\.$/ig) === null;
            }
        }
        return true;
    }
}
function convertCompletionItemKind(kind) {
    switch(kind){
        case Kind.primitiveType:
        case Kind.keyword:
            return 14;
        case Kind.const:
        case Kind.let:
        case Kind.variable:
        case Kind.localVariable:
        case Kind.alias:
        case Kind.parameter:
            return 6;
        case Kind.memberVariable:
        case Kind.memberGetAccessor:
        case Kind.memberSetAccessor:
            return 5;
        case Kind.function:
        case Kind.localFunction:
            return 3;
        case Kind.method:
        case Kind.constructSignature:
        case Kind.callSignature:
        case Kind.indexSignature:
            return 2;
        case Kind.enum:
            return 13;
        case Kind.enumMember:
            return 20;
        case Kind.module:
        case Kind.externalModuleName:
            return 9;
        case Kind.class:
        case Kind.type:
            return 7;
        case Kind.interface:
            return 8;
        case Kind.warning:
            return 1;
        case Kind.script:
            return 17;
        case Kind.directory:
            return 19;
        case Kind.string:
            return 21;
        default:
            return 10;
    }
}
function handleKindModifiers(item, tsEntry) {
    if (tsEntry.kindModifiers) {
        const kindModifiers = parseKindModifier(tsEntry.kindModifiers);
        if (kindModifiers.has(KindModifiers.optional)) {
            if (!item.insertText) {
                item.insertText = item.label;
            }
            if (!item.filterText) {
                item.filterText = item.label;
            }
            item.label += '?';
        }
        if (kindModifiers.has(KindModifiers.deprecated)) {
            item.tags = [
                1
            ];
        }
        if (kindModifiers.has(KindModifiers.color)) {
            item.kind = 16;
        }
        if (tsEntry.kind === Kind.script) {
            for (const extModifier of KindModifiers.fileExtensionKindModifiers){
                if (kindModifiers.has(extModifier)) {
                    if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
                        item.detail = tsEntry.name;
                    } else {
                        item.detail = tsEntry.name + extModifier;
                    }
                    break;
                }
            }
        }
    }
}
function rangeUnion(a, b) {
    const start = a.start.line < b.start.line || a.start.line === b.start.line && a.start.character < b.start.character ? a.start : b.start;
    const end = a.end.line > b.end.line || a.end.line === b.end.line && a.end.character > b.end.character ? a.end : b.end;
    return {
        start,
        end
    };
}
function getLineText(document, line) {
    const endOffset = document.offsetAt({
        line: line + 1,
        character: 0
    });
    const end = document.positionAt(endOffset);
    const text = document.getText({
        start: {
            line: line,
            character: 0
        },
        end: end.line === line ? end : document.positionAt(endOffset - 1)
    });
    return text;
}
// workspaceSymbol
function convertNavigateToItem(item, document) {
    const info = {
        name: getLabel(item),
        kind: convertScriptElementKind(item.kind),
        location: {
            uri: document.uri,
            range: convertTextSpan(item.textSpan, document)
        }
    };
    const kindModifiers = item.kindModifiers ? parseKindModifier(item.kindModifiers) : undefined;
    if (kindModifiers?.has(KindModifiers.deprecated)) {
        info.tags = [
            1
        ];
    }
    return info;
}
function getLabel(item) {
    const label = item.name;
    if (item.kind === 'method' || item.kind === 'function') {
        return label + '()';
    }
    return label;
}
function convertScriptElementKind(kind) {
    switch(kind){
        case Kind.method:
            return 6;
        case Kind.enum:
            return 10;
        case Kind.enumMember:
            return 22;
        case Kind.function:
            return 12;
        case Kind.class:
            return 5;
        case Kind.interface:
            return 11;
        case Kind.type:
            return 5;
        case Kind.memberVariable:
            return 8;
        case Kind.memberGetAccessor:
            return 8;
        case Kind.memberSetAccessor:
            return 8;
        case Kind.variable:
            return 13;
        default:
            return 13;
    }
}
// inlayHints
function convertInlayHint(hint, document) {
    const result = {
        position: document.positionAt(hint.position),
        label: hint.text,
        kind: hint.kind === 'Type' ? 1 : hint.kind === 'Parameter' ? 2 : undefined
    };
    result.paddingLeft = hint.whitespaceBefore;
    result.paddingRight = hint.whitespaceAfter;
    return result;
}
// documentHighlight
function convertHighlightSpan(span, document) {
    return {
        kind: span.kind === 'writtenReference' ? 3 : 2,
        range: convertTextSpan(span.textSpan, document)
    };
}
// selectionRanges
function convertSelectionRange(range, document) {
    return {
        parent: range.parent ? convertSelectionRange(range.parent, document) : undefined,
        range: convertTextSpan(range.textSpan, document)
    };
}
// rename
function convertFileTextChanges(changes, fileNameToUri, getTextDocument) {
    const workspaceEdit = {};
    for (const change of changes){
        if (!workspaceEdit.documentChanges) {
            workspaceEdit.documentChanges = [];
        }
        const uri = fileNameToUri(change.fileName);
        if (change.isNewFile) {
            workspaceEdit.documentChanges.push({
                kind: 'create',
                uri: uri.toString()
            });
            workspaceEdit.documentChanges.push({
                textDocument: {
                    uri: uri.toString(),
                    version: null
                },
                edits: change.textChanges.map((edit)=>({
                        newText: edit.newText,
                        range: {
                            start: {
                                line: 0,
                                character: edit.span.start
                            },
                            end: {
                                line: 0,
                                character: edit.span.start + edit.span.length
                            }
                        }
                    }))
            });
        } else {
            const doc = getTextDocument(uri);
            workspaceEdit.documentChanges.push({
                textDocument: {
                    uri: uri.toString(),
                    version: null
                },
                edits: change.textChanges.map((edit)=>convertTextChange(edit, doc))
            });
        }
    }
    return workspaceEdit;
}
// rename file
function convertRenameLocations(newText, locations, fileNameToUri, getTextDocument) {
    const workspaceEdit = {};
    for (const location of locations){
        if (!workspaceEdit.changes) {
            workspaceEdit.changes = {};
        }
        const uri = fileNameToUri(location.fileName);
        const doc = getTextDocument(uri);
        if (!workspaceEdit.changes[uri.toString()]) {
            workspaceEdit.changes[uri.toString()] = [];
        }
        let _newText = newText;
        if (location.prefixText) {
            _newText = location.prefixText + _newText;
        }
        if (location.suffixText) {
            _newText = _newText + location.suffixText;
        }
        workspaceEdit.changes[uri.toString()].push({
            newText: _newText,
            range: convertTextSpan(location.textSpan, doc)
        });
    }
    return workspaceEdit;
}
// hover
function convertQuickInfo(ts, info, document, fileNameToUri, getTextDocument) {
    const parts = [];
    const displayString = ts.displayPartsToString(info.displayParts);
    const documentation = markdownDocumentation(info.documentation ?? [], info.tags, fileNameToUri, getTextDocument);
    if (displayString) {
        parts.push([
            '```typescript',
            displayString,
            '```'
        ].join('\n'));
    }
    if (documentation) {
        parts.push(documentation);
    }
    const markdown = {
        kind: 'markdown',
        value: parts.join('\n\n')
    };
    return {
        contents: markdown,
        range: convertTextSpan(info.textSpan, document)
    };
}
// documentSymbol
function convertNavTree(item, document) {
    if (!shouldIncludeEntry(item)) {
        return [];
    }
    let remain = item.childItems ?? [];
    return item.spans.map((span)=>{
        const childItems = [];
        remain = remain.filter((child)=>{
            const childStart = child.spans[0].start;
            const childEnd = child.spans[child.spans.length - 1].start + child.spans[child.spans.length - 1].length;
            if (childStart >= span.start && childEnd <= span.start + span.length) {
                childItems.push(child);
                return false;
            }
            return true;
        });
        const nameSpan = item.spans.length === 1 ? item.nameSpan ?? span : span;
        const fullRange = {
            start: Math.min(span.start, nameSpan.start),
            end: Math.max(span.start + span.length, nameSpan.start + nameSpan.length)
        };
        const symbol = {
            name: item.text,
            kind: getSymbolKind(item.kind),
            range: convertTextSpan({
                start: fullRange.start,
                length: fullRange.end - fullRange.start
            }, document),
            selectionRange: convertTextSpan(nameSpan, document),
            children: childItems.map((item)=>convertNavTree(item, document)).flat()
        };
        const kindModifiers = parseKindModifier(item.kindModifiers);
        if (kindModifiers.has(KindModifiers.deprecated)) {
            var _symbol;
            symbol.deprecated = true;
            (_symbol = symbol).tags ?? (_symbol.tags = []);
            symbol.tags.push(1);
        }
        return symbol;
    });
}
const getSymbolKind = (kind)=>{
    switch(kind){
        case Kind.module:
            return 2;
        case Kind.class:
            return 5;
        case Kind.enum:
            return 10;
        case Kind.interface:
            return 11;
        case Kind.method:
            return 6;
        case Kind.memberVariable:
            return 7;
        case Kind.memberGetAccessor:
            return 7;
        case Kind.memberSetAccessor:
            return 7;
        case Kind.variable:
            return 13;
        case Kind.const:
            return 13;
        case Kind.localVariable:
            return 13;
        case Kind.function:
            return 12;
        case Kind.localFunction:
            return 12;
        case Kind.constructSignature:
            return 9;
        case Kind.constructorImplementation:
            return 9;
    }
    return 13;
};
function shouldIncludeEntry(item) {
    if (item.kind === Kind.alias) {
        return false;
    }
    return !!(item.text && item.text !== '<function>' && item.text !== '<class>');
}
// foldingRanges
function convertOutliningSpan(outliningSpan, document) {
    const start = document.positionAt(outliningSpan.textSpan.start);
    const end = adjustFoldingEnd(start, document.positionAt(outliningSpan.textSpan.start + outliningSpan.textSpan.length), document);
    return {
        startLine: start.line,
        endLine: end.line,
        startCharacter: start.character,
        endCharacter: end.character,
        kind: convertOutliningSpanKind(outliningSpan.kind)
    };
}
function convertOutliningSpanKind(kind) {
    switch(kind){
        case 'comment':
            return 'comment';
        case 'region':
            return 'region';
        case 'imports':
            return 'imports';
        case 'code':
        default:
            return undefined;
    }
}
const foldEndPairCharacters = [
    '}',
    ']',
    ')',
    '`'
];
// https://github.com/microsoft/vscode/blob/bed61166fb604e519e82e4d1d1ed839bc45d65f8/extensions/typescript-language-features/src/languageFeatures/folding.ts#L61-L73
function adjustFoldingEnd(start, end, document) {
    // workaround for #47240
    if (end.character > 0) {
        const foldEndCharacter = document.getText({
            start: {
                line: end.line,
                character: end.character - 1
            },
            end
        });
        if (foldEndPairCharacters.includes(foldEndCharacter)) {
            const endOffset = Math.max(document.offsetAt({
                line: end.line,
                character: 0
            }) - 1, document.offsetAt(start));
            return document.positionAt(endOffset);
        }
    }
    return end;
}
// formatting
function convertTextChange(edit, document) {
    return {
        range: convertTextSpan(edit.span, document),
        newText: edit.newText
    };
}
// callHierarchy
function convertCallHierarchyIncomingCall(item, ctx) {
    const uri = ctx.fileNameToUri(item.from.file);
    const document = ctx.getTextDocument(uri);
    return {
        from: convertCallHierarchyItem(item.from, ctx),
        fromRanges: item.fromSpans.map((span)=>convertTextSpan(span, document)).filter((span)=>!!span)
    };
}
function convertCallHierarchyOutgoingCall(item, fromDocument, ctx) {
    return {
        to: convertCallHierarchyItem(item.to, ctx),
        fromRanges: item.fromSpans.map((span)=>convertTextSpan(span, fromDocument)).filter((span)=>!!span)
    };
}
function convertCallHierarchyItem(item, ctx) {
    const rootPath = ctx.languageService.getProgram()?.getCompilerOptions().rootDir ?? '';
    const uri = ctx.fileNameToUri(item.file);
    const document = ctx.getTextDocument(uri);
    const useFileName = isSourceFileItem(item);
    const name = useFileName ? pathBrowserifyExports.basename(item.file) : item.name;
    const detail = useFileName ? pathBrowserifyExports.relative(rootPath, pathBrowserifyExports.dirname(item.file)) : item.containerName ?? '';
    const result = {
        kind: SymbolKind.fromProtocolScriptElementKind(item.kind),
        name,
        detail,
        uri: uri.toString(),
        range: convertTextSpan(item.span, document),
        selectionRange: convertTextSpan(item.selectionSpan, document)
    };
    const kindModifiers = item.kindModifiers ? parseKindModifier(item.kindModifiers) : undefined;
    if (kindModifiers?.has(KindModifiers.deprecated)) {
        result.tags = [
            1
        ];
    }
    return result;
}
function isSourceFileItem(item) {
    return item.kind === Kind.script || item.kind === Kind.module && item.selectionSpan.start === 0;
}
// base
function convertDocumentSpanToLocation(documentSpan, ctx) {
    const uri = ctx.fileNameToUri(documentSpan.fileName);
    const document = ctx.getTextDocument(uri);
    const range = convertTextSpan(documentSpan.textSpan, document);
    return {
        uri: uri.toString(),
        range
    };
}
function convertDefinitionInfoAndBoundSpan(info, document, ctx) {
    if (!info.definitions) {
        return [];
    }
    const originSelectionRange = convertTextSpan(info.textSpan, document);
    return info.definitions.map((entry)=>{
        const link = convertDocumentSpantoLocationLink(entry, ctx);
        if (link) {
            var _link;
            (_link = link).originSelectionRange ?? (_link.originSelectionRange = originSelectionRange);
            return link;
        }
    }).filter((entry)=>!!entry);
}
function convertDocumentSpantoLocationLink(documentSpan, ctx) {
    const targetUri = ctx.fileNameToUri(documentSpan.fileName);
    const document = ctx.getTextDocument(targetUri);
    const targetSelectionRange = convertTextSpan(documentSpan.textSpan, document);
    const targetRange = documentSpan.contextSpan ? convertTextSpan(documentSpan.contextSpan, document) : targetSelectionRange;
    const originSelectionRange = documentSpan.originalTextSpan ? convertTextSpan(documentSpan.originalTextSpan, document) : undefined;
    return {
        targetUri: targetUri.toString(),
        targetRange,
        targetSelectionRange,
        originSelectionRange
    };
}
function convertTextSpan(textSpan, document) {
    if (!document) {
        return {
            start: {
                line: 0,
                character: 0
            },
            end: {
                line: 0,
                character: 0
            }
        };
    }
    return {
        start: document.positionAt(textSpan.start),
        end: document.positionAt(textSpan.start + textSpan.length)
    };
}

async function getFormatCodeSettings(ctx, document, options) {
    const config = await ctx.env.getConfiguration?.(getConfigTitle(document) + '.format') ?? {};
    return {
        convertTabsToSpaces: options?.insertSpaces,
        tabSize: options?.tabSize,
        indentSize: options?.tabSize,
        indentStyle: 2,
        newLineCharacter: '\n',
        insertSpaceAfterCommaDelimiter: config.insertSpaceAfterCommaDelimiter ?? true,
        insertSpaceAfterConstructor: config.insertSpaceAfterConstructor ?? false,
        insertSpaceAfterSemicolonInForStatements: config.insertSpaceAfterSemicolonInForStatements ?? true,
        insertSpaceBeforeAndAfterBinaryOperators: config.insertSpaceBeforeAndAfterBinaryOperators ?? true,
        insertSpaceAfterKeywordsInControlFlowStatements: config.insertSpaceAfterKeywordsInControlFlowStatements ?? true,
        insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.insertSpaceAfterFunctionKeywordForAnonymousFunctions ?? true,
        insertSpaceBeforeFunctionParenthesis: config.insertSpaceBeforeFunctionParenthesis ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets ?? false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces ?? true,
        insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces ?? true,
        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces ?? false,
        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces ?? false,
        insertSpaceAfterTypeAssertion: config.insertSpaceAfterTypeAssertion ?? false,
        placeOpenBraceOnNewLineForFunctions: config.placeOpenBraceOnNewLineForFunctions ?? false,
        placeOpenBraceOnNewLineForControlBlocks: config.placeOpenBraceOnNewLineForControlBlocks ?? false,
        semicolons: config.semicolons ?? 'ignore'
    };
}

function createSyntaxOnlyService(ts, syntaxOnly) {
    let currentProjectVersion = -1;
    let fileNames = [];
    const scriptInfos = new Map();
    const host = {
        getProjectVersion: ()=>currentProjectVersion.toString(),
        getScriptFileNames: ()=>fileNames,
        getScriptSnapshot: (fileName)=>scriptInfos.get(fileName).snapshot,
        getScriptKind: (fileName)=>scriptInfos.get(fileName).kind,
        getScriptVersion: (fileName)=>scriptInfos.get(fileName).version.toString(),
        getCompilationSettings: ()=>({}),
        getCurrentDirectory: ()=>'',
        getDefaultLibFileName: ()=>'',
        readFile: ()=>undefined,
        fileExists: (fileName)=>scriptInfos.has(fileName)
    };
    return {
        languageService: syntaxOnly ? ts.createLanguageService(host, undefined, ts.LanguageServiceMode.Syntactic) : ts.createLanguageService(host),
        updateFile
    };
    function updateFile(fileName, snapshot, scriptKind) {
        let scriptInfo = scriptInfos.get(fileName);
        if (scriptInfo?.snapshot === snapshot && scriptInfo.kind === scriptKind) {
            return;
        }
        currentProjectVersion++;
        scriptInfo = {
            snapshot,
            kind: scriptKind,
            version: (scriptInfo?.version ?? 0) + 1
        };
        const filesChanged = !scriptInfos.has(fileName);
        scriptInfos.set(fileName, scriptInfo);
        if (filesChanged) {
            fileNames = [
                ...scriptInfos.keys()
            ];
        }
    }
}

const snapshots = new WeakMap();
let created;
function getLanguageServiceByDocument(ts, document) {
    if (!created) {
        created = createSyntaxOnlyService(ts, true);
    }
    let cache = snapshots.get(document);
    if (!cache || cache[0] !== document.version) {
        const snapshot = ts.ScriptSnapshot.fromString(document.getText());
        cache = [
            document.version,
            snapshot
        ];
        snapshots.set(document, cache);
        created.updateFile(document.uri, cache[1], document.languageId === 'javascript' ? ts.ScriptKind.JS : document.languageId === 'javascriptreact' ? ts.ScriptKind.JSX : document.languageId === 'typescriptreact' ? ts.ScriptKind.TSX : ts.ScriptKind.TS);
    }
    return {
        languageService: created.languageService,
        fileName: document.uri
    };
}
function create$2(ts, { isFormattingEnabled = async (document, context)=>{
    return await context.env.getConfiguration?.(getConfigTitle(document) + '.format.enable') ?? true;
} } = {}) {
    return {
        name: 'typescript-syntactic',
        capabilities: {
            autoInsertionProvider: {
                triggerCharacters: [
                    '>',
                    '>'
                ],
                configurationSections: [
                    'javascript.autoClosingTags',
                    'typescript.autoClosingTags'
                ]
            },
            foldingRangeProvider: true,
            selectionRangeProvider: true,
            documentSymbolProvider: true,
            documentFormattingProvider: true,
            documentOnTypeFormattingProvider: {
                // https://github.com/microsoft/vscode/blob/ce119308e8fd4cd3f992d42b297588e7abe33a0c/extensions/typescript-language-features/src/languageFeatures/formatting.ts#L99
                triggerCharacters: [
                    ';',
                    '}',
                    '\n'
                ]
            }
        },
        create (context) {
            return {
                async provideAutoInsertSnippet (document, selection, change) {
                    // selection must at end of change
                    if (document.offsetAt(selection) !== change.rangeOffset + change.text.length) {
                        return;
                    }
                    if ((document.languageId === 'javascriptreact' || document.languageId === 'typescriptreact') && change.text.endsWith('>') && (await context.env.getConfiguration?.(getConfigTitle(document) + '.autoClosingTags') ?? true)) {
                        const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                        const close = languageService.getJsxClosingTagAtPosition(fileName, document.offsetAt(selection));
                        if (close) {
                            return '$0' + close.newText;
                        }
                    }
                },
                provideFoldingRanges (document) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const outliningSpans = safeCall(()=>languageService.getOutliningSpans(fileName));
                    if (!outliningSpans) {
                        return [];
                    }
                    return outliningSpans.map((span)=>convertOutliningSpan(span, document));
                },
                provideSelectionRanges (document, positions) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const ranges = positions.map((position)=>{
                        const offset = document.offsetAt(position);
                        const range = safeCall(()=>languageService.getSmartSelectionRange(fileName, offset));
                        if (!range) {
                            return;
                        }
                        return convertSelectionRange(range, document);
                    });
                    if (ranges.every((range)=>!!range)) {
                        return ranges;
                    }
                },
                provideDocumentSymbols (document) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const barItems = safeCall(()=>languageService.getNavigationTree(fileName));
                    if (!barItems) {
                        return [];
                    }
                    // The root represents the file. Ignore this when showing in the UI
                    return barItems.childItems?.map((item)=>convertNavTree(item, document)).flat() ?? [];
                },
                async provideDocumentFormattingEdits (document, range, options, codeOptions) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    if (!await isFormattingEnabled(document, context)) {
                        return;
                    }
                    const tsOptions = await getFormatCodeSettings(context, document, options);
                    if (codeOptions) {
                        tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const scriptEdits = range ? safeCall(()=>languageService.getFormattingEditsForRange(fileName, document.offsetAt(range.start), document.offsetAt(range.end), tsOptions)) : safeCall(()=>languageService.getFormattingEditsForDocument(fileName, tsOptions));
                    if (!scriptEdits) {
                        return [];
                    }
                    return scriptEdits.map((edit)=>convertTextChange(edit, document));
                },
                async provideOnTypeFormattingEdits (document, position, key, options, codeOptions) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    if (!await isFormattingEnabled(document, context)) {
                        return;
                    }
                    const tsOptions = await getFormatCodeSettings(context, document, options);
                    if (codeOptions) {
                        tsOptions.baseIndentSize = codeOptions.initialIndentLevel * options.tabSize;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const scriptEdits = safeCall(()=>languageService.getFormattingEditsAfterKeystroke(fileName, document.offsetAt(position), key, tsOptions));
                    if (!scriptEdits) {
                        return [];
                    }
                    return scriptEdits.map((edit)=>convertTextChange(edit, document));
                }
            };
        }
    };
}

const localize = mainExports.loadMessageBundle(); // TODO: not working
const defaultJsDoc = `/**\n * $0\n */`;
function create$1(ts) {
    return {
        name: 'typescript-doc-comment-template',
        capabilities: {
            completionProvider: {
                triggerCharacters: [
                    '*'
                ]
            }
        },
        create () {
            return {
                provideCompletionItems (document, position) {
                    if (!isTsDocument(document)) {
                        return;
                    }
                    if (!isPotentiallyValidDocCompletionPosition(document, position)) {
                        return;
                    }
                    const { languageService, fileName } = getLanguageServiceByDocument(ts, document);
                    const offset = document.offsetAt(position);
                    const docCommentTemplate = languageService.getDocCommentTemplateAtPosition(fileName, offset);
                    if (!docCommentTemplate) {
                        return;
                    }
                    let insertText;
                    // Workaround for #43619
                    // docCommentTemplate previously returned undefined for empty jsdoc templates.
                    // TS 2.7 now returns a single line doc comment, which breaks indentation.
                    if (docCommentTemplate.newText === '/** */') {
                        insertText = defaultJsDoc;
                    } else {
                        insertText = templateToSnippet(docCommentTemplate.newText);
                    }
                    const item = createCompletionItem(document, position, insertText);
                    return {
                        isIncomplete: false,
                        items: [
                            item
                        ]
                    };
                }
            };
        }
    };
}
function createCompletionItem(document, position, insertText) {
    const item = {
        label: '/** */'
    };
    item.kind = 1;
    item.detail = localize('typescript.jsDocCompletionItem.documentation', 'JSDoc comment');
    item.sortText = '\0';
    item.insertTextFormat = 2;
    const line = getLineText(document, position.line);
    const prefix = line.slice(0, position.character).match(/\/\**\s*$/);
    const suffix = line.slice(position.character).match(/^\s*\**\//);
    const start = {
        line: position.line,
        character: position.character + (prefix ? -prefix[0].length : 0)
    };
    const end = {
        line: position.line,
        character: position.character + (suffix ? suffix[0].length : 0)
    };
    const range = {
        start,
        end
    };
    item.textEdit = {
        range,
        newText: insertText
    };
    return item;
}
function isPotentiallyValidDocCompletionPosition(document, position) {
    // Only show the JSdoc completion when the everything before the cursor is whitespace
    // or could be the opening of a comment
    const line = getLineText(document, position.line);
    const prefix = line.slice(0, position.character);
    if (!/^\s*$|\/\*\*\s*$|^\s*\/\*\*+\s*$/.test(prefix)) {
        return false;
    }
    // And everything after is possibly a closing comment or more whitespace
    const suffix = line.slice(position.character);
    return /^\s*(\*+\/)?\s*$/.test(suffix);
}
function templateToSnippet(template) {
    // TODO: use append placeholder
    let snippetIndex = 1;
    template = template.replace(/\$/g, '\\$');
    template = template.replace(/^[ \t]*(?=(\/|[ ]\*))/gm, '');
    template = template.replace(/^(\/\*\*\s*\*[ ]*)$/m, (x)=>x + `\$0`);
    template = template.replace(/\* @param([ ]\{\S+\})?\s+(\S+)[ \t]*$/gm, (_param, type, post)=>{
        let out = '* @param ';
        if (type === ' {any}' || type === ' {*}') {
            out += `{\$\{${snippetIndex++}:*\}} `;
        } else if (type) {
            out += type + ' ';
        }
        out += post + ` \${${snippetIndex++}}`;
        return out;
    });
    template = template.replace(/\* @returns[ \t]*$/gm, `* @returns \${${snippetIndex++}}`);
    return template;
}

var out = {};

var _4_0 = {};

var hasRequired_4_0;

function require_4_0 () {
	if (hasRequired_4_0) return _4_0;
	hasRequired_4_0 = 1;
	Object.defineProperty(_4_0, "__esModule", { value: true });
	function default_1(ts, host, _service) {
	    var _a, _b;
	    // @ts-expect-error
	    const importSuggestionsCache = (_b = (_a = ts.Completions) === null || _a === void 0 ? void 0 : _a.createImportSuggestionsForFileCache) === null || _b === void 0 ? void 0 : _b.call(_a);
	    // @ts-expect-error
	    // TODO: crash on 'addListener' from 'node:process', reuse because TS has same problem
	    host.getImportSuggestionsCache = () => importSuggestionsCache;
	}
	_4_0.default = default_1;
	return _4_0;
}

var _4_4 = {};

var moduleSpecifierCache$4 = {};

var hasRequiredModuleSpecifierCache$4;

function requireModuleSpecifierCache$4 () {
	if (hasRequiredModuleSpecifierCache$4) return moduleSpecifierCache$4;
	hasRequiredModuleSpecifierCache$4 = 1;
	Object.defineProperty(moduleSpecifierCache$4, "__esModule", { value: true });
	moduleSpecifierCache$4.createModuleSpecifierCache = void 0;
	// export interface ModuleSpecifierResolutionCacheHost {
	//     watchNodeModulesForPackageJsonChanges(directoryPath: string): FileWatcher;
	// }
	function createModuleSpecifierCache(
	// host: ModuleSpecifierResolutionCacheHost
	) {
	    // let containedNodeModulesWatchers: Map<string, FileWatcher> | undefined; // TODO
	    let cache;
	    let currentKey;
	    const result = {
	        get(fromFileName, toFileName, preferences) {
	            if (!cache || currentKey !== key(fromFileName, preferences))
	                return undefined;
	            return cache.get(toFileName);
	        },
	        set(fromFileName, toFileName, preferences, modulePaths, moduleSpecifiers) {
	            ensureCache(fromFileName, preferences).set(toFileName, createInfo(modulePaths, moduleSpecifiers, /*isAutoImportable*/ true));
	            // If any module specifiers were generated based off paths in node_modules,
	            // a package.json file in that package was read and is an input to the cached.
	            // Instead of watching each individual package.json file, set up a wildcard
	            // directory watcher for any node_modules referenced and clear the cache when
	            // it sees any changes.
	            if (moduleSpecifiers) {
	                for (const p of modulePaths) {
	                    if (p.isInNodeModules) ;
	                }
	            }
	        },
	        setModulePaths(fromFileName, toFileName, preferences, modulePaths) {
	            const cache = ensureCache(fromFileName, preferences);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.modulePaths = modulePaths;
	            }
	            else {
	                cache.set(toFileName, createInfo(modulePaths, /*moduleSpecifiers*/ undefined, /*isAutoImportable*/ undefined));
	            }
	        },
	        setIsAutoImportable(fromFileName, toFileName, preferences, isAutoImportable) {
	            const cache = ensureCache(fromFileName, preferences);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.isAutoImportable = isAutoImportable;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*modulePaths*/ undefined, /*moduleSpecifiers*/ undefined, isAutoImportable));
	            }
	        },
	        clear() {
	            // containedNodeModulesWatchers?.forEach(watcher => watcher.close());
	            cache === null || cache === void 0 ? void 0 : cache.clear();
	            // containedNodeModulesWatchers?.clear();
	            currentKey = undefined;
	        },
	        count() {
	            return cache ? cache.size : 0;
	        }
	    };
	    // if (Debug.isDebugging) {
	    //     Object.defineProperty(result, "__cache", { get: () => cache });
	    // }
	    return result;
	    function ensureCache(fromFileName, preferences) {
	        const newKey = key(fromFileName, preferences);
	        if (cache && (currentKey !== newKey)) {
	            result.clear();
	        }
	        currentKey = newKey;
	        return cache || (cache = new Map());
	    }
	    function key(fromFileName, preferences) {
	        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference}`;
	    }
	    function createInfo(modulePaths, moduleSpecifiers, isAutoImportable) {
	        return { modulePaths, moduleSpecifiers, isAutoImportable };
	    }
	}
	moduleSpecifierCache$4.createModuleSpecifierCache = createModuleSpecifierCache;
	return moduleSpecifierCache$4;
}

var packageJsonCache$2 = {};

var hasRequiredPackageJsonCache$2;

function requirePackageJsonCache$2 () {
	if (hasRequiredPackageJsonCache$2) return packageJsonCache$2;
	hasRequiredPackageJsonCache$2 = 1;
	Object.defineProperty(packageJsonCache$2, "__esModule", { value: true });
	packageJsonCache$2.createPackageJsonCache = packageJsonCache$2.canCreatePackageJsonCache = void 0;
	function canCreatePackageJsonCache(ts) {
	    return 'createPackageJsonInfo' in ts && 'getDirectoryPath' in ts && 'combinePaths' in ts && 'tryFileExists' in ts && 'forEachAncestorDirectory' in ts;
	}
	packageJsonCache$2.canCreatePackageJsonCache = canCreatePackageJsonCache;
	function createPackageJsonCache(ts, host) {
	    const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
	    const packageJsons = new Map();
	    const directoriesWithoutPackageJson = new Map();
	    return {
	        addOrUpdate,
	        // @ts-expect-error
	        forEach: packageJsons.forEach.bind(packageJsons),
	        get: packageJsons.get.bind(packageJsons),
	        delete: fileName => {
	            packageJsons.delete(fileName);
	            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
	        },
	        getInDirectory: directory => {
	            return packageJsons.get(combinePaths(directory, "package.json")) || undefined;
	        },
	        directoryHasPackageJson,
	        searchDirectoryAndAncestors: directory => {
	            // @ts-expect-error
	            forEachAncestorDirectory(directory, ancestor => {
	                if (directoryHasPackageJson(ancestor) !== 3 /* Ternary.Maybe */) {
	                    return true;
	                }
	                const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
	                if (tryFileExists(host, packageJsonFileName)) {
	                    addOrUpdate(packageJsonFileName);
	                }
	                else {
	                    directoriesWithoutPackageJson.set(ancestor, true);
	                }
	            });
	        },
	    };
	    function addOrUpdate(fileName) {
	        const packageJsonInfo = 
	        // Debug.checkDefined(
	        createPackageJsonInfo(fileName, host.host);
	        // );
	        packageJsons.set(fileName, packageJsonInfo);
	        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
	    }
	    function directoryHasPackageJson(directory) {
	        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 /* Ternary.True */ :
	            directoriesWithoutPackageJson.has(directory) ? 0 /* Ternary.False */ :
	                3 /* Ternary.Maybe */;
	    }
	}
	packageJsonCache$2.createPackageJsonCache = createPackageJsonCache;
	return packageJsonCache$2;
}

var hasRequired_4_4;

function require_4_4 () {
	if (hasRequired_4_4) return _4_4;
	hasRequired_4_4 = 1;
	Object.defineProperty(_4_4, "__esModule", { value: true });
	const moduleSpecifierCache_1 = requireModuleSpecifierCache$4();
	const packageJsonCache_1 = requirePackageJsonCache$2();
	function default_1(ts, host, service) {
	    const _createCacheableExportInfoMap = ts.createCacheableExportInfoMap;
	    const _combinePaths = ts.combinePaths;
	    const _forEachAncestorDirectory = ts.forEachAncestorDirectory;
	    const _getDirectoryPath = ts.getDirectoryPath;
	    const _toPath = ts.toPath;
	    const _createGetCanonicalFileName = ts.createGetCanonicalFileName;
	    if (!_createCacheableExportInfoMap
	        || !_combinePaths
	        || !_forEachAncestorDirectory
	        || !_getDirectoryPath
	        || !_toPath
	        || !_createGetCanonicalFileName
	        || !(0, packageJsonCache_1.canCreatePackageJsonCache)(ts))
	        return;
	    const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
	    const exportMapCache = _createCacheableExportInfoMap({
	        getCurrentProgram() {
	            return service.getProgram();
	        },
	        getPackageJsonAutoImportProvider() {
	            return service.getProgram();
	        },
	    });
	    const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, Object.assign(Object.assign({}, host), { 
	        // @ts-expect-error
	        host: Object.assign({}, host), toPath }));
	    // @ts-expect-error
	    host.getCachedExportInfoMap = () => exportMapCache;
	    // @ts-expect-error
	    host.getModuleSpecifierCache = () => moduleSpecifierCache;
	    // @ts-expect-error
	    host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
	        const rootPath = rootDir && toPath(rootDir);
	        const filePath = toPath(fileName);
	        const result = [];
	        const processDirectory = (directory) => {
	            switch (packageJsonCache.directoryHasPackageJson(directory)) {
	                // Sync and check same directory again
	                case 3 /* Ternary.Maybe */:
	                    packageJsonCache.searchDirectoryAndAncestors(directory);
	                    return processDirectory(directory);
	                // Check package.json
	                case -1 /* Ternary.True */:
	                    // const packageJsonFileName = _combinePaths(directory, "package.json");
	                    // this.watchPackageJsonFile(packageJsonFileName as ts.Path); // TODO
	                    const info = packageJsonCache.getInDirectory(directory);
	                    if (info)
	                        result.push(info);
	            }
	            if (rootPath && rootPath === directory) {
	                return true;
	            }
	        };
	        _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
	        return result;
	    };
	    function toPath(fileName) {
	        var _a;
	        return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host)));
	    }
	}
	_4_4.default = default_1;
	return _4_4;
}

var _4_7 = {};

var moduleSpecifierCache$3 = {};

var hasRequiredModuleSpecifierCache$3;

function requireModuleSpecifierCache$3 () {
	if (hasRequiredModuleSpecifierCache$3) return moduleSpecifierCache$3;
	hasRequiredModuleSpecifierCache$3 = 1;
	Object.defineProperty(moduleSpecifierCache$3, "__esModule", { value: true });
	moduleSpecifierCache$3.createModuleSpecifierCache = moduleSpecifierCache$3.nodeModulesPathPart = void 0;
	moduleSpecifierCache$3.nodeModulesPathPart = "/node_modules/";
	function createModuleSpecifierCache(
	// host: ModuleSpecifierResolutionCacheHost
	) {
	    let cache;
	    let currentKey;
	    const result = {
	        get(fromFileName, toFileName, preferences, options) {
	            if (!cache || currentKey !== key(fromFileName, preferences, options))
	                return undefined;
	            return cache.get(toFileName);
	        },
	        set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
	            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(modulePaths, moduleSpecifiers, /*isBlockedByPackageJsonDependencies*/ false));
	            // If any module specifiers were generated based off paths in node_modules,
	            // a package.json file in that package was read and is an input to the cached.
	            // Instead of watching each individual package.json file, set up a wildcard
	            // directory watcher for any node_modules referenced and clear the cache when
	            // it sees any changes.
	            if (moduleSpecifiers) {
	                for (const p of modulePaths) {
	                    if (p.isInNodeModules) ;
	                }
	            }
	        },
	        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.modulePaths = modulePaths;
	            }
	            else {
	                cache.set(toFileName, createInfo(modulePaths, /*moduleSpecifiers*/ undefined, /*isBlockedByPackageJsonDependencies*/ undefined));
	            }
	        },
	        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*modulePaths*/ undefined, /*moduleSpecifiers*/ undefined, isBlockedByPackageJsonDependencies));
	            }
	        },
	        clear() {
	            cache === null || cache === void 0 ? void 0 : cache.clear();
	            currentKey = undefined;
	        },
	        count() {
	            return cache ? cache.size : 0;
	        }
	    };
	    // if (Debug.isDebugging) {
	    //     Object.defineProperty(result, "__cache", { get: () => cache });
	    // }
	    return result;
	    function ensureCache(fromFileName, preferences, options) {
	        const newKey = key(fromFileName, preferences, options);
	        if (cache && (currentKey !== newKey)) {
	            result.clear();
	        }
	        currentKey = newKey;
	        return cache || (cache = new Map());
	    }
	    function key(fromFileName, preferences, options) {
	        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
	    }
	    function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
	        return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
	    }
	}
	moduleSpecifierCache$3.createModuleSpecifierCache = createModuleSpecifierCache;
	return moduleSpecifierCache$3;
}

var packageJsonCache$1 = {};

var hasRequiredPackageJsonCache$1;

function requirePackageJsonCache$1 () {
	if (hasRequiredPackageJsonCache$1) return packageJsonCache$1;
	hasRequiredPackageJsonCache$1 = 1;
	Object.defineProperty(packageJsonCache$1, "__esModule", { value: true });
	packageJsonCache$1.createPackageJsonCache = void 0;
	function createPackageJsonCache(ts, host) {
	    const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
	    const packageJsons = new Map();
	    const directoriesWithoutPackageJson = new Map();
	    return {
	        addOrUpdate,
	        forEach: packageJsons.forEach.bind(packageJsons),
	        get: packageJsons.get.bind(packageJsons),
	        delete: fileName => {
	            packageJsons.delete(fileName);
	            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
	        },
	        getInDirectory: directory => {
	            return packageJsons.get(combinePaths(directory, "package.json")) || undefined;
	        },
	        directoryHasPackageJson,
	        searchDirectoryAndAncestors: directory => {
	            forEachAncestorDirectory(directory, (ancestor) => {
	                if (directoryHasPackageJson(ancestor) !== 3 /* Ternary.Maybe */) {
	                    return true;
	                }
	                const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
	                if (tryFileExists(host, packageJsonFileName)) {
	                    addOrUpdate(packageJsonFileName);
	                }
	                else {
	                    directoriesWithoutPackageJson.set(ancestor, true);
	                }
	            });
	        },
	    };
	    function addOrUpdate(fileName) {
	        const packageJsonInfo = 
	        // Debug.checkDefined(
	        createPackageJsonInfo(fileName, host.host);
	        // );
	        packageJsons.set(fileName, packageJsonInfo);
	        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
	    }
	    function directoryHasPackageJson(directory) {
	        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 /* Ternary.True */ :
	            directoriesWithoutPackageJson.has(directory) ? 0 /* Ternary.False */ :
	                3 /* Ternary.Maybe */;
	    }
	}
	packageJsonCache$1.createPackageJsonCache = createPackageJsonCache;
	return packageJsonCache$1;
}

var hasRequired_4_7;

function require_4_7 () {
	if (hasRequired_4_7) return _4_7;
	hasRequired_4_7 = 1;
	Object.defineProperty(_4_7, "__esModule", { value: true });
	const moduleSpecifierCache_1 = requireModuleSpecifierCache$3();
	const packageJsonCache_1 = requirePackageJsonCache$1();
	function default_1(ts, host, service) {
	    const _createCacheableExportInfoMap = ts.createCacheableExportInfoMap;
	    const _combinePaths = ts.combinePaths;
	    const _forEachAncestorDirectory = ts.forEachAncestorDirectory;
	    const _getDirectoryPath = ts.getDirectoryPath;
	    const _toPath = ts.toPath;
	    const _createGetCanonicalFileName = ts.createGetCanonicalFileName;
	    if (!_createCacheableExportInfoMap
	        || !_combinePaths
	        || !_forEachAncestorDirectory
	        || !_getDirectoryPath
	        || !_toPath
	        || !_createGetCanonicalFileName)
	        return;
	    const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
	    const exportMapCache = _createCacheableExportInfoMap({
	        getCurrentProgram() {
	            return service.getProgram();
	        },
	        getPackageJsonAutoImportProvider() {
	            return service.getProgram();
	        },
	        getGlobalTypingsCacheLocation() {
	            return undefined;
	        },
	    });
	    const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, Object.assign(Object.assign({}, host), { 
	        // @ts-expect-error
	        host: Object.assign({}, host), toPath }));
	    // @ts-expect-error
	    host.getCachedExportInfoMap = () => exportMapCache;
	    // @ts-expect-error
	    host.getModuleSpecifierCache = () => moduleSpecifierCache;
	    // @ts-expect-error
	    host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
	        const rootPath = rootDir && toPath(rootDir);
	        const filePath = toPath(fileName);
	        const result = [];
	        const processDirectory = (directory) => {
	            switch (packageJsonCache.directoryHasPackageJson(directory)) {
	                // Sync and check same directory again
	                case 3 /* Ternary.Maybe */:
	                    packageJsonCache.searchDirectoryAndAncestors(directory);
	                    return processDirectory(directory);
	                // Check package.json
	                case -1 /* Ternary.True */:
	                    // const packageJsonFileName = _combinePaths(directory, "package.json");
	                    // this.watchPackageJsonFile(packageJsonFileName as ts.Path); // TODO
	                    const info = packageJsonCache.getInDirectory(directory);
	                    if (info)
	                        result.push(info);
	            }
	            if (rootPath && rootPath === directory) {
	                return true;
	            }
	        };
	        _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
	        return result;
	    };
	    function toPath(fileName) {
	        var _a;
	        return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a = host.useCaseSensitiveFileNames) === null || _a === void 0 ? void 0 : _a.call(host)));
	    }
	}
	_4_7.default = default_1;
	return _4_7;
}

var _5_0 = {};

var projectService = {};

var packageJsonCache = {};

var hasRequiredPackageJsonCache;

function requirePackageJsonCache () {
	if (hasRequiredPackageJsonCache) return packageJsonCache;
	hasRequiredPackageJsonCache = 1;
	Object.defineProperty(packageJsonCache, "__esModule", { value: true });
	packageJsonCache.createPackageJsonCache = void 0;
	function createPackageJsonCache(ts, host) {
	    const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
	    const packageJsons = new Map();
	    const directoriesWithoutPackageJson = new Map();
	    return {
	        addOrUpdate,
	        // @ts-expect-error
	        forEach: packageJsons.forEach.bind(packageJsons),
	        get: packageJsons.get.bind(packageJsons),
	        delete: (fileName) => {
	            packageJsons.delete(fileName);
	            directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
	        },
	        getInDirectory: (directory) => {
	            return packageJsons.get(combinePaths(directory, 'package.json')) || undefined;
	        },
	        directoryHasPackageJson,
	        searchDirectoryAndAncestors: (directory) => {
	            // @ts-expect-error
	            forEachAncestorDirectory(directory, (ancestor) => {
	                if (directoryHasPackageJson(ancestor) !== 3 /* Ternary.Maybe */) {
	                    return true;
	                }
	                const packageJsonFileName = host.toPath(combinePaths(ancestor, 'package.json'));
	                if (tryFileExists(host, packageJsonFileName)) {
	                    addOrUpdate(packageJsonFileName);
	                }
	                else {
	                    directoriesWithoutPackageJson.set(ancestor, true);
	                }
	            });
	        },
	    };
	    function addOrUpdate(fileName) {
	        const packageJsonInfo = /*Debug.checkDefined( */ createPackageJsonInfo(fileName, host.host); /*);*/
	        packageJsons.set(fileName, packageJsonInfo);
	        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
	    }
	    function directoryHasPackageJson(directory) {
	        return packageJsons.has(combinePaths(directory, 'package.json'))
	            ? -1 /* Ternary.True */
	            : directoriesWithoutPackageJson.has(directory)
	                ? 0 /* Ternary.False */
	                : 3 /* Ternary.Maybe */;
	    }
	}
	packageJsonCache.createPackageJsonCache = createPackageJsonCache;
	return packageJsonCache;
}

var hasRequiredProjectService;

function requireProjectService () {
	if (hasRequiredProjectService) return projectService;
	hasRequiredProjectService = 1;
	Object.defineProperty(projectService, "__esModule", { value: true });
	projectService.createProjectService = void 0;
	const packageJsonCache_1 = requirePackageJsonCache();
	function createProjectService(ts, sys, currentDirectory, hostConfiguration, serverMode) {
	    const { toPath, getNormalizedAbsolutePath, normalizePath: toNormalizedPath, createGetCanonicalFileName, forEachAncestorDirectory, getDirectoryPath, } = ts;
	    const projectService = {
	        serverMode,
	        host: sys,
	        currentDirectory: toNormalizedPath(currentDirectory),
	        toCanonicalFileName: createGetCanonicalFileName(sys.useCaseSensitiveFileNames),
	        toPath(fileName) {
	            return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
	        },
	        getExecutingFilePath() {
	            return this.getNormalizedAbsolutePath(this.host.getExecutingFilePath());
	        },
	        getNormalizedAbsolutePath(fileName) {
	            return getNormalizedAbsolutePath(fileName, this.host.getCurrentDirectory());
	        },
	        packageJsonCache: undefined,
	        getPackageJsonsVisibleToFile(fileName, rootDir) {
	            const packageJsonCache = this.packageJsonCache;
	            const rootPath = rootDir && this.toPath(rootDir);
	            const filePath = this.toPath(fileName);
	            const result = [];
	            const processDirectory = (directory) => {
	                switch (packageJsonCache.directoryHasPackageJson(directory)) {
	                    // Sync and check same directory again
	                    case 3 /* Ternary.Maybe */:
	                        packageJsonCache.searchDirectoryAndAncestors(directory);
	                        return processDirectory(directory);
	                    // Check package.json
	                    case -1 /* Ternary.True */:
	                        // const packageJsonFileName = _combinePaths(directory, "package.json");
	                        // this.watchPackageJsonFile(packageJsonFileName as ts.Path); // TODO
	                        const info = packageJsonCache.getInDirectory(directory);
	                        if (info)
	                            result.push(info);
	                }
	                if (rootPath && rootPath === directory) {
	                    return true;
	                }
	            };
	            forEachAncestorDirectory(getDirectoryPath(filePath), processDirectory);
	            return result;
	        },
	        includePackageJsonAutoImports() {
	            switch (hostConfiguration.preferences.includePackageJsonAutoImports) {
	                case 'on': return 1 /* PackageJsonAutoImportPreference.On */;
	                case 'off': return 0 /* PackageJsonAutoImportPreference.Off */;
	                default: return 2 /* PackageJsonAutoImportPreference.Auto */;
	            }
	        },
	        fileExists(fileName) {
	            return this.host.fileExists(fileName);
	        },
	    };
	    projectService.packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, projectService);
	    return projectService;
	}
	projectService.createProjectService = createProjectService;
	return projectService;
}

var project$3 = {};

var moduleSpecifierCache$2 = {};

var hasRequiredModuleSpecifierCache$2;

function requireModuleSpecifierCache$2 () {
	if (hasRequiredModuleSpecifierCache$2) return moduleSpecifierCache$2;
	hasRequiredModuleSpecifierCache$2 = 1;
	Object.defineProperty(moduleSpecifierCache$2, "__esModule", { value: true });
	moduleSpecifierCache$2.createModuleSpecifierCache = moduleSpecifierCache$2.nodeModulesPathPart = void 0;
	moduleSpecifierCache$2.nodeModulesPathPart = "/node_modules/";
	function createModuleSpecifierCache(
	// host: ModuleSpecifierResolutionCacheHost
	) {
	    let cache;
	    let currentKey;
	    const result = {
	        get(fromFileName, toFileName, preferences, options) {
	            if (!cache || currentKey !== key(fromFileName, preferences, options))
	                return undefined;
	            return cache.get(toFileName);
	        },
	        set(fromFileName, toFileName, preferences, options, modulePaths, moduleSpecifiers) {
	            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(modulePaths, moduleSpecifiers, /*isBlockedByPackageJsonDependencies*/ false));
	            // If any module specifiers were generated based off paths in node_modules,
	            // a package.json file in that package was read and is an input to the cached.
	            // Instead of watching each individual package.json file, set up a wildcard
	            // directory watcher for any node_modules referenced and clear the cache when
	            // it sees any changes.
	            if (moduleSpecifiers) {
	                for (const p of modulePaths) {
	                    if (p.isInNodeModules) ;
	                }
	            }
	        },
	        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.modulePaths = modulePaths;
	            }
	            else {
	                cache.set(toFileName, createInfo(modulePaths, /*moduleSpecifiers*/ undefined, /*isBlockedByPackageJsonDependencies*/ undefined));
	            }
	        },
	        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*modulePaths*/ undefined, /*moduleSpecifiers*/ undefined, isBlockedByPackageJsonDependencies));
	            }
	        },
	        clear() {
	            cache === null || cache === void 0 ? void 0 : cache.clear();
	            currentKey = undefined;
	        },
	        count() {
	            return cache ? cache.size : 0;
	        }
	    };
	    // if (Debug.isDebugging) {
	    //	 Object.defineProperty(result, "__cache", { get: () => cache });
	    // }
	    return result;
	    function ensureCache(fromFileName, preferences, options) {
	        const newKey = key(fromFileName, preferences, options);
	        if (cache && (currentKey !== newKey)) {
	            result.clear();
	        }
	        currentKey = newKey;
	        return cache || (cache = new Map());
	    }
	    function key(fromFileName, preferences, options) {
	        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
	    }
	    function createInfo(modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
	        return { modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
	    }
	}
	moduleSpecifierCache$2.createModuleSpecifierCache = createModuleSpecifierCache;
	return moduleSpecifierCache$2;
}

var autoImportProviderProject = {};

var hasRequiredAutoImportProviderProject;

function requireAutoImportProviderProject () {
	if (hasRequiredAutoImportProviderProject) return autoImportProviderProject;
	hasRequiredAutoImportProviderProject = 1;
	Object.defineProperty(autoImportProviderProject, "__esModule", { value: true });
	autoImportProviderProject.createAutoImportProviderProjectStatic = void 0;
	const project_1 = requireProject$3();
	function createAutoImportProviderProjectStatic(tsBase, host, createLanguageService) {
	    const ts = tsBase;
	    const { combinePaths, inferredTypesContainingFile, arrayFrom, resolvePackageNameToPackageJson, concatenate, forEach, startsWith, getEntrypointsFromPackageJsonInfo, mapDefined, timestamp, } = ts;
	    return {
	        maxDependencies: 10,
	        compilerOptionsOverrides: {
	            diagnostics: false,
	            skipLibCheck: true,
	            sourceMap: false,
	            types: ts.emptyArray,
	            lib: ts.emptyArray,
	            noLib: true,
	        },
	        getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions) {
	            var _a, _b;
	            if (!dependencySelection) {
	                return ts.emptyArray;
	            }
	            const program = hostProject.getCurrentProgram();
	            if (!program) {
	                return ts.emptyArray;
	            }
	            const start = timestamp();
	            let dependencyNames;
	            let rootNames;
	            const rootFileName = combinePaths(hostProject.currentDirectory, inferredTypesContainingFile);
	            const packageJsons = hostProject.getPackageJsonsForAutoImport(combinePaths(hostProject.currentDirectory, rootFileName));
	            for (const packageJson of packageJsons) {
	                (_a = packageJson.dependencies) === null || _a === void 0 ? void 0 : _a.forEach((_, dependenyName) => addDependency(dependenyName));
	                (_b = packageJson.peerDependencies) === null || _b === void 0 ? void 0 : _b.forEach((_, dependencyName) => addDependency(dependencyName));
	            }
	            let dependenciesAdded = 0;
	            if (dependencyNames) {
	                const symlinkCache = hostProject.getSymlinkCache();
	                for (const name of arrayFrom(dependencyNames.keys())) {
	                    // Avoid creating a large project that would significantly slow down time to editor interactivity
	                    if (dependencySelection === 2 /* PackageJsonAutoImportPreference.Auto */ && dependenciesAdded > this.maxDependencies) {
	                        hostProject.log(`AutoImportProviderProject: attempted to add more than ${this.maxDependencies} dependencies. Aborting.`);
	                        return ts.emptyArray;
	                    }
	                    // 1. Try to load from the implementation package. For many dependencies, the
	                    //	package.json will exist, but the package will not contain any typings,
	                    //	so `entrypoints` will be undefined. In that case, or if the dependency
	                    //	is missing altogether, we will move on to trying the @types package (2).
	                    const packageJson = resolvePackageNameToPackageJson(name, hostProject.currentDirectory, compilerOptions, moduleResolutionHost, 
	                    // @ts-expect-error
	                    program.getModuleResolutionCache());
	                    if (packageJson) {
	                        const entrypoints = getRootNamesFromPackageJson(packageJson, program, symlinkCache);
	                        if (entrypoints) {
	                            rootNames = concatenate(rootNames, entrypoints);
	                            dependenciesAdded += entrypoints.length ? 1 : 0;
	                            continue;
	                        }
	                    }
	                    // 2. Try to load from the @types package in the tree and in the global
	                    //	typings cache location, if enabled.
	                    // @ts-expect-error
	                    const done = forEach([hostProject.currentDirectory, hostProject.getGlobalTypingsCacheLocation()], (directory) => {
	                        if (directory) {
	                            const typesPackageJson = resolvePackageNameToPackageJson(`@types/${name}`, directory, compilerOptions, moduleResolutionHost, 
	                            // @ts-expect-error
	                            program.getModuleResolutionCache());
	                            if (typesPackageJson) {
	                                const entrypoints = getRootNamesFromPackageJson(typesPackageJson, program, symlinkCache);
	                                rootNames = concatenate(rootNames, entrypoints);
	                                dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
	                                return true;
	                            }
	                        }
	                    });
	                    if (done)
	                        continue;
	                    // 3. If the @types package did not exist and the user has settings that
	                    //	allow processing JS from node_modules, go back to the implementation
	                    //	package and load the JS.
	                    if (packageJson && compilerOptions.allowJs && compilerOptions.maxNodeModuleJsDepth) {
	                        const entrypoints = getRootNamesFromPackageJson(packageJson, program, symlinkCache, /*allowJs*/ true);
	                        rootNames = concatenate(rootNames, entrypoints);
	                        dependenciesAdded += (entrypoints === null || entrypoints === void 0 ? void 0 : entrypoints.length) ? 1 : 0;
	                    }
	                }
	            }
	            if (rootNames === null || rootNames === void 0 ? void 0 : rootNames.length) {
	                hostProject.log(`AutoImportProviderProject: found ${rootNames.length} root files in ${dependenciesAdded} dependencies in ${timestamp() - start} ms`);
	            }
	            return rootNames || ts.emptyArray;
	            function addDependency(dependency) {
	                if (!startsWith(dependency, '@types/')) {
	                    (dependencyNames || (dependencyNames = new Set())).add(dependency);
	                }
	            }
	            function getRootNamesFromPackageJson(packageJson, program, symlinkCache, resolveJs) {
	                var _a;
	                const entrypoints = getEntrypointsFromPackageJsonInfo(packageJson, compilerOptions, moduleResolutionHost, 
	                // @ts-expect-error
	                program.getModuleResolutionCache(), resolveJs);
	                if (entrypoints) {
	                    // some packages have giant exports maps, don't add them to the project to not slow down the editor
	                    if (entrypoints.length > 100)
	                        return;
	                    const real = (_a = moduleResolutionHost.realpath) === null || _a === void 0 ? void 0 : _a.call(moduleResolutionHost, packageJson.packageDirectory);
	                    const isSymlink = real && real !== packageJson.packageDirectory;
	                    if (isSymlink) {
	                        symlinkCache.setSymlinkedDirectory(packageJson.packageDirectory, {
	                            real,
	                            realPath: hostProject.toPath(real),
	                        });
	                    }
	                    // @ts-expect-error
	                    return mapDefined(entrypoints, (entrypoint) => {
	                        const resolvedFileName = isSymlink ? entrypoint.replace(packageJson.packageDirectory, real) : entrypoint;
	                        if (!program.getSourceFile(resolvedFileName) && !(isSymlink && program.getSourceFile(entrypoint))) {
	                            return resolvedFileName;
	                        }
	                    });
	                }
	            }
	        },
	        create(dependencySelection, hostProject, moduleResolutionHost) {
	            if (dependencySelection === 0 /* PackageJsonAutoImportPreference.Off */) {
	                return undefined;
	            }
	            const compilerOptions = Object.assign(Object.assign({}, hostProject.getCompilerOptions()), this.compilerOptionsOverrides);
	            let rootNames = this.getRootFileNames(dependencySelection, hostProject, moduleResolutionHost, compilerOptions);
	            if (!rootNames.length) {
	                return undefined;
	            }
	            return createAutoImportProviderProject(tsBase, host, createLanguageService, { self: this, hostProject, rootNames, compilerOptions });
	        }
	    };
	}
	autoImportProviderProject.createAutoImportProviderProjectStatic = createAutoImportProviderProjectStatic;
	function createAutoImportProviderProject(tsBase, host, createLanguageService, options) {
	    const { self, rootNames, compilerOptions, hostProject } = options;
	    const ts = tsBase;
	    const { some } = ts;
	    const project = Object.assign(Object.assign({}, (0, project_1.createProject)(tsBase, host, createLanguageService, {
	        projectService: hostProject.projectService,
	        currentDirectory: hostProject.currentDirectory,
	        compilerOptions,
	    })), { projectVersion: 0, getProjectVersion() {
	            return this.projectVersion.toString();
	        }, rootFileNames: rootNames, hostProject,
	        isEmpty() {
	            return !some(this.rootFileNames);
	        },
	        isOrphan() {
	            return true;
	        },
	        updateGraph() {
	            var _a;
	            let rootFileNames = this.rootFileNames;
	            if (!rootFileNames) {
	                rootFileNames = self.getRootFileNames(this.hostProject.includePackageJsonAutoImports(), this.hostProject, this.hostProject.getModuleResolutionHostForAutoImportProvider(), this.getCompilationSettings());
	            }
	            this.rootFileNames = rootFileNames;
	            const oldProgram = this.getCurrentProgram();
	            this.program = (_a = this.languageService) === null || _a === void 0 ? void 0 : _a.getProgram();
	            this.dirty = false;
	            if (oldProgram && oldProgram !== this.getCurrentProgram()) {
	                this.hostProject.clearCachedExportInfoMap();
	            }
	        },
	        scheduleInvalidateResolutionsOfFailedLookupLocations() {
	            // Invalidation will happen on-demand as part of updateGraph
	            return;
	        },
	        hasRoots() {
	            var _a;
	            return !!((_a = this.rootFileNames) === null || _a === void 0 ? void 0 : _a.length);
	        },
	        markAsDirty() {
	            if (!this.dirty) {
	                this.rootFileNames = undefined;
	                this.projectVersion++;
	                this.dirty = true;
	            }
	        },
	        getScriptFileNames() {
	            return this.rootFileNames || ts.emptyArray;
	        },
	        getLanguageService() {
	            throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
	        },
	        onAutoImportProviderSettingsChanged() {
	            throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
	        },
	        onPackageJsonChange() {
	            throw new Error("package.json changes should be notified on an AutoImportProvider's host project");
	        },
	        getModuleResolutionHostForAutoImportProvider() {
	            throw new Error("AutoImportProviderProject cannot provide its own host; use `hostProject.getModuleResolutionHostForAutomImportProvider()` instead.");
	        },
	        includePackageJsonAutoImports() {
	            return 0 /* PackageJsonAutoImportPreference.Off */;
	        },
	        getTypeAcquisition() {
	            return { enable: false };
	        },
	        getSymlinkCache() {
	            return this.hostProject.getSymlinkCache();
	        },
	        getModuleResolutionCache() {
	            var _a, _b;
	            // @ts-expect-error
	            return (_b = (_a = this.hostProject.languageService) === null || _a === void 0 ? void 0 : _a.getProgram()) === null || _b === void 0 ? void 0 : _b.getModuleResolutionCache();
	        } });
	    return (0, project_1.initProject)(project, new Proxy(host, {
	        get(target, key) {
	            return key in project ? project[key] : target[key];
	        },
	        set(_target, key, value) {
	            project[key] = value;
	            return true;
	        }
	    }), createLanguageService);
	}
	return autoImportProviderProject;
}

var hasRequiredProject$3;

function requireProject$3 () {
	if (hasRequiredProject$3) return project$3;
	hasRequiredProject$3 = 1;
	Object.defineProperty(project$3, "__esModule", { value: true });
	project$3.initProject = project$3.createProject = void 0;
	const moduleSpecifierCache_1 = requireModuleSpecifierCache$2();
	const autoImportProviderProject_1 = requireAutoImportProviderProject();
	function createProject(ts, host, createLanguageService, options) {
	    var _a, _b;
	    const { combinePaths, inferredTypesContainingFile, createSymlinkCache, toPath, createCacheableExportInfoMap, timestamp, isInsideNodeModules, LanguageServiceMode, } = ts;
	    const tsCreateModuleSpecifierCache = (_a = ts.server) === null || _a === void 0 ? void 0 : _a.createModuleSpecifierCache;
	    const noopHost = {
	        watchNodeModulesForPackageJsonChanges: () => ({ close: () => { } }),
	        toPath(fileName) {
	            return toPath(fileName, host.getCurrentDirectory(), projectService.toCanonicalFileName);
	        }
	    };
	    const AutoImportProviderProject = (0, autoImportProviderProject_1.createAutoImportProviderProjectStatic)(ts, host, createLanguageService);
	    const { projectService, compilerOptions, currentDirectory } = options;
	    function updateProjectIfDirty(project) {
	        return project.dirty && project.updateGraph();
	    }
	    return {
	        dirty: false,
	        hostProject: undefined,
	        languageServiceEnabled: true,
	        languageService: undefined,
	        projectService,
	        getCanonicalFileName: projectService.toCanonicalFileName,
	        exportMapCache: undefined,
	        getCachedExportInfoMap() {
	            return (this.exportMapCache || (this.exportMapCache = createCacheableExportInfoMap(this)));
	        },
	        clearCachedExportInfoMap() {
	            var _a;
	            (_a = this.exportMapCache) === null || _a === void 0 ? void 0 : _a.clear();
	        },
	        moduleSpecifierCache: tsCreateModuleSpecifierCache
	            ? tsCreateModuleSpecifierCache(noopHost)
	            : ((_b = options.createModuleSpecifierCache) !== null && _b !== void 0 ? _b : moduleSpecifierCache_1.createModuleSpecifierCache)(),
	        getModuleSpecifierCache() {
	            return this.moduleSpecifierCache;
	        },
	        compilerOptions,
	        getCompilationSettings() {
	            return this.compilerOptions;
	        },
	        getCompilerOptions() {
	            return this.compilerOptions;
	        },
	        program: undefined,
	        getCurrentProgram() {
	            return this.program;
	        },
	        currentDirectory: projectService.getNormalizedAbsolutePath(currentDirectory || ''),
	        getCurrentDirectory() {
	            return this.currentDirectory;
	        },
	        symlinks: undefined,
	        getSymlinkCache() {
	            if (!this.symlinks) {
	                this.symlinks = createSymlinkCache(this.getCurrentDirectory(), this.getCanonicalFileName);
	            }
	            if (this.program && !this.symlinks.hasProcessedResolutions()) {
	                this.symlinks.setSymlinksFromResolutions(this.program.getSourceFiles(), 
	                // @ts-expect-error
	                this.program.getAutomaticTypeDirectiveResolutions());
	            }
	            return this.symlinks;
	        },
	        packageJsonsForAutoImport: undefined,
	        getPackageJsonsForAutoImport(rootDir) {
	            const packageJsons = this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);
	            this.packageJsonsForAutoImport = new Set(packageJsons.map((p) => p.fileName));
	            return packageJsons;
	        },
	        getPackageJsonsVisibleToFile(fileName, rootDir) {
	            return this.projectService.getPackageJsonsVisibleToFile(fileName, rootDir);
	        },
	        getModuleResolutionHostForAutoImportProvider() {
	            var _a;
	            if (this.program) {
	                return {
	                    // @ts-expect-error
	                    fileExists: this.program.fileExists,
	                    // @ts-expect-error
	                    directoryExists: this.program.directoryExists,
	                    // @ts-expect-error
	                    realpath: this.program.realpath || ((_a = this.projectService.host.realpath) === null || _a === void 0 ? void 0 : _a.bind(this.projectService.host)),
	                    getCurrentDirectory: this.getCurrentDirectory.bind(this),
	                    readFile: this.projectService.host.readFile.bind(this.projectService.host),
	                    getDirectories: this.projectService.host.getDirectories.bind(this.projectService.host),
	                    // trace: this.projectService.host.trace?.bind(this.projectService.host),
	                    trace: () => { },
	                    // @ts-expect-error
	                    useCaseSensitiveFileNames: this.program.useCaseSensitiveFileNames(),
	                };
	            }
	            return this.projectService.host;
	        },
	        autoImportProviderHost: undefined,
	        getPackageJsonAutoImportProvider() {
	            if (this.autoImportProviderHost === false) {
	                return undefined;
	            }
	            if (this.projectService.serverMode !== LanguageServiceMode.Semantic) {
	                this.autoImportProviderHost = false;
	                return undefined;
	            }
	            if (this.autoImportProviderHost) {
	                updateProjectIfDirty(this.autoImportProviderHost);
	                if (this.autoImportProviderHost.isEmpty()) {
	                    this.autoImportProviderHost.close();
	                    this.autoImportProviderHost = undefined;
	                    return undefined;
	                }
	                return this.autoImportProviderHost.getCurrentProgram();
	            }
	            const dependencySelection = projectService.includePackageJsonAutoImports();
	            if (dependencySelection) {
	                // tracing?.push(tracing.Phase.Session, "getPackageJsonAutoImportProvider");
	                const start = timestamp();
	                this.autoImportProviderHost = AutoImportProviderProject.create(dependencySelection, this, this.getModuleResolutionHostForAutoImportProvider());
	                if (this.autoImportProviderHost) {
	                    updateProjectIfDirty(this.autoImportProviderHost);
	                    this.sendPerformanceEvent('CreatePackageJsonAutoImportProvider', timestamp() - start);
	                    // tracing?.pop();
	                    return this.autoImportProviderHost.getCurrentProgram();
	                }
	                // tracing?.pop();
	            }
	        },
	        includePackageJsonAutoImports() {
	            if (this.projectService.includePackageJsonAutoImports() === 0 /* PackageJsonAutoImportPreference.Off */ ||
	                !this.languageServiceEnabled ||
	                isInsideNodeModules(this.currentDirectory) /* ||
	            !this.isDefaultProjectForOpenFiles()*/) {
	                return 0 /* PackageJsonAutoImportPreference.Off */;
	            }
	            return this.projectService.includePackageJsonAutoImports();
	        },
	        close() { },
	        log(_message) { },
	        sendPerformanceEvent(_kind, _durationMs) { },
	        toPath(fileName) {
	            return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
	        },
	        getGlobalTypingsCacheLocation() {
	            return undefined;
	        },
	        useSourceOfProjectReferenceRedirect() {
	            return !this.getCompilerOptions().disableSourceOfProjectReferenceRedirect;
	        },
	        onAutoImportProviderSettingsChanged() {
	            var _a;
	            if (this.autoImportProviderHost === false) {
	                this.autoImportProviderHost = undefined;
	            }
	            else {
	                (_a = this.autoImportProviderHost) === null || _a === void 0 ? void 0 : _a.markAsDirty();
	            }
	        },
	    };
	}
	project$3.createProject = createProject;
	function initProject(project, host, createLanguageService) {
	    const languageService = createLanguageService(host);
	    project.languageService = languageService;
	    project.program = languageService.getProgram();
	    return project;
	}
	project$3.initProject = initProject;
	return project$3;
}

var hasRequired_5_0;

function require_5_0 () {
	if (hasRequired_5_0) return _5_0;
	hasRequired_5_0 = 1;
	Object.defineProperty(_5_0, "__esModule", { value: true });
	const projectService_1 = requireProjectService();
	const project_1 = requireProject$3();
	// only create the once for all hosts, as this will improve performance as the internal cache can be reused
	let projectService;
	const projects = new Set();
	function default_1(ts, sys, host, createLanguageService, _createProject = project_1.createProject) {
	    const hostConfiguration = { preferences: { includePackageJsonAutoImports: 'auto' } };
	    if (!projectService) {
	        projectService = (0, projectService_1.createProjectService)(ts, sys, host.getCurrentDirectory(), hostConfiguration, ts.LanguageServiceMode.Semantic);
	    }
	    const project = _createProject(ts, host, createLanguageService, {
	        projectService,
	        currentDirectory: host.getCurrentDirectory(),
	        compilerOptions: host.getCompilationSettings(),
	    });
	    const proxyMethods = [
	        'getCachedExportInfoMap',
	        'getModuleSpecifierCache',
	        'getGlobalTypingsCacheLocation',
	        'getSymlinkCache',
	        'getPackageJsonsVisibleToFile',
	        'getPackageJsonAutoImportProvider',
	        'includePackageJsonAutoImports',
	        'useSourceOfProjectReferenceRedirect'
	    ];
	    proxyMethods.forEach(key => host[key] = project[key].bind(project));
	    (0, project_1.initProject)(project, host, createLanguageService);
	    projects.add(project);
	    return {
	        languageService: project.languageService,
	        setPreferences(newPreferences) {
	            let onAutoImportProviderSettingsChanged = newPreferences.includePackageJsonAutoImports !== hostConfiguration.preferences.includePackageJsonAutoImports;
	            hostConfiguration.preferences = newPreferences;
	            if (onAutoImportProviderSettingsChanged) {
	                project.onAutoImportProviderSettingsChanged();
	            }
	        },
	        projectUpdated(path) {
	            projects.forEach(projectToUpdate => {
	                var _a, _b, _c;
	                if (project === projectToUpdate || !projectToUpdate.autoImportProviderHost)
	                    return;
	                const realPaths = [...(_c = (_b = (_a = projectToUpdate.symlinks) === null || _a === void 0 ? void 0 : _a.getSymlinkedDirectoriesByRealpath()) === null || _b === void 0 ? void 0 : _b.keys()) !== null && _c !== void 0 ? _c : []]
	                    .map(name => projectToUpdate.projectService.getNormalizedAbsolutePath(name));
	                if (realPaths.includes(projectToUpdate.projectService.toCanonicalFileName(path))) {
	                    projectToUpdate.autoImportProviderHost.markAsDirty();
	                }
	            });
	        },
	    };
	}
	_5_0.default = default_1;
	return _5_0;
}

var _5_3 = {};

var project$2 = {};

var hasRequiredProject$2;

function requireProject$2 () {
	if (hasRequiredProject$2) return project$2;
	hasRequiredProject$2 = 1;
	Object.defineProperty(project$2, "__esModule", { value: true });
	project$2.createProject = void 0;
	const project_1 = requireProject$3();
	function createProject(ts, host, createLanguageService, options) {
	    const { createSymlinkCache, ensureTrailingDirectorySeparator } = ts;
	    const project = (0, project_1.createProject)(ts, host, createLanguageService, options);
	    project.getSymlinkCache = () => {
	        if (!project.symlinks) {
	            project.symlinks = createSymlinkCache(project.getCurrentDirectory(), project.getCanonicalFileName);
	            const setSymlinkedDirectory = project.symlinks.setSymlinkedDirectory;
	            project.symlinks.setSymlinkedDirectory = (symlink, real) => {
	                if (typeof real === 'object') {
	                    real.real = ensureTrailingDirectorySeparator(real.real);
	                    real.realPath = ensureTrailingDirectorySeparator(real.realPath);
	                }
	                setSymlinkedDirectory(symlink, real);
	            };
	        }
	        if (project.program && !project.symlinks.hasProcessedResolutions()) {
	            project.symlinks.setSymlinksFromResolutions(
	            // @ts-expect-error
	            project.program.forEachResolvedModule, 
	            // @ts-expect-error
	            project.program.forEachResolvedTypeReferenceDirective, 
	            // @ts-expect-error
	            project.program.getAutomaticTypeDirectiveResolutions());
	        }
	        return project.symlinks;
	    };
	    return project;
	}
	project$2.createProject = createProject;
	return project$2;
}

var hasRequired_5_3;

function require_5_3 () {
	if (hasRequired_5_3) return _5_3;
	hasRequired_5_3 = 1;
	Object.defineProperty(_5_3, "__esModule", { value: true });
	const _5_0_1 = require_5_0();
	const project_1 = requireProject$2();
	function default_1(ts, sys, host, createLanguageService) {
	    return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
	}
	_5_3.default = default_1;
	return _5_3;
}

var _5_5 = {};

var project$1 = {};

var moduleSpecifierCache$1 = {};

var hasRequiredModuleSpecifierCache$1;

function requireModuleSpecifierCache$1 () {
	if (hasRequiredModuleSpecifierCache$1) return moduleSpecifierCache$1;
	hasRequiredModuleSpecifierCache$1 = 1;
	Object.defineProperty(moduleSpecifierCache$1, "__esModule", { value: true });
	moduleSpecifierCache$1.createModuleSpecifierCache = void 0;
	function createModuleSpecifierCache(
	// host: ModuleSpecifierResolutionCacheHost
	) {
	    let cache;
	    let currentKey;
	    const result = {
	        get(fromFileName, toFileName, preferences, options) {
	            if (!cache || currentKey !== key(fromFileName, preferences, options))
	                return undefined;
	            return cache.get(toFileName);
	        },
	        set(fromFileName, toFileName, preferences, options, kind, modulePaths, moduleSpecifiers) {
	            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(kind, modulePaths, moduleSpecifiers, /*isBlockedByPackageJsonDependencies*/ false));
	            // If any module specifiers were generated based off paths in node_modules,
	            // a package.json file in that package was read and is an input to the cached.
	            // Instead of watching each individual package.json file, set up a wildcard
	            // directory watcher for any node_modules referenced and clear the cache when
	            // it sees any changes.
	            if (moduleSpecifiers) {
	                for (const p of modulePaths) {
	                    if (p.isInNodeModules) ;
	                }
	            }
	        },
	        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.modulePaths = modulePaths;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*kind*/ undefined, modulePaths, /*moduleSpecifiers*/ undefined, /*isBlockedByPackageJsonDependencies*/ undefined));
	            }
	        },
	        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, isBlockedByPackageJsonDependencies) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*kind*/ undefined, /*modulePaths*/ undefined, /*moduleSpecifiers*/ undefined, isBlockedByPackageJsonDependencies));
	            }
	        },
	        clear() {
	            cache === null || cache === void 0 ? void 0 : cache.clear();
	            currentKey = undefined;
	        },
	        count() {
	            return cache ? cache.size : 0;
	        }
	    };
	    // if (Debug.isDebugging) {
	    //	 Object.defineProperty(result, "__cache", { get: () => cache });
	    // }
	    return result;
	    function ensureCache(fromFileName, preferences, options) {
	        const newKey = key(fromFileName, preferences, options);
	        if (cache && (currentKey !== newKey)) {
	            result.clear();
	        }
	        currentKey = newKey;
	        return cache || (cache = new Map());
	    }
	    function key(fromFileName, preferences, options) {
	        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
	    }
	    function createInfo(kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies) {
	        return { kind, modulePaths, moduleSpecifiers, isBlockedByPackageJsonDependencies };
	    }
	}
	moduleSpecifierCache$1.createModuleSpecifierCache = createModuleSpecifierCache;
	return moduleSpecifierCache$1;
}

var hasRequiredProject$1;

function requireProject$1 () {
	if (hasRequiredProject$1) return project$1;
	hasRequiredProject$1 = 1;
	Object.defineProperty(project$1, "__esModule", { value: true });
	project$1.createProject = void 0;
	const project_1 = requireProject$2();
	const moduleSpecifierCache_1 = requireModuleSpecifierCache$1();
	function createProject(ts, host, createLanguageService, options) {
	    // @ts-expect-error
	    options.createModuleSpecifierCache = moduleSpecifierCache_1.createModuleSpecifierCache;
	    return (0, project_1.createProject)(ts, host, createLanguageService, options);
	}
	project$1.createProject = createProject;
	return project$1;
}

var hasRequired_5_5;

function require_5_5 () {
	if (hasRequired_5_5) return _5_5;
	hasRequired_5_5 = 1;
	Object.defineProperty(_5_5, "__esModule", { value: true });
	const _5_0_1 = require_5_0();
	const project_1 = requireProject$1();
	function default_1(ts, sys, host, createLanguageService) {
	    return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
	}
	_5_5.default = default_1;
	return _5_5;
}

var _5_6 = {};

var project = {};

var moduleSpecifierCache = {};

var hasRequiredModuleSpecifierCache;

function requireModuleSpecifierCache () {
	if (hasRequiredModuleSpecifierCache) return moduleSpecifierCache;
	hasRequiredModuleSpecifierCache = 1;
	Object.defineProperty(moduleSpecifierCache, "__esModule", { value: true });
	moduleSpecifierCache.createModuleSpecifierCache = void 0;
	function createModuleSpecifierCache(
	// host: ModuleSpecifierResolutionCacheHost
	) {
	    let cache;
	    let currentKey;
	    const result = {
	        get(fromFileName, toFileName, preferences, options) {
	            if (!cache || currentKey !== key(fromFileName, preferences, options))
	                return undefined;
	            return cache.get(toFileName);
	        },
	        set(fromFileName, toFileName, preferences, options, kind, modulePaths, moduleSpecifiers) {
	            ensureCache(fromFileName, preferences, options).set(toFileName, createInfo(kind, modulePaths, moduleSpecifiers, /*packageName */ undefined, /*isBlockedByPackageJsonDependencies*/ false));
	            // If any module specifiers were generated based off paths in node_modules,
	            // a package.json file in that package was read and is an input to the cached.
	            // Instead of watching each individual package.json file, set up a wildcard
	            // directory watcher for any node_modules referenced and clear the cache when
	            // it sees any changes.
	            if (moduleSpecifiers) {
	                for (const p of modulePaths) {
	                    if (p.isInNodeModules) ;
	                }
	            }
	        },
	        setModulePaths(fromFileName, toFileName, preferences, options, modulePaths) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.modulePaths = modulePaths;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*kind*/ undefined, modulePaths, /*moduleSpecifiers*/ undefined, /*packageName */ undefined, /*isBlockedByPackageJsonDependencies*/ undefined));
	            }
	        },
	        setBlockedByPackageJsonDependencies(fromFileName, toFileName, preferences, options, packageName, isBlockedByPackageJsonDependencies) {
	            const cache = ensureCache(fromFileName, preferences, options);
	            const info = cache.get(toFileName);
	            if (info) {
	                info.isBlockedByPackageJsonDependencies = isBlockedByPackageJsonDependencies;
	                info.packageName = packageName;
	            }
	            else {
	                cache.set(toFileName, createInfo(/*kind*/ undefined, /*modulePaths*/ undefined, /*moduleSpecifiers*/ undefined, /*packageName */ undefined, isBlockedByPackageJsonDependencies));
	            }
	        },
	        clear() {
	            cache === null || cache === void 0 ? void 0 : cache.clear();
	            currentKey = undefined;
	        },
	        count() {
	            return cache ? cache.size : 0;
	        }
	    };
	    // if (Debug.isDebugging) {
	    //	 Object.defineProperty(result, "__cache", { get: () => cache });
	    // }
	    return result;
	    function ensureCache(fromFileName, preferences, options) {
	        const newKey = key(fromFileName, preferences, options);
	        if (cache && (currentKey !== newKey)) {
	            result.clear();
	        }
	        currentKey = newKey;
	        return cache || (cache = new Map());
	    }
	    function key(fromFileName, preferences, options) {
	        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference},${options.overrideImportMode}`;
	    }
	    function createInfo(kind, modulePaths, moduleSpecifiers, packageName, isBlockedByPackageJsonDependencies) {
	        return { kind, modulePaths, moduleSpecifiers, packageName, isBlockedByPackageJsonDependencies };
	    }
	}
	moduleSpecifierCache.createModuleSpecifierCache = createModuleSpecifierCache;
	return moduleSpecifierCache;
}

var hasRequiredProject;

function requireProject () {
	if (hasRequiredProject) return project;
	hasRequiredProject = 1;
	Object.defineProperty(project, "__esModule", { value: true });
	project.createProject = void 0;
	const project_1 = requireProject$2();
	const moduleSpecifierCache_1 = requireModuleSpecifierCache();
	function createProject(ts, host, createLanguageService, options) {
	    // @ts-expect-error
	    options.createModuleSpecifierCache = moduleSpecifierCache_1.createModuleSpecifierCache;
	    return (0, project_1.createProject)(ts, host, createLanguageService, options);
	}
	project.createProject = createProject;
	return project;
}

var hasRequired_5_6;

function require_5_6 () {
	if (hasRequired_5_6) return _5_6;
	hasRequired_5_6 = 1;
	Object.defineProperty(_5_6, "__esModule", { value: true });
	const _5_0_1 = require_5_0();
	const project_1 = requireProject();
	function default_1(ts, sys, host, createLanguageService) {
	    return (0, _5_0_1.default)(ts, sys, host, createLanguageService, project_1.createProject);
	}
	_5_6.default = default_1;
	return _5_6;
}

var hasRequiredOut;

function requireOut () {
	if (hasRequiredOut) return out;
	hasRequiredOut = 1;
	Object.defineProperty(out, "__esModule", { value: true });
	out.createLanguageService = void 0;
	const semver = requireSemver();
	const _4_0_1 = require_4_0();
	const _4_4_1 = require_4_4();
	const _4_7_1 = require_4_7();
	const _5_0_1 = require_5_0();
	const _5_3_1 = require_5_3();
	const _5_5_1 = require_5_5();
	const _5_6_1 = require_5_6();
	function createLanguageService(ts, sys, host, createLanguageService) {
	    // moduleSpecifierCache changes introduced in 5.6.1-rc 
	    // https://github.com/microsoft/TypeScript/pull/59604
	    if (semver.gte(ts.version, '5.6.1-rc')) {
	        return (0, _5_6_1.default)(ts, sys, host, createLanguageService);
	    }
	    if (semver.gte(ts.version, '5.5.1')) {
	        return (0, _5_5_1.default)(ts, sys, host, createLanguageService);
	    }
	    else if (semver.gte(ts.version, '5.3.0')) {
	        return (0, _5_3_1.default)(ts, sys, host, createLanguageService);
	    }
	    else if (semver.gte(ts.version, '5.0.0')) {
	        return (0, _5_0_1.default)(ts, sys, host, createLanguageService);
	    }
	    else if (semver.gte(ts.version, '4.7.0')) {
	        const service = createLanguageService(host);
	        (0, _4_7_1.default)(ts, host, service);
	        return { languageService: service };
	    }
	    else if (semver.gte(ts.version, '4.4.0')) {
	        const service = createLanguageService(host);
	        (0, _4_4_1.default)(ts, host, service);
	        return { languageService: service };
	    }
	    else if (semver.gte(ts.version, '4.0.0')) {
	        const service = createLanguageService(host);
	        (0, _4_0_1.default)(ts, host, service);
	        return { languageService: service };
	    }
	    return { languageService: createLanguageService(host) };
	}
	out.createLanguageService = createLanguageService;
	return out;
}

var outExports = requireOut();

var LIB;(()=>{var t={975:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else {if(47===r)break;r=47;}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf("/");if(a!==n.length-1){ -1===a?(n="",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf("/"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=h,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2);}else n.length>0?n+="/"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0;}else 46===r&&-1!==s?++s:s=-1;}return n}var n={resolve:function(){for(var t,n="",i=false,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0));}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return ".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return ".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i);}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return "";if((t=n.resolve(t))===(r=n.resolve(r)))return "";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u);}var g="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+="..":g+="/..");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return ".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=true,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=false;return  -1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=true;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return "";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else  -1===a&&(s=false,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a));}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else  -1===o&&(s=false,o=n+1);return  -1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=true,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a) -1===i&&(o=false,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return  -1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,h=0,a=-1,c=true,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f))) -1===a&&(c=false,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return  -1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n;}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:true,get:e[n]});},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:true});};var n={};let i;if(r.r(n),r.d(n,{URI:()=>l,Utils:()=>I}),"object"==typeof process)i="win32"===process.platform;else if("object"==typeof navigator){let t=navigator.userAgent;i=t.indexOf("Windows")>=0;}const o=/^\w[\w\d+.-]*$/,s=/^\//,h=/^\/\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!o.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!s.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(h.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const c="",f="/",u=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class l{static isUri(t){return t instanceof l||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=false){"object"==typeof t?(this.scheme=t.scheme||c,this.authority=t.authority||c,this.path=t.path||c,this.query=t.query||c,this.fragment=t.fragment||c):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||c,this.path=function(t,e){switch(t){case "https":case "http":case "file":e?e[0]!==f&&(e=f+e):e=f;}return e}(this.scheme,r||c),this.query=n||c,this.fragment=i||c,a(this,o));}get fsPath(){return v(this)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=c),void 0===r?r=this.authority:null===r&&(r=c),void 0===n?n=this.path:null===n&&(n=c),void 0===i?i=this.query:null===i&&(i=c),void 0===o?o=this.fragment:null===o&&(o=c),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=false){const r=u.exec(t);return r?new d(r[2]||c,w(r[4]||c),w(r[5]||c),w(r[7]||c),w(r[9]||c),e):new d(c,c,c,c,c)}static file(t){let e=c;if(i&&(t=t.replace(/\\/g,f)),t[0]===f&&t[1]===f){const r=t.indexOf(f,2);-1===r?(e=t.substring(2),t=f):(e=t.substring(2,r),t=t.substring(r)||f);}return new d("file",e,t,c,c)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,true),e}toString(t=false){return b(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof l)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===g?t.fsPath:null,e}}return t}}const g=i?1:void 0;class d extends l{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this)),this._fsPath}toString(t=false){return t?b(this,true):(this._formatted||(this._formatted=b(this,false)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=g),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function m(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s) -1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else { void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o);}}return  -1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function y(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r]);}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?t.path[1].toLowerCase()+t.path.substr(2):t.path,i&&(r=r.replace(/\//g,"\\")),r}function b(t,e){const r=e?y:m;let n="",{scheme:i,authority:o,path:s,query:h,fragment:a}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=f,n+=f),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,false,false):(n+=r(e.substr(0,t),false,false),n+=":",n+=r(e.substr(t+1),false,true)),n+="@";}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,false,true):(n+=r(o.substr(0,t),false,true),n+=o.substr(t));}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`);}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`);}n+=r(s,true,false);}return h&&(n+="?",n+=r(h,false,false)),a&&(n+="#",n+=e?a:m(a,false,false)),n}function C(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+C(t.substr(3)):t}}const A=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(A)?t.replace(A,(t=>C(t))):t}var x=r(975);const P=x.posix||x,_="/";var I;!function(t){t.joinPath=function(t,...e){return t.with({path:P.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=false;r[0]!==_&&(r=_+r,n=true);let i=P.resolve(r,...e);return n&&i[0]===_&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===_)return t;let e=P.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return P.basename(t.path)},t.extname=function(t){return P.extname(t.path)};}(I||(I={})),LIB=n;})();const{URI,Utils}=LIB;

async function getUserPreferences(ctx, document) {
    let currentDirectory = '';
    if (ctx.project.typescript) {
        currentDirectory = ctx.project.typescript.languageServiceHost.getCurrentDirectory();
    }
    const uri = URI.parse(document.uri);
    const documentUri = ctx.decodeEmbeddedDocumentUri(uri)?.[0] ?? uri;
    const config = await ctx.env.getConfiguration?.(getConfigTitle(document)) ?? {};
    const preferencesConfig = config?.preferences ?? {};
    const preferences = {
        ...config.unstable ?? {},
        quotePreference: getQuoteStylePreference(preferencesConfig),
        importModuleSpecifierPreference: getImportModuleSpecifierPreference(preferencesConfig),
        importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
        jsxAttributeCompletionStyle: getJsxAttributeCompletionStyle(preferencesConfig),
        allowTextChangesInNewFiles: documentUri.scheme === 'file',
        providePrefixAndSuffixTextForRename: (preferencesConfig.renameShorthandProperties ?? true) === false ? false : preferencesConfig.useAliasesForRenames ?? true,
        allowRenameOfImportPath: true,
        includeAutomaticOptionalChainCompletions: config.suggest?.includeAutomaticOptionalChainCompletions ?? true,
        provideRefactorNotApplicableReason: true,
        generateReturnInDocTemplate: config.suggest?.jsdoc?.generateReturns ?? true,
        includeCompletionsForImportStatements: config.suggest?.includeCompletionsForImportStatements ?? true,
        includeCompletionsWithSnippetText: config.suggest?.includeCompletionsWithSnippetText ?? true,
        includeCompletionsWithClassMemberSnippets: config.suggest?.classMemberSnippets?.enabled ?? true,
        includeCompletionsWithObjectLiteralMethodSnippets: config.suggest?.objectLiteralMethodSnippets?.enabled ?? true,
        autoImportFileExcludePatterns: getAutoImportFileExcludePatternsPreference(preferencesConfig, currentDirectory),
        useLabelDetailsInCompletionEntries: true,
        allowIncompleteCompletions: true,
        displayPartsForJSDoc: true,
        // inlay hints
        includeInlayParameterNameHints: getInlayParameterNameHintsPreference(config),
        includeInlayParameterNameHintsWhenArgumentMatchesName: !(config.inlayHints?.parameterNames?.suppressWhenArgumentMatchesName ?? true),
        includeInlayFunctionParameterTypeHints: config.inlayHints?.parameterTypes?.enabled ?? true,
        includeInlayVariableTypeHints: config.inlayHints?.variableTypes?.enabled ?? true,
        includeInlayVariableTypeHintsWhenTypeMatchesName: !(config.inlayHints?.variableTypes?.suppressWhenTypeMatchesName ?? true),
        includeInlayPropertyDeclarationTypeHints: config.inlayHints?.propertyDeclarationTypes?.enabled ?? true,
        includeInlayFunctionLikeReturnTypeHints: config.inlayHints?.functionLikeReturnTypes?.enabled ?? true,
        includeInlayEnumMemberValueHints: config.inlayHints?.enumMemberValues?.enabled ?? true,
        // https://github.com/microsoft/vscode/blob/main/extensions/typescript-language-features/src/languageFeatures/completions.ts#L728-L730
        includeCompletionsForModuleExports: config.suggest?.autoImports ?? true,
        includeCompletionsWithInsertText: true,
        includePackageJsonAutoImports: preferencesConfig.includePackageJsonAutoImports ?? 'auto'
    };
    return preferences;
}
function getQuoteStylePreference(config) {
    switch(config.quoteStyle){
        case 'single':
            return 'single';
        case 'double':
            return 'double';
        default:
            return 'auto';
    }
}
function getAutoImportFileExcludePatternsPreference(config, workspacePath) {
    return workspacePath && config.autoImportFileExcludePatterns?.map((p)=>{
        // Normalization rules: https://github.com/microsoft/TypeScript/pull/49578
        const slashNormalized = p.replace(/\\/g, '/');
        const isRelative = /^\.\.?($|\/)/.test(slashNormalized);
        return pathBrowserifyExports.isAbsolute(p) ? p : p.startsWith('*') ? '/' + slashNormalized : isRelative ? pathBrowserifyExports.join(workspacePath, p) : '/**/' + slashNormalized;
    });
}
function getImportModuleSpecifierPreference(config) {
    switch(config.importModuleSpecifier){
        case 'project-relative':
            return 'project-relative';
        case 'relative':
            return 'relative';
        case 'non-relative':
            return 'non-relative';
        default:
            return undefined;
    }
}
function getImportModuleSpecifierEndingPreference(config) {
    switch(config.importModuleSpecifierEnding){
        case 'minimal':
            return 'minimal';
        case 'index':
            return 'index';
        case 'js':
            return 'js';
        default:
            return 'minimal'; // fix https://github.com/johnsoncodehk/volar/issues/1667
    }
}
function getJsxAttributeCompletionStyle(config) {
    switch(config.jsxAttributeCompletionStyle){
        case 'braces':
            return 'braces';
        case 'none':
            return 'none';
        default:
            return 'auto';
    }
}
function getInlayParameterNameHintsPreference(config) {
    switch(config.inlayHints?.parameterNames?.enabled){
        case 'none':
            return 'none';
        case 'literals':
            return 'literals';
        case 'all':
            return 'all';
        default:
            return undefined;
    }
}

const awaitInSyncFunction = 'fixAwaitInSyncFunction';
const classIncorrectlyImplementsInterface = 'fixClassIncorrectlyImplementsInterface';
const unreachableCode = 'fixUnreachableCode';
const unusedIdentifier = 'unusedIdentifier';
const fixImport = 'import';

function register$2(ctx) {
    return async (codeAction, formattingOptions)=>{
        const data = codeAction.data;
        const document = ctx.getTextDocument(URI.parse(data.uri));
        const [formatOptions, preferences] = await Promise.all([
            getFormatCodeSettings(ctx, document, formattingOptions),
            getUserPreferences(ctx, document)
        ]);
        if (data?.type === 'fixAll') {
            resolveFixAllCodeAction(ctx, codeAction, data, formatOptions, preferences);
        } else if (data?.type === 'refactor') {
            resolveRefactorCodeAction(ctx, codeAction, data, document, formatOptions, preferences);
        } else if (data?.type === 'organizeImports') {
            resolveOrganizeImportsCodeAction(ctx, codeAction, data, formatOptions, preferences);
        }
        return codeAction;
    };
}
function resolveFixAllCodeAction(ctx, codeAction, data, formatOptions, preferences) {
    const fixes = data.fixIds.map((fixId)=>safeCall(()=>ctx.languageService.getCombinedCodeFix({
                type: 'file',
                fileName: data.fileName
            }, fixId, formatOptions, preferences)));
    const changes = fixes.map((fix)=>fix?.changes ?? []).flat();
    codeAction.edit = convertFileTextChanges(changes, ctx.fileNameToUri, ctx.getTextDocument);
}
function resolveRefactorCodeAction(ctx, codeAction, data, document, formatOptions, preferences) {
    const editInfo = safeCall(()=>ctx.languageService.getEditsForRefactor(data.fileName, formatOptions, data.range, data.refactorName, data.actionName, preferences));
    if (!editInfo) {
        return;
    }
    codeAction.edit = convertFileTextChanges(editInfo.edits, ctx.fileNameToUri, ctx.getTextDocument);
    if (editInfo.renameLocation !== undefined && editInfo.renameFilename !== undefined) {
        codeAction.command = ctx.commands.rename.create(document.uri, document.positionAt(editInfo.renameLocation));
    }
}
function resolveOrganizeImportsCodeAction(ctx, codeAction, data, formatOptions, preferences) {
    const changes = safeCall(()=>ctx.languageService.organizeImports({
            type: 'file',
            fileName: data.fileName
        }, formatOptions, preferences));
    codeAction.edit = convertFileTextChanges(changes ?? [], ctx.fileNameToUri, ctx.getTextDocument);
}

const renameCommandRefactors = new Set([
    'refactor.rewrite.property.generateAccessors',
    'refactor.extract.type',
    'refactor.extract.interface',
    'refactor.extract.typedef',
    'refactor.extract.constant',
    'refactor.extract.function'
]);
function register$1(ctx) {
    let resolveCommandSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes('command');
    let resolveEditSupport = ctx.env.clientCapabilities?.textDocument?.codeAction?.resolveSupport?.properties?.includes('edit');
    let loged = false;
    const wranUnsupportResolve = ()=>{
        if (loged) {
            return;
        }
        loged = true;
        console.warn('[volar-service-typescript] The language client lacks support for the command/edit properties in the resolve code action. Therefore, the code action resolve is pre-calculated.');
    };
    if (!ctx.env.clientCapabilities) {
        resolveCommandSupport = true;
        resolveEditSupport = true;
    }
    return async (uri, document, range, context, formattingOptions)=>{
        const [formatOptions, preferences] = await Promise.all([
            getFormatCodeSettings(ctx, document, formattingOptions),
            getUserPreferences(ctx, document)
        ]);
        const fileName = ctx.uriToFileName(uri);
        const start = document.offsetAt(range.start);
        const end = document.offsetAt(range.end);
        let result = [];
        const onlyQuickFix = matchOnlyKind(`${'quickfix'}.ts`);
        if (!context.only || onlyQuickFix) {
            for (const error of context.diagnostics){
                const codeFixes = safeCall(()=>ctx.languageService.getCodeFixesAtPosition(fileName, document.offsetAt(error.range.start), document.offsetAt(error.range.end), [
                        Number(error.code)
                    ], formatOptions, preferences)) ?? [];
                for (const codeFix of codeFixes){
                    result = result.concat(convertCodeFixAction(codeFix, [
                        error
                    ], onlyQuickFix ?? ''));
                }
            }
        }
        if (context.only) {
            for (const only of context.only){
                if (only.split('.')[0] === 'refactor') {
                    const refactors = safeCall(()=>ctx.languageService.getApplicableRefactors(fileName, {
                            pos: start,
                            end: end
                        }, preferences, undefined, only)) ?? [];
                    for (const refactor of refactors){
                        result = result.concat(convertApplicableRefactorInfo(refactor));
                    }
                }
            }
        } else {
            const refactors = safeCall(()=>ctx.languageService.getApplicableRefactors(fileName, {
                    pos: start,
                    end: end
                }, preferences, undefined, undefined)) ?? [];
            for (const refactor of refactors){
                result = result.concat(convertApplicableRefactorInfo(refactor));
            }
        }
        const onlySourceOrganizeImports = matchOnlyKind(`${'source.organizeImports'}.ts`);
        if (onlySourceOrganizeImports) {
            const action = {
                title: 'Organize Imports',
                kind: onlySourceOrganizeImports
            };
            const data = {
                type: 'organizeImports',
                uri: document.uri,
                fileName
            };
            if (resolveEditSupport) {
                action.data = data;
            } else {
                wranUnsupportResolve();
                resolveOrganizeImportsCodeAction(ctx, action, data, formatOptions, preferences);
            }
            result.push(action);
        }
        const onlySourceFixAll = matchOnlyKind(`${'source.fixAll'}.ts`);
        if (onlySourceFixAll) {
            const action = {
                title: 'Fix All',
                kind: onlySourceFixAll
            };
            const data = {
                uri: document.uri,
                type: 'fixAll',
                fileName,
                fixIds: [
                    classIncorrectlyImplementsInterface,
                    awaitInSyncFunction,
                    unreachableCode
                ]
            };
            if (resolveEditSupport) {
                action.data = data;
            } else {
                wranUnsupportResolve();
                resolveFixAllCodeAction(ctx, action, data, formatOptions, preferences);
            }
            result.push(action);
        }
        const onlyRemoveUnused = matchOnlyKind(`${'source'}.removeUnused.ts`);
        if (onlyRemoveUnused) {
            const action = {
                title: 'Remove all unused code',
                kind: onlyRemoveUnused
            };
            const data = {
                uri: document.uri,
                type: 'fixAll',
                fileName,
                fixIds: [
                    // not working and throw
                    unusedIdentifier,
                    // TODO: remove patching
                    'unusedIdentifier_prefix',
                    'unusedIdentifier_deleteImports',
                    'unusedIdentifier_delete',
                    'unusedIdentifier_infer'
                ]
            };
            if (resolveEditSupport) {
                action.data = data;
            } else {
                wranUnsupportResolve();
                resolveFixAllCodeAction(ctx, action, data, formatOptions, preferences);
            }
            result.push(action);
        }
        const onlyAddMissingImports = matchOnlyKind(`${'source'}.addMissingImports.ts`);
        if (onlyAddMissingImports) {
            const action = {
                title: 'Add all missing imports',
                kind: onlyAddMissingImports
            };
            const data = {
                uri: document.uri,
                type: 'fixAll',
                fileName,
                fixIds: [
                    // not working and throw
                    fixImport,
                    // TODO: remove patching
                    'fixMissingImport'
                ]
            };
            if (resolveEditSupport) {
                action.data = data;
            } else {
                wranUnsupportResolve();
                resolveFixAllCodeAction(ctx, action, data, formatOptions, preferences);
            }
            result.push(action);
        }
        for (const codeAction of result){
            if (codeAction.diagnostics === undefined) {
                codeAction.diagnostics = context.diagnostics;
            }
        }
        return result;
        function matchOnlyKind(kind) {
            if (context.only) {
                for (const only of context.only){
                    const a = only.split('.');
                    const b = kind.split('.');
                    if (a.length <= b.length) {
                        let matchNums = 0;
                        for(let i = 0; i < a.length; i++){
                            if (a[i] == b[i]) {
                                matchNums++;
                            }
                        }
                        if (matchNums === a.length) {
                            return only;
                        }
                    }
                }
            }
        }
        function convertCodeFixAction(codeFix, diagnostics, kind) {
            const edit = convertFileTextChanges(codeFix.changes, ctx.fileNameToUri, ctx.getTextDocument);
            const codeActions = [];
            const fix = {
                title: codeFix.description,
                kind,
                edit
            };
            fix.diagnostics = diagnostics;
            codeActions.push(fix);
            if (codeFix.fixAllDescription && codeFix.fixId) {
                const fixAll = {
                    title: codeFix.fixAllDescription,
                    kind
                };
                const data = {
                    uri: document.uri,
                    type: 'fixAll',
                    fileName,
                    fixIds: [
                        codeFix.fixId
                    ]
                };
                if (resolveEditSupport) {
                    fixAll.data = data;
                } else {
                    wranUnsupportResolve();
                    resolveFixAllCodeAction(ctx, fixAll, data, formatOptions, preferences);
                }
                fixAll.diagnostics = diagnostics;
                codeActions.push(fixAll);
            }
            return codeActions;
        }
        function convertApplicableRefactorInfo(refactor) {
            const codeActions = [];
            for (const action of refactor.actions){
                const codeAction = {
                    title: action.description,
                    kind: action.kind
                };
                if (action.notApplicableReason) {
                    codeAction.disabled = {
                        reason: action.notApplicableReason
                    };
                }
                if (refactor.inlineable) {
                    codeAction.isPreferred = true;
                }
                const data = {
                    uri: document.uri,
                    type: 'refactor',
                    fileName,
                    range: {
                        pos: start,
                        end: end
                    },
                    refactorName: refactor.name,
                    actionName: action.name
                };
                const hasCommand = renameCommandRefactors.has(action.kind);
                if (hasCommand && resolveCommandSupport && resolveEditSupport) {
                    codeAction.data = data;
                } else if (!hasCommand && resolveEditSupport) {
                    codeAction.data = data;
                } else if (!codeAction.disabled) {
                    wranUnsupportResolve();
                    resolveRefactorCodeAction(ctx, codeAction, data, document, formatOptions, preferences);
                }
                codeActions.push(codeAction);
            }
            return codeActions;
        }
    };
}

function register(ts, ctx) {
    return (uri, document, range, legend)=>{
        console.log('chufale tokens de shiyan ');
        const fileName = ctx.uriToFileName(uri);
        const start = range ? document.offsetAt(range.start) : 0;
        const length = range ? document.offsetAt(range.end) - start : document.getText().length;
        if (ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested()) {
            return;
        }
        const response = safeCall(()=>ctx.languageService.getEncodedSemanticClassifications(fileName, {
                start,
                length
            }, ts.SemanticClassificationFormat.TwentyTwenty));
        if (!response) {
            return;
        }
        let tokenModifiersTable = [];
        tokenModifiersTable[2] = 1 << legend.tokenModifiers.indexOf('async');
        tokenModifiersTable[0] = 1 << legend.tokenModifiers.indexOf('declaration');
        tokenModifiersTable[3] = 1 << legend.tokenModifiers.indexOf('readonly');
        tokenModifiersTable[1] = 1 << legend.tokenModifiers.indexOf('static');
        tokenModifiersTable[5] = 1 << legend.tokenModifiers.indexOf('local');
        tokenModifiersTable[4] = 1 << legend.tokenModifiers.indexOf('defaultLibrary');
        tokenModifiersTable = tokenModifiersTable.map((mod)=>Math.max(mod, 0));
        const end = start + length;
        const tokenSpan = response.spans;
        const tokens = [];
        let i = 0;
        while(i < tokenSpan.length){
            const offset = tokenSpan[i++];
            if (offset >= end) {
                break;
            }
            const length = tokenSpan[i++];
            const tsClassification = tokenSpan[i++];
            //7
            const tokenType = getTokenTypeFromClassification(tsClassification);
            if (tokenType === undefined) {
                continue;
            }
            // we can use the document's range conversion methods because the result is at the same version as the document
            const startPos = document.positionAt(offset);
            const endPos = document.positionAt(offset + length);
            const serverToken = tsTokenTypeToServerTokenType(tokenType);
            if (serverToken === undefined) {
                continue;
            }
            const tokenModifiers = getTokenModifierFromClassification(tsClassification);
            const serverTokenModifiers = tsTokenModifierToServerTokenModifier(tokenModifiers);
            for(let line = startPos.line; line <= endPos.line; line++){
                const startCharacter = line === startPos.line ? startPos.character : 0;
                const endCharacter = line === endPos.line ? endPos.character : docLineLength(document, line);
                tokens.push([
                    line,
                    startCharacter,
                    endCharacter - startCharacter,
                    serverToken,
                    serverTokenModifiers
                ]);
            }
        }
        return tokens;
        function tsTokenTypeToServerTokenType(tokenType) {
            return legend.tokenTypes.indexOf(tokenTypes[tokenType]);
        }
        function tsTokenModifierToServerTokenModifier(input) {
            let m = 0;
            let i = 0;
            while(input){
                if (input & 1) {
                    m |= tokenModifiersTable[i];
                }
                input = input >> 1;
                i++;
            }
            return m;
        }
    };
}
function docLineLength(document, line) {
    const currentLineOffset = document.offsetAt({
        line,
        character: 0
    });
    const nextLineOffset = document.offsetAt({
        line: line + 1,
        character: 0
    });
    return nextLineOffset - currentLineOffset;
}
function getTokenTypeFromClassification(tsClassification) {
    if (tsClassification > 255) {
        const res = (tsClassification >> 8) - 1;
        return res;
    }
    return undefined;
}
function getTokenModifierFromClassification(tsClassification) {
    return tsClassification & 255;
}
const tokenTypes = [];
tokenTypes[0] = 'class';
tokenTypes[1] = 'enum';
tokenTypes[2] = 'interface';
tokenTypes[3] = 'namespace';
tokenTypes[4] = 'typeParameter';
tokenTypes[5] = 'type';
tokenTypes[6] = 'parameter';
tokenTypes[7] = 'variable';
tokenTypes[8] = 'enumMember';
tokenTypes[9] = 'property';
tokenTypes[10] = 'function';
tokenTypes[11] = 'method';

function snippetForFunctionCall(item, displayParts) {
    if (item.insertText && typeof item.insertText !== 'string') {
        return {
            snippet: item.insertText,
            parameterCount: 0
        };
    }
    let _tabstop = 1;
    const parameterListParts = getParameterListParts(displayParts);
    let snippet = '';
    snippet += `${item.insertText || item.label}(`;
    snippet = appendJoinedPlaceholders(snippet, parameterListParts.parts, ', ');
    if (parameterListParts.hasOptionalParameters) {
        snippet += '$' + _tabstop++;
    }
    snippet += ')';
    snippet += '$' + _tabstop++;
    return {
        snippet,
        parameterCount: parameterListParts.parts.length + (parameterListParts.hasOptionalParameters ? 1 : 0)
    };
    function appendJoinedPlaceholders(snippet, parts, joiner) {
        for(let i = 0; i < parts.length; ++i){
            const paramterPart = parts[i];
            snippet += '${' + _tabstop++ + ':' + paramterPart.text + '}';
            if (i !== parts.length - 1) {
                snippet += joiner;
            }
        }
        return snippet;
    }
}
function getParameterListParts(displayParts) {
    const parts = [];
    let isInMethod = false;
    let hasOptionalParameters = false;
    let parenCount = 0;
    let braceCount = 0;
    outer: {
        for(let i = 0; i < displayParts.length; ++i){
            const part = displayParts[i];
            switch(part.kind){
                case DisplayPartKind.methodName:
                case DisplayPartKind.functionName:
                case DisplayPartKind.text:
                case DisplayPartKind.propertyName:
                    if (parenCount === 0 && braceCount === 0) {
                        isInMethod = true;
                    }
                    break;
                case DisplayPartKind.parameterName:
                    if (parenCount === 1 && braceCount === 0 && isInMethod) {
                        // Only take top level paren names
                        const next = displayParts[i + 1];
                        // Skip optional parameters
                        const nameIsFollowedByOptionalIndicator = next && next.text === '?';
                        // Skip this parameter
                        const nameIsThis = part.text === 'this';
                        if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
                            parts.push(part);
                        }
                        hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
                    }
                    break;
                case DisplayPartKind.punctuation:
                    if (part.text === '(') {
                        ++parenCount;
                    } else if (part.text === ')') {
                        --parenCount;
                        if (parenCount <= 0 && isInMethod) {
                            break outer;
                        }
                    } else if (part.text === '...' && parenCount === 1) {
                        // Found rest parmeter. Do not fill in any further arguments
                        hasOptionalParameters = true;
                        break outer;
                    } else if (part.text === '{') {
                        ++braceCount;
                    } else if (part.text === '}') {
                        --braceCount;
                    }
                    break;
            }
        }
    }
    return {
        hasOptionalParameters,
        parts
    };
}

const documentRegistries = [];
function getDocumentRegistry(ts, useCaseSensitiveFileNames, currentDirectory) {
    let documentRegistry = documentRegistries.find((item)=>item[0] === useCaseSensitiveFileNames && item[1] === currentDirectory)?.[2];
    if (!documentRegistry) {
        documentRegistry = ts.createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory);
        documentRegistries.push([
            useCaseSensitiveFileNames,
            currentDirectory,
            documentRegistry
        ]);
    }
    return documentRegistry;
}
function create(ts, { disableAutoImportCache = false, isValidationEnabled = async (document, context)=>{
    return await context.env.getConfiguration?.(getConfigTitle(document) + '.validate.enable') ?? true;
}, isSuggestionsEnabled = async (document, context)=>{
    return await context.env.getConfiguration?.(getConfigTitle(document) + '.suggest.enabled') ?? true;
} } = {}) {
    return {
        name: 'typescript-semantic',
        capabilities: {
            completionProvider: {
                triggerCharacters: getBasicTriggerCharacters(ts.version),
                resolveProvider: true
            },
            renameProvider: {
                prepareProvider: true
            },
            fileRenameEditsProvider: true,
            codeActionProvider: {
                codeActionKinds: [
                    '',
                    'quickfix',
                    'refactor',
                    'refactor.extract',
                    'refactor.inline',
                    'refactor.rewrite',
                    'source',
                    'source.fixAll',
                    'source.organizeImports'
                ],
                resolveProvider: true
            },
            inlayHintProvider: {},
            callHierarchyProvider: true,
            definitionProvider: true,
            typeDefinitionProvider: true,
            diagnosticProvider: {
                interFileDependencies: true,
                workspaceDiagnostics: false
            },
            hoverProvider: true,
            implementationProvider: true,
            referencesProvider: true,
            fileReferencesProvider: true,
            documentHighlightProvider: true,
            semanticTokensProvider: {
                // https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#standard-token-types-and-modifiers
                legend: {
                    tokenTypes: [
                        'namespace',
                        'class',
                        'enum',
                        'interface',
                        'typeParameter',
                        'type',
                        'parameter',
                        'variable',
                        'property',
                        'enumMember',
                        'function',
                        'method'
                    ],
                    tokenModifiers: [
                        'declaration',
                        'readonly',
                        'static',
                        'async',
                        'defaultLibrary',
                        'local'
                    ]
                }
            },
            workspaceSymbolProvider: {},
            signatureHelpProvider: {
                triggerCharacters: [
                    '(',
                    ',',
                    '<'
                ],
                retriggerCharacters: [
                    ')'
                ]
            }
        },
        create (context) {
            if (!context.project.typescript) {
                console.warn(`[volar] typescript-semantic requires typescript project.`);
                return {};
            }
            const { sys, languageServiceHost, uriConverter, getExtraServiceScript } = context.project.typescript;
            let languageService;
            let created;
            if (disableAutoImportCache) {
                languageService = ts.createLanguageService(languageServiceHost, getDocumentRegistry(ts, sys.useCaseSensitiveFileNames, languageServiceHost.getCurrentDirectory()));
            } else {
                created = outExports.createLanguageService(ts, sys, languageServiceHost, (proxiedHost)=>ts.createLanguageService(proxiedHost, getDocumentRegistry(ts, sys.useCaseSensitiveFileNames, languageServiceHost.getCurrentDirectory())));
                languageService = created.languageService;
            }
            const ctx = {
                ...context,
                languageServiceHost,
                languageService,
                uriToFileName (uri) {
                    const virtualScript = getVirtualScriptByUri(uri);
                    if (virtualScript) {
                        return virtualScript.fileName;
                    }
                    return uriConverter.asFileName(uri);
                },
                fileNameToUri (fileName) {
                    const extraServiceScript = getExtraServiceScript(fileName);
                    if (extraServiceScript) {
                        const sourceScript = context.language.scripts.fromVirtualCode(extraServiceScript.code);
                        return context.encodeEmbeddedDocumentUri(sourceScript.id, extraServiceScript.code.id);
                    }
                    const uri = uriConverter.asUri(fileName);
                    const sourceScript = context.language.scripts.get(uri);
                    const serviceScript = sourceScript?.generated?.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                    if (sourceScript && serviceScript) {
                        return context.encodeEmbeddedDocumentUri(sourceScript.id, serviceScript.code.id);
                    }
                    return uri;
                },
                getTextDocument (uri) {
                    const decoded = context.decodeEmbeddedDocumentUri(uri);
                    if (decoded) {
                        const sourceScript = context.language.scripts.get(decoded[0]);
                        const virtualCode = sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                        if (virtualCode) {
                            return context.documents.get(uri, virtualCode.languageId, virtualCode.snapshot);
                        }
                    } else {
                        const sourceFile = context.language.scripts.get(uri);
                        if (sourceFile) {
                            return context.documents.get(uri, sourceFile.languageId, sourceFile.snapshot);
                        }
                    }
                }
            };
            const getCodeActions = register$1(ctx);
            const doCodeActionResolve = register$2(ctx);
            const getDocumentSemanticTokens = register(ts, ctx);
            /* typescript-language-features is hardcode true */ const renameInfoOptions = {
                allowRenameOfImportPath: true
            };
            let formattingOptions;
            if (created?.setPreferences && context.env.getConfiguration) {
                updatePreferences();
                context.env.onDidChangeConfiguration?.(updatePreferences);
                async function updatePreferences() {
                    const preferences = await context.env.getConfiguration?.('typescript.preferences');
                    if (preferences) {
                        created.setPreferences?.(preferences);
                    }
                }
            }
            if (created?.projectUpdated) {
                const sourceScriptNames = new Set();
                const normalizeFileName = sys.useCaseSensitiveFileNames ? (id)=>id : (id)=>id.toLowerCase();
                updateSourceScriptFileNames();
                context.env.onDidChangeWatchedFiles?.((params)=>{
                    const someFileCreateOrDeiete = params.changes.some((change)=>change.type !== 2);
                    if (someFileCreateOrDeiete) {
                        updateSourceScriptFileNames();
                    }
                    for (const change of params.changes){
                        const fileName = uriConverter.asFileName(URI.parse(change.uri));
                        if (sourceScriptNames.has(normalizeFileName(fileName))) {
                            created.projectUpdated?.(languageServiceHost.getCurrentDirectory());
                        }
                    }
                });
                function updateSourceScriptFileNames() {
                    sourceScriptNames.clear();
                    for (const fileName of languageServiceHost.getScriptFileNames()){
                        const maybeEmbeddedUri = ctx.fileNameToUri(fileName);
                        const decoded = context.decodeEmbeddedDocumentUri(maybeEmbeddedUri);
                        const uri = decoded ? decoded[0] : maybeEmbeddedUri;
                        const sourceScript = context.language.scripts.get(uri);
                        if (sourceScript?.generated) {
                            const tsCode = sourceScript.generated.languagePlugin.typescript?.getServiceScript(sourceScript.generated.root);
                            if (tsCode) {
                                sourceScriptNames.add(normalizeFileName(fileName));
                            }
                        } else if (sourceScript) {
                            sourceScriptNames.add(normalizeFileName(fileName));
                        }
                    }
                }
            }
            return {
                provide: {
                    'typescript/languageService': ()=>languageService,
                    'typescript/languageServiceHost': ()=>languageServiceHost,
                    'typescript/documentFileName': (uri)=>ctx.uriToFileName(uri),
                    'typescript/documentUri': (fileName)=>ctx.fileNameToUri(fileName)
                },
                dispose () {
                    languageService.dispose();
                },
                provideDocumentFormattingEdits (_document, _range, options) {
                    formattingOptions = options;
                    return undefined;
                },
                provideOnTypeFormattingEdits (_document, _position, _key, options) {
                    formattingOptions = options;
                    return undefined;
                },
                async provideCompletionItems (document, position, completeContext, token) {
                    LogUtil.log('=== provideCompletionItems ===');
                    LogUtil.log('Document URI: ' + document.uri);
                    LogUtil.log('Position: line=' + position.line + ', character=' + position.character);
                    LogUtil.log('Trigger character: ' + (completeContext?.triggerCharacter || 'none'));
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        LogUtil.log('Not a semantic document, skipping');
                        return;
                    }
                    if (!await isSuggestionsEnabled(document, context)) {
                        LogUtil.log('Suggestions disabled, skipping');
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        LogUtil.log('Cancellation requested, skipping');
                        return;
                    }
                    const preferences = await getUserPreferences(ctx, document);
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    LogUtil.log('fileName: ' + fileName);
                    LogUtil.log('offset: ' + offset);
                    const opts = {
                        ...preferences,
                        triggerCharacter: completeContext.triggerCharacter,
                        triggerKind: completeContext.triggerKind
                    };
                    const info = safeCall(()=>ctx.languageService.getCompletionsAtPosition(fileName, offset, opts));
                    if (info) {
                        LogUtil.log('Completion items count: ' + info.entries?.length);
                        return convertCompletionInfo(ts, info, document, position, (tsEntry)=>({
                                uri: document.uri,
                                fileName,
                                offset,
                                originalItem: {
                                    name: tsEntry.name,
                                    source: tsEntry.source,
                                    data: tsEntry.data,
                                    labelDetails: tsEntry.labelDetails
                                }
                            }));
                    } else {
                        LogUtil.log('No completion info returned');
                    }
                },
                async resolveCompletionItem (item, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return item;
                    }
                    const data = item.data;
                    if (!data) {
                        return item;
                    }
                    const { fileName, offset } = data;
                    const uri = URI.parse(data.uri);
                    const document = ctx.getTextDocument(uri);
                    const [formatOptions, preferences] = await Promise.all([
                        getFormatCodeSettings(ctx, document, formattingOptions),
                        getUserPreferences(ctx, document)
                    ]);
                    const details = safeCall(()=>ctx.languageService.getCompletionEntryDetails(fileName, offset, data.originalItem.name, formatOptions, data.originalItem.source, preferences, data.originalItem.data));
                    // 
                    LogUtil.log('=== resolveCompletionItem ===');
                    LogUtil.log('completionName: ' + data.originalItem.name);
                    LogUtil.log('importSource: ' + (data.originalItem.source || 'null'));
                    LogUtil.log('hasCodeActions: ' + !!details?.codeActions?.length);
                    if (details?.codeActions?.length) {
                        LogUtil.log('codeActions:');
                        for (const action of details.codeActions){
                            LogUtil.log('  description: ' + action.description);
                            for (const change of action.changes){
                                LogUtil.log('  file: ' + change.fileName);
                                for (const textChange of change.textChanges){
                                    LogUtil.log('    span: ' + JSON.stringify(textChange.span));
                                    LogUtil.log('    newText: ' + textChange.newText.substring(0, 100));
                                }
                            }
                        }
                    }
                    if (!details) {
                        return item;
                    }
                    if (data.originalItem.labelDetails) {
                        var _item;
                        (_item = item).labelDetails ?? (_item.labelDetails = {});
                        Object.assign(item.labelDetails, data.originalItem.labelDetails);
                    }
                    applyCompletionEntryDetails(ts, item, details, document, ctx.fileNameToUri, ctx.getTextDocument);
                    const useCodeSnippetsOnMethodSuggest = await ctx.env.getConfiguration?.(getConfigTitle(document) + '.suggest.completeFunctionCalls') ?? false;
                    const useCodeSnippet = useCodeSnippetsOnMethodSuggest && (item.kind === 3 || item.kind === 2);
                    if (useCodeSnippet) {
                        const shouldCompleteFunction = isValidFunctionCompletionContext(ctx.languageService, fileName, offset, document);
                        if (shouldCompleteFunction) {
                            const { snippet, parameterCount } = snippetForFunctionCall({
                                insertText: item.insertText ?? item.textEdit?.newText,
                                label: item.label
                            }, details.displayParts);
                            if (item.textEdit) {
                                item.textEdit.newText = snippet;
                            }
                            if (item.insertText) {
                                item.insertText = snippet;
                            }
                            item.insertTextFormat = 2;
                        }
                    }
                    return item;
                    function isValidFunctionCompletionContext(client, filepath, offset, document) {
                        // Workaround for https://github.com/microsoft/TypeScript/issues/12677
                        // Don't complete function calls inside of destructive assignments or imports
                        try {
                            const response = client.getQuickInfoAtPosition(filepath, offset);
                            if (response) {
                                switch(response.kind){
                                    case 'var':
                                    case 'let':
                                    case 'const':
                                    case 'alias':
                                        return false;
                                }
                            }
                        } catch  {
                        // Noop
                        }
                        // Don't complete function call if there is already something that looks like a function call
                        // https://github.com/microsoft/vscode/issues/18131
                        const position = document.positionAt(offset);
                        const after = getLineText(document, position.line).slice(position.character);
                        return after.match(/^[a-z_$0-9]*\s*\(/gi) === null;
                    }
                },
                async provideRenameRange (document, position, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const renameInfo = safeCall(()=>ctx.languageService.getRenameInfo(fileName, offset, renameInfoOptions));
                    if (!renameInfo) {
                        return;
                    }
                    if (!renameInfo.canRename) {
                        return {
                            message: renameInfo.localizedErrorMessage
                        };
                    }
                    return convertTextSpan(renameInfo.triggerSpan, document);
                },
                async provideRenameEdits (document, position, newName, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document, true)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const renameInfo = safeCall(()=>ctx.languageService.getRenameInfo(fileName, offset, renameInfoOptions));
                    if (!renameInfo?.canRename) {
                        return;
                    }
                    if (renameInfo.fileToRename) {
                        const [formatOptions, preferences] = await Promise.all([
                            getFormatCodeSettings(ctx, document, formattingOptions),
                            getUserPreferences(ctx, document)
                        ]);
                        return renameFile(renameInfo.fileToRename, newName, formatOptions, preferences);
                    }
                    const { providePrefixAndSuffixTextForRename } = await getUserPreferences(ctx, document);
                    const entries = ctx.languageService.findRenameLocations(fileName, offset, false, false, providePrefixAndSuffixTextForRename);
                    if (!entries) {
                        return;
                    }
                    return convertRenameLocations(newName, entries, ctx.fileNameToUri, ctx.getTextDocument);
                    function renameFile(fileToRename, newName, formatOptions, preferences) {
                        // Make sure we preserve file extension if none provided
                        if (!pathBrowserifyExports.extname(newName)) {
                            newName += pathBrowserifyExports.extname(fileToRename);
                        }
                        const dirname = pathBrowserifyExports.dirname(fileToRename);
                        const newFilePath = pathBrowserifyExports.join(dirname, newName);
                        const response = safeCall(()=>ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
                        if (!response) {
                            return;
                        }
                        const edits = convertFileTextChanges(response, ctx.fileNameToUri, ctx.getTextDocument);
                        if (!edits.documentChanges) {
                            edits.documentChanges = [];
                        }
                        edits.documentChanges.push({
                            kind: 'rename',
                            oldUri: ctx.fileNameToUri(fileToRename).toString(),
                            newUri: ctx.fileNameToUri(newFilePath).toString()
                        });
                        return edits;
                    }
                },
                async provideCodeActions (document, range, context, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    return getCodeActions(uri, document, range, context, formattingOptions);
                },
                async resolveCodeAction (codeAction, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return codeAction;
                    }
                    return doCodeActionResolve(codeAction, formattingOptions);
                },
                async provideInlayHints (document, range, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const preferences = await getUserPreferences(ctx, document);
                    const fileName = ctx.uriToFileName(uri);
                    const start = document.offsetAt(range.start);
                    const end = document.offsetAt(range.end);
                    const inlayHints = safeCall(()=>'provideInlayHints' in ctx.languageService ? ctx.languageService.provideInlayHints(fileName, {
                            start,
                            length: end - start
                        }, preferences) : []);
                    if (!inlayHints) {
                        return [];
                    }
                    return inlayHints.map((hint)=>convertInlayHint(hint, document));
                },
                async provideCallHierarchyItems (document, position, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const calls = safeCall(()=>ctx.languageService.prepareCallHierarchy(fileName, offset));
                    if (!calls) {
                        return [];
                    }
                    const items = Array.isArray(calls) ? calls : [
                        calls
                    ];
                    return items.map((item)=>convertCallHierarchyItem(item, ctx));
                },
                async provideCallHierarchyIncomingCalls (item, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return [];
                    }
                    const uri = URI.parse(item.uri);
                    const document = ctx.getTextDocument(uri);
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(item.selectionRange.start);
                    const calls = safeCall(()=>ctx.languageService.provideCallHierarchyIncomingCalls(fileName, offset));
                    if (!calls) {
                        return [];
                    }
                    const items = Array.isArray(calls) ? calls : [
                        calls
                    ];
                    return items.map((item)=>convertCallHierarchyIncomingCall(item, ctx));
                },
                async provideCallHierarchyOutgoingCalls (item, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return [];
                    }
                    const uri = URI.parse(item.uri);
                    const document = ctx.getTextDocument(uri);
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(item.selectionRange.start);
                    const calls = safeCall(()=>ctx.languageService.provideCallHierarchyOutgoingCalls(fileName, offset));
                    if (!calls) {
                        return [];
                    }
                    const items = Array.isArray(calls) ? calls : [
                        calls
                    ];
                    return items.map((item)=>convertCallHierarchyOutgoingCall(item, document, ctx));
                },
                async provideDefinition (document, position, token) {
                    LogUtil.log('=== provideDefinition ===');
                    LogUtil.log('Document URI: ' + document.uri);
                    LogUtil.log('Position: line=' + position.line + ', character=' + position.character);
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        LogUtil.log('Not a semantic document, skipping');
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        LogUtil.log('Cancellation requested, skipping');
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    LogUtil.log('fileName: ' + fileName);
                    LogUtil.log('offset: ' + offset);
                    const info = safeCall(()=>ctx.languageService.getDefinitionAndBoundSpan(fileName, offset));
                    if (!info) {
                        LogUtil.log('No definition info returned');
                        return [];
                    }
                    LogUtil.log('Definition count: ' + (info.definitions?.length || 0));
                    return convertDefinitionInfoAndBoundSpan(info, document, ctx);
                },
                async provideTypeDefinition (document, position, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const entries = safeCall(()=>ctx.languageService.getTypeDefinitionAtPosition(fileName, offset));
                    if (!entries) {
                        return [];
                    }
                    return entries.map((entry)=>convertDocumentSpantoLocationLink(entry, ctx));
                },
                async provideDiagnostics (document, token) {
                    return [
                        ...await provideDiagnosticsWorker(document, token, 'syntactic') ?? [],
                        ...await provideDiagnosticsWorker(document, token, 'semantic') ?? []
                    ];
                },
                async provideHover (document, position, token) {
                    LogUtil.log('=== provideHover ===');
                    LogUtil.log('Document URI: ' + document.uri);
                    LogUtil.log('Position: line=' + position.line + ', character=' + position.character);
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        LogUtil.log('Not a semantic document, skipping');
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        LogUtil.log('Cancellation requested, skipping');
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    LogUtil.log('fileName: ' + fileName);
                    LogUtil.log('offset: ' + offset);
                    const info = safeCall(()=>ctx.languageService.getQuickInfoAtPosition(fileName, offset));
                    if (!info) {
                        LogUtil.log('No hover info returned');
                        return;
                    }
                    LogUtil.log('Hover info kind: ' + info.kind);
                    LogUtil.log('Hover info textSpan: start=' + info.textSpan.start + ', length=' + info.textSpan.length);
                    LogUtil.log('Hover info displayParts:', info.displayParts);
                    const result = convertQuickInfo(ts, info, document, ctx.fileNameToUri, ctx.getTextDocument);
                    LogUtil.log('Hover result:', result);
                    return result;
                },
                async provideImplementation (document, position, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const entries = safeCall(()=>ctx.languageService.getImplementationAtPosition(fileName, offset));
                    if (!entries) {
                        return [];
                    }
                    return entries.map((entry)=>convertDocumentSpantoLocationLink(entry, ctx));
                },
                async provideReferences (document, position, referenceContext, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document, true)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const references = safeCall(()=>ctx.languageService.findReferences(fileName, offset));
                    if (!references) {
                        return [];
                    }
                    const result = [];
                    for (const reference of references){
                        if (referenceContext.includeDeclaration) {
                            const definition = convertDocumentSpanToLocation(reference.definition, ctx);
                            if (definition) {
                                result.push(definition);
                            }
                        }
                        for (const referenceEntry of reference.references){
                            const reference = convertDocumentSpanToLocation(referenceEntry, ctx);
                            if (reference) {
                                result.push(reference);
                            }
                        }
                    }
                    return result;
                },
                async provideFileReferences (document, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document, true)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const entries = safeCall(()=>ctx.languageService.getFileReferences(fileName));
                    if (!entries) {
                        return [];
                    }
                    return entries.map((entry)=>convertDocumentSpanToLocation(entry, ctx));
                },
                async provideDocumentHighlights (document, position, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const highlights = safeCall(()=>ctx.languageService.getDocumentHighlights(fileName, offset, [
                            fileName
                        ]));
                    if (!highlights) {
                        return [];
                    }
                    const results = [];
                    for (const highlight of highlights){
                        for (const span of highlight.highlightSpans){
                            results.push(convertHighlightSpan(span, document));
                        }
                    }
                    return results;
                },
                async provideDocumentSemanticTokens (document, range, legend, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    return getDocumentSemanticTokens(uri, document, range, legend);
                },
                async provideWorkspaceSymbols (query, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const items = safeCall(()=>ctx.languageService.getNavigateToItems(query));
                    if (!items) {
                        return [];
                    }
                    return items.filter((item)=>item.containerName || item.kind !== 'alias').map((item)=>convertNavigateToItem(item, ctx.getTextDocument(ctx.fileNameToUri(item.fileName)))).filter((item)=>!!item);
                },
                async provideFileRenameEdits (oldUri, newUri, token) {
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const document = ctx.getTextDocument(oldUri);
                    const [formatOptions, preferences] = await Promise.all([
                        getFormatCodeSettings(ctx, document, formattingOptions),
                        getUserPreferences(ctx, document)
                    ]);
                    const fileToRename = ctx.uriToFileName(oldUri);
                    const newFilePath = ctx.uriToFileName(newUri);
                    const response = safeCall(()=>ctx.languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences));
                    if (!response?.length) {
                        return;
                    }
                    return convertFileTextChanges(response, ctx.fileNameToUri, ctx.getTextDocument);
                },
                async provideSignatureHelp (document, position, context, token) {
                    const uri = URI.parse(document.uri);
                    if (!isSemanticDocument(uri, document)) {
                        return;
                    }
                    if (await isCancellationRequestedWhileSync(token)) {
                        return;
                    }
                    const options = {};
                    if (context?.triggerKind === 1) {
                        options.triggerReason = {
                            kind: 'invoked'
                        };
                    } else if (context?.triggerKind === 2) {
                        options.triggerReason = {
                            kind: 'characterTyped',
                            triggerCharacter: context.triggerCharacter
                        };
                    } else if (context?.triggerKind === 3) {
                        options.triggerReason = {
                            kind: 'retrigger',
                            triggerCharacter: context.triggerCharacter
                        };
                    }
                    const fileName = ctx.uriToFileName(uri);
                    const offset = document.offsetAt(position);
                    const helpItems = safeCall(()=>ctx.languageService.getSignatureHelpItems(fileName, offset, options));
                    if (!helpItems) {
                        return;
                    }
                    return {
                        activeSignature: helpItems.selectedItemIndex,
                        activeParameter: helpItems.argumentIndex,
                        signatures: helpItems.items.map((item)=>{
                            const signature = {
                                label: '',
                                documentation: undefined,
                                parameters: []
                            };
                            signature.label += ts.displayPartsToString(item.prefixDisplayParts);
                            item.parameters.forEach((p, i, a)=>{
                                const label = ts.displayPartsToString(p.displayParts);
                                const parameter = {
                                    label,
                                    documentation: ts.displayPartsToString(p.documentation)
                                };
                                signature.label += label;
                                signature.parameters.push(parameter);
                                if (i < a.length - 1) {
                                    signature.label += ts.displayPartsToString(item.separatorDisplayParts);
                                }
                            });
                            signature.label += ts.displayPartsToString(item.suffixDisplayParts);
                            return signature;
                        })
                    };
                }
            };
            async function provideDiagnosticsWorker(document, token, mode) {
                LogUtil.log('=== provideDiagnosticsWorker ===');
                LogUtil.log('Document URI: ' + document.uri);
                LogUtil.log('Mode: ' + mode);
                const uri = URI.parse(document.uri);
                if (!isSemanticDocument(uri, document)) {
                    LogUtil.log('Not a semantic document, skipping');
                    return;
                }
                if (!await isValidationEnabled(document, context)) {
                    LogUtil.log('Validation disabled, skipping');
                    return;
                }
                if (mode === 'semantic' && await isCancellationRequestedWhileSync(token)) {
                    LogUtil.log('Cancellation requested, skipping');
                    return;
                }
                const fileName = ctx.uriToFileName(uri);
                LogUtil.log('fileName: ' + fileName);
                const program = ctx.languageService.getProgram();
                const sourceFile = program?.getSourceFile(fileName);
                if (!program || !sourceFile) {
                    LogUtil.log('No program or source file found');
                    return [];
                }
                LogUtil.log('Source file found, text length: ' + sourceFile.text?.length);
                const tsToken = {
                    isCancellationRequested () {
                        return ctx.project.typescript?.languageServiceHost.getCancellationToken?.().isCancellationRequested() ?? false;
                    },
                    throwIfCancellationRequested () {}
                };
                if (mode === 'syntactic') {
                    const syntacticDiagnostics = safeCall(()=>program.getSyntacticDiagnostics(sourceFile, tsToken)) ?? [];
                    const suggestionDiagnostics = safeCall(()=>ctx.languageService.getSuggestionDiagnostics(fileName)) ?? [];
                    LogUtil.log('Syntactic diagnostics count: ' + syntacticDiagnostics.length);
                    LogUtil.log('Suggestion diagnostics count: ' + suggestionDiagnostics.length);
                    return [
                        ...syntacticDiagnostics,
                        ...suggestionDiagnostics
                    ].map((diagnostic)=>convertDiagnostic(diagnostic, document, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic)=>!!diagnostic);
                } else if (mode === 'semantic') {
                    const semanticDiagnostics = safeCall(()=>program.getSemanticDiagnostics(sourceFile, tsToken)) ?? [];
                    const declarationDiagnostics = getEmitDeclarations(program.getCompilerOptions()) ? safeCall(()=>program.getDeclarationDiagnostics(sourceFile, tsToken)) ?? [] : [];
                    LogUtil.log('Semantic diagnostics count: ' + semanticDiagnostics.length);
                    LogUtil.log('Declaration diagnostics count: ' + declarationDiagnostics.length);
                    // 
                    for (const diag of semanticDiagnostics){
                        LogUtil.log('Diagnostic: code=' + diag.code + ', message=' + (typeof diag.messageText === 'string' ? diag.messageText : diag.messageText?.messageText));
                    }
                    return [
                        ...semanticDiagnostics,
                        ...declarationDiagnostics
                    ].map((diagnostic)=>convertDiagnostic(diagnostic, document, ctx.fileNameToUri, ctx.getTextDocument)).filter((diagnostic)=>!!diagnostic);
                }
            }
            function getEmitDeclarations(compilerOptions) {
                return !!(compilerOptions.declaration || compilerOptions.composite);
            }
            function isSemanticDocument(uri, document, withJson = false) {
                const virtualScript = getVirtualScriptByUri(uri);
                if (virtualScript) {
                    return true;
                }
                if (withJson && isJsonDocument(document)) {
                    return true;
                }
                return isTsDocument(document);
            }
            async function isCancellationRequestedWhileSync(token) {
                if (sys.sync) {
                    let oldSysVersion;
                    let newSysVersion = sys.version;
                    do {
                        oldSysVersion = newSysVersion;
                        languageService.getProgram(); // trigger file requests
                        newSysVersion = await aggressiveSync(sys.sync);
                    }while (newSysVersion !== oldSysVersion && !token.isCancellationRequested)
                }
                return token.isCancellationRequested;
            }
            async function aggressiveSync(fn) {
                const promise = fn();
                let newVersion;
                let syncing = true;
                promise.then((version)=>{
                    newVersion = version;
                    syncing = false;
                });
                while(syncing){
                    languageService.getProgram(); // trigger file requests before old requests are completed
                    await Promise.race([
                        promise,
                        sleep(10)
                    ]);
                }
                return newVersion;
            }
            function sleep(ms) {
                return new Promise((resolve)=>setTimeout(resolve, ms));
            }
            function getVirtualScriptByUri(uri) {
                const decoded = context.decodeEmbeddedDocumentUri(uri);
                const sourceScript = decoded && context.language.scripts.get(decoded[0]);
                const virtualCode = decoded && sourceScript?.generated?.embeddedCodes.get(decoded[1]);
                if (virtualCode && sourceScript?.generated?.languagePlugin.typescript) {
                    const { getServiceScript, getExtraServiceScripts } = sourceScript.generated?.languagePlugin.typescript;
                    const sourceFileName = uriConverter.asFileName(sourceScript.id);
                    if (getServiceScript(sourceScript.generated.root)?.code === virtualCode) {
                        return {
                            fileName: sourceFileName,
                            code: virtualCode
                        };
                    }
                    for (const extraScript of getExtraServiceScripts?.(sourceFileName, sourceScript.generated.root) ?? []){
                        if (extraScript.code === virtualCode) {
                            return extraScript;
                        }
                    }
                }
            }
        }
    };
}
function getBasicTriggerCharacters(tsVersion) {
    /*const triggerCharacters = ['.', '"', '\'', '`', '/', '<'
    , "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
  ];*/ const triggerCharacters = [
        '.',
        '"',
        '\'',
        '`',
        '/',
        '<'
    ];
    // https://github.com/microsoft/vscode/blob/8e65ae28d5fb8b3c931135da1a41edb9c80ae46f/extensions/typescript-language-features/src/languageFeatures/completions.ts#L811-L833
    if (semverExports.lt(tsVersion, '3.1.0') || semverExports.gte(tsVersion, '3.2.0')) {
        triggerCharacters.push('@');
    }
    if (semverExports.gte(tsVersion, '3.8.1')) {
        triggerCharacters.push('#');
    }
    /*if (semver.gte(tsVersion, '4.3.0')) {
    triggerCharacters.push(' ');
  }*/ return triggerCharacters;
}

function createTypeScriptServices(ts, options) {
    return [
        create(ts, options),
        create$2(ts, options),
        create$1(ts),
        create$3()
    ];
}

var languageCoreExports = requireLanguageCore();

/**
 * SlimeNodeType - AST 
 *
 *  ESTree  type 
 *  as const 
 */ const SlimeNodeType = {
    // --- Program ---
    Program: "Program",
    // --- Identifier ---
    Identifier: "Identifier",
    PrivateIdentifier: "PrivateIdentifier",
    // --- Literal ---
    Literal: "Literal",
    NullLiteral: "NullLiteral",
    StringLiteral: "StringLiteral",
    NumericLiteral: "NumericLiteral",
    BooleanLiteral: "BooleanLiteral",
    // --- Statements ---
    ExpressionStatement: "ExpressionStatement",
    BlockStatement: "BlockStatement",
    StaticBlock: "StaticBlock",
    EmptyStatement: "EmptyStatement",
    DebuggerStatement: "DebuggerStatement",
    ReturnStatement: "ReturnStatement",
    BreakStatement: "BreakStatement",
    ContinueStatement: "ContinueStatement",
    LabeledStatement: "LabeledStatement",
    WithStatement: "WithStatement",
    IfStatement: "IfStatement",
    SwitchStatement: "SwitchStatement",
    SwitchCase: "SwitchCase",
    ThrowStatement: "ThrowStatement",
    TryStatement: "TryStatement",
    CatchClause: "CatchClause",
    WhileStatement: "WhileStatement",
    DoWhileStatement: "DoWhileStatement",
    ForStatement: "ForStatement",
    ForInStatement: "ForInStatement",
    ForOfStatement: "ForOfStatement",
    // --- Declarations ---
    FunctionDeclaration: "FunctionDeclaration",
    VariableDeclaration: "VariableDeclaration",
    VariableDeclarator: "VariableDeclarator",
    ClassDeclaration: "ClassDeclaration",
    // --- Expressions ---
    ThisExpression: "ThisExpression",
    ArrayExpression: "ArrayExpression",
    ObjectExpression: "ObjectExpression",
    Property: "Property",
    FunctionExpression: "FunctionExpression",
    ArrowFunctionExpression: "ArrowFunctionExpression",
    ClassExpression: "ClassExpression",
    UnaryExpression: "UnaryExpression",
    UpdateExpression: "UpdateExpression",
    BinaryExpression: "BinaryExpression",
    AssignmentExpression: "AssignmentExpression",
    LogicalExpression: "LogicalExpression",
    MemberExpression: "MemberExpression",
    ConditionalExpression: "ConditionalExpression",
    CallExpression: "CallExpression",
    NewExpression: "NewExpression",
    SequenceExpression: "SequenceExpression",
    TemplateLiteral: "TemplateLiteral",
    TaggedTemplateExpression: "TaggedTemplateExpression",
    TemplateElement: "TemplateElement",
    SpreadElement: "SpreadElement",
    YieldExpression: "YieldExpression",
    AwaitExpression: "AwaitExpression",
    ImportExpression: "ImportExpression",
    ChainExpression: "ChainExpression",
    MetaProperty: "MetaProperty",
    Super: "Super",
    ParenthesizedExpression: "ParenthesizedExpression",
    OptionalCallExpression: "OptionalCallExpression",
    OptionalMemberExpression: "OptionalMemberExpression",
    // --- Patterns ---
    ObjectPattern: "ObjectPattern",
    ArrayPattern: "ArrayPattern",
    RestElement: "RestElement",
    AssignmentPattern: "AssignmentPattern",
    // --- Classes ---
    ClassBody: "ClassBody",
    MethodDefinition: "MethodDefinition",
    PropertyDefinition: "PropertyDefinition",
    // --- Modules ---
    ImportDeclaration: "ImportDeclaration",
    ImportSpecifier: "ImportSpecifier",
    ImportDefaultSpecifier: "ImportDefaultSpecifier",
    ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
    ExportNamedDeclaration: "ExportNamedDeclaration",
    ExportSpecifier: "ExportSpecifier",
    ExportDefaultDeclaration: "ExportDefaultDeclaration",
    ExportAllDeclaration: "ExportAllDeclaration"
};

function _define_property$h(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SlimeCodeLocation {
    constructor(){
        _define_property$h(this, "type", '');
        _define_property$h(this, "line", 0);
        _define_property$h(this, "value", '');
        _define_property$h(this, "column", 0);
        _define_property$h(this, "length", 0);
        //lengthindexlengthindex
        _define_property$h(this, "index", 0);
    }
}

/**
 * 
 */ function _define_property$g(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SubhutiCreateToken {
    constructor(ovsToken){
        _define_property$g(this, "name", void 0);
        _define_property$g(this, "type", void 0);
        _define_property$g(this, "pattern", void 0);
        _define_property$g(this, "isKeyword", void 0);
        _define_property$g(this, "skip", void 0); //  token
        _define_property$g(this, "value", void 0);
        _define_property$g(this, "categories", void 0);
        _define_property$g(this, "lookaheadAfter", void 0); // 
        _define_property$g(this, "contextConstraint", void 0); // 
        this.name = ovsToken.name;
        this.type = ovsToken.type || ovsToken.name; // type  name
        this.pattern = ovsToken.pattern;
        if (ovsToken.value) {
            this.value = ovsToken.value;
        } else {
            this.value = emptyValue;
        }
        this.isKeyword = ovsToken.isKeyword ?? false;
        this.skip = ovsToken.skip;
        this.lookaheadAfter = ovsToken.lookaheadAfter; // 
        this.contextConstraint = ovsToken.contextConstraint; // 
    }
}
const emptyValue = 'Error:CannotUseValue';
function createKeywordToken(name, pattern) {
    //  do  double
    const keywordPattern = new RegExp(pattern + '(?![a-zA-Z0-9_$])');
    const token = new SubhutiCreateToken({
        name: name,
        pattern: keywordPattern,
        value: pattern
    });
    token.isKeyword = true;
    return token;
}
function createRegToken(name, pattern) {
    const token = new SubhutiCreateToken({
        name: name,
        pattern: pattern,
        value: pattern.source
    });
    return token;
}
function createValueRegToken(name, pattern, value, skip, lookahead, contextConstraint) {
    const token = new SubhutiCreateToken({
        name: name,
        pattern: pattern,
        value: value,
        skip: skip,
        lookaheadAfter: lookahead,
        contextConstraint: contextConstraint
    });
    return token;
}
function createEmptyValueRegToken(name, pattern, contextConstraint) {
    const token = new SubhutiCreateToken({
        name: name,
        pattern: pattern,
        contextConstraint: contextConstraint
    });
    return token;
}

/**
 * ES2025 Token  -  ECMAScript 2025  A.1 
 * https://tc39.es/ecma262/2025/#sec-grammar-summary
 *
 * 
 * 1. TokenNames  A.1 
 * 2.  ReservedWord 
 * 3. 
 */ // ============================================
//  Token  TokenNames 
// ============================================
/**
 *  Token 
 * : = += -= *= /= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??=
 */ const SlimeAssignmentOperatorTokenTypes = {
    Assign: 'Assign',
    PlusAssign: 'PlusAssign',
    MinusAssign: 'MinusAssign',
    MultiplyAssign: 'MultiplyAssign',
    DivideAssign: 'DivideAssign',
    ModuloAssign: 'ModuloAssign',
    ExponentiationAssign: 'ExponentiationAssign',
    LeftShiftAssign: 'LeftShiftAssign',
    RightShiftAssign: 'RightShiftAssign',
    UnsignedRightShiftAssign: 'UnsignedRightShiftAssign',
    BitwiseAndAssign: 'BitwiseAndAssign',
    BitwiseOrAssign: 'BitwiseOrAssign',
    BitwiseXorAssign: 'BitwiseXorAssign',
    LogicalAndAssign: 'LogicalAndAssign',
    LogicalOrAssign: 'LogicalOrAssign',
    NullishCoalescingAssign: 'NullishCoalescingAssign'
};
/**
 *  Token 
 * : ++ --
 */ const SlimeUpdateOperatorTokenTypes = {
    Increment: 'Increment',
    Decrement: 'Decrement'
};
/**
 *  Token 
 * : - + ! ~ typeof void delete
 */ const SlimeUnaryOperatorTokenTypes = {
    Minus: 'Minus',
    Plus: 'Plus',
    LogicalNot: 'LogicalNot',
    BitwiseNot: 'BitwiseNot',
    Typeof: 'Typeof',
    Void: 'Void',
    Delete: 'Delete'
};
/**
 *  Token 
 * : == != === !== < > <= >= << >> >>> + - * / % ** | ^ & in instanceof
 */ const SlimeBinaryOperatorTokenTypes = {
    // 
    Equal: 'Equal',
    NotEqual: 'NotEqual',
    StrictEqual: 'StrictEqual',
    StrictNotEqual: 'StrictNotEqual',
    // 
    Less: 'Less',
    Greater: 'Greater',
    LessEqual: 'LessEqual',
    GreaterEqual: 'GreaterEqual',
    // 
    LeftShift: 'LeftShift',
    RightShift: 'RightShift',
    UnsignedRightShift: 'UnsignedRightShift',
    // 
    Plus: 'Plus',
    Minus: 'Minus',
    Asterisk: 'Asterisk',
    Slash: 'Slash',
    Modulo: 'Modulo',
    Exponentiation: 'Exponentiation',
    // 
    BitwiseOr: 'BitwiseOr',
    BitwiseXor: 'BitwiseXor',
    BitwiseAnd: 'BitwiseAnd',
    // 
    In: 'In',
    Instanceof: 'Instanceof'
};
/**
 *  Token 
 * : || && ??
 */ const SlimeLogicalOperatorTokenTypes = {
    LogicalOr: 'LogicalOr',
    LogicalAnd: 'LogicalAnd',
    NullishCoalescing: 'NullishCoalescing'
};
/**
 * Contextual KeywordsToken 
 *
 *  IdentifierName
 *  ReservedWord
 *
 * 
 * - async:  `async function`
 * - static:  `static method()` / `static field`
 * - get:  `get prop()` (MethodDefinition)
 * - set:  `set prop(v)` (MethodDefinition)
 * - of: for-of  `for (x of iterable)`
 * - from:  `import x from 'module'` / `export * from 'module'`
 * - as:  `import { x as y }` / `export { x as y }`
 * - target:  `new.target` (NewTarget)
 * - meta:  `import.meta` (ImportMeta)
 */ const SlimeContextualKeywordTokenTypes = {
    // 
    // consumeIdentifierValue()  token.tokenValue === value
    Async: 'async',
    Static: 'static',
    Let: 'let',
    Get: 'get',
    Set: 'set',
    Of: 'of',
    From: 'from',
    As: 'as',
    Target: 'target',
    Meta: 'meta'
};
/**
 * Reserved WordsToken 
 *
 *  A.1.7: ReservedWord :: one of
 *   await break case catch class const continue debugger default
 *   delete do else enum export extends false finally for function
 *   if import in instanceof new null return super switch this
 *   throw true try typeof var void while with yield
 *
 * 
 * - let  ES2025  ReservedWord
 *    let  SlimeContextualKeywordTokenTypes 
 * - delete, typeof, void, in, instanceof 
 */ const SlimeReservedWordTokenTypes = {
    Await: 'Await',
    Break: 'Break',
    Case: 'Case',
    Catch: 'Catch',
    Class: 'Class',
    Const: 'Const',
    Continue: 'Continue',
    Debugger: 'Debugger',
    Default: 'Default',
    Do: 'Do',
    Else: 'Else',
    Enum: 'Enum',
    Export: 'Export',
    Extends: 'Extends',
    False: 'False',
    Finally: 'Finally',
    For: 'For',
    Function: 'Function',
    If: 'If',
    Import: 'Import',
    New: 'New',
    NullLiteral: 'NullLiteral',
    Return: 'Return',
    Super: 'Super',
    Switch: 'Switch',
    This: 'This',
    Throw: 'Throw',
    True: 'True',
    Try: 'Try',
    Var: 'Var',
    While: 'While',
    With: 'With',
    Yield: 'Yield'
};
// ============================================
// Token  A.1 
// ============================================
const SlimeTokenType = {
    // ============================================
    // A.1.2 White Space
    // ============================================
    WhiteSpace: 'WhiteSpace',
    // ============================================
    // A.1.3 Line Terminators
    // ============================================
    LineTerminator: 'LineTerminator',
    // ============================================
    // A.1.4 Comments
    // ============================================
    HashbangComment: 'HashbangComment',
    MultiLineComment: 'MultiLineComment',
    SingleLineComment: 'SingleLineComment',
    // B.1.1 HTML-like Comments (Web )
    SingleLineHTMLOpenComment: 'SingleLineHTMLOpenComment',
    SingleLineHTMLCloseComment: 'SingleLineHTMLCloseComment',
    // ============================================
    // A.1.5 Tokens (CommonToken)
    // ============================================
    IdentifierName: 'IdentifierName',
    PrivateIdentifier: 'PrivateIdentifier',
    NumericLiteral: 'NumericLiteral',
    StringLiteral: 'StringLiteral',
    NoSubstitutionTemplate: 'NoSubstitutionTemplate',
    TemplateHead: 'TemplateHead',
    TemplateMiddle: 'TemplateMiddle',
    TemplateTail: 'TemplateTail',
    RegularExpressionLiteral: 'RegularExpressionLiteral',
    // ============================================
    // A.1.6 Punctuators
    // ============================================
    Ellipsis: 'Ellipsis',
    Arrow: 'Arrow',
    OptionalChaining: 'OptionalChaining',
    LBrace: 'LBrace',
    RBrace: 'RBrace',
    LParen: 'LParen',
    RParen: 'RParen',
    LBracket: 'LBracket',
    RBracket: 'RBracket',
    Dot: 'Dot',
    Semicolon: 'Semicolon',
    Comma: 'Comma',
    Question: 'Question',
    Colon: 'Colon',
    // ============================================
    // A.1.7 Reserved Words
    // ============================================
    ...SlimeReservedWordTokenTypes,
    // ============================================
    //  Token
    // ============================================
    ...SlimeAssignmentOperatorTokenTypes,
    ...SlimeUpdateOperatorTokenTypes,
    ...SlimeUnaryOperatorTokenTypes,
    ...SlimeBinaryOperatorTokenTypes,
    ...SlimeLogicalOperatorTokenTypes,
    // ============================================
    // 
    // ============================================
    ...SlimeContextualKeywordTokenTypes
};

// ============================================
// Token  TokenConsumer 
// ============================================
// ============================================
// 
// ============================================
// ECMAScript `/` 
//  InputElementDiv  InputElementRegExp 
//
//  B Slash +  Rescan
// 1. `/`  Slash
// 2.  Slash  rescanSlashAsRegExp() 
//
//  100% 
// ============================================
// ============================================
// ES2025  12.7 
//
// IdentifierStart ::
//     UnicodeIDStart | $ | _ | \ UnicodeEscapeSequence
//
// IdentifierPart ::
//     UnicodeIDContinue | $ | \ UnicodeEscapeSequence | <ZWNJ> | <ZWJ>
//
// BabelAcornTypeScript
// ============================================
// IdentifierStart: UnicodeIDStart | $ | _ | \uXXXX | \u{XXXXX}
// Unicode  \p{}  'u' flag 
const ID_START_SOURCE = String.raw`[\p{ID_Start}$_]|\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]+\}`;
// IdentifierPart: UnicodeIDContinue | $ | \uXXXX | \u{XXXXX} | ZWNJ(\u200C) | ZWJ(\u200D)
const ID_CONTINUE_SOURCE = String.raw`[\p{ID_Continue}$\u200C\u200D]|\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]+\}`;
// IdentifierName: IdentifierStart IdentifierPart*
const IDENTIFIER_NAME_PATTERN = new RegExp(`(?:${ID_START_SOURCE})(?:${ID_CONTINUE_SOURCE})*`, 'u');
// PrivateIdentifier: # IdentifierName
const PRIVATE_IDENTIFIER_PATTERN = new RegExp(`#(?:${ID_START_SOURCE})(?:${ID_CONTINUE_SOURCE})*`, 'u');
const SlimeTokensObj = {
    // ============================================
    // A.1.2  (Comments)
    // ============================================
    // HashbangComment index === 0 skip token
    //  Parser  Program 
    // LineTerminator : LF(\n), CR(\r), LS(\u2028), PS(\u2029)
    //  onlyAtStart 
    HashbangComment: createValueRegToken(SlimeTokenType.HashbangComment, /#![^\n\r\u2028\u2029]*/, '', false, undefined, {
        onlyAtStart: true
    } // 
    ),
    // SingleLineComment  MultiLineComment  LineTerminator
    MultiLineComment: createValueRegToken(SlimeTokenType.MultiLineComment, /\/\*[\s\S]*?\*\//, '', true),
    SingleLineComment: createValueRegToken(SlimeTokenType.SingleLineComment, /\/\/[^\n\r\u2028\u2029]*/, '', true),
    // B.1.1 HTML-like Comments (Web )
    // SingleLineHTMLOpenComment: <!-- 
    // : SingleLineHTMLOpenComment :: <!-- SingleLineCommentChars_opt
    SingleLineHTMLOpenComment: createValueRegToken(SlimeTokenType.SingleLineHTMLOpenComment, /<!--[^\n\r\u2028\u2029]*/, '', true // skip = true
    ),
    // SingleLineHTMLCloseComment: --> 
    // : HTMLCloseComment :: WhiteSpaceSequence_opt SingleLineDelimitedCommentSequence_opt --> SingleLineCommentChars_opt
    //  onlyAtLineStart  >  skip token 
    //  `x = y-->10;`  -->  --  > ` --> nothing` 
    SingleLineHTMLCloseComment: createValueRegToken(SlimeTokenType.SingleLineHTMLCloseComment, /-->[^\n\r\u2028\u2029]*/, '', true, undefined, {
        onlyAtLineStart: true
    } // 
    ),
    // ============================================
    // A.1.1 
    // ============================================
    // ECMAScript 12.2 White Space
    // : TAB, VT, FF, SP, NBSP, BOM,  Unicode Zs 
    // Zs : U+0020 (SP), U+00A0 (NBSP), U+1680, U+2000-U+200A, U+202F, U+205F, U+3000
    WhiteSpace: createValueRegToken(SlimeTokenType.WhiteSpace, /[\t\v\f \u00A0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]+/, '', true),
    LineTerminatorCRLF: createValueRegToken(SlimeTokenType.LineTerminator, /\r\n/, '', true),
    LineTerminator: createValueRegToken(SlimeTokenType.LineTerminator, /[\n\r\u2028\u2029]/, '', true),
    // ============================================
    // A.1.5 
    // ============================================
    AwaitTok: createKeywordToken(SlimeTokenType.Await, 'await'),
    BreakTok: createKeywordToken(SlimeTokenType.Break, 'break'),
    CaseTok: createKeywordToken(SlimeTokenType.Case, 'case'),
    CatchTok: createKeywordToken(SlimeTokenType.Catch, 'catch'),
    ClassTok: createKeywordToken(SlimeTokenType.Class, 'class'),
    ConstTok: createKeywordToken(SlimeTokenType.Const, 'const'),
    ContinueTok: createKeywordToken(SlimeTokenType.Continue, 'continue'),
    DebuggerTok: createKeywordToken(SlimeTokenType.Debugger, 'debugger'),
    DefaultTok: createKeywordToken(SlimeTokenType.Default, 'default'),
    DeleteTok: createKeywordToken(SlimeTokenType.Delete, 'delete'),
    DoTok: createKeywordToken(SlimeTokenType.Do, 'do'),
    ElseTok: createKeywordToken(SlimeTokenType.Else, 'else'),
    EnumTok: createKeywordToken(SlimeTokenType.Enum, 'enum'),
    ExportTok: createKeywordToken(SlimeTokenType.Export, 'export'),
    ExtendsTok: createKeywordToken(SlimeTokenType.Extends, 'extends'),
    FalseTok: createKeywordToken(SlimeTokenType.False, 'false'),
    FinallyTok: createKeywordToken(SlimeTokenType.Finally, 'finally'),
    ForTok: createKeywordToken(SlimeTokenType.For, 'for'),
    FunctionTok: createKeywordToken(SlimeTokenType.Function, 'function'),
    IfTok: createKeywordToken(SlimeTokenType.If, 'if'),
    ImportTok: createKeywordToken(SlimeTokenType.Import, 'import'),
    InTok: createKeywordToken(SlimeTokenType.In, 'in'),
    InstanceofTok: createKeywordToken(SlimeTokenType.Instanceof, 'instanceof'),
    // let  token
    // LetTok: createKeywordToken(SlimeTokenType.Let, 'let'),
    NewTok: createKeywordToken(SlimeTokenType.New, 'new'),
    NullTok: createKeywordToken(SlimeTokenType.NullLiteral, 'null'),
    ReturnTok: createKeywordToken(SlimeTokenType.Return, 'return'),
    SuperTok: createKeywordToken(SlimeTokenType.Super, 'super'),
    SwitchTok: createKeywordToken(SlimeTokenType.Switch, 'switch'),
    ThisTok: createKeywordToken(SlimeTokenType.This, 'this'),
    ThrowTok: createKeywordToken(SlimeTokenType.Throw, 'throw'),
    TrueTok: createKeywordToken(SlimeTokenType.True, 'true'),
    TryTok: createKeywordToken(SlimeTokenType.Try, 'try'),
    TypeofTok: createKeywordToken(SlimeTokenType.Typeof, 'typeof'),
    VarTok: createKeywordToken(SlimeTokenType.Var, 'var'),
    VoidTok: createKeywordToken(SlimeTokenType.Void, 'void'),
    WhileTok: createKeywordToken(SlimeTokenType.While, 'while'),
    WithTok: createKeywordToken(SlimeTokenType.With, 'with'),
    YieldTok: createKeywordToken(SlimeTokenType.Yield, 'yield'),
    // async, static, as, get, set, of, target, meta, from
    //  IdentifierName  Parser 
    // ============================================
    // A.1.9 
    // : NumericLiteral :: DecimalLiteral | DecimalBigIntegerLiteral | NonDecimalIntegerLiteral | LegacyOctalIntegerLiteral
    //  NumericLiteral
    //
    //  Babel 
    // 1.  legacy octal  non-octal decimal
    // 2. Parser/AST
    // 3. 
    // ============================================
    // BigInt  -  n
    // DecimalBigIntegerLiteral :: 0n | NonZeroDigit DecimalDigits_opt n
    // NonDecimalIntegerLiteral BigIntLiteralSuffix
    NumericLiteralBigIntHex: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n/),
    NumericLiteralBigIntBinary: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[bB][01](_?[01])*n/),
    NumericLiteralBigIntOctal: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[oO][0-7](_?[0-7])*n/),
    NumericLiteralBigIntDecimal: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /(?:0|[1-9](_?[0-9])*)n/),
    //  (NonDecimalIntegerLiteral) - 
    // HexIntegerLiteral :: 0x HexDigits | 0X HexDigits
    // BinaryIntegerLiteral :: 0b BinaryDigits | 0B BinaryDigits
    // OctalIntegerLiteral :: 0o OctalDigits | 0O OctalDigits
    NumericLiteralHex: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/),
    NumericLiteralBinary: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[bB][01](_?[01])*/),
    NumericLiteralOctal: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /0[oO][0-7](_?[0-7])*/),
    //  LegacyOctal  NonOctalDecimal
    //  Babel  readNumber 
    //
    // 
    // 1. 0[0-9]* -  0  legacy octal  07 non-octal decimal  09
    // 2. [1-9](_?[0-9])* -  1-9  numeric separator
    // 3. \.([0-9](_?[0-9])*)? - 
    // 4. ([eE][+-]?[0-9](_?[0-9])*)? - 
    // 5. \.[0-9]... -  .xxx 
    //
    //  Parser 
    // - LegacyOctalIntegerLiteral (07, 077): 
    // - NonOctalDecimalIntegerLiteral (08, 09): 
    // -  0  07.5 
    NumericLiteralDecimal: createEmptyValueRegToken(SlimeTokenType.NumericLiteral, /(?:0[0-9]*|[1-9](_?[0-9])*)(?:\.([0-9](_?[0-9])*)?)?([eE][+-]?[0-9](_?[0-9])*)?|\.[0-9](_?[0-9])*([eE][+-]?[0-9](_?[0-9])*)?/),
    // ============================================
    // A.1.10 
    // ============================================
    /**
     * StringLiteral :
     *     " DoubleStringCharacters_opt "
     *     ' SingleStringCharacters_opt '
     *
     * Lexer  StringLiteral token
     */ //  (LineContinuation): \  \r\n | \r | \n
    //  ES2025  12.9.4 String Literals  Annex B
    // Annex B:  \0-\7, \00-\77, \000-\377
    DoubleStringCharacters: createEmptyValueRegToken(SlimeTokenType.StringLiteral, /"(?:[^\n\r"\\]|\\(?:\r\n|\r|\n|['"\\bfnrtv]|[^'"\\bfnrtv\n\r]|x[0-9a-fA-F]{2}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]+\})))*"/),
    SingleStringCharacters: createEmptyValueRegToken(SlimeTokenType.StringLiteral, /'(?:[^\n\r'\\]|\\(?:\r\n|\r|\n|['"\\bfnrtv]|[^'"\\bfnrtv\n\r]|x[0-9a-fA-F]{2}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]+\})))*'/),
    // ============================================
    // A.1.12 
    // ============================================
    TemplateHead: createEmptyValueRegToken(SlimeTokenType.TemplateHead, /`(?:[^`\\$]|\\[\s\S]|\$(?!\{))*\$\{/),
    TemplateMiddle: createEmptyValueRegToken(SlimeTokenType.TemplateMiddle, /\}(?:[^`\\$]|\\[\s\S]|\$(?!\{))*\$\{/),
    TemplateTail: createEmptyValueRegToken(SlimeTokenType.TemplateTail, /\}(?:[^`\\$]|\\[\s\S]|\$(?!\{))*`/),
    NoSubstitutionTemplate: createEmptyValueRegToken(SlimeTokenType.NoSubstitutionTemplate, /`(?:[^`\\$]|\\[\s\S]|\$(?!\{))*`/),
    // ============================================
    // A.1.8 
    // ============================================
    // 4 
    UnsignedRightShiftAssign: createValueRegToken(SlimeTokenType.UnsignedRightShiftAssign, />>>=/, '>>>='),
    // 3 
    Ellipsis: createValueRegToken(SlimeTokenType.Ellipsis, /\.\.\./, '...'),
    UnsignedRightShift: createValueRegToken(SlimeTokenType.UnsignedRightShift, />>>/, '>>>'),
    StrictEqual: createValueRegToken(SlimeTokenType.StrictEqual, /===/, '==='),
    StrictNotEqual: createValueRegToken(SlimeTokenType.StrictNotEqual, /!==/, '!=='),
    LeftShiftAssign: createValueRegToken(SlimeTokenType.LeftShiftAssign, /<<=/, '<<='),
    RightShiftAssign: createValueRegToken(SlimeTokenType.RightShiftAssign, />>=/, '>>='),
    ExponentiationAssign: createValueRegToken(SlimeTokenType.ExponentiationAssign, /\*\*=/, '**='),
    LogicalAndAssign: createValueRegToken(SlimeTokenType.LogicalAndAssign, /&&=/, '&&='),
    LogicalOrAssign: createValueRegToken(SlimeTokenType.LogicalOrAssign, /\|\|=/, '||='),
    NullishCoalescingAssign: createValueRegToken(SlimeTokenType.NullishCoalescingAssign, /\?\?=/, '??='),
    // 2 
    Arrow: createValueRegToken(SlimeTokenType.Arrow, /=>/, '=>'),
    PlusAssign: createValueRegToken(SlimeTokenType.PlusAssign, /\+=/, '+='),
    MinusAssign: createValueRegToken(SlimeTokenType.MinusAssign, /-=/, '-='),
    MultiplyAssign: createValueRegToken(SlimeTokenType.MultiplyAssign, /\*=/, '*='),
    // DivideAssign 
    // /=xxx/g  rescanSlashAsRegExp() 
    DivideAssign: createValueRegToken(SlimeTokenType.DivideAssign, /\/=/, '/='),
    ModuloAssign: createValueRegToken(SlimeTokenType.ModuloAssign, /%=/, '%='),
    LeftShift: createValueRegToken(SlimeTokenType.LeftShift, /<</, '<<'),
    RightShift: createValueRegToken(SlimeTokenType.RightShift, />>/, '>>'),
    LessEqual: createValueRegToken(SlimeTokenType.LessEqual, /<=/, '<='),
    GreaterEqual: createValueRegToken(SlimeTokenType.GreaterEqual, />=/, '>='),
    Equal: createValueRegToken(SlimeTokenType.Equal, /==/, '=='),
    NotEqual: createValueRegToken(SlimeTokenType.NotEqual, /!=/, '!='),
    LogicalAnd: createValueRegToken(SlimeTokenType.LogicalAnd, /&&/, '&&'),
    LogicalOr: createValueRegToken(SlimeTokenType.LogicalOr, /\|\|/, '||'),
    NullishCoalescing: createValueRegToken(SlimeTokenType.NullishCoalescing, /\?\?/, '??'),
    Increment: createValueRegToken(SlimeTokenType.Increment, /\+\+/, '++'),
    Decrement: createValueRegToken(SlimeTokenType.Decrement, /--/, '--'),
    Exponentiation: createValueRegToken(SlimeTokenType.Exponentiation, /\*\*/, '**'),
    BitwiseAndAssign: createValueRegToken(SlimeTokenType.BitwiseAndAssign, /&=/, '&='),
    BitwiseOrAssign: createValueRegToken(SlimeTokenType.BitwiseOrAssign, /\|=/, '|='),
    BitwiseXorAssign: createValueRegToken(SlimeTokenType.BitwiseXorAssign, /\^=/, '^='),
    OptionalChaining: createValueRegToken(SlimeTokenType.OptionalChaining, /\?\./, '?.', false, {
        not: /^\d/
    }),
    // 1 
    LBrace: createValueRegToken(SlimeTokenType.LBrace, /\{/, '{'),
    RBrace: createValueRegToken(SlimeTokenType.RBrace, /\}/, '}'),
    LParen: createValueRegToken(SlimeTokenType.LParen, /\(/, '('),
    RParen: createValueRegToken(SlimeTokenType.RParen, /\)/, ')'),
    LBracket: createValueRegToken(SlimeTokenType.LBracket, /\[/, '['),
    RBracket: createValueRegToken(SlimeTokenType.RBracket, /\]/, ']'),
    Dot: createValueRegToken(SlimeTokenType.Dot, /\./, '.'),
    Semicolon: createValueRegToken(SlimeTokenType.Semicolon, /;/, ';'),
    Comma: createValueRegToken(SlimeTokenType.Comma, /,/, ','),
    Less: createValueRegToken(SlimeTokenType.Less, /</, '<'),
    Greater: createValueRegToken(SlimeTokenType.Greater, />/, '>'),
    Plus: createValueRegToken(SlimeTokenType.Plus, /\+/, '+'),
    Minus: createValueRegToken(SlimeTokenType.Minus, /-/, '-'),
    Asterisk: createValueRegToken(SlimeTokenType.Asterisk, /\*/, '*'),
    // ============================================
    //  Slash
    //  rescanSlashAsRegExp() 
    // ============================================
    Slash: createValueRegToken(SlimeTokenType.Slash, /\//, '/'),
    // RegularExpressionLiteral 
    //  rescanSlashAsRegExp() 
    //  100% 
    Modulo: createValueRegToken(SlimeTokenType.Modulo, /%/, '%'),
    BitwiseAnd: createValueRegToken(SlimeTokenType.BitwiseAnd, /&/, '&'),
    BitwiseOr: createValueRegToken(SlimeTokenType.BitwiseOr, /\|/, '|'),
    BitwiseXor: createValueRegToken(SlimeTokenType.BitwiseXor, /\^/, '^'),
    BitwiseNot: createValueRegToken(SlimeTokenType.BitwiseNot, /~/, '~'),
    LogicalNot: createValueRegToken(SlimeTokenType.LogicalNot, /!/, '!'),
    Question: createValueRegToken(SlimeTokenType.Question, /\?/, '?'),
    Colon: createValueRegToken(SlimeTokenType.Colon, /:/, ':'),
    Assign: createValueRegToken(SlimeTokenType.Assign, /=/, '='),
    // ============================================
    // A.1.5 
    // ============================================
    // ES2025  12.7 Identifier Names
    //
    // IdentifierName ::
    //     IdentifierStart
    //     IdentifierName IdentifierPart
    //
    // IdentifierStart ::
    //     UnicodeIDStart
    //     $
    //     _
    //     \ UnicodeEscapeSequence
    //
    // IdentifierPart ::
    //     UnicodeIDContinue
    //     $
    //     \ UnicodeEscapeSequence
    //     <ZWNJ>
    //     <ZWJ>
    //
    // UnicodeIDStart :: any Unicode code point with the Unicode property "ID_Start"
    // UnicodeIDContinue :: any Unicode code point with the Unicode property "ID_Continue"
    //
    // BabelAcornTypeScript
    // ============================================
    PrivateIdentifier: createEmptyValueRegToken(SlimeTokenType.PrivateIdentifier, PRIVATE_IDENTIFIER_PATTERN),
    IdentifierName: createEmptyValueRegToken(SlimeTokenType.IdentifierName, IDENTIFIER_NAME_PATTERN)
};
const slimeTokens = Object.values(SlimeTokensObj);

function _define_property$f(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// 
const Es6TokenName = SlimeTokenType;
//  token 
const createSoftKeywordToken = (name, value)=>({
        name,
        type: name,
        value
    });
//  es2025TokensObj
const es6TokensObj = {
    ...SlimeTokensObj,
    //  ES2025  IdentifierName 
    OfTok: createSoftKeywordToken('OfTok', 'of'),
    AsyncTok: createSoftKeywordToken('AsyncTok', 'async'),
    StaticTok: createSoftKeywordToken('StaticTok', 'static'),
    AsTok: createSoftKeywordToken('AsTok', 'as'),
    GetTok: createSoftKeywordToken('GetTok', 'get'),
    SetTok: createSoftKeywordToken('SetTok', 'set'),
    FromTok: createSoftKeywordToken('FromTok', 'from'),
    // ES2025 
    Eq: SlimeTokensObj.Assign
};
//  Token  VariableDeclaration  kind
// 'let'  token
const es6TokenMapObj = {
    'const': SlimeTokensObj.ConstTok,
    'let': createSoftKeywordToken('Let', 'let'),
    'var': SlimeTokensObj.VarTok
};
class SlimeGenerator {
    static findNextTokenLocByTypeAndIndex(tokenType, index) {
        const popToken = this.tokens.find((item)=>item.tokenName === tokenType && item.index > index);
        let loc = null;
        if (popToken) {
            loc = {
                // index: popToken.index,
                value: popToken.tokenValue,
                type: popToken.tokenName,
                start: {
                    index: popToken.index,
                    line: popToken.rowNum,
                    column: popToken.columnStartNum
                },
                end: {
                    index: popToken.index + popToken.tokenValue.length,
                    line: popToken.rowNum,
                    column: popToken.columnEndNum
                }
            };
        }
        return loc;
    }
    static generator(node, tokens) {
        this.mappings = [];
        this.tokens = tokens;
        this.lastSourcePosition = new SlimeCodeLocation();
        this.generatePosition = new SlimeCodeLocation();
        this.sourceCodeIndex = 0;
        this.generateLine = 0;
        this.generateColumn = 0;
        this.generateIndex = 0;
        this.generateCode = '';
        this.indent = 0; // 2
        this.generatorNode(node);
        return {
            mapping: this.mappings,
            code: this.generateCode
        };
    }
    static generatorProgram(node) {
        this.generatorNodes(node.body);
    }
    static generatorModuleDeclarations(node) {
        for (const nodeElement of node){
            this.generatorNode(nodeElement);
        // this.addSemicolonAndNewLine()
        }
    }
    static generatorImportDeclaration(node) {
        this.addCodeAndMappings(es6TokensObj.ImportTok, node.loc);
        this.addSpacing();
        const hasSpecifiers = node.specifiers && node.specifiers.length > 0;
        //  {}  brace tokens 
        const hasEmptyNamedImport = !hasSpecifiers && node.lBraceToken && node.rBraceToken;
        if (hasSpecifiers) {
            //  specifier 
            const getSpecType = (s)=>s.specifier?.type || s.type;
            const getSpec = (s)=>s.specifier || s;
            const hasDefault = node.specifiers.some((s)=>getSpecType(s) === SlimeNodeType.ImportDefaultSpecifier);
            const hasNamed = node.specifiers.some((s)=>getSpecType(s) === SlimeNodeType.ImportSpecifier);
            const hasNamespace = node.specifiers.some((s)=>getSpecType(s) === SlimeNodeType.ImportNamespaceSpecifier);
            if (hasDefault) {
                const defaultItem = node.specifiers.find((s)=>getSpecType(s) === SlimeNodeType.ImportDefaultSpecifier);
                this.generatorNode(getSpec(defaultItem));
                if (hasNamed || hasNamespace) {
                    this.addComma();
                    this.addSpacing();
                }
            }
            if (hasNamespace) {
                const nsItem = node.specifiers.find((s)=>getSpecType(s) === SlimeNodeType.ImportNamespaceSpecifier);
                this.generatorNode(getSpec(nsItem));
            } else if (hasNamed) {
                // import {name, greet}
                const namedItems = node.specifiers.filter((s)=>getSpecType(s) === SlimeNodeType.ImportSpecifier);
                this.addLBrace();
                namedItems.forEach((item, index)=>{
                    if (index > 0) this.addComma();
                    this.generatorNode(getSpec(item));
                });
                this.addRBrace();
            }
            //  specifiers  from
            this.addSpacing();
            this.addCodeAndMappings(es6TokensObj.FromTok, node.loc);
            this.addSpacing();
        } else if (hasEmptyNamedImport) {
            // : import {} from "foo"
            this.addLBrace();
            this.addRBrace();
            this.addSpacing();
            this.addCodeAndMappings(es6TokensObj.FromTok, node.loc);
            this.addSpacing();
        }
        // source 
        this.generatorNode(node.source);
        // ES2025 Import Attributes: with { type: "json" }
        this.generatorAttributes(node.attributes);
        // 
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine(); // 1
    // addIndent()  generatorNodes 
    }
    /**  ES2025 Import Attributes: with { type: "json" }  with {} */ static generatorAttributes(attrs) {
        //  attrs  undefined
        //  attrs  with {}
        if (attrs === undefined) return;
        this.addSpacing();
        this.addCode({
            type: 'With',
            name: 'With',
            value: 'with'
        });
        this.addSpacing();
        this.addLBrace();
        attrs.forEach((attr, index)=>{
            if (index > 0) {
                this.addComma();
                this.addSpacing();
            }
            // key: Identifier  Literal
            if (attr.key.type === SlimeNodeType.Identifier) {
                this.generatorIdentifier(attr.key);
            } else {
                this.generatorNode(attr.key);
            }
            this.addCode(es6TokensObj.Colon);
            this.addSpacing();
            this.generatorNode(attr.value);
        });
        this.addRBrace();
    }
    static generatorImportSpecifier(node) {
        // import {name} or import {name as localName}
        // 
        const importedName = node.imported.name;
        const localName = node.local.name;
        if (importedName !== localName) {
            // import {name as localName}
            this.generatorNode(node.imported);
            this.addSpacing();
            this.addCode(es6TokensObj.AsTok);
            this.addSpacing();
            this.generatorNode(node.local);
        } else {
            // import {name}
            this.generatorNode(node.local);
        }
    }
    static generatorImportDefaultSpecifier(node) {
        this.generatorNode(node.local);
    }
    static generatorImportNamespaceSpecifier(node) {
        // import * as name
        this.addCode(es6TokensObj.Asterisk);
        this.addSpacing();
        this.addCode(es6TokensObj.AsTok);
        this.addSpacing();
        this.generatorNode(node.local);
    }
    static generatorExportNamedDeclaration(node) {
        this.addCode(es6TokensObj.ExportTok);
        this.addSpacing();
        if (node.declaration) {
            // export const name = 'Alice'
            this.generatorNode(node.declaration);
        } else if (node.specifiers) {
            // export {name}  export {name as userName}  export {}
            this.addLBrace();
            node.specifiers.forEach((item, index)=>{
                if (index > 0) {
                    this.addComma();
                    this.addSpacing();
                }
                // specifiers : { specifier: {...}, commaToken?: {...} }
                const spec = item.specifier || item;
                this.generatorExportSpecifier(spec);
            });
            this.addRBrace();
            if (node.source) {
                // export {name} from './module.js'
                this.addSpacing();
                this.addCode(es6TokensObj.FromTok);
                this.addSpacing();
                this.generatorNode(node.source);
            }
            // ES2025 Import Attributes: with { type: "json" }
            this.generatorAttributes(node.attributes);
            // 
            this.addCode(es6TokensObj.Semicolon);
            this.addNewLine();
        }
    }
    static generatorExportSpecifier(spec) {
        // local: , exported: 
        // ES2022: local  exported  Identifier  Literal
        this.generatorNode(spec.local);
        // Identifier  nameLiteral  value
        const localValue = spec.local.type === SlimeNodeType.Literal ? spec.local.value : spec.local.name;
        const exportedValue = spec.exported.type === SlimeNodeType.Literal ? spec.exported.value : spec.exported.name;
        // 
        if (localValue !== exportedValue) {
            // export {name as userName}  export {"string" as "alias"}
            this.addSpacing();
            this.addCode(es6TokensObj.AsTok);
            this.addSpacing();
            this.generatorNode(spec.exported);
        }
    // else: export {name} - 
    }
    static generatorExportAllDeclaration(node) {
        // export * from './module.js'  export * as name from './module.js'
        this.addCode(es6TokensObj.ExportTok);
        this.addSpacing();
        this.addCode(es6TokensObj.Asterisk);
        this.addSpacing();
        //  as name
        if (node.exported) {
            this.addCode(es6TokensObj.AsTok);
            this.addSpacing();
            this.generatorNode(node.exported);
            this.addSpacing();
        }
        this.addCode(es6TokensObj.FromTok);
        this.addSpacing();
        this.generatorNode(node.source);
        // ES2025 Import Attributes: with { type: "json" }
        this.generatorAttributes(node.attributes);
        // 
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    static generatorNodes(nodes) {
        nodes.forEach((node, index)=>{
            this.generatorNode(node);
            // 2
            if (index < nodes.length - 1) {
                this.addIndent();
            }
        // this.addSemicolonAndNewLine()
        });
    }
    static generatorExpressionStatement(node) {
        this.generatorNode(node.expression);
        // 
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine(); // 1
    // addIndent()  generatorNodes 
    }
    static generatorYieldExpression(node) {
        // yield  yield* argument
        this.addCode(es6TokensObj.YieldTok);
        if (node.delegate) {
            this.addCode(es6TokensObj.Asterisk);
        }
        if (node.argument) {
            this.addSpacing();
            this.generatorNode(node.argument);
        }
    }
    static generatorAwaitExpression(node) {
        // await argument
        this.addCode(es6TokensObj.AwaitTok);
        if (node.argument) {
            this.addSpacing();
            this.generatorNode(node.argument);
        }
    }
    static generatorTemplateLiteral(node) {
        // `part1 ${expr1} part2 ${expr2} part3`
        const quasis = node.quasis || [];
        const expressions = node.expressions || [];
        // 
        if (expressions.length === 0 && quasis.length === 1 && quasis[0].value?.raw) {
            //  token
            this.addString(quasis[0].value.raw);
            return;
        }
        // quasisexpressionsquasisexpressions1
        for(let i = 0; i < quasis.length; i++){
            const quasi = quasis[i];
            //  raw 
            if (quasi.value) {
                const raw = quasi.value.raw || '';
                this.addString(raw);
            }
            // quasiexpression
            if (i < expressions.length) {
                this.generatorNode(expressions[i]);
            }
        }
    }
    static generatorCallExpression(node) {
        //  callee ParenthesizedExpression
        this.generatorNode(node.callee);
        // obj?.method() -  ?.(  (
        if (node.optional) {
            this.addCode(es6TokensObj.OptionalChaining); // ?.
        }
        // tokenAST
        this.addLParen();
        if (node.arguments.length) {
            node.arguments.forEach((item, index)=>{
                if (index !== 0) {
                    this.addComma();
                }
                // { argument: {...}, commaToken?: {...} }
                const argument = item.argument || item;
                // SpreadElement
                if (argument.type === SlimeNodeType.SpreadElement) {
                    this.generatorSpreadElement(argument);
                } else {
                    this.generatorNode(argument);
                }
            });
        }
        this.addRParen();
    }
    static generatorFunctionExpression(node) {
        // asyncasync
        if (node.async) {
            this.addCode(es6TokensObj.AsyncTok);
            this.addSpacing();
        }
        this.addCodeAndMappings(es6TokensObj.FunctionTok, node.loc);
        // *
        if (node.generator) {
            this.addCode(es6TokensObj.Asterisk);
        }
        if (node.id) {
            this.addSpacing();
            this.generatorNode(node.id);
        }
        // params  SlimeFunctionParam[] 
        this.generatorFunctionParams(node.params);
        // body
        if (node.body && node.body.type) {
            this.generatorNode(node.body);
        } else {
            // 
            this.addLBrace();
            this.addRBrace();
        }
    }
    /**
     * 
     */ static generatorArrowFunctionExpression(node) {
        // asyncasync
        if (node.async) {
            this.addCode(es6TokensObj.AsyncTok);
            this.addSpacing();
        }
        //  { param: Identifier } 
        const unwrapParam = (p)=>p.param !== undefined ? p.param : p;
        const firstParam = node.params?.[0] ? unwrapParam(node.params[0]) : null;
        // 
        // 1. lParenToken 
        // 2.  token
        const hasParenTokens = node.lParenToken || node.rParenToken;
        const canOmitParens = node.params && node.params.length === 1 && firstParam?.type === SlimeNodeType.Identifier && !hasParenTokens;
        if (canOmitParens) {
            // 
            this.generatorNode(firstParam);
        } else {
            // 
            this.addLParen();
            if (node.params) {
                node.params.forEach((item, index)=>{
                    if (index !== 0) {
                        this.addComma();
                    }
                    const param = unwrapParam(item);
                    this.generatorNode(param);
                });
            }
            this.addRParen();
        }
        // 
        this.addSpacing();
        this.addCode(es6TokensObj.Arrow);
        this.addSpacing();
        // 
        if (node.expression && node.body.type !== SlimeNodeType.BlockStatement) {
            // x => x * 2  x => ({ key: value })
            //  bodyObjectExpression
            //  { } 
            if (node.body.type === SlimeNodeType.ObjectExpression) {
                this.addLParen();
                this.generatorNode(node.body);
                this.addRParen();
            } else {
                this.generatorNode(node.body);
            }
        } else {
            // x => { return x * 2 }
            // 2 false
            this.generatorNode(node.body, false);
        }
    }
    /**
     * 
     */ static generatorBinaryExpression(node) {
        // 
        this.generatorNode(node.left);
        // 
        //  addString()  addCode()
        // 1. +, -, *, /  token
        // 2.  source map 
        // 3. 
        this.addSpacing();
        this.addString(node.operator);
        this.addSpacing();
        // 
        this.generatorNode(node.right);
    }
    /**
     * 
     * @param params SlimeFunctionParam[] 
     */ static generatorFunctionParams(params) {
        this.addLParen();
        if (params && params.length > 0) {
            params.forEach((item, index)=>{
                if (index !== 0) {
                    this.addComma();
                }
                //  { param: Pattern, commaToken?: ... }
                const param = item.param || item;
                this.generatorNode(param);
            });
        }
        this.addRParen();
    }
    /**
     * ""
     * 
     * - CallExpression
     * - ObjectExpression1
     * - ArrayExpression
     */ static isComplexNode(node) {
        if (!node) return false;
        if (node.type === SlimeNodeType.CallExpression) return true;
        if (node.type === SlimeNodeType.ObjectExpression && node.properties?.length > 1) return true;
        if (node.type === SlimeNodeType.ArrayExpression) {
            return node.elements?.some((item)=>this.isComplexNode(item?.element));
        }
        return false;
    }
    static generatorArrayExpression(node) {
        this.addLBracket(node.loc);
        // 
        const hasComplexElements = node.elements?.some((item)=>this.isComplexNode(item?.element));
        if (hasComplexElements && node.elements.length > 0) {
            // 
            this.addNewLine();
            this.indent++;
            this.addIndent();
            node.elements.forEach((item, index)=>{
                const element = item.element;
                if (element === null || element === undefined) ; else if (element.type === SlimeNodeType.SpreadElement) {
                    this.generatorSpreadElement(element);
                } else {
                    this.generatorNode(element);
                }
                // 
                if (index < node.elements.length - 1) {
                    this.addComma();
                    this.addNewLine();
                    this.addIndent();
                }
            });
            this.addNewLine();
            this.indent--;
            this.addIndent();
        } else {
            // 
            for (const item of node.elements){
                const element = item.element;
                if (element === null || element === undefined) ; else if (element.type === SlimeNodeType.SpreadElement) {
                    this.generatorSpreadElement(element);
                } else {
                    this.generatorNode(element);
                }
                if (item.commaToken) {
                    this.addComma();
                }
            }
        }
        this.addRBracket(node.loc);
    }
    static generatorObjectExpression(node) {
        this.addLBrace();
        node.properties.forEach((item, index)=>{
            // properties  SlimeObjectPropertyItem[]  { property, commaToken }
            const property = item.property;
            // ES2018: SpreadElement
            if (property.type === SlimeNodeType.SpreadElement) {
                this.generatorSpreadElement(property);
            } else {
                // Property
                this.generatorNode(property);
            }
            //  token
            if (item.commaToken) {
                this.addComma();
            }
        });
        this.addRBrace();
    }
    static generatorParenthesizedExpression(node) {
        // (expression)
        this.addLParen();
        this.generatorNode(node.expression);
        this.addRParen();
    }
    static generatorSequenceExpression(node) {
        // a, b, c
        if (node.expressions && Array.isArray(node.expressions)) {
            for(let i = 0; i < node.expressions.length; i++){
                if (i > 0) {
                    this.addComma();
                }
                this.generatorNode(node.expressions[i]);
            }
        }
    }
    static generatorPrivateIdentifier(node) {
        //  addString()  #privateField
        //  source map 
        this.addString(node.name);
    }
    static generatorProperty(node) {
        //  getter/setter
        if (node.kind === 'get' || node.kind === 'set') {
            // getter: get name() { ... }
            // setter: set name(value) { ... }
            if (node.kind === 'get') {
                this.addCode(es6TokensObj.GetTok);
            } else {
                this.addCode(es6TokensObj.SetTok);
            }
            this.addSpacing();
            // 
            if (node.computed) {
                this.addLBracket();
                this.generatorNode(node.key);
                this.addRBracket();
            } else {
                this.generatorNode(node.key);
            }
            // 
            const value = node.value;
            this.generatorFunctionParams(value.params);
            if (value.body) {
                this.generatorNode(value.body);
            }
        } else if (node.method) {
            // : name() { ... }  *name() { ... }  async name() { ... }
            const value = node.value;
            //  async
            if (value.async) {
                this.addCode(es6TokensObj.AsyncTok);
                this.addSpacing();
            }
            //  generator
            if (value.generator) {
                this.addCode(es6TokensObj.Asterisk);
            }
            // 
            if (node.computed) {
                this.addLBracket();
                this.generatorNode(node.key);
                this.addRBracket();
            } else {
                this.generatorNode(node.key);
            }
            // 
            this.generatorFunctionParams(value.params);
            if (value.body) {
                this.generatorNode(value.body);
            }
        } else if (node.shorthand) {
            // : { name }  { name: name }
            // : { name = 'default' }  { name: name = 'default' }
            if (node.value && node.value.type === SlimeNodeType.AssignmentPattern) {
                // 
                this.generatorNode(node.value);
            } else {
                this.generatorNode(node.key);
            }
        } else {
            // : key: value
            if (node.computed) {
                this.addLBracket();
                this.generatorNode(node.key);
                this.addRBracket();
            } else {
                this.generatorNode(node.key);
            }
            this.addCode(es6TokensObj.Colon);
            this.generatorNode(node.value);
        }
    }
    static generatorIdentifier(node) {
        //  token  SubhutiCreateToken 
        // type:  token 
        // name: token 
        // value: 
        //  addCodeAndMappings() source map  token 
        // 1. node.raw2. loc.value 3. node.name
        //  #\u{61}  #a
        const identifierName = node.raw || node.loc?.value || node.name || '';
        if (!identifierName) {
            console.error('generatorIdentifier: node.name is undefined', JSON.stringify(node, null, 2));
        }
        const identifier = {
            type: Es6TokenName.IdentifierNameTok,
            name: Es6TokenName.IdentifierNameTok,
            value: identifierName
        };
        this.addCodeAndMappings(identifier, node.loc);
    }
    static generatorFunctionDeclaration(node) {
        // asyncasync
        if (node.async) {
            this.addCode(es6TokensObj.AsyncTok);
            this.addSpacing();
        }
        //  function 
        this.addCode(es6TokensObj.FunctionTok);
        // Generator * 
        if (node.generator) {
            this.addCode(es6TokensObj.Asterisk);
        }
        // 
        if (node.id) {
            this.addSpacing(); // function/function* 
            this.generatorIdentifier(node.id);
        }
        // 
        this.generatorFunctionParams(node.params);
        // 
        if (node.body) {
            // 2 true
            this.generatorBlockStatement(node.body, true);
        }
    }
    static generatorClassDeclaration(node) {
        this.addCode(es6TokensObj.ClassTok); //  class 
        if (node.id) {
            this.addSpacing(); // 
            this.generatorNode(node.id); // 
        }
        if (node.superClass) {
            this.addSpacing(); // class Name  extends 
            this.addCode(es6TokensObj.ExtendsTok); //  extends 
            this.addSpacing(); // extends 
            this.generatorNode(node.superClass); // 
        }
        this.generatorClassBody(node.body); // 
    }
    static generatorClassExpression(node) {
        this.addCode(es6TokensObj.ClassTok); //  class 
        if (node.id) {
            this.addSpacing(); // 
            this.generatorNode(node.id); // 
        }
        if (node.superClass) {
            this.addSpacing(); // class Name  extends 
            this.addCode(es6TokensObj.ExtendsTok); //  extends 
            this.addSpacing(); // extends 
            this.generatorNode(node.superClass); // 
        }
        this.generatorClassBody(node.body); // 
    }
    static generatorClassBody(body) {
        this.addLBrace(body.loc); // 
        if (body?.body?.length) {
            body.body.forEach((element)=>{
                this.generatorNode(element); // 
            });
        }
        this.addRBrace(body.loc); // 
    }
    static generatorMethodDefinition(node) {
        //  static 
        if (node.static) {
            this.addCode(es6TokensObj.StaticTok);
            this.addSpacing();
        }
        //  async 
        if (node.value && node.value.async) {
            this.addCode(es6TokensObj.AsyncTok);
            this.addSpacing();
        }
        //  getter/setter
        if (node.kind === 'get') {
            this.addCode(es6TokensObj.GetTok);
            this.addSpacing();
        } else if (node.kind === 'set') {
            this.addCode(es6TokensObj.SetTok);
            this.addSpacing();
        }
        //  generator *
        if (node.value && node.value.generator) {
            this.addCode(es6TokensObj.Asterisk);
        }
        //  key
        if (node.key) {
            if (node.computed) {
                this.addLBracket();
                this.generatorNode(node.key);
                this.addRBracket();
            } else {
                this.generatorNode(node.key);
            }
        }
        //  value function 
        if (node.value) {
            //  function 
            this.generatorFunctionParams(node.value.params);
            if (node.value.body) {
                this.generatorNode(node.value.body);
            }
        }
    }
    static generatorPropertyDefinition(node) {
        //  static 
        if (node.static) {
            this.addCode(es6TokensObj.StaticTok);
            this.addSpacing();
        }
        //  key
        if (node.key) {
            // 
            if (node.computed) {
                this.addLBracket();
                this.generatorNode(node.key);
                this.addRBracket();
            } else {
                this.generatorNode(node.key);
            }
        }
        //  value
        if (node.value) {
            this.addSpacing();
            this.addCode(es6TokensObj.Eq);
            this.addSpacing();
            this.generatorNode(node.value);
        }
        // 
        this.addCode(es6TokensObj.Semicolon);
    }
    static generatorNewExpression(node) {
        this.addCode(es6TokensObj.NewTok);
        this.addSpacing();
        //  callee
        if (node.callee) {
            this.generatorNode(node.callee);
        }
        //  lParenToken 
        //  `new foo` vs `new foo()` 
        if (node.lParenToken || node.arguments && node.arguments.length > 0) {
            this.addLParen();
            if (node.arguments && node.arguments.length > 0) {
                node.arguments.forEach((arg, index)=>{
                    if (index > 0) {
                        this.addComma();
                        this.addSpacing();
                    }
                    //  SlimeCallArgument argument 
                    if (arg && arg.argument) {
                        this.generatorNode(arg.argument);
                    } else {
                        this.generatorNode(arg);
                    }
                });
            }
            this.addRParen();
        }
    }
    /**
     * 
     * @param node AST 
     * @param addNewLineAfter  BlockStatement }  false
     */ static generatorNode(node, addNewLineAfter = false) {
        // nodenullundefined
        if (!node) {
            return;
        }
        if (node.type === SlimeNodeType.Program) {
            return this.generatorProgram(node);
        } else if (node.type === SlimeNodeType.PrivateIdentifier) {
            this.generatorPrivateIdentifier(node);
        } else if (node.type === SlimeNodeType.Identifier) {
            this.generatorIdentifier(node);
        } else if (node.type === SlimeNodeType.ThisExpression || node.type === 'ThisExpression') {
            this.addCode(es6TokensObj.ThisTok);
        } else if (node.type === SlimeNodeType.NumericLiteral) {
            this.generatorNumberLiteral(node);
        } else if (node.type === SlimeNodeType.Literal) {
            // ESTree  Literal  number, string, boolean, null, RegExp, BigInt
            this.generatorLiteral(node);
        } else if (node.type === SlimeNodeType.MemberExpression) {
            this.generatorMemberExpression(node);
        } else if (node.type === SlimeNodeType.CallExpression) {
            this.generatorCallExpression(node);
        } else if (node.type === SlimeNodeType.FunctionExpression) {
            this.generatorFunctionExpression(node);
        } else if (node.type === SlimeNodeType.ArrowFunctionExpression) {
            this.generatorArrowFunctionExpression(node);
        } else if (node.type === SlimeNodeType.BinaryExpression) {
            this.generatorBinaryExpression(node);
        } else if (node.type === SlimeNodeType.LogicalExpression || node.type === 'LogicalExpression') {
            // LogicalExpression  BinaryExpression 
            this.generatorBinaryExpression(node);
        } else if (node.type === SlimeNodeType.StringLiteral) {
            this.generatorStringLiteral(node);
        } else if (node.type === SlimeNodeType.ArrayExpression) {
            this.generatorArrayExpression(node);
        } else if (node.type === SlimeNodeType.ObjectExpression) {
            this.generatorObjectExpression(node);
        } else if (node.type === SlimeNodeType.ParenthesizedExpression) {
            this.generatorParenthesizedExpression(node);
        } else if (node.type === 'SequenceExpression') {
            this.generatorSequenceExpression(node);
        } else if (node.type === SlimeNodeType.Property) {
            this.generatorProperty(node);
        } else if (node.type === SlimeNodeType.VariableDeclarator) {
            this.generatorVariableDeclarator(node);
        } else if (node.type === SlimeNodeType.RestElement) {
            this.generatorRestElement(node);
        } else if (node.type === SlimeNodeType.SpreadElement) {
            this.generatorSpreadElement(node);
        } else if (node.type === SlimeNodeType.ObjectPattern) {
            this.generatorObjectPattern(node);
        } else if (node.type === SlimeNodeType.ArrayPattern) {
            this.generatorArrayPattern(node);
        } else if (node.type === SlimeNodeType.AssignmentPattern) {
            this.generatorAssignmentPattern(node);
        } else if (node.type === SlimeNodeType.FunctionDeclaration) {
            this.generatorFunctionDeclaration(node);
        } else if (node.type === SlimeNodeType.ClassDeclaration) {
            this.generatorClassDeclaration(node);
        } else if (node.type === SlimeNodeType.ClassExpression) {
            this.generatorClassExpression(node); //  ClassExpression 
        } else if (node.type === SlimeNodeType.MethodDefinition) {
            this.generatorMethodDefinition(node); //  MethodDefinition 
        } else if (node.type === 'PropertyDefinition') {
            this.generatorPropertyDefinition(node); //  PropertyDefinition 
        } else if (node.type === 'NewExpression') {
            this.generatorNewExpression(node); //  NewExpression 
        } else if (node.type === SlimeNodeType.VariableDeclaration) {
            this.generatorVariableDeclaration(node);
        } else if (node.type === SlimeNodeType.ExpressionStatement) {
            this.generatorExpressionStatement(node);
        } else if (node.type === SlimeNodeType.ReturnStatement) {
            this.generatorReturnStatement(node);
        } else if (node.type === SlimeNodeType.BlockStatement) {
            // 2 addNewLineAfter  BlockStatement
            this.generatorBlockStatement(node, addNewLineAfter);
        } else if (node.type === SlimeNodeType.IfStatement) {
            this.generatorIfStatement(node);
        } else if (node.type === SlimeNodeType.ForStatement) {
            this.generatorForStatement(node);
        } else if (node.type === SlimeNodeType.ForInStatement || node.type === SlimeNodeType.ForOfStatement) {
            this.generatorForInOfStatement(node);
        } else if (node.type === SlimeNodeType.WhileStatement) {
            this.generatorWhileStatement(node);
        } else if (node.type === SlimeNodeType.DoWhileStatement) {
            this.generatorDoWhileStatement(node);
        } else if (node.type === SlimeNodeType.SwitchStatement) {
            this.generatorSwitchStatement(node);
        } else if (node.type === SlimeNodeType.SwitchCase) {
            this.generatorSwitchCase(node);
        } else if (node.type === SlimeNodeType.TryStatement) {
            this.generatorTryStatement(node);
        } else if (node.type === 'CatchClause') {
            this.generatorCatchClause(node);
        } else if (node.type === SlimeNodeType.ThrowStatement) {
            this.generatorThrowStatement(node);
        } else if (node.type === SlimeNodeType.BreakStatement) {
            this.generatorBreakStatement(node);
        } else if (node.type === SlimeNodeType.ContinueStatement) {
            this.generatorContinueStatement(node);
        } else if (node.type === SlimeNodeType.LabeledStatement) {
            this.generatorLabeledStatement(node);
        } else if (node.type === SlimeNodeType.WithStatement) {
            this.generatorWithStatement(node);
        } else if (node.type === SlimeNodeType.DebuggerStatement) {
            this.generatorDebuggerStatement(node);
        } else if (node.type === SlimeNodeType.EmptyStatement) {
            this.generatorEmptyStatement(node);
        } else if (node.type === SlimeNodeType.ImportSpecifier) {
            this.generatorImportSpecifier(node);
        } else if (node.type === SlimeNodeType.ImportDefaultSpecifier) {
            this.generatorImportDefaultSpecifier(node);
        } else if (node.type === SlimeNodeType.ImportNamespaceSpecifier) {
            this.generatorImportNamespaceSpecifier(node);
        } else if (node.type === SlimeNodeType.ExportNamedDeclaration) {
            this.generatorExportNamedDeclaration(node);
        } else if (node.type === SlimeNodeType.ExportDefaultDeclaration) {
            this.generatorExportDefaultDeclaration(node);
        } else if (node.type === 'ExportAllDeclaration') {
            this.generatorExportAllDeclaration(node);
        } else if (node.type === SlimeNodeType.ImportDeclaration) {
            this.generatorImportDeclaration(node);
        } else if (node.type === SlimeNodeType.ImportExpression) {
            this.generatorImportExpression(node);
        } else if (node.type === SlimeNodeType.ChainExpression) {
            this.generatorChainExpression(node);
        } else if (node.type === SlimeNodeType.StaticBlock) {
            this.generatorStaticBlock(node);
        } else if (node.type === 'ConditionalExpression') {
            this.generatorConditionalExpression(node);
        } else if (node.type === 'AssignmentExpression') {
            this.generatorAssignmentExpression(node);
        } else if (node.type === 'BooleanLiteral') {
            this.addString(node.value ? 'true' : 'false');
        } else if (node.type === 'NullLiteral') {
            this.addString('null');
        } else if (node.type === 'UnaryExpression') {
            this.generatorUnaryExpression(node);
        } else if (node.type === SlimeNodeType.UpdateExpression) {
            this.generatorUpdateExpression(node);
        } else if (node.type === SlimeNodeType.YieldExpression) {
            this.generatorYieldExpression(node);
        } else if (node.type === SlimeNodeType.AwaitExpression) {
            this.generatorAwaitExpression(node);
        } else if (node.type === SlimeNodeType.TemplateLiteral) {
            this.generatorTemplateLiteral(node);
        } else if (node.type === "Super") {
            // Super"super"
            this.addString('super');
        } else if (node.type === 'TaggedTemplateExpression') {
            // Tagged Template Literals: tag`template`
            this.generatorNode(node.tag);
            this.generatorTemplateLiteral(node.quasi);
        } else if (node.type === 'MetaProperty') {
            // new.target or import.meta
            this.generatorNode(node.meta);
            this.addCode(es6TokensObj.Dot);
            this.generatorNode(node.property);
        } else if (node.type === SlimeNodeType.OptionalCallExpression) {
            // obj?.method()
            this.generatorOptionalCallExpression(node);
        } else if (node.type === SlimeNodeType.OptionalMemberExpression) {
            // obj?.prop  obj?.[expr]
            this.generatorOptionalMemberExpression(node);
        } else {
            console.error(':', JSON.stringify(node, null, 2));
            throw new Error('' + node.type);
        }
        if (node.loc && node.loc.newLine) {
            this.addNewLine(); // 
        }
    }
    static generatorUnaryExpression(node) {
        // UnaryExpression: operator + argument
        this.addString(node.operator);
        if (node.operator === 'typeof' || node.operator === 'void' || node.operator === 'delete') {
            this.addSpacing(); // 
        }
        this.generatorNode(node.argument);
    }
    static generatorUpdateExpression(node) {
        // UpdateExpression: ++/-- expression
        if (node.prefix) {
            // ++i  --i
            this.addString(node.operator);
            this.generatorNode(node.argument);
        } else {
            // i++  i--
            this.generatorNode(node.argument);
            this.addString(node.operator);
        }
    }
    static generatorConditionalExpression(node) {
        this.generatorNode(node.test);
        this.addString('?');
        this.generatorNode(node.consequent);
        this.addString(':');
        this.generatorNode(node.alternate);
    }
    static generatorAssignmentExpression(node) {
        this.generatorNode(node.left);
        this.addSpacing();
        this.addString(node.operator || '=');
        this.addSpacing();
        this.generatorNode(node.right);
    }
    static generatorObjectPattern(node) {
        // {name, age}  {name: userName}  {name = "default"}  {a, ...rest}
        // properties  SlimeObjectPatternProperty[]  { property, commaToken }
        this.addLBrace();
        node.properties.forEach((item, index)=>{
            // 
            const prop = item.property !== undefined ? item.property : item;
            const commaToken = item.commaToken;
            // ES2018: RestElement
            if (prop.type === SlimeNodeType.RestElement) {
                this.generatorRestElement(prop);
            } else if (prop.shorthand) {
                // {name}  {name = "default"}
                // valueAssignmentPattern name = "default"
                //  name
                if (prop.value && prop.value.type === SlimeNodeType.AssignmentPattern) {
                    this.generatorNode(prop.value);
                } else {
                    this.generatorNode(prop.key);
                }
            } else {
                // {name: userName}  {[expr]: userName}
                // 
                if (prop.computed) {
                    this.addLBracket();
                    this.generatorNode(prop.key);
                    this.addRBracket();
                } else {
                    this.generatorNode(prop.key);
                }
                this.addCode(es6TokensObj.Colon);
                this.addSpacing();
                this.generatorNode(prop.value);
            }
            //  commaToken 
            if (commaToken) {
                this.addComma();
            } else if (index < node.properties.length - 1) {
                this.addComma();
            }
        });
        this.addRBrace();
    }
    static generatorArrayPattern(node) {
        // [a, b, c]  [a, , c] [a,,]
        // elements  SlimeArrayPatternElement[]  { element, commaToken }
        this.addLBracket();
        node.elements.forEach((item, index)=>{
            // 
            const wrapped = item;
            const element = wrapped.element !== undefined ? wrapped.element : item;
            const commaToken = wrapped.commaToken;
            if (element) {
                this.generatorNode(element);
            }
            // nullElision [a, , c]
            // 
            //  commaToken 
            if (commaToken) {
                this.addComma();
            } else if (index < node.elements.length - 1) {
                this.addComma();
            }
        });
        this.addRBracket();
    }
    static generatorRestElement(node) {
        this.addCode(es6TokensObj.Ellipsis);
        this.generatorNode(node.argument);
    }
    static generatorSpreadElement(node) {
        this.addCode(es6TokensObj.Ellipsis);
        this.generatorNode(node.argument);
    }
    static generatorAssignmentPattern(node) {
        // name = 'Guest'
        this.generatorNode(node.left);
        this.addSpacing();
        this.addCode(es6TokensObj.Eq);
        this.addSpacing();
        this.generatorNode(node.right);
    }
    /**
     * {...}
     * @param node BlockStatement 
     * @param addNewLineAfter  }  false
     */ static generatorBlockStatement(node, addNewLineAfter = false) {
        this.addLBrace();
        this.addNewLine(); // 2{ 
        this.indent++; // 2
        this.addIndent(); // 2
        this.generatorNodes(node.body);
        this.indent--; // 2
        this.addIndent(); // 2 } 
        this.addRBrace();
        // 2 } 
        if (addNewLineAfter) {
            this.addNewLine();
        }
    }
    static generatorReturnStatement(node) {
        this.addCode(es6TokensObj.ReturnTok);
        if (node.argument) {
            this.addSpacing();
            this.generatorNode(node.argument);
        }
        // 
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    static addSpacing() {
        this.addString(' ');
    }
    static addDot(loc) {
        this.addCodeAndMappings(es6TokensObj.Dot, loc);
    }
    static addComma(loc) {
        this.addCodeAndMappings(es6TokensObj.Comma, loc);
    }
    static addLParen(loc) {
        this.addCodeAndMappings(es6TokensObj.LParen, loc);
    }
    static addRParen(loc) {
        this.addCodeAndMappings(es6TokensObj.RParen, loc);
    }
    static addLBrace(loc) {
        this.addCodeAndMappings(es6TokensObj.LBrace, loc);
    }
    static addRBrace(loc) {
        this.addCodeAndMappings(es6TokensObj.RBrace, loc);
    }
    static addLBracket(loc) {
        this.addCodeAndMappings(es6TokensObj.LBracket, loc);
    }
    static addRBracket(loc) {
        this.addCodeAndMappings(es6TokensObj.RBracket, loc);
    }
    static generatorMemberExpression(node) {
        // object.property  object[property]  object?.property
        this.generatorNode(node.object);
        if (node.computed) {
            // object[property]  object?.[property]
            if (node.optional) {
                this.addCode(es6TokensObj.OptionalChaining); // ?.
            }
            this.addLBracket();
            this.generatorNode(node.property);
            this.addRBracket();
        } else {
            // object.property  object?.property
            if (node.optional) {
                //  ?. token
                if (node.optionalChainingToken) {
                    this.addCodeAndMappings(es6TokensObj.OptionalChaining, node.optionalChainingToken.loc);
                } else {
                    this.addCode(es6TokensObj.OptionalChaining);
                }
            } else if (node.dotToken) {
                this.addDot(node.dotToken.loc);
            } else {
                // dotsuper.method()
                this.addCode(es6TokensObj.Dot);
            }
            if (node.property) {
                this.generatorNode(node.property);
            }
        }
    }
    /**
     * obj?.method()  obj?.()
     */ static generatorOptionalCallExpression(node) {
        //  callee
        this.generatorNode(node.callee);
        // optional: true ?.
        if (node.optional) {
            this.addCode(es6TokensObj.OptionalChaining); // ?.
        }
        // 
        this.addLParen();
        if (node.arguments && node.arguments.length > 0) {
            node.arguments.forEach((arg, index)=>{
                if (index > 0) {
                    this.addComma();
                }
                // { argument: {...}, commaToken?: {...} }
                const argument = arg.argument || arg;
                if (argument.type === SlimeNodeType.SpreadElement) {
                    this.generatorSpreadElement(argument);
                } else {
                    this.generatorNode(argument);
                }
            });
        }
        this.addRParen();
    }
    /**
     * obj?.prop  obj?.[expr]
     */ static generatorOptionalMemberExpression(node) {
        //  object
        this.generatorNode(node.object);
        if (node.computed) {
            // obj?.[expr] - 
            if (node.optional) {
                this.addCode(es6TokensObj.OptionalChaining); // ?.
            }
            this.addLBracket();
            this.generatorNode(node.property);
            this.addRBracket();
        } else {
            // obj?.prop - 
            if (node.optional) {
                this.addCode(es6TokensObj.OptionalChaining); // ?.
            } else {
                this.addCode(es6TokensObj.Dot);
            }
            this.generatorNode(node.property);
        }
    }
    /**
     * 
     * @param node VariableDeclaration 
     * @param addSemicolonAndNewLine  true
     */ static generatorVariableDeclarationCore(node, addSemicolonAndNewLine) {
        //  kind 
        // 1. : { value: 'const', loc: ... }
        // 2. : 'const'
        const kindValue = typeof node.kind === 'string' ? node.kind : node.kind?.value?.valueOf();
        const kindLoc = typeof node.kind === 'string' ? undefined : node.kind?.loc;
        this.addCodeAndMappings(es6TokenMapObj[kindValue], kindLoc);
        this.addSpacing();
        for(let i = 0; i < node.declarations.length; i++){
            this.generatorNode(node.declarations[i]);
            // 
            if (i < node.declarations.length - 1) {
                this.addCode(es6TokensObj.Comma);
                this.addSpacing();
            }
        }
        // 
        if (addSemicolonAndNewLine) {
            this.addCode(es6TokensObj.Semicolon);
            this.addNewLine(); // 1
        }
    // addIndent()  generatorNodes 
    }
    static generatorVariableDeclaration(node) {
        // console.log(989898)
        // console.log(node.kind.loc)
        this.generatorVariableDeclarationCore(node, true);
    }
    static get lastMapping() {
        if (this.mappings.length) {
            return this.mappings[this.mappings.length - 1];
        }
        return null;
    }
    static generatorVariableDeclarator(node) {
        this.generatorNode(node.id);
        // 
        if (node.init) {
            this.addSpacing();
            //  node.equal token
            if (node.equal) {
                this.addCodeAndMappings(es6TokensObj.Eq, node.equal.loc);
            } else {
                this.addCode(es6TokensObj.Eq);
            }
            this.addSpacing();
            this.generatorNode(node.init);
        }
    }
    static generatorNumberLiteral(node) {
        //  SubhutiCreateToken  type 
        //  addCodeAndMappings()  source map 
        // 
        //  raw  0xFF
        const numValue = node.raw || String(node.value);
        this.addCodeAndMappings({
            type: Es6TokenName.NumericLiteral,
            name: Es6TokenName.NumericLiteral,
            value: numValue
        }, node.loc);
    }
    static generatorStringLiteral(node) {
        //  SubhutiCreateToken  type 
        //  addCodeAndMappings()  source map 
        // 
        //  raw 
        //  raw value
        const strValue = node.raw || `'${node.value}'`;
        this.addCodeAndMappings({
            type: Es6TokenName.StringLiteral,
            name: Es6TokenName.StringLiteral,
            value: strValue
        }, node.loc);
    }
    /**
     *  ESTree  Literal 
     * Literal number, string, boolean, null, RegExp, BigInt
     */ static generatorLiteral(node) {
        const value = node.value;
        const raw = node.raw;
        if (value === null) {
            // null 
            this.addCodeAndMappings({
                type: 'NullLiteral',
                name: 'NullLiteral',
                value: 'null'
            }, node.loc);
        } else if (typeof value === 'boolean') {
            // boolean 
            const boolValue = value ? 'true' : 'false';
            this.addCodeAndMappings({
                type: 'BooleanLiteral',
                name: 'BooleanLiteral',
                value: boolValue
            }, node.loc);
        } else if (typeof value === 'number') {
            // number  raw 
            const numValue = raw || String(value);
            this.addCodeAndMappings({
                type: Es6TokenName.NumericLiteral,
                name: Es6TokenName.NumericLiteral,
                value: numValue
            }, node.loc);
        } else if (typeof value === 'string') {
            // string  raw 
            const strValue = raw || `'${value}'`;
            this.addCodeAndMappings({
                type: Es6TokenName.StringLiteral,
                name: Es6TokenName.StringLiteral,
                value: strValue
            }, node.loc);
        } else if (typeof value === 'bigint' || raw && raw.endsWith('n')) {
            // BigInt 
            const bigintValue = raw || `${value}n`;
            this.addCodeAndMappings({
                type: 'BigIntLiteral',
                name: 'BigIntLiteral',
                value: bigintValue
            }, node.loc);
        } else if (value instanceof RegExp || node.regex) {
            // RegExp 
            const regexValue = raw || String(value);
            this.addCodeAndMappings({
                type: 'RegularExpressionLiteral',
                name: 'RegularExpressionLiteral',
                value: regexValue
            }, node.loc);
        } else {
            //  raw  String(value)
            const fallbackValue = raw || String(value);
            this.addString(fallbackValue);
        }
    }
    static cstLocationToSlimeLocation(cstLocation) {
        if (cstLocation) {
            //  loc 
            if (!cstLocation.value || cstLocation.value === null || cstLocation.value === 'null' || cstLocation.value === 'undefined') {
                return null; //  loc
            }
            const sourcePosition = {
                type: cstLocation.type,
                index: cstLocation.start.index,
                value: cstLocation.value,
                // length: sourceLength,
                length: cstLocation.end.index - cstLocation.start.index,
                line: cstLocation.start.line,
                column: cstLocation.start.column
            };
            return sourcePosition;
        }
        return null;
    }
    static addCodeAndMappingsBySourcePosition(token, sourcePosition) {
        this.addMappings(token, sourcePosition);
        this.addCode(token);
    }
    static addCodeAndMappingsFindLoc(token, tokenType, findIndex) {
        const cstLocation = this.findNextTokenLocByTypeAndIndex(tokenType, findIndex);
        if (cstLocation) {
            this.addCodeAndMappings(token, cstLocation);
        } else {
            //  token
            this.addCodeAndMappings(token);
        }
    }
    /**
     *  source map 
     *
     * 
     * - token  SubhutiCreateToken 
     *   - type: token -  token 
     *   - name: token 
     *   - value: token - 
     *
     * 
     * - 
     * - 
     *
     *  source map addString() 
     */ static addCodeAndMappings(token, cstLocation = null) {
        // 
        if (!token) {
            console.warn('SlimeGenerator.addCodeAndMappings: token is undefined');
            return;
        }
        if (cstLocation) {
            const sourcePosition = this.cstLocationToSlimeLocation(cstLocation);
            if (sourcePosition) {
                // sourcePosition
                this.addCodeAndMappingsBySourcePosition(token, sourcePosition);
            } else {
                // cstLocationvalue=null
                this.addCode(token);
            }
        } else {
            this.addCode(token);
        }
    }
    /**
     *  token source map 
     *
     * 
     * 1.  tokenif, function, class;, {, }
     * 2.  source map 
     * 3.  addCodeAndMappings() 
     *
     * 
     * -  SubhutiCreateToken  type, name, value 
     *
     *  addString() 
     * - addCode() token  source map
     * - addString() source map
     */ static addCode(code) {
        this.generateCode += code.value;
        this.generateColumn += code.value.length;
        this.generateIndex += code.value.length;
    }
    /**
     *  source map 
     *
     * 
     * 1. +, -, *, /
     * 2. 
     * 3. 
     *
     *  addCode() 
     * - addCode() SubhutiCreateToken  source map
     * - addString() source map
     *
     *  2-3
     */ static addString(str) {
        this.generateCode += str;
        this.generateColumn += str.length;
        this.generateIndex += str.length;
    }
    static addSemicolonAndNewLine() {
    // this.addSemicolon()
    // this.addNewLine()
    }
    static addSemicolon() {
        this.addString(';');
    }
    static addNewLine() {
        this.generateCode += '\n';
        this.generateLine++;
        this.generateColumn = 0;
        this.generateIndex++;
    }
    /**
     * 22 * indent
     */ static addIndent() {
        const indentStr = '  '.repeat(this.indent);
        this.addString(indentStr);
    }
    /**
     * @deprecated  addSpacing() 
     *
     *  addSpacing()
     * 
     */ static addCodeSpacing() {
        this.addString(' ');
    }
    static addMappings(generateToken, sourcePosition) {
        //  Prettier 
        //  return 
        // if (this.mappings.length) {
        //   const lastMapping = this.mappings[this.mappings.length - 1]
        //   if (sourcePosition.line > lastMapping.source.line) {
        //     this.addNewLine()
        //   }
        // }
        let generate = {
            type: generateToken.name,
            index: this.generateIndex,
            value: generateToken.value,
            length: generateToken.value.length,
            line: this.generateLine,
            column: this.generateColumn
        };
        this.mappings.push({
            source: sourcePosition,
            generate: generate
        });
    }
    /**
     *  if 
     * if (test) consequent [else alternate]
     */ static generatorIfStatement(node) {
        this.addCode(es6TokensObj.IfTok);
        this.addSpacing(); // if (
        this.addCode(es6TokensObj.LParen);
        this.generatorNode(node.test);
        this.addCode(es6TokensObj.RParen);
        //  consequent  BlockStatement
        if (node.consequent.type !== SlimeNodeType.BlockStatement) {
            this.addSpacing();
        }
        // 2if  true
        this.generatorNode(node.consequent, true);
        if (node.alternate) {
            this.addCode(es6TokensObj.ElseTok);
            //  alternate  BlockStatement else 
            if (node.alternate.type !== SlimeNodeType.BlockStatement) {
                this.addSpacing();
            }
            // 2else  true
            this.generatorNode(node.alternate, true);
        }
    }
    /**
     *  for 
     */ static generatorForStatement(node) {
        this.addCode(es6TokensObj.ForTok);
        this.addSpacing(); // for (
        this.addCode(es6TokensObj.LParen);
        // init  VariableDeclaration
        if (node.init) {
            if (node.init.type === SlimeNodeType.VariableDeclaration) {
                this.generatorVariableDeclarationCore(node.init, false);
            } else {
                this.generatorNode(node.init);
            }
        }
        this.addCode(es6TokensObj.Semicolon);
        if (node.test) this.generatorNode(node.test);
        this.addCode(es6TokensObj.Semicolon);
        if (node.update) this.generatorNode(node.update);
        this.addCode(es6TokensObj.RParen);
        // 2for  true
        if (node.body) {
            this.generatorNode(node.body, true);
        }
    }
    /**
     *  for...in / for...of 
     */ static generatorForInOfStatement(node) {
        this.addCode(es6TokensObj.ForTok);
        //  for await...of await
        if (node.await) {
            this.addSpacing();
            this.addCode(es6TokensObj.AwaitTok);
        }
        this.addSpacing();
        this.addCode(es6TokensObj.LParen);
        //  left ()
        //  left  null
        if (!node.left) ; else if (node.left.type === SlimeNodeType.VariableDeclaration) {
            this.addCode(es6TokenMapObj[node.left.kind.value.valueOf()]);
            this.addSpacing();
            //  id
            if (node.left.declarations && node.left.declarations.length > 0) {
                const decl = node.left.declarations[0];
                this.generatorNode(decl.id);
                // ES5 : for (var x = init in expr) - 
                if (decl.init) {
                    this.addSpacing();
                    this.addCode(es6TokensObj.Assign);
                    this.addSpacing();
                    this.generatorNode(decl.init);
                }
            }
        } else {
            this.generatorNode(node.left);
        }
        //  in  of
        this.addSpacing();
        if (node.type === SlimeNodeType.ForInStatement) {
            this.addCode(es6TokensObj.InTok);
        } else {
            this.addCode(es6TokensObj.OfTok);
        }
        this.addSpacing();
        //  right ()
        this.generatorNode(node.right);
        this.addCode(es6TokensObj.RParen);
        // 2for...in/of  true
        this.generatorNode(node.body, true);
    }
    /**
     *  while 
     */ static generatorWhileStatement(node) {
        this.addCode(es6TokensObj.WhileTok);
        this.addSpacing(); // while (
        this.addCode(es6TokensObj.LParen);
        if (node.test) this.generatorNode(node.test);
        this.addCode(es6TokensObj.RParen);
        // 2while  true
        if (node.body) {
            this.generatorNode(node.body, true);
        }
    }
    /**
     *  do...while 
     */ static generatorDoWhileStatement(node) {
        this.addCode(es6TokensObj.DoTok);
        // do 
        if (node.body?.type === SlimeNodeType.BlockStatement) {
            // BlockStatement 
            this.generatorNode(node.body);
        } else {
            //  do x++; while (...)
            this.addSpacing();
            //  ExpressionStatement 
            this.generatorNode(node.body);
        }
        this.addCode(es6TokensObj.WhileTok);
        this.addSpacing(); // while (
        this.addCode(es6TokensObj.LParen);
        this.generatorNode(node.test);
        this.addCode(es6TokensObj.RParen);
        // do...while 
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    /**
     *  switch 
     */ static generatorSwitchStatement(node) {
        this.addCode(es6TokensObj.SwitchTok);
        this.addSpacing(); // switch (
        this.addCode(es6TokensObj.LParen);
        this.generatorNode(node.discriminant);
        this.addCode(es6TokensObj.RParen);
        this.addCode(es6TokensObj.LBrace);
        if (node.cases) {
            this.generatorNodes(node.cases);
        }
        this.addCode(es6TokensObj.RBrace);
    }
    /**
     *  switch case 
     */ static generatorSwitchCase(node) {
        if (node.test) {
            // case 
            this.addCode(es6TokensObj.CaseTok);
            this.addSpacing();
            this.generatorNode(node.test);
            this.addCode(es6TokensObj.Colon);
        } else {
            // default 
            this.addCode(es6TokensObj.DefaultTok);
            this.addCode(es6TokensObj.Colon);
        }
        //  consequent 
        if (node.consequent && node.consequent.length > 0) {
            this.generatorNodes(node.consequent);
        }
    }
    /**
     *  try 
     */ static generatorTryStatement(node) {
        this.addCode(es6TokensObj.TryTok);
        this.addSpacing();
        // try block  catch  finally false
        this.generatorNode(node.block, false);
        if (node.handler) {
            this.addCode(es6TokensObj.CatchTok);
            // ES2019  catchcatch { ... }
            if (node.handler.param) {
                this.addSpacing();
                this.addLParen();
                this.generatorNode(node.handler.param);
                this.addRParen();
            }
            // catch block  finally
            const hasFinalizer = !!node.finalizer;
            this.generatorNode(node.handler.body, !hasFinalizer);
        }
        if (node.finalizer) {
            this.addCode(es6TokensObj.FinallyTok);
            this.addSpacing();
            // finally block  true
            this.generatorNode(node.finalizer, true);
        }
    }
    /**
     *  catch 
     *
     *  catch  TryStatement 
     *  CatchClause 
     */ static generatorCatchClause(node) {
        this.addCode(es6TokensObj.CatchTok);
        // ES2019  catchcatch { ... }
        if (node.param) {
            this.addSpacing();
            this.addLParen();
            this.generatorNode(node.param);
            this.addRParen();
        }
        if (node.body) {
            this.generatorNode(node.body);
        }
    }
    /**
     *  throw 
     */ static generatorThrowStatement(node) {
        this.addCode(es6TokensObj.ThrowTok);
        if (node.argument) {
            this.addSpacing(); // throw  argument 
            this.generatorNode(node.argument);
        }
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    /**
     *  break 
     */ static generatorBreakStatement(node) {
        this.addCode(es6TokensObj.BreakTok);
        if (node.label) {
            this.addSpacing(); // break  label 
            this.generatorNode(node.label);
        }
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    /**
     *  continue 
     */ static generatorContinueStatement(node) {
        this.addCode(es6TokensObj.ContinueTok);
        if (node.label) {
            this.addSpacing(); // continue  label 
            this.generatorNode(node.label);
        }
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    /**
     * 
     */ static generatorLabeledStatement(node) {
        this.generatorNode(node.label);
        this.addCode(es6TokensObj.Colon);
        this.generatorNode(node.body);
    }
    /**
     *  with 
     */ static generatorWithStatement(node) {
        this.addCode(es6TokensObj.WithTok);
        this.addCode(es6TokensObj.LParen);
        this.generatorNode(node.object);
        this.addCode(es6TokensObj.RParen);
        this.generatorNode(node.body);
    }
    /**
     *  debugger 
     */ static generatorDebuggerStatement(node) {
        this.addCode(es6TokensObj.DebuggerTok);
        this.addCode(es6TokensObj.Semicolon);
        this.addNewLine();
    }
    /**
     * 
     */ static generatorEmptyStatement(node) {
        this.addCode(es6TokensObj.Semicolon);
    }
    /**
     *  export default 
     * export default expression
     */ static generatorExportDefaultDeclaration(node) {
        this.addCode(es6TokensObj.ExportTok);
        this.addSpacing(); // 
        this.addCode(es6TokensObj.DefaultTok);
        this.addSpacing(); // 
        this.generatorNode(node.declaration);
        //  declaration  FunctionDeclaration  ClassDeclaration
        // FunctionDeclaration  ClassDeclaration 
        const declarationType = node.declaration?.type;
        if (declarationType !== SlimeNodeType.FunctionDeclaration && declarationType !== SlimeNodeType.ClassDeclaration) {
            this.addCode(es6TokensObj.Semicolon);
            this.addNewLine();
        }
    }
    /**
     *  ChainExpression
     * : obj?.prop  obj?.method()
     */ static generatorChainExpression(node) {
        // ChainExpression 
        this.generatorNode(node.expression);
    }
    /**
     *  ImportExpression
     * : import('./module.js')
     */ static generatorImportExpression(node) {
        this.addCode(es6TokensObj.ImportTok);
        this.addLParen();
        this.generatorNode(node.source);
        this.addRParen();
    }
    /**
     *  StaticBlock
     * : static { console.log('init') }
     */ static generatorStaticBlock(node) {
        this.addCode(es6TokensObj.StaticTok);
        this.addSpacing();
        this.addLBrace();
        this.addNewLine();
        this.indent++;
        this.addIndent();
        this.generatorNodes(node.body);
        this.indent--;
        this.addIndent();
        this.addRBrace();
        this.addNewLine();
    }
}
_define_property$f(SlimeGenerator, "mappings", null);
_define_property$f(SlimeGenerator, "lastSourcePosition", null);
_define_property$f(SlimeGenerator, "generatePosition", null);
_define_property$f(SlimeGenerator, "sourceCodeIndex", null);
_define_property$f(SlimeGenerator, "generateCode", '');
_define_property$f(SlimeGenerator, "generateLine", 0);
_define_property$f(SlimeGenerator, "generateColumn", 0);
_define_property$f(SlimeGenerator, "generateIndex", 0);
_define_property$f(SlimeGenerator, "tokens", null);
_define_property$f(SlimeGenerator, "indent", 0); // 2
_define_property$f(SlimeGenerator, "patternTypes", [
    SlimeNodeType.Identifier,
    SlimeNodeType.ObjectPattern,
    SlimeNodeType.ArrayPattern,
    SlimeNodeType.RestElement,
    SlimeNodeType.AssignmentPattern,
    SlimeNodeType.MemberExpression
]);

/**
 * Subhuti Token Consumer - Token 
 *
 * 
 * 1.  token 
 * 2.  consume 
 * 3. 
 *
 * 
 * -  SubhutiParser
 * -  Semicolon/Comma
 *
 * @version 3.0.0
 */ function _define_property$e(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SubhutiTokenConsumer {
    // ============================================
    // Token 
    // ============================================
    /**
     *  token Parser 
     * @param tokenName token  TokenNames
     * @param goal 
     */ consume(tokenName, goal) {
        return this.parser._consumeToken(tokenName, goal);
    }
    constructor(parser){
        /**
     * Parser 
     */ _define_property$e(this, "parser", void 0);
        this.parser = parser;
    }
}

function _define_property$d(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 *  pattern Parser  rescan
 *  ECMAScript RegularExpressionFirstChar  * ( /* )
 */ const REGEXP_LITERAL_PATTERN = /^\/(?:[^\n\r\/\\[*]|\\[^\n\r]|\[(?:[^\n\r\]\\]|\\[^\n\r])*\])(?:[^\n\r\/\\[]|\\[^\n\r]|\[(?:[^\n\r\]\\]|\\[^\n\r])*\])*\/[dgimsuvy]*/;
/**
 * 
 *  Parser  Slash  RegularExpressionLiteral
 *
 * @param text  / 
 * @returns  null
 */ function matchRegExpLiteral(text) {
    const match = text.match(REGEXP_LITERAL_PATTERN);
    return match ? match[0] : null;
}
/**
 *  ECMAScript  InputElement
 */ var LexicalGoal = /*#__PURE__*/ function(LexicalGoal) {
    /** InputElementDiv -  */ LexicalGoal["InputElementDiv"] = "InputElementDiv";
    /** InputElementRegExp -  */ LexicalGoal["InputElementRegExp"] = "InputElementRegExp";
    /** InputElementTemplateTail - }  */ LexicalGoal["InputElementTemplateTail"] = "InputElementTemplateTail";
    return LexicalGoal;
}({});
const SubhutiLexerTokenNames = {
    TemplateHead: 'TemplateHead',
    TemplateMiddle: 'TemplateMiddle',
    TemplateTail: 'TemplateTail'
};
class SubhutiLexer {
    /**
   * 
   * @param code 
   * @returns Token 
   */ tokenize(code) {
        const result = [];
        let index = 0;
        let rowNum = 1;
        let columnNum = 1;
        this._lastRowNum = 1; //  token 
        while(index < code.length){
            //  tokens
            const matched = this._matchToken(code, index, rowNum, columnNum, result);
            if (!matched) {
                const errorChar = code[index];
                throw new Error(`Unexpected character "${errorChar}" at position ${index} (line ${rowNum}, column ${columnNum})`);
            }
            // skip  token 
            if (!matched.skip) {
                result.push(matched.token);
                //  skip token  token  hasLineBreakBefore
                this._lastRowNum = rowNum;
            }
            // 
            const valueLength = matched.token.tokenValue.length;
            index += valueLength;
            // 
            // LineTerminator : LF(\n), CR(\r), LS(\u2028), PS(\u2029)
            // : \r\n 
            const lineBreaks = matched.token.tokenValue.match(/\r\n|[\n\r\u2028\u2029]/g);
            if (lineBreaks && lineBreaks.length > 0) {
                rowNum += lineBreaks.length;
                // 
                const lastBreakIndex = matched.token.tokenValue.lastIndexOf(lineBreaks[lineBreaks.length - 1]);
                const lastBreakLen = lineBreaks[lineBreaks.length - 1].length;
                columnNum = matched.token.tokenValue.length - lastBreakIndex - lastBreakLen + 1;
            } else {
                columnNum += valueLength;
            }
            // 
            this._updateTemplateDepth(matched.token.tokenName);
        }
        return result;
    }
    _matchToken(code, index, rowNum, columnNum, matchedTokens) {
        const remaining = code.slice(index);
        //  token 
        const lastTokenName = matchedTokens.length > 0 ? matchedTokens[matchedTokens.length - 1].tokenName : null;
        for (const token of this._getActiveTokens()){
            const match = remaining.match(token.pattern);
            if (!match) continue;
            // onlyAtStart -  Hashbang
            if (token.contextConstraint?.onlyAtStart && index !== 0) {
                continue; //  token
            }
            // onlyAtLineStart -  HTMLCloseComment -->
            //  >  skip token 
            if (token.contextConstraint?.onlyAtLineStart && rowNum <= this._lastRowNum) {
                continue; //  token
            }
            // onlyAfter -  token 
            if (token.contextConstraint?.onlyAfter) {
                if (!lastTokenName || !token.contextConstraint.onlyAfter.has(lastTokenName)) {
                    continue; //  token
                }
            }
            // notAfter -  token 
            if (token.contextConstraint?.notAfter) {
                if (lastTokenName && token.contextConstraint.notAfter.has(lastTokenName)) {
                    continue; //  token
                }
            }
            //  lookahead 
            if (token.lookaheadAfter?.not) {
                const afterText = remaining.slice(match[0].length);
                const { not } = token.lookaheadAfter;
                const shouldSkip = not instanceof RegExp ? not.test(afterText) : afterText.startsWith(not);
                if (shouldSkip) continue;
            }
            return {
                token: this._createMatchToken(token, match[0], index, rowNum, columnNum),
                skip: token.skip
            };
        }
        return null;
    }
    _createMatchToken(token, value, index, rowNum, columnNum) {
        return {
            tokenName: token.name,
            tokenValue: value,
            index: index,
            rowNum: rowNum,
            columnStartNum: columnNum,
            columnEndNum: columnNum + value.length - 1,
            hasLineBreakBefore: rowNum > this._lastRowNum // Babel 
        };
    }
    /**
   *  tokens
   *  ECMAScript  InputElement 
   * 
   * 
   */ _getActiveTokens() {
        //  tokens 
        //  token 
        return this._templateDepth > 0 ? this._allTokens : this._tokensOutsideTemplate;
    }
    /**
   * 
   *
   *  ECMAScript  InputElement 
   * - TemplateHead (`${`)  +1
   * - TemplateTail (}`)  -1
   * - TemplateMiddle: 
   *
   * BabelAcornTypeScript Scanner
   *  token 
   */ _updateTemplateDepth(tokenName) {
        if (tokenName === SubhutiLexerTokenNames.TemplateHead) {
            this._templateDepth++;
        } else if (tokenName === SubhutiLexerTokenNames.TemplateTail) {
            this._templateDepth--;
        }
    }
    /**
   *  token (TemplateMiddle  TemplateTail)
   *  InputElementTemplateTail 
   */ _matchTemplateToken(remaining, index, rowNum, columnNum) {
        for (const token of this._allTokens){
            if (token.name !== SubhutiLexerTokenNames.TemplateMiddle && token.name !== SubhutiLexerTokenNames.TemplateTail) {
                continue;
            }
            const match = remaining.match(token.pattern);
            if (match) {
                return {
                    token: this._createMatchTokenWithLastRow(token.name, match[0], index, rowNum, columnNum, rowNum),
                    skip: false
                };
            }
        }
        return null;
    }
    // ============================================
    //  APIOn-Demand Lexing
    //  ECMAScript  InputElement 
    // ============================================
    /**
   * 
   */ createInitialState() {
        return {
            position: 0,
            rowNum: 1,
            columnNum: 1,
            templateDepth: 0,
            lastTokenRowNum: 1,
            lastTokenName: null
        };
    }
    /**
   *  token
   *
   * @param code 
   * @param state 
   * @param lexicalGoal InputElementDiv  InputElementRegExp
   * @returns token  nullEOF
   */ readNextToken(code, state, lexicalGoal = "InputElementDiv") {
        //  token
        while(state.position < code.length){
            const matched = this._matchTokenWithGoal(code, state.position, state.rowNum, state.columnNum, state.lastTokenName, state.templateDepth, lexicalGoal);
            if (!matched) {
                const errorChar = code[state.position];
                throw new Error(`Unexpected character "${errorChar}" at position ${state.position} (line ${state.rowNum}, column ${state.columnNum})`);
            }
            // 
            const valueLength = matched.token.tokenValue.length;
            state.position += valueLength;
            // 
            const lineBreaks = matched.token.tokenValue.match(/\r\n|[\n\r\u2028\u2029]/g);
            if (lineBreaks && lineBreaks.length > 0) {
                state.rowNum += lineBreaks.length;
                const lastBreakIndex = matched.token.tokenValue.lastIndexOf(lineBreaks[lineBreaks.length - 1]);
                const lastBreakLen = lineBreaks[lineBreaks.length - 1].length;
                state.columnNum = matched.token.tokenValue.length - lastBreakIndex - lastBreakLen + 1;
            } else {
                state.columnNum += valueLength;
            }
            // 
            if (matched.token.tokenName === SubhutiLexerTokenNames.TemplateHead) {
                state.templateDepth++;
            } else if (matched.token.tokenName === SubhutiLexerTokenNames.TemplateTail) {
                state.templateDepth--;
            }
            // skip  token 
            if (matched.skip) {
                continue;
            }
            // 
            state.lastTokenRowNum = matched.token.rowNum;
            state.lastTokenName = matched.token.tokenName;
            return matched.token;
        }
        return null // EOF
        ;
    }
    /**
   * 
   */ isEOF(code, state) {
        // 
        let pos = state.position;
        while(pos < code.length){
            const remaining = code.slice(pos);
            // 
            const whitespaceMatch = remaining.match(/^[\s]+/);
            if (whitespaceMatch) {
                pos += whitespaceMatch[0].length;
                continue;
            }
            const singleLineComment = remaining.match(/^\/\/[^\n\r]*/);
            if (singleLineComment) {
                pos += singleLineComment[0].length;
                continue;
            }
            const multiLineComment = remaining.match(/^\/\*[\s\S]*?\*\//);
            if (multiLineComment) {
                pos += multiLineComment[0].length;
                continue;
            }
            // 
            return false;
        }
        return true;
    }
    /**
   *  token 
   */ _matchTokenWithGoal(code, index, rowNum, columnNum, lastTokenName, templateDepth, lexicalGoal) {
        const remaining = code.slice(index);
        //  tokens
        //  templateDepth > 0 TemplateMiddle/TemplateTail
        //  InputElementTemplateTail 
        const activeTokens = this._tokensOutsideTemplate;
        for (const token of activeTokens){
            // InputElementTemplateTail  TemplateMiddle  TemplateTail
            //  } 
            if (lexicalGoal === "InputElementTemplateTail") {
                //  token
                const templateMatch = this._matchTemplateToken(remaining, index, rowNum, columnNum);
                if (templateMatch) {
                    return templateMatch;
                }
            // 
            }
            //  Slash
            if (token.name === 'Slash' || token.name === 'DivideAssign') {
                if (lexicalGoal === "InputElementRegExp" && remaining.startsWith('/')) {
                    //  InputElementRegExp 
                    const regexpMatch = matchRegExpLiteral(remaining);
                    if (regexpMatch) {
                        return {
                            token: this._createMatchTokenWithLastRow('RegularExpressionLiteral', regexpMatch, index, rowNum, columnNum, rowNum // lastRowNum 
                            ),
                            skip: false
                        };
                    }
                //  token Slash
                }
            }
            const match = remaining.match(token.pattern);
            if (!match) continue;
            // onlyAtStart
            if (token.contextConstraint?.onlyAtStart && index !== 0) {
                continue;
            }
            // onlyAtLineStart -  HTMLCloseComment -->
            if (token.contextConstraint?.onlyAtLineStart && rowNum <= this._lastRowNum) {
                continue;
            }
            // onlyAfter Slash token
            if (token.contextConstraint?.onlyAfter) {
                if (!lastTokenName || !token.contextConstraint.onlyAfter.has(lastTokenName)) {
                    continue;
                }
            }
            // notAfter
            if (token.contextConstraint?.notAfter) {
                if (lastTokenName && token.contextConstraint.notAfter.has(lastTokenName)) {
                    continue;
                }
            }
            //  lookahead 
            if (token.lookaheadAfter?.not) {
                const afterText = remaining.slice(match[0].length);
                const { not } = token.lookaheadAfter;
                const shouldSkip = not instanceof RegExp ? not.test(afterText) : afterText.startsWith(not);
                if (shouldSkip) continue;
            }
            return {
                token: this._createMatchTokenWithLastRow(token.name, match[0], index, rowNum, columnNum, this._lastRowNum),
                skip: token.skip
            };
        }
        return null;
    }
    // ============================================
    // + API
    // ============================================
    /**
   *  token
   *
   * @param code 
   * @param codeIndex 
   * @param line 
   * @param column 
   * @param goal 
   * @param lastTokenName  token 
   * @param templateDepth 
   * @returns TokenCacheEntry  nullEOF
   */ readTokenAt(code, codeIndex, line, column, goal, lastTokenName = null, templateDepth = 0) {
        let pos = codeIndex;
        let rowNum = line;
        let columnNum = column;
        let lastRowNum = line //  hasLineBreakBefore 
        ;
        let currentLastTokenName = lastTokenName;
        //  token
        while(pos < code.length){
            const matched = this._matchTokenWithGoal(code, pos, rowNum, columnNum, currentLastTokenName, templateDepth, goal);
            if (!matched) {
                const errorChar = code[pos];
                throw new Error(`Unexpected character "${errorChar}" at position ${pos} (line ${rowNum}, column ${columnNum})`);
            }
            const valueLength = matched.token.tokenValue.length;
            const nextPos = pos + valueLength;
            // 
            let nextRowNum = rowNum;
            let nextColumnNum = columnNum;
            const lineBreaks = matched.token.tokenValue.match(/\r\n|[\n\r\u2028\u2029]/g);
            if (lineBreaks && lineBreaks.length > 0) {
                nextRowNum += lineBreaks.length;
                const lastBreakIndex = matched.token.tokenValue.lastIndexOf(lineBreaks[lineBreaks.length - 1]);
                const lastBreakLen = lineBreaks[lineBreaks.length - 1].length;
                nextColumnNum = matched.token.tokenValue.length - lastBreakIndex - lastBreakLen + 1;
            } else {
                nextColumnNum += valueLength;
            }
            // skip  token 
            if (matched.skip) {
                //  lastRowNum
                // lastRowNum  skip token 
                //  hasLineBreakBefore 
                pos = nextPos;
                rowNum = nextRowNum;
                columnNum = nextColumnNum;
                continue;
            }
            //  token
            //  token  hasLineBreakBefore
            const token = {
                tokenName: matched.token.tokenName,
                tokenValue: matched.token.tokenValue,
                index: pos,
                rowNum: rowNum,
                columnStartNum: columnNum,
                columnEndNum: columnNum + valueLength - 1,
                hasLineBreakBefore: rowNum > lastRowNum
            };
            return {
                token,
                nextCodeIndex: nextPos,
                nextLine: nextRowNum,
                nextColumn: nextColumnNum,
                lastTokenName: token.tokenName
            };
        }
        return null // EOF
        ;
    }
    /**
   *  token lastRowNum 
   */ _createMatchTokenWithLastRow(tokenName, value, index, rowNum, columnNum, lastRowNum) {
        return {
            tokenName: tokenName,
            tokenValue: value,
            index: index,
            rowNum: rowNum,
            columnStartNum: columnNum,
            columnEndNum: columnNum + value.length - 1,
            hasLineBreakBefore: rowNum > lastRowNum
        };
    }
    constructor(tokens){
        _define_property$d(this, "_allTokens", void 0);
        _define_property$d(this, "_tokensOutsideTemplate", void 0);
        _define_property$d(this, "_templateDepth", 0);
        _define_property$d(this, "_lastRowNum", 1); //  token  hasLineBreakBefore
        //  ^  flags
        //  (?:...)  ^A|B  A 
        // ^abc|\.14  "float = 3.14"  9  .14
        //       ^(?:abc|\.14) 
        this._allTokens = tokens.map((token)=>{
            if (!token.pattern) return token;
            return {
                ...token,
                pattern: new RegExp('^(?:' + token.pattern.source + ')', token.pattern.flags)
            };
        });
        //  token 
        //  ECMAScript 
        this._tokensOutsideTemplate = this._allTokens.filter((t)=>t.name !== SubhutiLexerTokenNames.TemplateMiddle && t.name !== SubhutiLexerTokenNames.TemplateTail);
    }
}

class SlimeTokenConsumer extends SubhutiTokenConsumer {
    // ============================================
    // 
    // ============================================
    /**
     *  IdentifierName 
     *
     *  get, set, of, target, meta, from
     *  ES2025  IdentifierName
     * 
     *
     * @param value 
     * @returns CST  undefined
     */ consumeIdentifierValue(value) {
        const token = this.parser.curToken;
        if (token?.tokenName === SlimeTokenType.IdentifierName && token.tokenValue === value) {
            return this.consume(SlimeTokenType.IdentifierName);
        }
        // 
        this.parser._markParseFail();
        return undefined;
    }
    // ============================================
    //  (Keywords)
    // ============================================
    Await() {
        return this.consume(SlimeReservedWordTokenTypes.Await);
    }
    Break() {
        return this.consume(SlimeReservedWordTokenTypes.Break);
    }
    Case() {
        return this.consume(SlimeReservedWordTokenTypes.Case);
    }
    Catch() {
        return this.consume(SlimeReservedWordTokenTypes.Catch);
    }
    Class() {
        return this.consume(SlimeReservedWordTokenTypes.Class);
    }
    Const() {
        return this.consume(SlimeReservedWordTokenTypes.Const);
    }
    Continue() {
        return this.consume(SlimeReservedWordTokenTypes.Continue);
    }
    Debugger() {
        return this.consume(SlimeReservedWordTokenTypes.Debugger);
    }
    Default() {
        return this.consume(SlimeReservedWordTokenTypes.Default);
    }
    Do() {
        return this.consume(SlimeReservedWordTokenTypes.Do);
    }
    Else() {
        return this.consume(SlimeReservedWordTokenTypes.Else);
    }
    Enum() {
        return this.consume(SlimeReservedWordTokenTypes.Enum);
    }
    Export() {
        return this.consume(SlimeReservedWordTokenTypes.Export);
    }
    Extends() {
        return this.consume(SlimeReservedWordTokenTypes.Extends);
    }
    False() {
        return this.consume(SlimeReservedWordTokenTypes.False);
    }
    Finally() {
        return this.consume(SlimeReservedWordTokenTypes.Finally);
    }
    For() {
        return this.consume(SlimeReservedWordTokenTypes.For);
    }
    Function() {
        return this.consume(SlimeReservedWordTokenTypes.Function);
    }
    If() {
        return this.consume(SlimeReservedWordTokenTypes.If);
    }
    Import() {
        return this.consume(SlimeReservedWordTokenTypes.Import);
    }
    New() {
        return this.consume(SlimeReservedWordTokenTypes.New);
    }
    /**
     * NullLiteral
     *  A.1: NullLiteral :: null
     */ NullLiteral() {
        return this.consume(SlimeReservedWordTokenTypes.NullLiteral);
    }
    Return() {
        return this.consume(SlimeReservedWordTokenTypes.Return);
    }
    Super() {
        return this.consume(SlimeReservedWordTokenTypes.Super);
    }
    Switch() {
        return this.consume(SlimeReservedWordTokenTypes.Switch);
    }
    This() {
        return this.consume(SlimeReservedWordTokenTypes.This);
    }
    Throw() {
        return this.consume(SlimeReservedWordTokenTypes.Throw);
    }
    True() {
        return this.consume(SlimeReservedWordTokenTypes.True);
    }
    Try() {
        return this.consume(SlimeReservedWordTokenTypes.Try);
    }
    Var() {
        return this.consume(SlimeReservedWordTokenTypes.Var);
    }
    While() {
        return this.consume(SlimeReservedWordTokenTypes.While);
    }
    With() {
        return this.consume(SlimeReservedWordTokenTypes.With);
    }
    Yield() {
        return this.consume(SlimeReservedWordTokenTypes.Yield);
    }
    /**
     *  'let' 
     *  let 
     * let 
     */ Let() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Let);
    }
    Void() {
        return this.consume(SlimeUnaryOperatorTokenTypes.Void);
    }
    Typeof() {
        return this.consume(SlimeUnaryOperatorTokenTypes.Typeof);
    }
    In() {
        return this.consume(SlimeBinaryOperatorTokenTypes.In);
    }
    Instanceof() {
        return this.consume(SlimeBinaryOperatorTokenTypes.Instanceof);
    }
    Delete() {
        return this.consume(SlimeUnaryOperatorTokenTypes.Delete);
    }
    // ============================================
    //  (Soft Keywords / Contextual Keywords)
    //  ES2025  IdentifierName
    // 
    // ============================================
    /**
     *  'async' 
     *  async async async 
     * async  `let async = 1`
     */ Async() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Async);
    }
    /**
     *  'static' 
     * 
     * 
     */ Static() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Static);
    }
    /**
     *  'as' 
     *  import/export 
     */ As() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.As);
    }
    /**
     *  'get' 
     *  getter 
     */ Get() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Get);
    }
    /**
     *  'set' 
     *  setter 
     */ Set() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Set);
    }
    /**
     *  'of' 
     *  for-of 
     */ Of() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Of);
    }
    /**
     *  'target' 
     *  new.target
     */ Target() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Target);
    }
    /**
     *  'meta' 
     *  import.meta
     */ Meta() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.Meta);
    }
    /**
     *  'from' 
     *  import/export 
     */ From() {
        return this.consumeIdentifierValue(SlimeContextualKeywordTokenTypes.From);
    }
    // ============================================
    //  (Literals)
    // ============================================
    /**
     * NumericLiteral
     *  NumericLiteral 
     * - DecimalLiteral ( 123, 1.5, .5, 1e10)
     * - DecimalBigIntegerLiteral ( 123n)
     * - NonDecimalIntegerLiteral ( 0xFF, 0b11, 0o77)
     * - NonDecimalIntegerLiteral BigIntLiteralSuffix ( 0xFFn, 0b11n, 0o77n)
     * - LegacyOctalIntegerLiteral ( 077, Annex B)
     */ NumericLiteral() {
        return this.consume(SlimeTokenType.NumericLiteral);
    }
    StringLiteral() {
        return this.consume(SlimeTokenType.StringLiteral);
    }
    NoSubstitutionTemplate() {
        return this.consume(SlimeTokenType.NoSubstitutionTemplate);
    }
    TemplateHead() {
        return this.consume(SlimeTokenType.TemplateHead);
    }
    /**
     *  TemplateMiddle token (}...${)
     *  InputElementTemplateTail  }  RBrace
     */ TemplateMiddle() {
        return this.consume(SlimeTokenType.TemplateMiddle, LexicalGoal.InputElementTemplateTail);
    }
    /**
     *  TemplateTail token (}...`)
     *  InputElementTemplateTail  }  RBrace
     */ TemplateTail() {
        return this.consume(SlimeTokenType.TemplateTail, LexicalGoal.InputElementTemplateTail);
    }
    RegularExpressionLiteral() {
        return this.consume(SlimeTokenType.RegularExpressionLiteral);
    }
    // ============================================
    //  (Comments)
    // ============================================
    /**
     * Hashbang  (#!...)
     *  Parser  Program 
     */ HashbangComment() {
        return this.consume(SlimeTokenType.HashbangComment);
    }
    // ============================================
    //  (Identifiers)
    // ============================================
    /**
     * IdentifierName
     * : IdentifierName :: IdentifierStart | IdentifierName IdentifierPart
     */ IdentifierName() {
        return this.consume(SlimeTokenType.IdentifierName);
    }
    /**
     * PrivateIdentifier
     * : PrivateIdentifier :: # IdentifierName
     */ PrivateIdentifier() {
        return this.consume(SlimeTokenType.PrivateIdentifier);
    }
    // ============================================
    //  - 4 (4-character Operators)
    // ============================================
    UnsignedRightShiftAssign() {
        return this.consume(SlimeTokenType.UnsignedRightShiftAssign);
    }
    // ============================================
    //  - 3 (3-character Operators)
    // ============================================
    Ellipsis() {
        return this.consume(SlimeTokenType.Ellipsis);
    }
    UnsignedRightShift() {
        return this.consume(SlimeTokenType.UnsignedRightShift);
    }
    StrictEqual() {
        return this.consume(SlimeTokenType.StrictEqual);
    }
    StrictNotEqual() {
        return this.consume(SlimeTokenType.StrictNotEqual);
    }
    LeftShiftAssign() {
        return this.consume(SlimeTokenType.LeftShiftAssign);
    }
    RightShiftAssign() {
        return this.consume(SlimeTokenType.RightShiftAssign);
    }
    ExponentiationAssign() {
        return this.consume(SlimeTokenType.ExponentiationAssign);
    }
    LogicalAndAssign() {
        return this.consume(SlimeTokenType.LogicalAndAssign);
    }
    LogicalOrAssign() {
        return this.consume(SlimeTokenType.LogicalOrAssign);
    }
    NullishCoalescingAssign() {
        return this.consume(SlimeTokenType.NullishCoalescingAssign);
    }
    // ============================================
    //  - 2 (2-character Operators)
    // ============================================
    Arrow() {
        return this.consume(SlimeTokenType.Arrow);
    }
    PlusAssign() {
        return this.consume(SlimeTokenType.PlusAssign);
    }
    MinusAssign() {
        return this.consume(SlimeTokenType.MinusAssign);
    }
    MultiplyAssign() {
        return this.consume(SlimeTokenType.MultiplyAssign);
    }
    DivideAssign() {
        return this.consume(SlimeTokenType.DivideAssign);
    }
    ModuloAssign() {
        return this.consume(SlimeTokenType.ModuloAssign);
    }
    LeftShift() {
        return this.consume(SlimeTokenType.LeftShift);
    }
    RightShift() {
        return this.consume(SlimeTokenType.RightShift);
    }
    LessEqual() {
        return this.consume(SlimeTokenType.LessEqual);
    }
    GreaterEqual() {
        return this.consume(SlimeTokenType.GreaterEqual);
    }
    Equal() {
        return this.consume(SlimeTokenType.Equal);
    }
    NotEqual() {
        return this.consume(SlimeTokenType.NotEqual);
    }
    LogicalAnd() {
        return this.consume(SlimeTokenType.LogicalAnd);
    }
    LogicalOr() {
        return this.consume(SlimeTokenType.LogicalOr);
    }
    NullishCoalescing() {
        return this.consume(SlimeTokenType.NullishCoalescing);
    }
    Increment() {
        return this.consume(SlimeTokenType.Increment);
    }
    Decrement() {
        return this.consume(SlimeTokenType.Decrement);
    }
    Exponentiation() {
        return this.consume(SlimeTokenType.Exponentiation);
    }
    BitwiseAndAssign() {
        return this.consume(SlimeTokenType.BitwiseAndAssign);
    }
    BitwiseOrAssign() {
        return this.consume(SlimeTokenType.BitwiseOrAssign);
    }
    BitwiseXorAssign() {
        return this.consume(SlimeTokenType.BitwiseXorAssign);
    }
    OptionalChaining() {
        return this.consume(SlimeTokenType.OptionalChaining);
    }
    // ============================================
    //  - 1 (1-character Operators)
    // ============================================
    LBrace() {
        return this.consume(SlimeTokenType.LBrace);
    }
    RBrace() {
        return this.consume(SlimeTokenType.RBrace);
    }
    LParen() {
        return this.consume(SlimeTokenType.LParen);
    }
    RParen() {
        return this.consume(SlimeTokenType.RParen);
    }
    LBracket() {
        return this.consume(SlimeTokenType.LBracket);
    }
    RBracket() {
        return this.consume(SlimeTokenType.RBracket);
    }
    Dot() {
        return this.consume(SlimeTokenType.Dot);
    }
    Semicolon() {
        return this.consume(SlimeTokenType.Semicolon);
    }
    Comma() {
        return this.consume(SlimeTokenType.Comma);
    }
    Less() {
        return this.consume(SlimeTokenType.Less);
    }
    Greater() {
        return this.consume(SlimeTokenType.Greater);
    }
    Plus() {
        return this.consume(SlimeTokenType.Plus);
    }
    Minus() {
        return this.consume(SlimeTokenType.Minus);
    }
    Asterisk() {
        return this.consume(SlimeTokenType.Asterisk);
    }
    Slash() {
        return this.consume(SlimeTokenType.Slash);
    }
    Modulo() {
        return this.consume(SlimeTokenType.Modulo);
    }
    BitwiseAnd() {
        return this.consume(SlimeTokenType.BitwiseAnd);
    }
    BitwiseOr() {
        return this.consume(SlimeTokenType.BitwiseOr);
    }
    BitwiseXor() {
        return this.consume(SlimeTokenType.BitwiseXor);
    }
    BitwiseNot() {
        return this.consume(SlimeTokenType.BitwiseNot);
    }
    LogicalNot() {
        return this.consume(SlimeTokenType.LogicalNot);
    }
    Question() {
        return this.consume(SlimeTokenType.Question);
    }
    Colon() {
        return this.consume(SlimeTokenType.Colon);
    }
    Assign() {
        return this.consume(SlimeTokenType.Assign);
    }
}

const ovsTokenName = {
    OvsViewToken: "OvsViewToken",
    Hash: "Hash"
};
// OVS  tokens
[
    createKeywordToken(ovsTokenName.OvsViewToken, "ovsView"),
    createRegToken(ovsTokenName.Hash, /#/)
];
//  tokens:
// 1. OvsViewToken  ovsView 
// 2. SlimeTokensObj PrivateIdentifier #name  Hash #
// 3. Hash  fallback PrivateIdentifier  #
const ovs6Tokens = [
    createKeywordToken(ovsTokenName.OvsViewToken, "ovsView"),
    ...Object.values(SlimeTokensObj),
    createRegToken(ovsTokenName.Hash, /#/) //  PrivateIdentifier 
];
class OvsTokenConsumer extends SlimeTokenConsumer {
    OvsViewToken() {
        return this.consume(ovsTokenName.OvsViewToken);
    }
    /**  # tokenNoRenderBlock  */ Hash() {
        return this.consume(ovsTokenName.Hash);
    }
}

/**
 * Subhuti Token Lookahead - Token 
 *
 * 
 * 1. Token 
 * 2. 
 * 3.  ECMAScript 2025  [lookahead ...] 
 *
 * 
 * - 
 * - SubhutiParser
 * - On-Demand Lexing
 *
 * https://tc39.es/ecma262/2025/#sec-grammar-summary
 *
 * @version 4.0.0 - 
 */ function _define_property$c(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SubhutiTokenLookahead {
    get parserFail() {
        return !this._parseSuccess;
    }
    /**
     * 
     *
     * 
     *
     * @returns never ( undefined never )
     */ setParseFail() {
        this._parseSuccess = false;
        return undefined;
    }
    /**
     *  token
     */ get curToken() {
        //  SubhutiParser  getter
        return undefined;
    }
    // ============================================
    //  1 boolean
    // ============================================
    /**
     *  token
     *  SubhutiParser 
     *
     * @param offset 1 =  token2 = ...
     * @returns token  undefinedEOF
     */ peek(offset = 1) {
        //  SubhutiParser 
        return undefined;
    }
    /**
     * LA (LookAhead) -  token
     *
     *  parser 
     * - LA(1) =  token
     * - LA(2) =  token
     * - LA(n) =  n  token
     *
     * @param offset 1 =  token2 = ...
     * @returns token  undefinedEOF
     */ LA(offset = 1) {
        return this.peek(offset);
    }
    /**
     *  N  token
     *
     * @param count  token 
     * @returns token  count EOF
     */ peekSequence(count) {
        const result = [];
        for(let i = 1; i <= count; i++){
            const token = this.peek(i);
            if (!token) break;
            result.push(token);
        }
        return result;
    }
    /**
     * [lookahead = token]
     *  token 
     */ lookahead(tokenName, offset = 1) {
        return this.peek(offset)?.tokenName === tokenName;
    }
    /**
     * [lookahead  token]
     *  token 
     */ lookaheadNot(tokenName, offset = 1) {
        const token = this.peek(offset);
        // EOF  true" token"
        return token ? token.tokenName !== tokenName : true;
    }
    /**
     * [lookahead  {t1, t2, ...}]
     *  token 
     */ lookaheadIn(tokenNames, offset = 1) {
        const token = this.peek(offset);
        return token ? tokenNames.includes(token.tokenName) : false;
    }
    /**
     * [lookahead  {t1, t2, ...}]
     *  token 
     */ lookaheadNotIn(tokenNames, offset = 1) {
        const token = this.peek(offset);
        // EOF  true""
        return token ? !tokenNames.includes(token.tokenName) : true;
    }
    /**
     * [lookahead = t1 t2 ...]
     *  token 
     */ lookaheadSequence(tokenNames) {
        const peeked = this.peekSequence(tokenNames.length);
        if (peeked.length !== tokenNames.length) {
            return false;
        }
        return peeked.every((token, i)=>token.tokenName === tokenNames[i]);
    }
    /**
     * [lookahead  t1 t2 ...]
     *  token 
     */ lookaheadNotSequence(tokenNames) {
        return !this.lookaheadSequence(tokenNames);
    }
    /**
     * token 
     *
     * @param tokenNames token 
     * @returns true = 
     *
     * @example
     * // async [no LineTerminator here] function
     * if (this.lookaheadSequenceNoLT(['AsyncTok', 'FunctionTok'])) { ... }
     */ lookaheadSequenceNoLT(tokenNames) {
        const peeked = this.peekSequence(tokenNames.length);
        if (peeked.length !== tokenNames.length) {
            return false;
        }
        //  token 
        for(let i = 0; i < tokenNames.length; i++){
            if (peeked[i].tokenName !== tokenNames[i]) {
                return false;
            }
            //  token 
            if (i > 0 && peeked[i].hasLineBreakBefore) {
                return false;
            }
        }
        return true;
    }
    /**
     * [no LineTerminator here]
     *  token 
     */ lookaheadHasLineBreak() {
        return this.curToken?.hasLineBreakBefore ?? false;
    }
    // ============================================
    //  2
    // -  _parseSuccess
    // -  boolean
    // ============================================
    /**
     *  token 
     * 
     *
     * @param tokenName -  token 
     * @param offset -  1
     * @returns 
     *
     * @example
     * // [lookahead = =]
     * this.assertLookahead('Assign')
     */ assertLookahead(tokenName, offset = 1) {
        if (!this._parseSuccess) return false;
        const result = this.lookahead(tokenName, offset);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenName -  token 
     * @param offset -  1
     * @returns 
     *
     * @example
     * // [lookahead  else]
     * this.assertLookaheadNot('ElseTok')
     */ assertLookaheadNot(tokenName, offset = 1) {
        if (!this._parseSuccess) return false;
        const result = this.lookaheadNot(tokenName, offset);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenNames -  token 
     * @param offset -  1
     * @returns 
     *
     * @example
     * // [lookahead  {8, 9}]
     * this.assertLookaheadIn(['DecimalDigit8', 'DecimalDigit9'])
     */ assertLookaheadIn(tokenNames, offset = 1) {
        if (!this._parseSuccess) return false;
        const result = this.lookaheadIn(tokenNames, offset);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenNames -  token 
     * @param offset -  1
     * @returns 
     *
     * @example
     * // [lookahead  {{, function, class}]
     * this.assertLookaheadNotIn(['LBrace', 'FunctionTok', 'ClassTok'])
     */ assertLookaheadNotIn(tokenNames, offset = 1) {
        if (!this._parseSuccess) return false;
        const result = this.lookaheadNotIn(tokenNames, offset);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenNames - token 
     * @returns 
     *
     * @example
     * // [lookahead = async function]
     * this.assertLookaheadSequence(['AsyncTok', 'FunctionTok'])
     */ assertLookaheadSequence(tokenNames) {
        if (!this._parseSuccess) return false;
        const result = this.lookaheadSequence(tokenNames);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenNames - token 
     * @returns 
     *
     * @example
     * // [lookahead  let []
     * this.assertLookaheadNotSequence(['LetTok', 'LBracket'])
     */ assertLookaheadNotSequence(tokenNames) {
        if (!this._parseSuccess) return false;
        const result = this.lookaheadNotSequence(tokenNames);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @param tokenNames - token 
     * @returns 
     *
     * @example
     * // [lookahead  async [no LineTerminator here] function]
     * this.assertLookaheadNotSequenceNoLT(['AsyncTok', 'FunctionTok'])
     */ assertLookaheadNotSequenceNoLT(tokenNames) {
        if (!this._parseSuccess) return false;
        const result = !this.lookaheadSequenceNoLT(tokenNames);
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     *  token 
     * 
     *
     * @returns 
     *
     * @example
     * // [no LineTerminator here]
     * this.assertNoLineBreak()
     */ assertNoLineBreak() {
        if (!this._parseSuccess) return false;
        const result = !this.lookaheadHasLineBreak();
        if (!result) {
            this._parseSuccess = false;
        }
        return result;
    }
    /**
     * 
     * 
     *
     * @param condition - 
     * @returns 
     *
     * @example
     * // 
     * const cst = this.tokenConsumer.Identifier()
     * this.assertCondition(!(cst && ReservedWords.has(cst.value!)))
     */ assertCondition(condition) {
        if (!this._parseSuccess) return false;
        if (!condition) {
            this._parseSuccess = false;
        }
        return condition;
    }
    // ============================================
    // Token  (Token Matching)
    //  Babel/Acorn  match/isContextual 
    // ============================================
    /**
     *  token 
     *  Babel  match 
     * @param tokenName token 
     */ match(tokenName) {
        return this.curToken?.tokenName === tokenName;
    }
    constructor(){
        // ============================================
        // 
        // ============================================
        /**
     * 
     * - true: 
     * - false:  undefined
     */ _define_property$c(this, "_parseSuccess", true);
    }
}

function _define_property$b(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SubhutiCst {
    // ========================================
    //  -  CST 
    // ========================================
    /**
     *  N 
     *
     * @param name 
     * @param index  0
     * @returns  undefined
     *
     * 
     * ```typescript
     * const leftOperand = cst.getChild('Expression', 0)
     * const rightOperand = cst.getChild('Expression', 1)
     * ```
     */ getChild(name, index = 0) {
        if (!this.children) return undefined;
        const matches = this.children.filter((c)=>c.name === name);
        return matches[index];
    }
    /**
     * 
     *
     * @param name 
     * @returns 
     *
     * 
     * ```typescript
     * const allStatements = cst.getChildren('Statement')
     * ```
     */ getChildren(name) {
        if (!this.children) return [];
        return this.children.filter((c)=>c.name === name);
    }
    /**
     *  token 
     *
     * @param tokenName Token 
     * @returns  token  undefined
     *
     * 
     * ```typescript
     * const identifier = cst.getToken('Identifier')
     * console.log(identifier?.value)
     * ```
     */ getToken(tokenName) {
        if (!this.children) return undefined;
        return this.children.find((c)=>c.name === tokenName && c.value !== undefined);
    }
    /**
     * 
     *
     * @param name 
     * @returns  true false
     *
     * 
     * ```typescript
     * if (cst.hasChild('ElseClause')) {
     *   //  else 
     * }
     * ```
     */ hasChild(name) {
        if (!this.children) return false;
        return this.children.some((c)=>c.name === name);
    }
    /**
     * 
     */ get childCount() {
        return this.children?.length || 0;
    }
    /**
     * token 
     */ get isToken() {
        return this.value !== undefined;
    }
    /**
     * 
     */ get isEmpty() {
        return !this.children || this.children.length === 0;
    }
    constructor(cst){
        // pathName: string;
        _define_property$b(this, "name", void 0);
        _define_property$b(this, "children", void 0);
        _define_property$b(this, "loc", void 0);
        _define_property$b(this, "value", void 0);
        if (cst) {
            this.name = cst.name;
            // this.pathName = cst.pathName;
            this.children = cst.children;
            this.value = cst.value;
        }
    }
}

/**
 * Subhuti Error - v3.0
 * 
 * 
 * - YAGNI
 * -  API  API
 * -  ErrorDiagnoser  ErrorFormatter
 * 
 * @version 3.0.0 - 
 * @date 2025-11-04
 */ function _define_property$a(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * 
 *
 * 
 * - 
 * - 
 * - 
 *
 * Rust compiler error messages
 */ class ParsingError extends Error {
    /**
     * 
     * 
     *  8 
     * 1. {} () []
     * 2. 
     * 3. 
     * 4. 
     * 5. EOF 
     */ generateSuggestions() {
        const suggestions = [];
        const { expected, found } = this;
        // 1. 
        if (expected === 'RBrace') {
            suggestions.push('  }');
        } else if (expected === 'RParen') {
            suggestions.push('  )');
        } else if (expected === 'RBracket') {
            suggestions.push('  ]');
        } else if (expected === 'Semicolon') {
            suggestions.push('  ;');
        } else if (found?.tokenName === 'Semicolon' && expected !== 'Semicolon') {
            suggestions.push(' ');
        } else if (expected.endsWith('Tok') && found?.tokenName === 'Identifier') {
            const keyword = expected.replace('Tok', '').toLowerCase();
            suggestions.push(`  "${keyword}"`);
        } else if (expected === 'Identifier') {
            if (found?.tokenName === 'Number') {
                suggestions.push(' ');
            } else if (found?.tokenName?.endsWith('Tok')) {
                const keyword = found.tokenName.replace('Tok', '').toLowerCase();
                suggestions.push(` "${keyword}" `);
            }
        }
        // 5. EOF
        if (!found || found.tokenName === 'EOF') {
            suggestions.push(' ');
        }
        // 
        return suggestions.slice(0, 3);
    }
    /**
     * 
     */ toString() {
        // Or 
        if (this.type === 'or-branch-shadowing') {
            return this.toOrBranchShadowingString();
        }
        // 
        if (this.type === 'left-recursion' || this.type === 'infinite-loop') {
            return this.toLoopDetailedString();
        }
        // 
        return this.useDetailed ? this.toDetailedString() : this.toSimpleString();
    }
    /**
     * Rust  + 
     */ toDetailedString() {
        const lines = [];
        // 
        lines.push(' Parsing Error');
        lines.push('');
        //  - 
        lines.push(`Token[${this.position.tokenIndex}]: ${this.found?.tokenName || 'EOF'} @ line ${this.position.line}:${this.position.column} (pos ${this.position.codeIndex})`);
        lines.push('');
        // 
        lines.push(`Expected: ${this.expected}`);
        lines.push(`Found:    ${this.found?.tokenName || 'EOF'}`);
        //  5 
        if (this.ruleStack.length > 0) {
            lines.push('');
            lines.push('Rule stack:');
            const visible = this.ruleStack.slice(-5);
            const hidden = this.ruleStack.length - visible.length;
            if (hidden > 0) {
                lines.push(`  ... (${hidden} more)`);
            }
            visible.forEach((rule, i)=>{
                const isLast = i === visible.length - 1;
                const prefix = isLast ? '>' : '>';
                lines.push(`  ${prefix} ${rule}`);
            });
        }
        // 
        if (this.suggestions.length > 0) {
            lines.push('');
            lines.push('Suggestions:');
            this.suggestions.forEach((suggestion)=>{
                lines.push(`  ${suggestion}`);
            });
        }
        return lines.join('\n');
    }
    /**
     * 
     */ toSimpleString() {
        return `Parsing Error at token[${this.position.tokenIndex}] line ${this.position.line}:${this.position.column}: Expected ${this.expected}, found ${this.found?.tokenName || 'EOF'}`;
    }
    /**
     * 
     */ toShortString() {
        return this.toSimpleString();
    }
    /**
     * 
     */ formatLeftRecursionPath(lines) {
        if (!this.loopRuleName || this.ruleStack.length === 0) {
            return;
        }
        // 
        let firstRecursionIndex = -1;
        let recursiveRuleName = this.loopRuleName;
        const ruleCounts = new Map();
        for(let i = 0; i < this.ruleStack.length; i++){
            const rule = this.ruleStack[i];
            const count = (ruleCounts.get(rule) || 0) + 1;
            ruleCounts.set(rule, count);
            // 
            if (count === 2 && firstRecursionIndex === -1) {
                firstRecursionIndex = this.ruleStack.indexOf(rule);
                recursiveRuleName = rule;
            }
        }
        if (firstRecursionIndex === -1) {
            // 
            lines.push(`  :`);
            this.ruleStack.forEach((rule, i)=>{
                lines.push(`    ${i + 1}. ${rule}`);
            });
            return;
        }
        // 
        const recursionPath = this.ruleStack.slice(firstRecursionIndex);
        // 
        const isDirect = recursionPath.length === 1;
        const pathType = isDirect ? '' : '';
        lines.push(`  : ${pathType}`);
        lines.push(`  : ${recursiveRuleName}`);
        lines.push(`  : ${recursionPath.join('  ')}  ${recursiveRuleName} `);
        lines.push('');
        lines.push('  :');
        recursionPath.forEach((rule, i)=>{
            const isFirst = i === 0;
            const isRecursive = rule === recursiveRuleName;
            const marker = isFirst ? '  ' : isRecursive ? '  ' : '';
            lines.push(`    ${i + 1}. ${rule}${marker}`);
        });
        lines.push(`    ${recursionPath.length + 1}. ${recursiveRuleName}  `);
    }
    /**
     * 
     * 
     * 
     * - 
     * -  token 
     * - 
     * - 
     * - CST 
     * - 
     * - Token 
     * - 
     */ toLoopDetailedString() {
        const lines = [];
        // 
        lines.push(` ${this.type === 'left-recursion' ? '' : ''}`);
        lines.push('');
        //  - 
        lines.push(` "${this.loopRuleName}"  token[${this.position.tokenIndex}] `);
        lines.push(`Token[${this.position.tokenIndex}]: ${this.found?.tokenName || 'EOF'}("${this.found?.tokenValue || ''}") @ line ${this.position.line}:${this.position.column}`);
        lines.push('');
        //  
        if (this.rulePath) {
            lines.push(':');
            lines.push(this.rulePath);
            lines.push('');
        } else if (this.ruleStack.length > 0) {
            // 
            if (this.type === 'left-recursion') {
                lines.push(':');
                this.formatLeftRecursionPath(lines);
                lines.push('');
            } else {
                // 
                lines.push(':');
                const visible = this.ruleStack.slice(-8);
                const hidden = this.ruleStack.length - visible.length;
                if (hidden > 0) {
                    lines.push(`  ... ( ${hidden} )`);
                }
                visible.forEach((rule, i)=>{
                    const isLast = i === visible.length - 1;
                    const prefix = '  ' + '  '.repeat(i) + (isLast ? '>' : '>');
                    lines.push(`${prefix} ${rule}`);
                });
                lines.push(`  ${'  '.repeat(visible.length)}> ${this.loopRuleName}  `);
                lines.push('');
            }
        }
        // 
        lines.push(':');
        lines.push(`   CST : ${this.loopCstDepth}`);
        if (this.loopDetectionSet) {
            lines.push(`   : ${this.loopDetectionSet.length} `);
            if (this.loopDetectionSet.length > 0 && this.loopDetectionSet.length <= 10) {
                lines.push(`    ${this.loopDetectionSet.join(', ')}`);
            } else if (this.loopDetectionSet.length > 10) {
                lines.push(`    ${this.loopDetectionSet.slice(0, 10).join(', ')} ...`);
            }
        }
        // 
        if (this.loopCacheStats) {
            lines.push(`   : ${this.loopCacheStats.hitRate} (${this.loopCacheStats.hits} hits / ${this.loopCacheStats.misses} misses)`);
            lines.push(`   : ${this.loopCacheStats.currentSize}`);
        }
        // Token 
        if (this.loopTokenContext && this.loopTokenContext.length > 0) {
            lines.push('');
            lines.push('Token :');
            this.loopTokenContext.forEach((token)=>{
                const isCurrent = token === this.found;
                const marker = isCurrent ? ' <-- ' : '';
                lines.push(`  ${token.tokenName}("${token.tokenValue}")${marker}`);
            });
        }
        //  hint
        if (this.hint) {
            lines.push(' :');
            lines.push(`  ${this.hint}`);
            lines.push('');
        }
        lines.push('');
        // 
        lines.push(' PEG ');
        lines.push('');
        lines.push('');
        lines.push(':');
        lines.push('   :  Expression  Expression \'+\' Term | Term');
        lines.push('   :  Expression  Term (\'+\' Term)*');
        lines.push('');
        lines.push(':');
        lines.push('   :       A  A \'x\' | \'y\'            : A  \'y\' (\'x\')*');
        lines.push('   :   A  B, B  C, C  A        ');
        lines.push('   :     A  B, B  A               ');
        return lines.join('\n');
    }
    /**
     * Or 
     */ toOrBranchShadowingString() {
        const lines = [];
        lines.push('');
        lines.push('='.repeat(80));
        lines.push('  Or ');
        lines.push('='.repeat(80));
        lines.push(` "${this.loopRuleName}"  token[${this.position.tokenIndex}] `);
        lines.push(`Token[${this.position.tokenIndex}]: ${this.found?.tokenName}("${this.found?.tokenValue}") @ line ${this.position.line}:${this.position.column}`);
        lines.push('');
        // 
        if (this.ruleStack.length > 0) {
            lines.push(':');
            this.ruleStack.forEach((rule, index)=>{
                const marker = index === this.ruleStack.length - 1 ? ' <-- ' : '';
                lines.push(`  [${index}] ${rule}${marker}`);
            });
            lines.push('');
        }
        // Token 
        if (this.loopTokenContext && this.loopTokenContext.length > 0) {
            lines.push('Token :');
            this.loopTokenContext.forEach((token)=>{
                const isCurrent = token === this.found;
                const marker = isCurrent ? ' <-- ' : '';
                lines.push(`  ${token.tokenName}("${token.tokenValue}")${marker}`);
            });
            lines.push('');
        }
        //  hint
        if (this.hint) {
            lines.push(' :');
            lines.push(`  ${this.hint}`);
            lines.push('');
        }
        lines.push('');
        // 
        lines.push('  Or ');
        lines.push('');
        lines.push(':');
        lines.push('   PEG Or Ordered Choice');
        lines.push('  - ');
        lines.push('  - ""');
        lines.push('  - ');
        lines.push('');
        lines.push(':');
        lines.push('   :');
        lines.push('    LeftHandSideExpression  NewExpression | CallExpression');
        lines.push('    // NewExpression  MemberExpression');
        lines.push('    // CallExpression  MemberExpression Arguments');
        lines.push('    // NewExpression  "console.log" CallExpression  "console.log(...)"');
        lines.push('');
        lines.push('   :');
        lines.push('    LeftHandSideExpression  CallExpression | NewExpression');
        lines.push('    // CallExpression');
        lines.push('    // NewExpression');
        lines.push('');
        lines.push(':');
        lines.push('  1.  Or ');
        lines.push('  2. ""');
        lines.push('  3. ""');
        return lines.join('\n');
    }
    constructor(message, details, useDetailed = true){
        super(message), _define_property$a(this, "expected", void 0), _define_property$a(this, "found", void 0), _define_property$a(this, "position", void 0), _define_property$a(this, "ruleStack", void 0), _define_property$a(this, "type", void 0), // Loop 
        _define_property$a(this, "loopRuleName", void 0), _define_property$a(this, "loopDetectionSet", void 0), _define_property$a(this, "loopCstDepth", void 0), _define_property$a(this, "loopCacheStats", void 0), _define_property$a(this, "loopTokenContext", void 0), // 
        _define_property$a(this, "hint", void 0), // 
        _define_property$a(this, "rulePath", void 0), /**
     *   parsing 
     */ _define_property$a(this, "suggestions", void 0), /**
     *  parsing 
     */ _define_property$a(this, "useDetailed", void 0);
        this.name = 'ParsingError';
        this.type = details.type || 'parsing';
        this.expected = details.expected;
        this.found = details.found;
        this.position = details.position;
        this.ruleStack = Object.freeze([
            ...details.ruleStack
        ]);
        // Loop 
        this.loopRuleName = details.loopRuleName;
        this.loopDetectionSet = details.loopDetectionSet ? Object.freeze([
            ...details.loopDetectionSet
        ]) : undefined;
        this.loopCstDepth = details.loopCstDepth;
        this.loopCacheStats = details.loopCacheStats;
        this.loopTokenContext = details.loopTokenContext ? Object.freeze([
            ...details.loopTokenContext
        ]) : undefined;
        // 
        this.hint = details.hint;
        // 
        this.rulePath = details.rulePath;
        this.useDetailed = useDetailed;
        //  suggestions
        if (details.suggestions && details.suggestions.length > 0) {
            this.suggestions = Object.freeze([
                ...details.suggestions
            ]);
        } else if (this.type === 'parsing' && useDetailed) {
            this.suggestions = Object.freeze(this.generateSuggestions());
        } else {
            this.suggestions = Object.freeze([]);
        }
    }
}
/**
 * Subhuti 
 * 
 * 
 */ class SubhutiErrorHandler {
    /**
     * 
     * 
     * @param enable - true: Rust+false: 
     */ setDetailed(enable) {
        this.enableDetailedErrors = enable;
    }
    /**
     * 
     * 
     * @param details - 
     * @returns ParsingError 
     */ createError(details) {
        return new ParsingError(`Expected ${details.expected}`, details, this.enableDetailedErrors);
    }
    constructor(){
        _define_property$a(this, "enableDetailedErrors", true);
    }
}

/**
 * SubhutiDebugRuleTracePrint - 
 *
 * 
 * - 
 * - 
 * - 
 * -  Or 
 *
 * 
 * - 
 * -  RuleStackItem[] 
 * - 
 * - 
 *
 * 
 * - showRulePath:  true
 */ // 
let _showRulePath = true;
/**
 * 
 * @param show - true false 
 */ function setShowRulePath(show) {
    _showRulePath = show;
}
/**
 * 
 *
 * 
 *
 * 
 * 1. formatLine - 
 * 2. formatTokenValue - Token 
 * 3. formatLocation - 
 * 4. formatRuleChain - 
 */ class TreeFormatHelper {
    /**
     * 
     *
     * @param parts - null/undefined/'' 
     * @param options - 
     */ static formatLine(content, options) {
        const indent = options.prefix ?? '  '.repeat(options.depth ?? 0);
        return indent + content;
    }
    static contentJoin(parts) {
        const content = parts.filter((p)=>p !== null && p !== undefined && p !== '');
        return content;
    }
    /**
     *  Token 
     *
     * @param value - 
     * @param maxLength - 
     */ static formatTokenValue(value, maxLength = 40) {
        // 
        let escaped = value.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
        // 
        if (escaped.length > maxLength) {
            escaped = escaped.slice(0, maxLength) + '...';
        }
        return escaped;
    }
    /**
     * 
     *
     * @param loc -  {start: {line, column}, end: {line, column}}
     */ static formatLocation(loc) {
        if (!loc?.start || !loc?.end) {
            return '';
        }
        const startLine = loc.start.line;
        const startCol = loc.start.column;
        const endLine = loc.end.line;
        const endCol = loc.end.column;
        if (startLine === endLine) {
            return `[${startLine}:${startCol}-${endCol}]`;
        } else {
            return `[${startLine}:${startCol}-${endLine}:${endCol}]`;
        }
    }
    /**
     * 
     *
     * @param rules - 
     * @param separator -  " > "
     */ static formatRuleChain(rules, separator = ' > ') {
        return rules.join(separator);
    }
}
// ============================================
// SubhutiDebugRuleTracePrint - 
// ============================================
class SubhutiDebugRuleTracePrint {
    /**
     *  Or 
     * 
     *
     * @param item - 
     * @returns  "" / " [Or]" / " [Or #1/3]"
     */ static formatOrSuffix(item) {
        //  orBranchInfo 
        if (item.orBranchInfo) {
            const info = item.orBranchInfo;
            if (info.isOrEntry) {
                // Or  [Or]
                return ' [Or]';
            } else if (info.isOrBranch) {
                return ` [Or #${info.branchIndex + 1}/${info.totalBranches}]`;
            } else {
                return ``;
            }
        }
        // 
        return '';
    }
    /**
     *  Or 
     */ static isOrEntry(item) {
        //  orBranchInfo 
        return item.orBranchInfo?.isOrEntry;
    }
    static getPrintToken(tokenItem, location) {
        //  token 
        const value = TreeFormatHelper.formatTokenValue(tokenItem.tokenValue || '', 20);
        if (tokenItem.tokenSuccess) {
            return [
                '',
                'Consume',
                `token[${tokenItem.tokenIndex}]`,
                value,
                '-',
                `<${tokenItem.tokenName}>`,
                location || '[]'
            ].join(' ');
        } else {
            return [
                '',
                `token[${tokenItem.tokenIndex}]`,
                'Expect:',
                tokenItem.tokenExpectName,
                '-',
                'Get:',
                value,
                '-',
                `<${tokenItem.tokenName}>`
            ].join(' ');
        }
    }
    /**
     * 
     */ static formatLine(str, depth, symbol = '') {
        return TreeFormatHelper.formatLine(str, //  
        {
            prefix: '  '.repeat(depth) + symbol
        });
    }
    static consoleLog(...strs) {
        if (!_showRulePath) return; // 
        console.log(...strs); // 
    // LogUtil.log(strs[0])  // 
    }
    /**
     * 
     * 
     *
     * 
     * 1.  shouldBreakLine
     * 2. 
     * 3. 
     * 4.  shouldBreakLine = true
     */ static formatPendingOutputs_NonCache_Impl(ruleStack) {
        if (!ruleStack.length) {
            throw new Error('ruleStack ');
        }
        const allLines = [];
        let unOutputIndex = ruleStack.findIndex((item)=>!item.outputted);
        if (unOutputIndex < 0) {
            //token
            unOutputIndex = ruleStack.length;
        }
        let pendingRules = ruleStack.slice(unOutputIndex);
        // 
        const lastOutputted = ruleStack[unOutputIndex - 1];
        // 
        // baseDepth = 0
        let baseDepth = 0;
        if (lastOutputted) {
            //  baseDepth =  + 1
            baseDepth = lastOutputted.displayDepth;
        }
        // OrEntry findLastIndex 
        let lastOrIndex = [
            ...pendingRules
        ].reverse().findIndex((item)=>!!item.orBranchInfo?.isOrEntry);
        const minChainRulesLength = 2;
        //  Or  + 1 Or minChainRulesLength 
        // lastOrIndex = -1  Or 
        //  Or lastOrIndex >= 0 lastOrIndex + 1 
        const breakPoint = Math.max(lastOrIndex + 1, minChainRulesLength);
        //
        if (breakPoint < pendingRules.length - 1) {
            const singleRules = pendingRules.splice(-breakPoint);
            const groups = [];
            let currentGroup = [
                pendingRules[0]
            ];
            groups.push(currentGroup);
            for(let i = 1; i < pendingRules.length; i++){
                const item = pendingRules[i];
                const prevItem = pendingRules[i - 1];
                //  shouldBreakLine 
                if (item.shouldBreakLine === prevItem.shouldBreakLine) {
                    currentGroup.push(item);
                } else {
                    // 
                    currentGroup = [
                        item
                    ];
                    groups.push(currentGroup);
                }
            }
            for (const group of groups){
                if (group[0].shouldBreakLine) {
                    const result = this.formatMultipleSingleRule(group, baseDepth);
                    allLines.push(...result.lines);
                    baseDepth = result.depth;
                } else {
                    baseDepth++;
                    const lines = this.formatChainRule(group, baseDepth);
                    allLines.push(...lines);
                }
            }
            const result = this.formatMultipleSingleRule(singleRules, baseDepth);
            allLines.push(...result.lines);
        } else {
            const result = this.formatMultipleSingleRule(pendingRules, baseDepth);
            allLines.push(...result.lines);
        }
        return allLines;
    }
    /**
     * 
     */ static flushPendingOutputs_NonCache_Impl(ruleStack) {
        const lines = this.formatPendingOutputs_NonCache_Impl(ruleStack);
        lines.forEach((line)=>this.consoleLog(line));
        // 
        const lastRule = ruleStack[ruleStack.length - 1];
        return lastRule?.displayDepth || 0;
    }
    static flushPendingOutputs_Cache_Impl(ruleStack) {
        let pendingRules = ruleStack.filter((item)=>!item.outputted);
        if (pendingRules.length === 0) {
            throw new Error('');
        }
        //  shouldBreakLine
        // this.adjustShouldBreakLine(pendingRules)
        //  shouldBreakLine 
        const groups = [];
        let currentGroup = [
            pendingRules[0]
        ];
        groups.push(currentGroup);
        for(let i = 1; i < pendingRules.length; i++){
            const item = pendingRules[i];
            const prevItem = pendingRules[i - 1];
            //  shouldBreakLine 
            if (item.shouldBreakLine === prevItem.shouldBreakLine) {
                currentGroup.push(item);
            } else {
                // 
                currentGroup = [
                    item
                ];
                groups.push(currentGroup);
            }
        }
        // 
        for (const group of groups){
            if (group[0].shouldBreakLine) {
                // 
                this.printMultipleSingleRule(group);
            } else {
                // 
                this.printChainRule(group);
            }
        }
    }
    /**
     * 
     * @param rules
     * @param depth 
     */ static formatChainRule(rules, depth = rules[0].displayDepth) {
        if (!rules.length) {
            throw new Error("");
        }
        const names = rules.map((r)=>SubhutiDebugRuleTracePrint.getRuleItemLogContent(r));
        const displayNames = names.length > 4 ? [
            ...names.slice(0, 2),
            '...',
            ...names.slice(-2)
        ] : names;
        const line = SubhutiDebugRuleTracePrint.formatLine(displayNames.join(' > '), depth, '');
        rules.forEach((r)=>{
            r.displayDepth = depth;
            r.outputted = true;
        });
        return [
            line
        ];
    }
    /**
     * 
     * @param rules
     * @param depth 
     */ static printChainRule(rules, depth = rules[0].displayDepth) {
        const lines = this.formatChainRule(rules, depth);
        lines.forEach((line)=>this.consoleLog(line));
    }
    /**
     * 
     *  rules  1 
     *
     * @param rules
     * @param depth 
     */ static formatMultipleSingleRule(rules, depth = rules[0].displayDepth) {
        const lines = [];
        rules.forEach((item, index)=>{
            depth++;
            // 
            const isLast = index === rules.length - 1;
            if (!item.isManuallyAdded) {
                item.displayDepth = depth;
            }
            let branch = isLast ? '' : '';
            let printStr = this.getRuleItemLogContent(item);
            const line = SubhutiDebugRuleTracePrint.formatLine(printStr, item.displayDepth, branch);
            lines.push(line);
            item.outputted = true;
        });
        return {
            lines,
            depth
        };
    }
    /**
     * 
     *  rules  1 
     *
     * @param rules
     * @param depth 
     */ static printMultipleSingleRule(rules, depth = rules[0].displayDepth) {
        const result = this.formatMultipleSingleRule(rules, depth);
        result.lines.forEach((line)=>this.consoleLog(line));
        return result.depth;
    }
    static getRuleItemLogContent(tokenItem) {
        let res = '';
        if (tokenItem.orBranchInfo) {
            const branchInfo = tokenItem.orBranchInfo;
            if (tokenItem.orBranchInfo.isOrEntry) {
                // branch = ' '
                // Or  [Or]
                res = ' ' + tokenItem.ruleName + '(Or)';
            } else if (tokenItem.orBranchInfo.isOrBranch) {
                res = `[Branch #${branchInfo.branchIndex + 1}](${tokenItem.ruleName})`;
            //   Or  outputted
            }
        } else {
            if (tokenItem.tokenExpectName) {
                res = SubhutiDebugRuleTracePrint.getPrintToken(tokenItem);
            } else {
                res = tokenItem.ruleName;
            }
        }
        if (tokenItem.isManuallyAdded) {
            // 
            res += ` [Cached]`;
        }
        return res;
    }
}

/**
 * Subhuti Debug - v4.0
 *
 * 
 * - YAGNI
 * - 
 * - + 
 *
 * 
 * - SubhutiDebugUtils - CSTToken
 *
 * 
 * -  /
 * -  Token /
 * -  CACHED
 * -  
 * -  
 * -  Or 
 * -  
 * -  totalCalls, avgTime, cacheHits
 * -  Top N 
 * -  bisectDebug
 * -  CST 
 * -  Token 
 *
 * @version 4.0.0 -  + 
 * @date 2025-11-06
 */ // ============================================
// 
// ============================================
/**
 * 
 */ function _define_property$9(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// ============================================
// SubhutiDebugUtils - v4.0
// ============================================
/**
 * Subhuti 
 *
 * 
 * - 
 * - CST Token 
 *
 * 
 * - 
 * - 
 * - 
 *
 * @version 4.0.0 - 
 * @date 2025-11-06
 */ class SubhutiDebugUtils {
    // ========================================
    // CST Token 
    // ========================================
    /**
     *  CST  token 
     *
     * @param node - CST 
     * @returns token 
     *
     * @example
     * ```typescript
     * const cst = parser.Script()
     * const tokens = SubhutiDebugUtils.collectTokens(cst)
     * console.log(tokens)  // ['const', 'obj', '=', '{', 'sum', ':', '5', '+', '6', '}']
     * ```
     */ static collectTokens(node) {
        const values = [];
        if (!node) return values;
        if (node.value !== undefined && (!node.children || node.children.length === 0)) {
            values.push(node.value);
        }
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children){
                values.push(...SubhutiDebugUtils.collectTokens(child));
            }
        }
        return values;
    }
    /**
     *  CST  token 
     *
     * @param cst - CST 
     * @param inputTokens -  token  token 
     * @returns 
     *
     * @example
     * ```typescript
     * const result = SubhutiDebugUtils.validateTokenCompleteness(cst, tokens)
     * if (result.complete) {
     *     console.log(' Token ')
     * } else {
     *     console.log(' :', result.missing)
     * }
     * ```
     */ static validateTokenCompleteness(cst, inputTokens) {
        //  token 
        const inputValues = inputTokens.map((t)=>typeof t === 'string' ? t : t.tokenValue || '').filter((v)=>v !== '');
        const cstTokens = SubhutiDebugUtils.collectTokens(cst);
        //  token
        const missing = [];
        for(let i = 0; i < inputValues.length; i++){
            if (i >= cstTokens.length || inputValues[i] !== cstTokens[i]) {
                missing.push(inputValues[i]);
            }
        }
        return {
            complete: missing.length === 0 && inputValues.length === cstTokens.length,
            inputCount: inputValues.length,
            cstCount: cstTokens.length,
            inputTokens: inputValues,
            cstTokens: cstTokens,
            missing: missing
        };
    }
    // ========================================
    // CST 
    // ========================================
    /**
     *  CST 
     *
     * @param node - CST 
     * @param path - 
     * @returns 
     */ static validateStructure(node, path = 'root') {
        const errors = [];
        if (node === null) {
            errors.push({
                path,
                issue: 'Node is null'
            });
            return errors;
        }
        if (node === undefined) {
            errors.push({
                path,
                issue: 'Node is undefined'
            });
            return errors;
        }
        if (!node.name && node.value === undefined) {
            errors.push({
                path,
                issue: 'Node has neither name nor value',
                node: {
                    ...node,
                    children: node.children ? `[${node.children.length} children]` : undefined
                }
            });
        }
        if (node.children !== undefined) {
            if (!Array.isArray(node.children)) {
                errors.push({
                    path,
                    issue: `children is not an array (type: ${typeof node.children})`,
                    node: {
                        name: node.name,
                        childrenType: typeof node.children
                    }
                });
                return errors;
            }
            node.children.forEach((child, index)=>{
                const childPath = `${path}.children[${index}]`;
                if (child === null) {
                    errors.push({
                        path: childPath,
                        issue: 'Child is null'
                    });
                    return;
                }
                if (child === undefined) {
                    errors.push({
                        path: childPath,
                        issue: 'Child is undefined'
                    });
                    return;
                }
                const childErrors = SubhutiDebugUtils.validateStructure(child, childPath);
                errors.push(...childErrors);
            });
        }
        if (node.value !== undefined && node.children && node.children.length > 0) {
            errors.push({
                path,
                issue: `Leaf node has both value and non-empty children`,
                node: {
                    name: node.name,
                    value: node.value,
                    childrenCount: node.children.length
                }
            });
        }
        return errors;
    }
    /**
     *  CST 
     *
     * @param node - CST 
     * @returns 
     */ static getCSTStatistics(node) {
        const stats = {
            totalNodes: 0,
            leafNodes: 0,
            maxDepth: 0,
            nodeTypes: new Map()
        };
        const traverse = (node, depth)=>{
            if (!node) return;
            stats.totalNodes++;
            stats.maxDepth = Math.max(stats.maxDepth, depth);
            if (node.name) {
                stats.nodeTypes.set(node.name, (stats.nodeTypes.get(node.name) || 0) + 1);
            }
            if (!node.children || node.children.length === 0) {
                stats.leafNodes++;
            } else {
                for (const child of node.children){
                    traverse(child, depth + 1);
                }
            }
        };
        traverse(node, 0);
        return stats;
    }
    /**
     *  CST 
     *
     * @param cst - CST 
     * @param prefix - 
     * @param isLast - 
     * @returns 
     */ static formatCst(cst, prefix = '', isLast = true) {
        const lines = [];
        // 
        const connector = isLast ? '' : '';
        const nodeLine = SubhutiDebugUtils.formatNode(cst, prefix, connector);
        lines.push(nodeLine);
        // 
        if (cst.children && cst.children.length > 0) {
            const childPrefix = prefix + (isLast ? '   ' : '  ');
            cst.children.forEach((child, index)=>{
                const isLastChild = index === cst.children.length - 1;
                lines.push(SubhutiDebugUtils.formatCst(child, childPrefix, isLastChild));
            });
        }
        return lines.join('\n');
    }
    /**
     *  TreeFormatHelper
     */ static formatNode(cst, prefix, connector) {
        const isToken = cst.value !== undefined;
        if (isToken) {
            // Token 
            const value = TreeFormatHelper.formatTokenValue(cst.value);
            const location = cst.loc ? TreeFormatHelper.formatLocation(cst.loc) : null;
            return TreeFormatHelper.formatLine([
                connector,
                cst.name + ':',
                `"${value}"`,
                location
            ].join(''), {
                prefix
            });
        } else {
            // Rule 
            return TreeFormatHelper.formatLine([
                connector,
                cst.name
            ].join(''), {
                prefix
            });
        }
    }
    // ========================================
    // 
    // ========================================
    /**
     *  - 
     *
     * 
     * 
     *
     * @param tokens -  token 
     * @param ParserClass - Parser 
     * @param levels - 
     * @param options - 
     * @param options.enableDebugOnLastLevel -  debug true
     * @param options.stopOnFirstError -  true
     * @param options.showStackTrace -  true
     * @param options.stackTraceLines -  10
     *
     * @example
     * ```typescript
     * import { SubhutiDebugUtils } from 'subhuti/src/SubhutiDebug'
     * import Es2025Parser from './Es2025Parser'
     *
     * const tokens = lexer.tokenize("let count = 1")
     *
     * SubhutiDebugUtils.bisectDebug(tokens, Es2025Parser, [
     *     { name: 'LexicalDeclaration', call: (p) => p.LexicalDeclaration({In: true}) },
     *     { name: 'Declaration', call: (p) => p.Declaration() },
     *     { name: 'StatementListItem', call: (p) => p.StatementListItem() },
     *     { name: 'Script', call: (p) => p.Script() }
     * ], { enableDebugOnLastLevel: false })
     * ```
     */ static bisectDebug(tokens, ParserClass, levels, options) {
        // 
        const opts = {
            enableDebugOnLastLevel: true,
            stopOnFirstError: true,
            showStackTrace: true,
            stackTraceLines: 10,
            ...options
        };
        console.log('\n ');
        console.log('='.repeat(80));
        console.log('\n');
        for(let i = 0; i < levels.length; i++){
            const level = levels[i];
            console.log(`\n[${''.repeat(i + 1)}]  ${i + 1}: ${level.name}`);
            console.log('-'.repeat(80));
            try {
                //  parser 
                const parser = new ParserClass(tokens);
                //  debug
                if (opts.enableDebugOnLastLevel && i === levels.length - 1) {
                    if (typeof parser.debug === 'function') {
                        parser.debug();
                    }
                }
                const result = level.call(parser);
                if (!result) {
                    console.log(`\n ${level.name}  undefined`);
                    continue;
                }
                //  token 
                const validation = SubhutiDebugUtils.validateTokenCompleteness(result, tokens);
                if (validation.complete) {
                    console.log(`\n ${level.name} Token: ${validation.cstCount}/${validation.inputCount}`);
                } else {
                    console.log(`\n ${level.name} Token`);
                    console.log(`   tokens: ${validation.inputCount} `);
                    console.log(`   CST tokens:  ${validation.cstCount} `);
                    console.log(`   : [${validation.inputTokens.join(', ')}]`);
                    console.log(`   CST:  [${validation.cstTokens.join(', ')}]`);
                    if (validation.missing.length > 0) {
                        console.log(`    : [${validation.missing.join(', ')}]`);
                    }
                    console.log(`\n : ${level.name} token`);
                    if (i > 0) {
                        console.log(`    ${levels[i - 1].name}`);
                        console.log(`    :  ${level.name}  ${levels[i - 1].name} `);
                    } else {
                        console.log(`    :  ${level.name} token`);
                    }
                    if (opts.stopOnFirstError) {
                        return; //  token 
                    }
                }
            } catch (error) {
                console.log(`\n ${level.name} `);
                console.log(`   : ${error.message}`);
                console.log(`\n : ${level.name} `);
                if (i > 0) {
                    console.log(`    ${levels[i - 1].name}`);
                    console.log(`    ${level.name}`);
                    console.log(`\n :  ${level.name}  ${levels[i - 1].name}`);
                } else {
                    console.log(`    ${level.name}`);
                    console.log(`\n :  ${level.name}  token `);
                }
                // 
                if (opts.showStackTrace && error.stack) {
                    console.log(`\n ${opts.stackTraceLines}:`);
                    const stackLines = error.stack.split('\n').slice(0, opts.stackTraceLines);
                    stackLines.forEach((line)=>console.log(`   ${line}`));
                }
                if (opts.stopOnFirstError) {
                    return; // 
                }
            }
        }
        console.log('\n' + '='.repeat(80));
        console.log(' ');
        console.log('='.repeat(80));
    }
}
// ============================================
// SubhutiTraceDebugger - v4.0
// ============================================
class SubhutiTraceDebugger {
    /**
     * 
     *
     * 
     * - 
     * - 
     * -  token 
     *
     *  SubhutiParser 
     */ resetForNewParse(tokens) {
        // 
        this.rulePathCache.clear();
        // 
        this.stats.clear();
        //  token  tokens
        if (tokens) {
            //  token  token
            this.inputTokens = this.extractValidTokens(tokens);
        }
    //  inputTokens Parser  tokens
    }
    /**
     *  token  token
     *
     * @returns  token  tokenValue, tokenName, loc 
     */ extractValidTokens(tokens) {
        const excludeNames = [
            'SingleLineComment',
            'MultiLineComment',
            'Spacing',
            'LineBreak'
        ];
        return tokens.filter((t)=>{
            const name = t.tokenName || '';
            return excludeNames.indexOf(name) === -1;
        });
    }
    /**
     *  RuleStackItem
     */ deepCloneRuleStackItem(item) {
        if (item.ruleName) {
            if (!item.childs.length) {
                throw new Error('');
            }
        }
        const clone = {
            ruleName: item.ruleName,
            tokenName: item.tokenName,
            tokenValue: item.tokenValue,
            startTime: item.startTime,
            outputted: item.outputted,
            tokenIndex: item.tokenIndex,
            tokenSuccess: item.tokenSuccess,
            tokenExpectName: item.tokenExpectName,
            shouldBreakLine: item.shouldBreakLine,
            displayDepth: item.displayDepth,
            childs: item.childs,
            // relativeDepthByStack: item.relativeDepthByStack,    // 
            // relativeDepthByChilds: item.relativeDepthByChilds,  // 
            orBranchInfo: item.orBranchInfo ? {
                orIndex: item.orBranchInfo.orIndex,
                branchIndex: item.orBranchInfo.branchIndex,
                isOrEntry: item.orBranchInfo.isOrEntry,
                isOrBranch: item.orBranchInfo.isOrBranch,
                totalBranches: item.orBranchInfo.totalBranches
            } : undefined
        };
        return clone;
    }
    // ========================================
    // 
    // ========================================
    /**
     *  Or 
     */ generateCacheKey(item) {
        // ruleName:tokenIndex:isOrEntry:isOrBranch:orIndex:branchIndex:tokenValue:tokenName
        const ruleName = item.ruleName;
        const tokenIndex = item.tokenIndex.toString();
        const isOrEntry = item.orBranchInfo ? item.orBranchInfo.isOrEntry ? '1' : '0' : '0';
        const isOrBranch = item.orBranchInfo ? item.orBranchInfo.isOrBranch ? '1' : '0' : '0';
        const orIndex = item.orBranchInfo?.orIndex?.toString() ?? '-1';
        const branchIndex = item.orBranchInfo?.branchIndex?.toString() ?? '-1';
        const tokenValue = item.tokenValue ?? '';
        const tokenName = item.tokenName ?? '';
        const tokenExpectName = item.tokenExpectName ?? '';
        const tokenSuccess = item.tokenSuccess ?? false;
        return `${ruleName}:${tokenIndex}:${isOrEntry}:${isOrBranch}:${orIndex}:${branchIndex}:${tokenValue}:${tokenName}:${tokenExpectName}:${tokenSuccess}`;
    }
    createTokenItem(tokenIndex, tokenValue, tokenName, expectName, success) {
        //  Token  RuleStackItem
        return {
            ruleName: undefined,
            tokenSuccess: success,
            tokenExpectName: expectName,
            startTime: 0,
            outputted: false,
            tokenIndex: tokenIndex,
            shouldBreakLine: true,
            // childs: [], token //  childs 
            tokenValue: tokenValue,
            tokenName: tokenName
        };
    }
    /**
     * 
     *
     * @param cacheKey - 
     * @param isRoot - 
     * @param OrBranchNeedNewLine - or
     * @param displayDepth -  displayDepth
     */ restoreFromCacheAndPushAndPrint(cacheKey, displayDepth, OrBranchNeedNewLine, isRoot = true) {
        //  1  Token
        const cached = this.cacheGet(cacheKey);
        if (!cached) {
            throw new Error('');
        }
        //  2 
        const restoredItem = this.deepCloneRuleStackItem(cached);
        restoredItem.outputted = false; // 
        restoredItem.isManuallyAdded = true;
        restoredItem.shouldBreakLine = false;
        OrBranchNeedNewLine = false;
        const lastRowShouldBreakLine = this.ruleStack[this.ruleStack.length - 1].shouldBreakLine;
        let tempBreakLine = false;
        if (isRoot) {
            displayDepth++;
            restoredItem.shouldBreakLine = true;
        } else if (OrBranchNeedNewLine) {
            displayDepth++;
            restoredItem.shouldBreakLine = true;
        } else if (restoredItem.tokenExpectName) {
            displayDepth++;
            restoredItem.shouldBreakLine = true;
        } else if (restoredItem.orBranchInfo && restoredItem.orBranchInfo.isOrEntry && restoredItem.childs.length > 1) {
            displayDepth++;
            restoredItem.shouldBreakLine = true;
            OrBranchNeedNewLine = true;
        } else if ([
            'UpdateExpression'
        ].indexOf(restoredItem.ruleName) > -1) {
            displayDepth++;
            restoredItem.shouldBreakLine = true;
        } else if (lastRowShouldBreakLine) {
            //+1
            displayDepth++;
            tempBreakLine = true;
        }
        restoredItem.displayDepth = displayDepth;
        if (OrBranchNeedNewLine && restoredItem.orBranchInfo) {
            OrBranchNeedNewLine = restoredItem.orBranchInfo.isOrBranch || false;
        }
        let childBeginIndex = this.ruleStack.push(restoredItem);
        //  4  displayDepth
        if (cached.childs) {
            let i = 0;
            for (const childKey of cached.childs){
                const nextItem = this.restoreFromCacheAndPushAndPrint(childKey, displayDepth, OrBranchNeedNewLine, false);
                //
                if (!isRoot && i === 0 && lastRowShouldBreakLine && !restoredItem.shouldBreakLine && nextItem.shouldBreakLine) {
                    this.ruleStack.splice(childBeginIndex);
                    //
                    if (!tempBreakLine) {
                        displayDepth++;
                    }
                    restoredItem.shouldBreakLine = true;
                    restoredItem.displayDepth = displayDepth;
                    this.restoreFromCacheAndPushAndPrint(childKey, displayDepth, OrBranchNeedNewLine, false);
                }
                i++;
            }
        }
        //  5 
        // pop 
        if (isRoot) {
            SubhutiDebugRuleTracePrint.flushPendingOutputs_Cache_Impl(this.ruleStack);
            this.ruleStack.splice(childBeginIndex);
        }
        return restoredItem;
    }
    /**
     *  - 
     *
     * 
     * 1. 
     * 2. 
     * 3. 
     * 4. 
     * 5. 
     *
     * @param ruleName - 
     * @param tokenIndex -  token 
     */ onRuleEnter(ruleName, tokenIndex) {
        // 
        const startTime = performance.now();
        // ============================================
        // 
        // ============================================
        let stat = this.stats.get(ruleName);
        if (!stat) {
            // 
            stat = {
                ruleName,
                totalCalls: 0,
                actualExecutions: 0,
                cacheHits: 0,
                totalTime: 0,
                executionTime: 0,
                avgTime: 0
            };
            this.stats.set(ruleName, stat);
        }
        // 
        stat.totalCalls++;
        // 
        const ruleItem = {
            ruleName,
            //  tokenIndex
            tokenIndex,
            startTime,
            outputted: false,
            childs: []
        };
        if (this.openDebugLogCache) {
            // ruleName:tokenIndex:orInfo
            const cacheKey = this.generateCacheKey(ruleItem);
            // 
            const RuleStackItem = this.cacheGet(cacheKey);
            // 
            if (RuleStackItem) {
                let depth = SubhutiDebugRuleTracePrint.flushPendingOutputs_NonCache_Impl(this.ruleStack);
                //  Token 
                this.restoreFromCacheAndPushAndPrint(cacheKey, depth, false);
                // 
                return startTime;
            }
        }
        // 
        // ============================================
        // 
        // ============================================
        //  onRuleExit 
        this.ruleStack.push(ruleItem);
        //  onRuleExit() 
        return startTime;
    }
    onRuleExit(ruleName, cacheHit, startTime) {
        let duration = 0;
        if (startTime !== undefined && typeof startTime === 'number') {
            duration = performance.now() - startTime;
        }
        // 
        if (this.ruleStack.length === 0) {
            throw new Error(` Rule exit error: ruleStack is empty when exiting ${ruleName}`);
        }
        const curRule = this.ruleStack.pop();
        // 
        if (!curRule || curRule.ruleName !== ruleName) {
            throw new Error(` Rule exit mismatch: expected ${ruleName} at top, got ${curRule?.ruleName || 'undefined'}`);
        }
        // ============================================
        // 
        // ============================================
        const stat = this.stats.get(ruleName);
        if (stat) {
            stat.totalTime += duration;
            if (cacheHit) {
                stat.cacheHits++;
            } else {
                stat.actualExecutions++;
                stat.executionTime += duration;
                if (stat.actualExecutions > 0) {
                    stat.avgTime = stat.executionTime / stat.actualExecutions;
                }
            }
        }
        //  Token
        if (!curRule.outputted) {
            return;
        }
        //  key
        const cacheKey = this.generateCacheKey(curRule);
        // 
        //  pop 
        const parentItem = this.ruleStack[this.ruleStack.length - 1];
        // 1 childs
        if (parentItem) {
            //  childs 
            if (!parentItem.childs) {
                throw new Error(` Parent rule ${parentItem.ruleName} does not have childs array when exiting rule ${ruleName}`);
            }
            // 
            //  Or 
            if (parentItem.childs.some((key)=>key === cacheKey)) {
                console.log(`    ${ruleName}  childs `);
                console.log(`  :`);
                parentItem.childs.forEach((key, idx)=>{
                    console.log(`    [${idx}] ${key}`);
                });
                throw new Error(` Rule ${ruleName} already exists in parent rule ${parentItem.ruleName}'s childs`);
            }
            //  key  childs
            this.parentPushChild(parentItem, cacheKey);
        }
        const cacheCurRule = this.cacheGet(cacheKey);
        // 2
        if (!cacheCurRule) {
            const cloned = this.deepCloneRuleStackItem(curRule);
            this.cacheSet(cacheKey, cloned);
        }
    }
    cacheSet(key, value) {
        if (!value.tokenExpectName) {
            if (!value.childs || value.childs?.length === 0) {
                throw new Error('bugai wei 0');
            }
        }
        this.rulePathCache.set(key, value);
    }
    cacheGet(key) {
        const res = this.rulePathCache.get(key);
        return res;
    }
    onTokenConsume(tokenIndex, tokenValue, tokenName, expectName, success) {
        // 
        if (this.ruleStack.length === 0) {
            throw new Error(` Token consume error: ruleStack is empty when consuming token ${tokenName}`);
        }
        //  token 
        const parentRule = this.ruleStack[this.ruleStack.length - 1];
        if (!success) {
            //token
            if (tokenIndex <= parentRule.tokenIndex) {
                return;
            }
        }
        //  Token  RuleStackItem  key
        const tokenItem = this.createTokenItem(tokenIndex, tokenValue, tokenName, expectName, success);
        const tokenKey = this.generateCacheKey(tokenItem);
        //  Token  
        if (!this.rulePathCache.has(tokenKey)) {
            this.cacheSet(tokenKey, this.deepCloneRuleStackItem(tokenItem));
        }
        //  childs 
        if (!parentRule.childs) {
            throw new Error(` Parent rule ${parentRule.ruleName} does not have childs array when consuming token ${tokenName}`);
        }
        // Token 
        if (parentRule.childs.some((key)=>key === tokenKey)) {
            throw new Error(` Token ${tokenName} already exists in parent rule ${parentRule.ruleName}'s childs`);
        }
        //  Token key  childs
        this.parentPushChild(parentRule, tokenKey);
        //  2 
        //  token 
        const depth = SubhutiDebugRuleTracePrint.flushPendingOutputs_NonCache_Impl(this.ruleStack);
        //  token 
        const token = this.inputTokens[tokenIndex];
        let location = null;
        if (success) {
            if (token) {
                if (token.loc) {
                    //  token 
                    location = TreeFormatHelper.formatLocation(token.loc);
                } else if (token.rowNum !== undefined && token.columnStartNum !== undefined) {
                    // 
                    const row = token.rowNum;
                    const start = token.columnStartNum;
                    const end = token.columnEndNum ?? start + tokenValue.length - 1;
                    location = `[${row}:${start}-${end}]`;
                }
            }
        }
        const tokenStr = SubhutiDebugRuleTracePrint.getPrintToken(tokenItem, location);
        const line = SubhutiDebugRuleTracePrint.formatLine(tokenStr, depth);
        SubhutiDebugRuleTracePrint.consoleLog(line);
    }
    onOrEnter(parentRuleName, tokenIndex) {
        //  tokenIndex 0 
        //  orIndex Or 
        let orIndex = 0;
        if (this.ruleStack.length > 0) {
            const parentRule = this.ruleStack[this.ruleStack.length - 1];
            if (parentRule.childs) {
                //  childs  Or isOrEntry=true
                for (const childKey of parentRule.childs){
                    const childItem = this.cacheGet(childKey);
                    if (childItem && childItem.orBranchInfo?.isOrEntry) {
                        orIndex++;
                    }
                }
            }
        }
        //  Or 
        // ruleName 
        this.ruleStack.push({
            ruleName: parentRuleName,
            startTime: performance.now(),
            outputted: false,
            //orEntry
            shouldBreakLine: true,
            tokenIndex,
            childs: [],
            orBranchInfo: {
                orIndex,
                isOrEntry: true,
                isOrBranch: false,
                startTokenIndex: tokenIndex,
                branchAttempts: [] // 
            }
        });
    }
    onOrExit(parentRuleName) {
        // 
        if (this.ruleStack.length === 0) {
            throw new Error(` Or exit error: ruleStack is empty when exiting Or for ${parentRuleName}`);
        }
        const curOrNode = this.ruleStack.pop();
        //  Or 
        if (!(curOrNode.ruleName === parentRuleName && curOrNode.orBranchInfo && curOrNode.orBranchInfo.isOrEntry && !curOrNode.orBranchInfo.isOrBranch)) {
            const orInfo = curOrNode.orBranchInfo ? `(entry=${curOrNode.orBranchInfo.isOrEntry}, branch=${curOrNode.orBranchInfo.isOrBranch})` : '(no orBranchInfo)';
            throw new Error(` Or exit mismatch: expected ${parentRuleName}(OrEntry) at top, got ${curOrNode.ruleName}${orInfo}`);
        }
        //  Or  Token
        if (!curOrNode.outputted) {
            return;
        }
        //  Or  key
        const cacheKey = this.generateCacheKey(curOrNode);
        // 
        const parentItem = this.ruleStack[this.ruleStack.length - 1];
        // 1 Or  childs
        if (parentItem) {
            //  childs 
            if (!parentItem.childs) {
                throw new Error(` Parent rule ${parentItem.ruleName} does not have childs array when exiting Or ${parentRuleName}`);
            }
            // Or 
            if (parentItem.childs.some((key)=>key === cacheKey)) {
                throw new Error(` ${cacheKey} Or ${parentRuleName} already exists in parent rule ${parentItem.ruleName}'s childs`);
            }
            //  Or  key  childs
            this.parentPushChild(parentItem, cacheKey);
        }
        // 2 Or   
        const cachedOrNode = this.cacheGet(cacheKey);
        if (!cachedOrNode) {
            const cloned = this.deepCloneRuleStackItem(curOrNode);
            this.cacheSet(cacheKey, cloned);
        }
    }
    onOrBranch(branchIndex, totalBranches, parentRuleName) {
        //  
        //  tokenIndex 0 
        const tokenIndex = this.ruleStack.length > 0 ? this.ruleStack[this.ruleStack.length - 1]?.tokenIndex ?? 0 : 0;
        //  orIndex Or  orIndex
        let orIndex = undefined;
        if (this.ruleStack.length > 0) {
            const parentOrEntry = this.ruleStack[this.ruleStack.length - 1];
            if (parentOrEntry.orBranchInfo?.isOrEntry) {
                orIndex = parentOrEntry.orBranchInfo.orIndex;
            }
        }
        //  Or 
        // ruleName 
        this.ruleStack.push({
            ruleName: parentRuleName,
            startTime: performance.now(),
            outputted: false,
            tokenIndex,
            childs: [],
            orBranchInfo: {
                orIndex,
                isOrEntry: false,
                isOrBranch: true,
                branchIndex,
                totalBranches
            }
        });
    }
    onOrBranchExit(parentRuleName, branchIndex) {
        // 
        if (this.ruleStack.length === 0) {
            throw new Error(` OrBranch exit error: ruleStack is empty when exiting branch ${branchIndex} for ${parentRuleName}`);
        }
        // 3Pop 
        const curBranchNode = this.ruleStack.pop();
        //  Or 
        if (!(curBranchNode.ruleName === parentRuleName && curBranchNode.orBranchInfo && curBranchNode.orBranchInfo.isOrBranch && !curBranchNode.orBranchInfo.isOrEntry && curBranchNode.orBranchInfo.branchIndex === branchIndex)) {
            const info = curBranchNode.orBranchInfo;
            const infoStr = info ? `(entry=${info.isOrEntry}, branch=${info.isOrBranch}, idx=${info.branchIndex})` : '(no orInfo)';
            throw new Error(` OrBranch exit mismatch: expected ${parentRuleName}(branchIdx=${branchIndex}) at top, got ${curBranchNode.ruleName}${infoStr}`);
        }
        //  Or  Token
        if (!curBranchNode.outputted) {
            return;
        }
        //  Or  key
        const cacheKey = this.generateCacheKey(curBranchNode);
        // Or 
        const parentOrNode = this.ruleStack[this.ruleStack.length - 1];
        // 1 Or  childs
        if (parentOrNode) {
            //  childs 
            if (!parentOrNode.childs) {
                throw new Error(` Parent Or node ${parentOrNode.ruleName} does not have childs array when exiting branch ${branchIndex}`);
            }
            // Or 
            if (parentOrNode.childs.some((key)=>key === cacheKey)) {
                throw new Error(` OrBranch ${branchIndex} already exists in parent Or node ${parentOrNode.ruleName}'s childs`);
            }
            //  Or  key  childs
            this.parentPushChild(parentOrNode, cacheKey);
        }
        // 2 Or   
        const cachedBranchNode = this.cacheGet(cacheKey);
        if (!cachedBranchNode) {
            const cloned = this.deepCloneRuleStackItem(curBranchNode);
            this.cacheSet(cacheKey, cloned);
        }
    }
    onBacktrack(fromTokenIndex, toTokenIndex) {
    // 
    }
    // ========================================
    // CST  SubhutiDebugUtils
    // ========================================
    /**
     *  token  SubhutiDebugUtils
     */ collectTokenValues(node) {
        return SubhutiDebugUtils.collectTokens(node);
    }
    /**
     *  Token  SubhutiDebugUtils
     */ checkTokenCompleteness(cst) {
        const result = SubhutiDebugUtils.validateTokenCompleteness(cst, this.inputTokens);
        return {
            input: result.inputTokens,
            cst: result.cstTokens,
            missing: result.missing
        };
    }
    /**
     *  CST  SubhutiDebugUtils
     */ validateStructure(node, path = 'root') {
        return SubhutiDebugUtils.validateStructure(node, path);
    }
    /**
     *  CST  SubhutiDebugUtils
     */ getCSTStatistics(node) {
        return SubhutiDebugUtils.getCSTStatistics(node);
    }
    // ========================================
    // 
    // ========================================
    /**
     * 
     */ getSummary() {
        const allStats = Array.from(this.stats.values());
        if (allStats.length === 0) {
            return ' ';
        }
        // 
        const totalCalls = allStats.reduce((sum, s)=>sum + s.totalCalls, 0);
        const totalExecutions = allStats.reduce((sum, s)=>sum + s.actualExecutions, 0);
        const totalCacheHits = allStats.reduce((sum, s)=>sum + s.cacheHits, 0);
        const totalTime = allStats.reduce((sum, s)=>sum + s.totalTime, 0);
        const cacheHitRate = totalCalls > 0 ? (totalCacheHits / totalCalls * 100).toFixed(1) : '0.0';
        const lines = [];
        lines.push('  ');
        lines.push(''.repeat(40));
        lines.push(`: ${totalTime.toFixed(2)}ms`);
        lines.push(`: ${totalCalls.toLocaleString()} `);
        lines.push(`: ${totalExecutions.toLocaleString()} `);
        lines.push(`: ${totalCacheHits.toLocaleString()}  (${cacheHitRate}%)`);
        lines.push('');
        // Top 5 
        const top5 = allStats.filter((s)=>s.actualExecutions > 0).sort((a, b)=>b.executionTime - a.executionTime).slice(0, 5);
        if (top5.length > 0) {
            lines.push('Top 5 :');
            top5.forEach((stat, i)=>{
                const avgUs = (stat.avgTime * 1000).toFixed(1);
                lines.push(`  ${i + 1}. ${stat.ruleName}: ${stat.executionTime.toFixed(2)}ms ` + `(${stat.totalCalls}, ${avgUs}s)`);
            });
        }
        return lines.join('\n');
    }
    // ========================================
    // CST 
    // ========================================
    /**
     *  CST Parser 
     */ setCst(cst) {
        this.topLevelCst = cst || null;
    }
    parentPushChild(parent, child) {
        parent.childs.push(child);
    }
    // ========================================
    //  Parser 
    // ========================================
    /**
     * 
     */ autoOutput() {
        console.log('\n' + '='.repeat(60));
        console.log(' Subhuti Debug ');
        console.log('='.repeat(60));
        // ========================================
        // 
        // ========================================
        console.log('\n');
        console.log(''.repeat(60));
        console.log('\n' + this.getSummary());
        // 
        console.log('\n :');
        const allStats = Array.from(this.stats.values()).sort((a, b)=>b.executionTime - a.executionTime);
        allStats.forEach((stat)=>{
            const cacheRate = stat.totalCalls > 0 ? (stat.cacheHits / stat.totalCalls * 100).toFixed(1) : '0.0';
            console.log(`  ${stat.ruleName}: ${stat.totalCalls} | ` + `${stat.actualExecutions} | ` + `${stat.executionTime.toFixed(2)}ms | ` + `${cacheRate}%`);
        });
        console.log('\n' + '='.repeat(60));
        // ========================================
        // CST 
        // ========================================
        if (this.topLevelCst) {
            console.log('\nCST ');
            console.log(''.repeat(60));
            console.log('\n CST ');
            console.log(''.repeat(60));
            // 2.1 
            const structureErrors = this.validateStructure(this.topLevelCst);
            console.log(`\n : ${structureErrors.length === 0 ? '' : ''}`);
            if (structureErrors.length > 0) {
                console.log(`    ${structureErrors.length} :`);
                structureErrors.forEach((err, i)=>{
                    console.log(`\n   [${i + 1}] ${err.path}`);
                    console.log(`       : ${err.issue}`);
                    if (err.node) {
                        const nodeStr = JSON.stringify(err.node, null, 2).split('\n').map((line)=>`       ${line}`).join('\n');
                        console.log(nodeStr);
                    }
                });
            } else {
                console.log('   ');
            }
            // 2.2 Token 
            const tokenResult = this.checkTokenCompleteness(this.topLevelCst);
            console.log(`\n Token : ${tokenResult.missing.length === 0 ? '' : ''}`);
            console.log(`    tokens: ${tokenResult.input.length} `);
            console.log(`   CST tokens:  ${tokenResult.cst.length} `);
            console.log(`   : [${tokenResult.input.join(', ')}]`);
            console.log(`   CST:  [${tokenResult.cst.join(', ')}]`);
            if (tokenResult.missing.length > 0) {
                console.log(`    : [${tokenResult.missing.join(', ')}]`);
            } else {
                console.log(`    `);
            }
            // 2.3 CST 
            const stats = this.getCSTStatistics(this.topLevelCst);
            console.log(`\n CST :`);
            console.log(`   : ${stats.totalNodes}`);
            console.log(`   : ${stats.leafNodes}`);
            console.log(`   : ${stats.maxDepth}`);
            console.log(`   : ${stats.nodeTypes.size} `);
            // 
            console.log(`\n   :`);
            const sortedTypes = Array.from(stats.nodeTypes.entries()).sort((a, b)=>b[1] - a[1]);
            sortedTypes.forEach(([name, count])=>{
                console.log(`     ${name}: ${count}`);
            });
            console.log(''.repeat(60));
            // ========================================
            // CST 
            // ========================================
            console.log('\nCST ');
            console.log(''.repeat(60));
            console.log('\n CST ');
            console.log(''.repeat(60));
            console.log(SubhutiDebugUtils.formatCst(this.topLevelCst));
            console.log(''.repeat(60));
        }
        console.log('\n' + '='.repeat(60));
        console.log(' Debug ');
        console.log('='.repeat(60));
    }
    /**
     * 
     *
     * @param tokens -  token 
     */ constructor(tokens){
        // ========================================
        //  -  ruleStack
        // ========================================
        _define_property$9(this, "ruleStack", []);
        // ========================================
        // 
        // ========================================
        _define_property$9(this, "stats", new Map());
        // ========================================
        // 
        // ========================================
        _define_property$9(this, "rulePathCache", new Map());
        // ========================================
        // Token 
        // ========================================
        _define_property$9(this, "inputTokens", []); //  token 
        // ========================================
        // CST 
        // ========================================
        _define_property$9(this, "topLevelCst", null);
        // ========================================
        // 
        // ========================================
        // openDebugLogCache = false
        _define_property$9(this, "openDebugLogCache", true);
        this.inputTokens = this.extractValidTokens(tokens || []);
    }
} // ============================================
 // 
 // ============================================
// ========================================
//  - 
// ========================================
/**
     * @deprecated  SubhutiDebugUtils.collectTokens()
     */ _define_property$9(SubhutiTraceDebugger, "collectTokens", SubhutiDebugUtils.collectTokens);
/**
     * @deprecated  SubhutiDebugUtils.validateTokenCompleteness()
     */ _define_property$9(SubhutiTraceDebugger, "validateTokenCompleteness", SubhutiDebugUtils.validateTokenCompleteness);

/**
 * @module LRUCache
 */
const defaultPerf = (typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function') ?
    performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ?
    process
    : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function' ?
        PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max) ? null
    : max <= Math.pow(2, 8) ? Uint8Array
        : max <= Math.pow(2, 16) ? Uint16Array
            : max <= Math.pow(2, 32) ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    #perf;
    /**
     * {@link LRUCache.OptionsBase.perf}
     */
    get perf() {
        return this.#perf;
    }
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #autopurgeTimers;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            autopurgeTimers: c.#autopurgeTimers,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf, } = options;
        if (perf !== undefined) {
            if (typeof perf?.now !== 'function') {
                throw new TypeError('perf option must have a now() method if specified');
            }
        }
        this.#perf = perf ?? defaultPerf;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        const purgeTimers = this.ttlAutopurge ?
            new Array(this.#max)
            : undefined;
        this.#autopurgeTimers = purgeTimers;
        this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            // clear out the purge timer if we're setting TTL to 0, and
            // previously had a ttl purge timer running, so it doesn't
            // fire unnecessarily.
            if (purgeTimers?.[index]) {
                clearTimeout(purgeTimers[index]);
                purgeTimers[index] = undefined;
            }
            if (ttl !== 0 && purgeTimers) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
                purgeTimers[index] = t;
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = this.#perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        /* c8 ignore start - this isn't tested for the info function,
         * but it's the same logic as found in other places. */
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
            return undefined;
        /* c8 ignore end */
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (this.#perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = this.#perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = this.#perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0 ? this.#tail
                : this.#free.length !== 0 ? this.#free.pop()
                    : this.#size === this.#max ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ?
                        oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        if (this.#autopurgeTimers?.[head]) {
            clearTimeout(this.#autopurgeTimers[head]);
            this.#autopurgeTimers[head] = undefined;
        }
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined || (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            // if nothing else has been written there but we're set to update the
            // cache and ignore the abort, or if it's still pending on this specific
            // background request, then write it to the cache.
            const vl = this.#valList[index];
            if (vl === p || (ignoreAbort && updateCache && vl === undefined)) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching !== undefined) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                if (this.#autopurgeTimers?.[index]) {
                    clearTimeout(this.#autopurgeTimers?.[index]);
                    this.#autopurgeTimers[index] = undefined;
                }
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
            for (const t of this.#autopurgeTimers ?? []) {
                if (t !== undefined)
                    clearTimeout(t);
            }
            this.#autopurgeTimers?.fill(undefined);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

/**
 * Subhuti SubhutiPackratCache Cache -  SubhutiPackratCache Parsing 
 *
 * 
 * - SubhutiPackratCache:  LRU  +  + 
 *
 * @version 4.0.0 -  lru-cache 
 * @date 2025-11-04
 */ function _define_property$8(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * Subhuti SubhutiPackratCache Cache -  LRU  +  SubhutiPackratCache Parsing  
 *
 * 
 * - LRU  lru-cache 
 * - 
 * - 
 * - 
 *
 * 
 * -  lru-cache10k+ stars 4000+ 
 * - LRU(10000) 
 * - 
 * - lru-cache  O(1)
 * - hits/misses/stores 
 *
 * 
 * ```typescript
 * //  99%- LRU(10000)
 * const cache = new SubhutiPackratCache()
 *
 * // - LRU(50000)
 * const cache = new SubhutiPackratCache(50000)
 *
 * //  + 
 * const cache = new SubhutiPackratCache(0)
 * ```
 *
 * 
 * - get: O(1) 
 * - set: O(1) 
 * - 
 */ class SubhutiPackratCache {
    // ========================================
    //  LRU + 
    // ========================================
    /**
     *  - O(1) 
     *
     * 
     * - LRU  lru-cache 
     * - hits / misses
     * -  lru-cache 
     *
     * @param ruleName 
     * @param tokenIndex token 
     * @returns  undefined
     */ get(ruleName, tokenIndex) {
        const key = `${ruleName}:${tokenIndex}`;
        const result = this.cache.get(key);
        if (result === undefined) {
            this.stats.misses++; //  
            return undefined;
        }
        //  
        this.stats.hits++; //  
        return result;
    }
    /**
     *  - O(1) 
     *
     * 
     * - LRU  lru-cache 
     * - stores
     * -  lru-cache 
     *
     * @param ruleName 
     * @param tokenIndex token 
     * @param result 
     */ set(ruleName, tokenIndex, result) {
        const key = `${ruleName}:${tokenIndex}`;
        this.stats.stores++;
        // lru-cache  LRU 
        this.cache.set(key, result);
    }
    /**
     * 
     *
     * 
     * - 
     * - 
     * - 
     */ clear() {
        this.cache.clear();
        // 
        this.stats.hits = 0;
        this.stats.misses = 0;
        this.stats.stores = 0;
    }
    /**
     * 
     */ get size() {
        return this.cache.size;
    }
    // ========================================
    // 
    // ========================================
    /**
     * API
     *
     * 
     * - hitsmissesstorestotal
     * - 
     * - 
     *
     * 
     * ```typescript
     * const report = cache.getStatsReport()
     * console.log(`: ${report.hitRate}`)
     * console.log(`: ${report.suggestions.join(', ')}`)
     * ```
     */ getStatsReport() {
        const total = this.stats.hits + this.stats.misses;
        const hitRate = total > 0 ? (this.stats.hits / total * 100).toFixed(1) : '0.0';
        const hitRateNum = parseFloat(hitRate);
        // 
        const usageRate = this.maxSize > 0 ? (this.size / this.maxSize * 100).toFixed(1) + '%' : 'unlimited';
        // 
        const suggestions = [];
        if (hitRateNum >= 70) {
            suggestions.push('  70%');
        } else if (hitRateNum >= 50) {
            suggestions.push(' 50-70%');
        } else if (hitRateNum >= 30) {
            suggestions.push(' 30-50%');
        } else {
            suggestions.push(' < 30%');
        }
        //  LRU 
        if (this.maxSize > 0) {
            const usageRatio = this.size / this.maxSize;
            if (usageRatio > 0.9) {
                suggestions.push(' > 90% maxSize');
            } else if (usageRatio > 0.7) {
                suggestions.push(' 70-90% maxSize');
            }
            //   
            if (usageRatio < 0.1 && total > 10000) {
                suggestions.push(' < 10% maxSize ');
            }
        }
        return {
            // 
            hits: this.stats.hits,
            misses: this.stats.misses,
            stores: this.stats.stores,
            total,
            hitRate: `${hitRate}%`,
            // 
            maxCacheSize: this.maxSize,
            currentSize: this.size,
            usageRate,
            // 
            suggestions
        };
    }
    // ========================================
    // 
    // ========================================
    /**
     *  SubhutiPackratCache Cache
     *
     * 
     * ```typescript
     * //  99%
     * new SubhutiPackratCache()           LRU(10000)
     *
     * // 
     * new SubhutiPackratCache(50000)      LRU(50000)
     *
     * // 
     * new SubhutiPackratCache(100000)     LRU(100000)
     *
     * //  + 
     * new SubhutiPackratCache(0)          Unlimited
     * ```
     *
     * @param maxSize 
     *                - 0
     *                - >0 LRU
     *                - 10000 99% 
     */ constructor(maxSize = 10000){
        // ========================================
        // LRU  lru-cache 
        // ========================================
        /**
     *  lru-cache 
     *
     * 
     * - 10+  4000+ 
     * - O(1) 
     * -  TTLdispose 
     * - TypeScript 
     *
     * `${ruleName}:${tokenIndex}`
     * "Expression:5"  Expression5token
     */ _define_property$8(this, "cache", void 0);
        /**
     * 0 
     */ _define_property$8(this, "maxSize", void 0);
        // ========================================
        // 
        // ========================================
        /**
     * 
     * 
     * 
     */ _define_property$8(this, "stats", {
            hits: 0,
            misses: 0,
            stores: 0
        });
        this.maxSize = maxSize;
        //  lru-cache
        if (maxSize === 0) {
            // 
            this.cache = new LRUCache({
                max: Infinity
            });
        } else {
            // LRU 
            this.cache = new LRUCache({
                max: maxSize
            });
        }
    }
}

/**
 * Subhuti Grammar Validation - 
 *
 *  Parser  AST 
 *
 * ProxyParser
 *
 * 
 * 1. **Parser Proxy**Or/Many/Option/AtLeastOne/
 * 2. **TokenConsumer Proxy**tokenLParen/RParen/Identifier
 * 3. **Proxy**
 *    - tokenConsumerParser
 *    - this.tokenConsumer.XXX()token
 *    - Parser ProxytokenConsumer
 *
 * 
 * 1.  consume_consumeToken
 * 2.  tokenConsumertoken
 * 3.  subrule
 * 4.  thishandlerproxytarget
 * 5.  Parser
 *
 * AST
 * - SubhutiGrammarAnalyzersubruletoken
 * - SubhutiConflictDetectorOrtoken
 *
 * @version 3.0.0 - 
 */ function _define_property$7(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * 
 *
 * 
 * 1.  Parser 
 * 2.  Parser  Proxy 
 * 3.  Or/Many/Option/AtLeastOne/consume 
 * 4.  AST
 *
 * 
 * - Parser 
 * - 
 * - 
 * - 
 */ class SubhutiRuleCollector {
    /**
     *  - 
     *
     * @param parser Parser 
     * @returns   AST 
     */ static collectRules(parser) {
        const collector = new SubhutiRuleCollector();
        return collector.collect(parser);
    }
    /**
     * 
     */ collect(parser) {
        //  
        parser.enableAnalysisMode();
        // 
        const proxy = this.createAnalyzeProxy(parser);
        //  @SubhutiRule 
        const ruleNames = this.getAllRuleNames(parser);
        // 
        for (const ruleName of ruleNames){
            this.collectRule(proxy, ruleName);
        }
        //  
        parser.disableAnalysisMode();
        return {
            cstMap: this.ruleASTs,
            tokenMap: this.tokenAstCache
        };
    }
    /**
     *  Parser 
     */ createAnalyzeProxy(parser) {
        const collector = this;
        const proxy = new Proxy(parser, {
            get (target, prop) {
                // if (prop === 'Or' || prop === 'Arguments') {
                //     console.log(`[PROXY] get: ${String(prop)}`)
                // }
                // 
                if (prop === 'Or') {
                    const debugRules = [
                        'ConditionalExpression',
                        'AssignmentExpression',
                        'Expression',
                        'Statement'
                    ];
                    debugRules.includes(collector.currentRuleName);
                    return (alternatives)=>{
                        return collector.handleOr(alternatives, proxy);
                    };
                }
                if (prop === 'Many') {
                    return (fn)=>collector.handleMany(fn, proxy);
                }
                if (prop === 'Option') {
                    return (fn)=>collector.handleOption(fn, proxy);
                }
                if (prop === 'AtLeastOne') {
                    return (fn)=>collector.handleAtLeastOne(fn, proxy);
                }
                //  consume  _consumeToken
                if (prop === 'consume' || prop === '_consumeToken') {
                    return (tokenName)=>collector.handleConsume(tokenName);
                }
                //  tokenConsumer
                if (prop === 'tokenConsumer') {
                    const originalConsumer = Reflect.get(target, prop);
                    return collector.createTokenConsumerProxy(originalConsumer);
                }
                // 
                const original = Reflect.get(target, prop);
                const coreMethod = [
                    'Or',
                    'Many',
                    'Option',
                    'AtLeastOne',
                    'consume',
                    '_consumeToken',
                    'tokenConsumer'
                ];
                if (typeof original === 'function' && typeof prop === 'string' && /^[A-Z]/.test(prop) && !coreMethod.includes(prop)) {
                    return function(...args) {
                        // 
                        if (collector.isExecutingTopLevelRule && prop === collector.currentRuleName) {
                            collector.isExecutingTopLevelRule = false;
                            // 
                            if (collector.executingRuleStack.has(prop)) {
                                // 
                                return collector.handleSubrule(prop);
                            }
                            // 
                            collector.executingRuleStack.add(prop);
                            try {
                                //  proxy 
                                const originalFun = original.__originalFunction__ || original;
                                //  proxy 
                                const result = originalFun.call(proxy, ...args);
                                return result;
                            } finally{
                                // 
                                collector.executingRuleStack.delete(prop);
                            }
                        }
                        // 
                        return collector.handleSubrule(prop);
                    };
                }
                // /
                return original;
            }
        });
        return proxy;
    }
    /**
     *  TokenConsumer  token 
     */ createTokenConsumerProxy(tokenConsumer) {
        const collector = this;
        return new Proxy(tokenConsumer, {
            get (target, prop) {
                const original = Reflect.get(target, prop);
                // 
                if (typeof original === 'function' && typeof prop === 'string') {
                    return function(...args) {
                        //  token  token 
                        collector.handleConsume(prop);
                        //  AST 
                        //  undefined
                        return undefined;
                    // // 
                    // try {
                    //     return original.apply(target, args)
                    // } catch (error: any) {
                    //     // tokenconsume
                    //     // undefined
                    //     return undefined
                    // }
                    };
                }
                return original;
            }
        });
    }
    /**
     * 
     *
     * 
     * -  Parser Token 
     * -   try-catch  Error
     * -  Proxy  AST
     *
     * 
     * - 
     * - 
     */ collectRule(proxy, ruleName) {
        //  
        const startTime = Date.now();
        // 
        this.currentRuleName = ruleName;
        this.currentRuleStack = [];
        this.isExecutingTopLevelRule = false;
        //  Sequence 
        const rootNode = {
            type: 'sequence',
            ruleName: ruleName,
            nodes: []
        };
        this.currentRuleStack.push(rootNode);
        try {
            // 
            // proxy
            const ruleMethod = proxy[ruleName];
            if (typeof ruleMethod === 'function') {
                this.isExecutingTopLevelRule = true;
                ruleMethod.call(proxy);
                this.isExecutingTopLevelRule = false;
            }
            //  AST
            this.ruleASTs.set(ruleName, rootNode);
            //  
            const elapsed = Date.now() - startTime;
            // 10
            if (elapsed > 10000) {
                console.error(` Rule "${ruleName}" took ${elapsed}ms (${(elapsed / 1000).toFixed(2)}s) - EXTREMELY SLOW!`);
            }
        } catch (error) {
            // 
            //  Proxy  AST
            this.ruleASTs.set(ruleName, rootNode);
        //  AST
        }
    }
    /**
     *  @SubhutiRule 
     *
     *  __isSubhutiRule__ 
     */ getAllRuleNames(parser) {
        const ruleNames = new Set();
        let prototype = Object.getPrototypeOf(parser);
        //  Object.prototype
        while(prototype && prototype !== Object.prototype){
            // 
            for (const key of Object.getOwnPropertyNames(prototype)){
                if (key === 'constructor') continue;
                const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
                if (descriptor && typeof descriptor.value === 'function') {
                    //   @SubhutiRule 
                    const method = descriptor.value;
                    if (method.__isSubhutiRule__ === true) {
                        ruleNames.add(key);
                    }
                }
            }
            // 
            prototype = Object.getPrototypeOf(prototype);
        }
        return Array.from(ruleNames);
    }
    // ============================================
    // Proxy 
    // ============================================
    /**
     *  Or 
     */ handleOr(alternatives, target) {
        const altNodes = [];
        for(let i = 0; i < alternatives.length; i++){
            const alt = alternatives[i];
            // 
            const seqNode = {
                type: 'sequence',
                nodes: []
            };
            this.currentRuleStack.push(seqNode);
            try {
                //  proxy 
                alt.alt.call(target);
                // 
                const result = this.currentRuleStack.pop();
                if (result) {
                    altNodes.push(result);
                }
            } catch (error) {
                // token
                // AST
                const result = this.currentRuleStack.pop();
                if (result && result.nodes && result.nodes.length > 0) {
                    // 
                    altNodes.push(result);
                }
            // 
            }
        }
        //  Or 
        if (altNodes.length > 0) {
            this.recordNode({
                type: 'or',
                alternatives: altNodes
            });
        }
    }
    /**
     *  Many 
     */ handleMany(fn, target) {
        const seqNode = {
            type: 'sequence',
            nodes: []
        };
        this.currentRuleStack.push(seqNode);
        try {
            // 
            fn.call(target);
            const innerNode = this.currentRuleStack.pop();
            if (innerNode) {
                this.recordNode({
                    type: 'many',
                    node: innerNode
                });
            }
        } catch (error) {
            // 
            const innerNode = this.currentRuleStack.pop();
            if (innerNode && innerNode.nodes && innerNode.nodes.length > 0) {
                this.recordNode({
                    type: 'many',
                    node: innerNode
                });
            }
        }
    }
    /**
     *  Option 
     */ handleOption(fn, target) {
        const seqNode = {
            type: 'sequence',
            nodes: []
        };
        this.currentRuleStack.push(seqNode);
        try {
            fn.call(target);
            const innerNode = this.currentRuleStack.pop();
            if (innerNode) {
                this.recordNode({
                    type: 'option',
                    node: innerNode
                });
            }
        } catch (error) {
            // 
            const innerNode = this.currentRuleStack.pop();
            if (innerNode && innerNode.nodes && innerNode.nodes.length > 0) {
                this.recordNode({
                    type: 'option',
                    node: innerNode
                });
            }
        }
    }
    /**
     *  AtLeastOne 
     */ handleAtLeastOne(fn, target) {
        const seqNode = {
            type: 'sequence',
            nodes: []
        };
        this.currentRuleStack.push(seqNode);
        try {
            fn.call(target);
            const innerNode = this.currentRuleStack.pop();
            if (innerNode) {
                this.recordNode({
                    type: 'atLeastOne',
                    node: innerNode
                });
            }
        } catch (error) {
            // 
            const innerNode = this.currentRuleStack.pop();
            if (innerNode && innerNode.nodes && innerNode.nodes.length > 0) {
                this.recordNode({
                    type: 'atLeastOne',
                    node: innerNode
                });
            }
        }
    }
    /**
     *  consume
     */ handleConsume(tokenName) {
        const tokenNode = {
            type: 'consume',
            tokenName
        };
        this.tokenAstCache.set(tokenName, tokenNode);
        this.recordNode(tokenNode);
    }
    /**
     * 
     */ handleSubrule(ruleName) {
        this.recordNode({
            type: 'subrule',
            ruleName
        });
    }
    /**
     * 
     */ recordNode(node) {
        const currentSeq = this.currentRuleStack[this.currentRuleStack.length - 1];
        if (currentSeq) {
            currentSeq.nodes.push(node);
        }
    }
    constructor(){
        /**  AST */ _define_property$7(this, "ruleASTs", new Map());
        _define_property$7(this, "tokenAstCache", new Map());
        /**  */ _define_property$7(this, "currentRuleStack", []);
        /**  */ _define_property$7(this, "currentRuleName", '');
        /**  */ _define_property$7(this, "isExecutingTopLevelRule", false);
        /**  */ _define_property$7(this, "executingRuleStack", new Set());
    }
}

function _define_property$6(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * 
 *
 * 
 * - children: Map<string, ArrayTrieNode> - key  token
 * - fullPaths: string[][] - 
 *
 * 
 *  ["If", "LParen", "Expression"] 
 * root -> "If" -> "LParen" -> "Expression"
 * 
 */ class ArrayTrieNode {
    constructor(){
        /** token->  */ _define_property$6(this, "children", new Map());
        /**  */ _define_property$6(this, "fullPaths", []);
    }
}
class ArrayTrie {
    /**
     * 
     *
     * 
     * 1.  root 
     * 2.  token
     * 3. 
     * 4. 
     * 5. 
     *
     * O(k)k=token
     */ insert(path) {
        let node = this.root;
        //  token
        for (const ruleName of path){
            // 
            if (!node.children.has(ruleName)) {
                node.children.set(ruleName, new ArrayTrieNode());
            }
            // 
            node = node.children.get(ruleName);
            //  
            // 
            node.fullPaths.push(path);
        }
    }
    /**
     * 
     */ findEqual(path) {
        let node = this.root;
        // 
        for (const token of path){
            if (!node.children.has(token)) {
                return null // 
                ;
            }
            node = node.children.get(token);
        }
        //  fullPaths 
        for (const fullPath of node.fullPaths){
            //   isEqual 
            if (this.isEqual(path, fullPath)) {
                return fullPath;
            }
        }
        return null;
    }
    /**
     *  prefix  prefix
     *
     * 
     * 1.  root 
     * 2.  prefix  token 
     * 3.  null
     * 4.  fullPaths 
     * 5. 
     *
     * O(k)k=token
     */ findPrefixMatch(prefix) {
        let node = this.root;
        //  
        for (const token of prefix){
            // 
            if (!node.children.has(token)) {
                return null;
            }
            // 
            node = node.children.get(token);
        }
        //  
        // fullPaths 
        for (const fullPath of node.fullPaths){
            // 
            //  fullPath  prefix 
            if (this.isPrefix(prefix, fullPath)) {
                return fullPath;
            }
        }
        // 
        return null;
    }
    /**
     * 
     *
     * 
     * 1. 
     * 2.  token
     *
     * O(k)k=
     *
     * @returns  true false
     * @param prefix
     * @param fullPath
     */ isEqual(prefix, fullPath) {
        // 
        if (prefix.length !== fullPath.length) {
            return false;
        }
        //   token
        for(let i = 0; i < prefix.length; i++){
            if (prefix[i] !== fullPath[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     *  prefix  fullPath 
     *
     * 
     * 1. 
     * 2.  token
     *
     * O(k)k=
     */ isPrefix(prefix, fullPath) {
        //   < 
        if (fullPath.length < prefix.length) {
            return false;
        }
        //   token
        for(let i = 0; i < prefix.length; i++){
            if (prefix[i] !== fullPath[i]) {
                return false;
            }
        }
        return true;
    }
    constructor(){
        _define_property$6(this, "root", new ArrayTrieNode());
    }
}

const validateInputs=(inputs)=>{
if(!Array.isArray(inputs)){
throw new TypeError("Argument must be an array of arrays")
}

inputs.forEach(validateInput);
validateDimensions(inputs);
validateCombinations(inputs);
};

const validateInput=(input)=>{
if(!Array.isArray(input)){
throw new TypeError(`Argument must be an array: ${input}`)
}
};




const validateDimensions=({length})=>{
if(length>=MAX_DIMENSIONS){
throw new TypeError(
`Too many arrays (${length}): please use the 'big-cartesian' library instead of 'fast-cartesian'`
)
}
};

const MAX_DIMENSIONS=100;


const validateCombinations=(inputs)=>{
const size=inputs.reduce(multiplySize,1);

if(size>=MAX_SIZE){
const sizeStr=Number.isFinite(size)?` (${size.toExponential(0)})`:"";
throw new TypeError(
`Too many combinations${sizeStr}: please use the 'big-cartesian' library instead of 'fast-cartesian'`
)
}
};

const multiplySize=(size,input)=>size*input.length;


const MAX_SIZE=2**32;

const fastCartesian=(
inputs)=>
{
validateInputs(inputs);
const result=[];

if(inputs.length===0){
return result
}

const loopFunc=getLoopFunc(inputs.length);
loopFunc(inputs,result);
return result
};










const getLoopFunc=(length)=>{
const cachedLoopFunc=cache[length];

if(cachedLoopFunc!==undefined){
return cachedLoopFunc
}

const loopFunc=mGetLoopFunc(length);

cache[length]=loopFunc;
return loopFunc
};

const cache={};










const mGetLoopFunc=(length)=>{
const indexes=Array.from({length},getIndex);
const start=indexes.
map((index)=>`for (const value${index} of arrays[${index}]) {`).
join("\n");
const middle=indexes.map((index)=>`value${index}`).join(", ");
const end="}\n".repeat(length);


return new Function(
"arrays",
"result",
`${start}\nresult.push([${middle}])\n${end}`
)
};

const getIndex=(value,index)=>String(index);

var graph;
var hasRequiredGraph;

function requireGraph () {
	if (hasRequiredGraph) return graph;
	hasRequiredGraph = 1;

	var DEFAULT_EDGE_NAME = "\x00";
	var GRAPH_NODE = "\x00";
	var EDGE_KEY_DELIM = "\x01";

	// Implementation notes:
	//
	//  * Node id query functions should return string ids for the nodes
	//  * Edge id query functions should return an "edgeObj", edge object, that is
	//    composed of enough information to uniquely identify an edge: {v, w, name}.
	//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
	//    reference edges. This is because we need a performant way to look these
	//    edges up and, object properties, which have string keys, are the closest
	//    we're going to get to a performant hashtable in JavaScript.

	class Graph {
	  _isDirected = true;
	  _isMultigraph = false;
	  _isCompound = false;

	  // Label for the graph itself
	  _label;

	  // Defaults to be set when creating a new node
	  _defaultNodeLabelFn = () => undefined;

	  // Defaults to be set when creating a new edge
	  _defaultEdgeLabelFn = () => undefined;

	  // v -> label
	  _nodes = {};

	  // v -> edgeObj
	  _in = {};

	  // u -> v -> Number
	  _preds = {};

	  // v -> edgeObj
	  _out = {};

	  // v -> w -> Number
	  _sucs = {};

	  // e -> edgeObj
	  _edgeObjs = {};

	  // e -> label
	  _edgeLabels = {};

	  /* Number of nodes in the graph. Should only be changed by the implementation. */
	  _nodeCount = 0;

	  /* Number of edges in the graph. Should only be changed by the implementation. */
	  _edgeCount = 0;

	  _parent;

	  _children;

	  constructor(opts) {
	    if (opts) {
	      this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : true;
	      this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : false;
	      this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : false;
	    }

	    if (this._isCompound) {
	      // v -> parent
	      this._parent = {};

	      // v -> children
	      this._children = {};
	      this._children[GRAPH_NODE] = {};
	    }
	  }

	  /* === Graph functions ========= */

	  /**
	   * Whether graph was created with 'directed' flag set to true or not.
	   */
	  isDirected() {
	    return this._isDirected;
	  }

	  /**
	   * Whether graph was created with 'multigraph' flag set to true or not.
	   */
	  isMultigraph() {
	    return this._isMultigraph;
	  }

	  /**
	   * Whether graph was created with 'compound' flag set to true or not.
	   */
	  isCompound() {
	    return this._isCompound;
	  }

	  /**
	   * Sets the label of the graph.
	   */
	  setGraph(label) {
	    this._label = label;
	    return this;
	  }

	  /**
	   * Gets the graph label.
	   */
	  graph() {
	    return this._label;
	  }


	  /* === Node functions ========== */

	  /**
	   * Sets the default node label. If newDefault is a function, it will be
	   * invoked ach time when setting a label for a node. Otherwise, this label
	   * will be assigned as default label in case if no label was specified while
	   * setting a node.
	   * Complexity: O(1).
	   */
	  setDefaultNodeLabel(newDefault) {
	    this._defaultNodeLabelFn = newDefault;
	    if (typeof newDefault !== 'function') {
	      this._defaultNodeLabelFn = () => newDefault;
	    }

	    return this;
	  }

	  /**
	   * Gets the number of nodes in the graph.
	   * Complexity: O(1).
	   */
	  nodeCount() {
	    return this._nodeCount;
	  }

	  /**
	   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
	   * not included in list.
	   * Complexity: O(1).
	   */
	  nodes() {
	    return Object.keys(this._nodes);
	  }

	  /**
	   * Gets list of nodes without in-edges.
	   * Complexity: O(|V|).
	   */
	  sources() {
	    var self = this;
	    return this.nodes().filter(v => Object.keys(self._in[v]).length === 0);
	  }

	  /**
	   * Gets list of nodes without out-edges.
	   * Complexity: O(|V|).
	   */
	  sinks() {
	    var self = this;
	    return this.nodes().filter(v => Object.keys(self._out[v]).length === 0);
	  }

	  /**
	   * Invokes setNode method for each node in names list.
	   * Complexity: O(|names|).
	   */
	  setNodes(vs, value) {
	    var args = arguments;
	    var self = this;
	    vs.forEach(function(v) {
	      if (args.length > 1) {
	        self.setNode(v, value);
	      } else {
	        self.setNode(v);
	      }
	    });
	    return this;
	  }

	  /**
	   * Creates or updates the value for the node v in the graph. If label is supplied
	   * it is set as the value for the node. If label is not supplied and the node was
	   * created by this call then the default node label will be assigned.
	   * Complexity: O(1).
	   */
	  setNode(v, value) {
	    if (Object.hasOwn(this._nodes, v)) {
	      if (arguments.length > 1) {
	        this._nodes[v] = value;
	      }
	      return this;
	    }

	    this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
	    if (this._isCompound) {
	      this._parent[v] = GRAPH_NODE;
	      this._children[v] = {};
	      this._children[GRAPH_NODE][v] = true;
	    }
	    this._in[v] = {};
	    this._preds[v] = {};
	    this._out[v] = {};
	    this._sucs[v] = {};
	    ++this._nodeCount;
	    return this;
	  }

	  /**
	   * Gets the label of node with specified name.
	   * Complexity: O(|V|).
	   */
	  node(v) {
	    return this._nodes[v];
	  }

	  /**
	   * Detects whether graph has a node with specified name or not.
	   */
	  hasNode(v) {
	    return Object.hasOwn(this._nodes, v);
	  }

	  /**
	   * Remove the node with the name from the graph or do nothing if the node is not in
	   * the graph. If the node was removed this function also removes any incident
	   * edges.
	   * Complexity: O(1).
	   */
	  removeNode(v) {
	    var self = this;
	    if (Object.hasOwn(this._nodes, v)) {
	      var removeEdge = e => self.removeEdge(self._edgeObjs[e]);
	      delete this._nodes[v];
	      if (this._isCompound) {
	        this._removeFromParentsChildList(v);
	        delete this._parent[v];
	        this.children(v).forEach(function(child) {
	          self.setParent(child);
	        });
	        delete this._children[v];
	      }
	      Object.keys(this._in[v]).forEach(removeEdge);
	      delete this._in[v];
	      delete this._preds[v];
	      Object.keys(this._out[v]).forEach(removeEdge);
	      delete this._out[v];
	      delete this._sucs[v];
	      --this._nodeCount;
	    }
	    return this;
	  }

	  /**
	   * Sets node p as a parent for node v if it is defined, or removes the
	   * parent for v if p is undefined. Method throws an exception in case of
	   * invoking it in context of noncompound graph.
	   * Average-case complexity: O(1).
	   */
	  setParent(v, parent) {
	    if (!this._isCompound) {
	      throw new Error("Cannot set parent in a non-compound graph");
	    }

	    if (parent === undefined) {
	      parent = GRAPH_NODE;
	    } else {
	      // Coerce parent to string
	      parent += "";
	      for (var ancestor = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {
	        if (ancestor === v) {
	          throw new Error("Setting " + parent+ " as parent of " + v +
	              " would create a cycle");
	        }
	      }

	      this.setNode(parent);
	    }

	    this.setNode(v);
	    this._removeFromParentsChildList(v);
	    this._parent[v] = parent;
	    this._children[parent][v] = true;
	    return this;
	  }

	  _removeFromParentsChildList(v) {
	    delete this._children[this._parent[v]][v];
	  }

	  /**
	   * Gets parent node for node v.
	   * Complexity: O(1).
	   */
	  parent(v) {
	    if (this._isCompound) {
	      var parent = this._parent[v];
	      if (parent !== GRAPH_NODE) {
	        return parent;
	      }
	    }
	  }

	  /**
	   * Gets list of direct children of node v.
	   * Complexity: O(1).
	   */
	  children(v = GRAPH_NODE) {
	    if (this._isCompound) {
	      var children = this._children[v];
	      if (children) {
	        return Object.keys(children);
	      }
	    } else if (v === GRAPH_NODE) {
	      return this.nodes();
	    } else if (this.hasNode(v)) {
	      return [];
	    }
	  }

	  /**
	   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
	   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
	   * Complexity: O(|V|).
	   */
	  predecessors(v) {
	    var predsV = this._preds[v];
	    if (predsV) {
	      return Object.keys(predsV);
	    }
	  }

	  /**
	   * Return all nodes that are successors of the specified node or undefined if node v is not in
	   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
	   * Complexity: O(|V|).
	   */
	  successors(v) {
	    var sucsV = this._sucs[v];
	    if (sucsV) {
	      return Object.keys(sucsV);
	    }
	  }

	  /**
	   * Return all nodes that are predecessors or successors of the specified node or undefined if
	   * node v is not in the graph.
	   * Complexity: O(|V|).
	   */
	  neighbors(v) {
	    var preds = this.predecessors(v);
	    if (preds) {
	      const union = new Set(preds);
	      for (var succ of this.successors(v)) {
	        union.add(succ);
	      }

	      return Array.from(union.values());
	    }
	  }

	  isLeaf(v) {
	    var neighbors;
	    if (this.isDirected()) {
	      neighbors = this.successors(v);
	    } else {
	      neighbors = this.neighbors(v);
	    }
	    return neighbors.length === 0;
	  }

	  /**
	   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
	   * are also removed. In case of compound graph, if parent is rejected by filter,
	   * than all its children are rejected too.
	   * Average-case complexity: O(|E|+|V|).
	   */
	  filterNodes(filter) {
	    var copy = new this.constructor({
	      directed: this._isDirected,
	      multigraph: this._isMultigraph,
	      compound: this._isCompound
	    });

	    copy.setGraph(this.graph());

	    var self = this;
	    Object.entries(this._nodes).forEach(function([v, value]) {
	      if (filter(v)) {
	        copy.setNode(v, value);
	      }
	    });

	    Object.values(this._edgeObjs).forEach(function(e) {
	      if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
	        copy.setEdge(e, self.edge(e));
	      }
	    });

	    var parents = {};
	    function findParent(v) {
	      var parent = self.parent(v);
	      if (parent === undefined || copy.hasNode(parent)) {
	        parents[v] = parent;
	        return parent;
	      } else if (parent in parents) {
	        return parents[parent];
	      } else {
	        return findParent(parent);
	      }
	    }

	    if (this._isCompound) {
	      copy.nodes().forEach(v => copy.setParent(v, findParent(v)));
	    }

	    return copy;
	  }

	  /* === Edge functions ========== */

	  /**
	   * Sets the default edge label or factory function. This label will be
	   * assigned as default label in case if no label was specified while setting
	   * an edge or this function will be invoked each time when setting an edge
	   * with no label specified and returned value * will be used as a label for edge.
	   * Complexity: O(1).
	   */
	  setDefaultEdgeLabel(newDefault) {
	    this._defaultEdgeLabelFn = newDefault;
	    if (typeof newDefault !== 'function') {
	      this._defaultEdgeLabelFn = () => newDefault;
	    }

	    return this;
	  }

	  /**
	   * Gets the number of edges in the graph.
	   * Complexity: O(1).
	   */
	  edgeCount() {
	    return this._edgeCount;
	  }

	  /**
	   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
	   * Complexity: O(|E|).
	   */
	  edges() {
	    return Object.values(this._edgeObjs);
	  }

	  /**
	   * Establish an edges path over the nodes in nodes list. If some edge is already
	   * exists, it will update its label, otherwise it will create an edge between pair
	   * of nodes with label provided or default label if no label provided.
	   * Complexity: O(|nodes|).
	   */
	  setPath(vs, value) {
	    var self = this;
	    var args = arguments;
	    vs.reduce(function(v, w) {
	      if (args.length > 1) {
	        self.setEdge(v, w, value);
	      } else {
	        self.setEdge(v, w);
	      }
	      return w;
	    });
	    return this;
	  }

	  /**
	   * Creates or updates the label for the edge (v, w) with the optionally supplied
	   * name. If label is supplied it is set as the value for the edge. If label is not
	   * supplied and the edge was created by this call then the default edge label will
	   * be assigned. The name parameter is only useful with multigraphs.
	   */
	  setEdge() {
	    var v, w, name, value;
	    var valueSpecified = false;
	    var arg0 = arguments[0];

	    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
	      v = arg0.v;
	      w = arg0.w;
	      name = arg0.name;
	      if (arguments.length === 2) {
	        value = arguments[1];
	        valueSpecified = true;
	      }
	    } else {
	      v = arg0;
	      w = arguments[1];
	      name = arguments[3];
	      if (arguments.length > 2) {
	        value = arguments[2];
	        valueSpecified = true;
	      }
	    }

	    v = "" + v;
	    w = "" + w;
	    if (name !== undefined) {
	      name = "" + name;
	    }

	    var e = edgeArgsToId(this._isDirected, v, w, name);
	    if (Object.hasOwn(this._edgeLabels, e)) {
	      if (valueSpecified) {
	        this._edgeLabels[e] = value;
	      }
	      return this;
	    }

	    if (name !== undefined && !this._isMultigraph) {
	      throw new Error("Cannot set a named edge when isMultigraph = false");
	    }

	    // It didn't exist, so we need to create it.
	    // First ensure the nodes exist.
	    this.setNode(v);
	    this.setNode(w);

	    this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

	    var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
	    // Ensure we add undirected edges in a consistent way.
	    v = edgeObj.v;
	    w = edgeObj.w;

	    Object.freeze(edgeObj);
	    this._edgeObjs[e] = edgeObj;
	    incrementOrInitEntry(this._preds[w], v);
	    incrementOrInitEntry(this._sucs[v], w);
	    this._in[w][e] = edgeObj;
	    this._out[v][e] = edgeObj;
	    this._edgeCount++;
	    return this;
	  }

	  /**
	   * Gets the label for the specified edge.
	   * Complexity: O(1).
	   */
	  edge(v, w, name) {
	    var e = (arguments.length === 1
	      ? edgeObjToId(this._isDirected, arguments[0])
	      : edgeArgsToId(this._isDirected, v, w, name));
	    return this._edgeLabels[e];
	  }

	  /**
	   * Gets the label for the specified edge and converts it to an object.
	   * Complexity: O(1)
	   */
	  edgeAsObj() {
	    const edge = this.edge(...arguments);
	    if (typeof edge !== "object") {
	      return {label: edge};
	    }

	    return edge;
	  }

	  /**
	   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
	   * Complexity: O(1).
	   */
	  hasEdge(v, w, name) {
	    var e = (arguments.length === 1
	      ? edgeObjToId(this._isDirected, arguments[0])
	      : edgeArgsToId(this._isDirected, v, w, name));
	    return Object.hasOwn(this._edgeLabels, e);
	  }

	  /**
	   * Removes the specified edge from the graph. No subgraphs are considered.
	   * Complexity: O(1).
	   */
	  removeEdge(v, w, name) {
	    var e = (arguments.length === 1
	      ? edgeObjToId(this._isDirected, arguments[0])
	      : edgeArgsToId(this._isDirected, v, w, name));
	    var edge = this._edgeObjs[e];
	    if (edge) {
	      v = edge.v;
	      w = edge.w;
	      delete this._edgeLabels[e];
	      delete this._edgeObjs[e];
	      decrementOrRemoveEntry(this._preds[w], v);
	      decrementOrRemoveEntry(this._sucs[v], w);
	      delete this._in[w][e];
	      delete this._out[v][e];
	      this._edgeCount--;
	    }
	    return this;
	  }

	  /**
	   * Return all edges that point to the node v. Optionally filters those edges down to just those
	   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
	   * Complexity: O(|E|).
	   */
	  inEdges(v, u) {
	    var inV = this._in[v];
	    if (inV) {
	      var edges = Object.values(inV);
	      if (!u) {
	        return edges;
	      }
	      return edges.filter(edge => edge.v === u);
	    }
	  }

	  /**
	   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
	   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
	   * Complexity: O(|E|).
	   */
	  outEdges(v, w) {
	    var outV = this._out[v];
	    if (outV) {
	      var edges = Object.values(outV);
	      if (!w) {
	        return edges;
	      }
	      return edges.filter(edge => edge.w === w);
	    }
	  }

	  /**
	   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
	   * down to just those between nodes v and w regardless of direction.
	   * Complexity: O(|E|).
	   */
	  nodeEdges(v, w) {
	    var inEdges = this.inEdges(v, w);
	    if (inEdges) {
	      return inEdges.concat(this.outEdges(v, w));
	    }
	  }
	}

	function incrementOrInitEntry(map, k) {
	  if (map[k]) {
	    map[k]++;
	  } else {
	    map[k] = 1;
	  }
	}

	function decrementOrRemoveEntry(map, k) {
	  if (!--map[k]) { delete map[k]; }
	}

	function edgeArgsToId(isDirected, v_, w_, name) {
	  var v = "" + v_;
	  var w = "" + w_;
	  if (!isDirected && v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }
	  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
	             (name === undefined ? DEFAULT_EDGE_NAME : name);
	}

	function edgeArgsToObj(isDirected, v_, w_, name) {
	  var v = "" + v_;
	  var w = "" + w_;
	  if (!isDirected && v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }
	  var edgeObj =  { v: v, w: w };
	  if (name) {
	    edgeObj.name = name;
	  }
	  return edgeObj;
	}

	function edgeObjToId(isDirected, edgeObj) {
	  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
	}

	graph = Graph;
	return graph;
}

var version;
var hasRequiredVersion;

function requireVersion () {
	if (hasRequiredVersion) return version;
	hasRequiredVersion = 1;
	version = '2.2.4';
	return version;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	// Includes only the "core" of graphlib
	lib = {
	  Graph: requireGraph(),
	  version: requireVersion()
	};
	return lib;
}

var json;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;
	var Graph = requireGraph();

	json = {
	  write: write,
	  read: read
	};

	/**
	 * Creates a JSON representation of the graph that can be serialized to a string with
	 * JSON.stringify. The graph can later be restored using json.read.
	 */
	function write(g) {
	  var json = {
	    options: {
	      directed: g.isDirected(),
	      multigraph: g.isMultigraph(),
	      compound: g.isCompound()
	    },
	    nodes: writeNodes(g),
	    edges: writeEdges(g)
	  };

	  if (g.graph() !== undefined) {
	    json.value = structuredClone(g.graph());
	  }
	  return json;
	}

	function writeNodes(g) {
	  return g.nodes().map(function(v) {
	    var nodeValue = g.node(v);
	    var parent = g.parent(v);
	    var node = { v: v };
	    if (nodeValue !== undefined) {
	      node.value = nodeValue;
	    }
	    if (parent !== undefined) {
	      node.parent = parent;
	    }
	    return node;
	  });
	}

	function writeEdges(g) {
	  return g.edges().map(function(e) {
	    var edgeValue = g.edge(e);
	    var edge = { v: e.v, w: e.w };
	    if (e.name !== undefined) {
	      edge.name = e.name;
	    }
	    if (edgeValue !== undefined) {
	      edge.value = edgeValue;
	    }
	    return edge;
	  });
	}

	/**
	 * Takes JSON as input and returns the graph representation.
	 *
	 * @example
	 * var g2 = graphlib.json.read(JSON.parse(str));
	 * g2.nodes();
	 * // ['a', 'b']
	 * g2.edges()
	 * // [ { v: 'a', w: 'b' } ]
	 */
	function read(json) {
	  var g = new Graph(json.options).setGraph(json.value);
	  json.nodes.forEach(function(entry) {
	    g.setNode(entry.v, entry.value);
	    if (entry.parent) {
	      g.setParent(entry.v, entry.parent);
	    }
	  });
	  json.edges.forEach(function(entry) {
	    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
	  });
	  return g;
	}
	return json;
}

var components_1;
var hasRequiredComponents;

function requireComponents () {
	if (hasRequiredComponents) return components_1;
	hasRequiredComponents = 1;
	components_1 = components;

	function components(g) {
	  var visited = {};
	  var cmpts = [];
	  var cmpt;

	  function dfs(v) {
	    if (Object.hasOwn(visited, v)) return;
	    visited[v] = true;
	    cmpt.push(v);
	    g.successors(v).forEach(dfs);
	    g.predecessors(v).forEach(dfs);
	  }

	  g.nodes().forEach(function(v) {
	    cmpt = [];
	    dfs(v);
	    if (cmpt.length) {
	      cmpts.push(cmpt);
	    }
	  });

	  return cmpts;
	}
	return components_1;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */

var priorityQueue;
var hasRequiredPriorityQueue;

function requirePriorityQueue () {
	if (hasRequiredPriorityQueue) return priorityQueue;
	hasRequiredPriorityQueue = 1;
	class PriorityQueue {
	  _arr = [];
	  _keyIndices = {};

	  /**
	   * Returns the number of elements in the queue. Takes `O(1)` time.
	   */
	  size() {
	    return this._arr.length;
	  }

	  /**
	   * Returns the keys that are in the queue. Takes `O(n)` time.
	   */
	  keys() {
	    return this._arr.map(function(x) { return x.key; });
	  }

	  /**
	   * Returns `true` if **key** is in the queue and `false` if not.
	   */
	  has(key) {
	    return Object.hasOwn(this._keyIndices, key);
	  }

	  /**
	   * Returns the priority for **key**. If **key** is not present in the queue
	   * then this function returns `undefined`. Takes `O(1)` time.
	   *
	   * @param {Object} key
	   */
	  priority(key) {
	    var index = this._keyIndices[key];
	    if (index !== undefined) {
	      return this._arr[index].priority;
	    }
	  }

	  /**
	   * Returns the key for the minimum element in this queue. If the queue is
	   * empty this function throws an Error. Takes `O(1)` time.
	   */
	  min() {
	    if (this.size() === 0) {
	      throw new Error("Queue underflow");
	    }
	    return this._arr[0].key;
	  }

	  /**
	   * Inserts a new key into the priority queue. If the key already exists in
	   * the queue this function returns `false`; otherwise it will return `true`.
	   * Takes `O(n)` time.
	   *
	   * @param {Object} key the key to add
	   * @param {Number} priority the initial priority for the key
	   */
	  add(key, priority) {
	    var keyIndices = this._keyIndices;
	    key = String(key);
	    if (!Object.hasOwn(keyIndices, key)) {
	      var arr = this._arr;
	      var index = arr.length;
	      keyIndices[key] = index;
	      arr.push({key: key, priority: priority});
	      this._decrease(index);
	      return true;
	    }
	    return false;
	  }

	  /**
	   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
	   */
	  removeMin() {
	    this._swap(0, this._arr.length - 1);
	    var min = this._arr.pop();
	    delete this._keyIndices[min.key];
	    this._heapify(0);
	    return min.key;
	  }

	  /**
	   * Decreases the priority for **key** to **priority**. If the new priority is
	   * greater than the previous priority, this function will throw an Error.
	   *
	   * @param {Object} key the key for which to raise priority
	   * @param {Number} priority the new priority for the key
	   */
	  decrease(key, priority) {
	    var index = this._keyIndices[key];
	    if (priority > this._arr[index].priority) {
	      throw new Error("New priority is greater than current priority. " +
	          "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
	    }
	    this._arr[index].priority = priority;
	    this._decrease(index);
	  }

	  _heapify(i) {
	    var arr = this._arr;
	    var l = 2 * i;
	    var r = l + 1;
	    var largest = i;
	    if (l < arr.length) {
	      largest = arr[l].priority < arr[largest].priority ? l : largest;
	      if (r < arr.length) {
	        largest = arr[r].priority < arr[largest].priority ? r : largest;
	      }
	      if (largest !== i) {
	        this._swap(i, largest);
	        this._heapify(largest);
	      }
	    }
	  }

	  _decrease(index) {
	    var arr = this._arr;
	    var priority = arr[index].priority;
	    var parent;
	    while (index !== 0) {
	      parent = index >> 1;
	      if (arr[parent].priority < priority) {
	        break;
	      }
	      this._swap(index, parent);
	      index = parent;
	    }
	  }

	  _swap(i, j) {
	    var arr = this._arr;
	    var keyIndices = this._keyIndices;
	    var origArrI = arr[i];
	    var origArrJ = arr[j];
	    arr[i] = origArrJ;
	    arr[j] = origArrI;
	    keyIndices[origArrJ.key] = i;
	    keyIndices[origArrI.key] = j;
	  }
	}

	priorityQueue = PriorityQueue;
	return priorityQueue;
}

var dijkstra_1;
var hasRequiredDijkstra;

function requireDijkstra () {
	if (hasRequiredDijkstra) return dijkstra_1;
	hasRequiredDijkstra = 1;
	var PriorityQueue = requirePriorityQueue();

	dijkstra_1 = dijkstra;

	var DEFAULT_WEIGHT_FUNC = () => 1;

	function dijkstra(g, source, weightFn, edgeFn) {
	  return runDijkstra(g, String(source),
	    weightFn || DEFAULT_WEIGHT_FUNC,
	    edgeFn || function(v) { return g.outEdges(v); });
	}

	function runDijkstra(g, source, weightFn, edgeFn) {
	  var results = {};
	  var pq = new PriorityQueue();
	  var v, vEntry;

	  var updateNeighbors = function(edge) {
	    var w = edge.v !== v ? edge.v : edge.w;
	    var wEntry = results[w];
	    var weight = weightFn(edge);
	    var distance = vEntry.distance + weight;

	    if (weight < 0) {
	      throw new Error("dijkstra does not allow negative edge weights. " +
	                      "Bad edge: " + edge + " Weight: " + weight);
	    }

	    if (distance < wEntry.distance) {
	      wEntry.distance = distance;
	      wEntry.predecessor = v;
	      pq.decrease(w, distance);
	    }
	  };

	  g.nodes().forEach(function(v) {
	    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
	    results[v] = { distance: distance };
	    pq.add(v, distance);
	  });

	  while (pq.size() > 0) {
	    v = pq.removeMin();
	    vEntry = results[v];
	    if (vEntry.distance === Number.POSITIVE_INFINITY) {
	      break;
	    }

	    edgeFn(v).forEach(updateNeighbors);
	  }

	  return results;
	}
	return dijkstra_1;
}

var dijkstraAll_1;
var hasRequiredDijkstraAll;

function requireDijkstraAll () {
	if (hasRequiredDijkstraAll) return dijkstraAll_1;
	hasRequiredDijkstraAll = 1;
	var dijkstra = requireDijkstra();

	dijkstraAll_1 = dijkstraAll;

	function dijkstraAll(g, weightFunc, edgeFunc) {
	  return g.nodes().reduce(function(acc, v) {
	    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
	    return acc;
	  }, {});
	}
	return dijkstraAll_1;
}

var tarjan_1;
var hasRequiredTarjan;

function requireTarjan () {
	if (hasRequiredTarjan) return tarjan_1;
	hasRequiredTarjan = 1;
	tarjan_1 = tarjan;

	function tarjan(g) {
	  var index = 0;
	  var stack = [];
	  var visited = {}; // node id -> { onStack, lowlink, index }
	  var results = [];

	  function dfs(v) {
	    var entry = visited[v] = {
	      onStack: true,
	      lowlink: index,
	      index: index++
	    };
	    stack.push(v);

	    g.successors(v).forEach(function(w) {
	      if (!Object.hasOwn(visited, w)) {
	        dfs(w);
	        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
	      } else if (visited[w].onStack) {
	        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
	      }
	    });

	    if (entry.lowlink === entry.index) {
	      var cmpt = [];
	      var w;
	      do {
	        w = stack.pop();
	        visited[w].onStack = false;
	        cmpt.push(w);
	      } while (v !== w);
	      results.push(cmpt);
	    }
	  }

	  g.nodes().forEach(function(v) {
	    if (!Object.hasOwn(visited, v)) {
	      dfs(v);
	    }
	  });

	  return results;
	}
	return tarjan_1;
}

var findCycles_1;
var hasRequiredFindCycles;

function requireFindCycles () {
	if (hasRequiredFindCycles) return findCycles_1;
	hasRequiredFindCycles = 1;
	var tarjan = requireTarjan();

	findCycles_1 = findCycles;

	function findCycles(g) {
	  return tarjan(g).filter(function(cmpt) {
	    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
	  });
	}
	return findCycles_1;
}

var floydWarshall_1;
var hasRequiredFloydWarshall;

function requireFloydWarshall () {
	if (hasRequiredFloydWarshall) return floydWarshall_1;
	hasRequiredFloydWarshall = 1;
	floydWarshall_1 = floydWarshall;

	var DEFAULT_WEIGHT_FUNC = () => 1;

	function floydWarshall(g, weightFn, edgeFn) {
	  return runFloydWarshall(g,
	    weightFn || DEFAULT_WEIGHT_FUNC,
	    edgeFn || function(v) { return g.outEdges(v); });
	}

	function runFloydWarshall(g, weightFn, edgeFn) {
	  var results = {};
	  var nodes = g.nodes();

	  nodes.forEach(function(v) {
	    results[v] = {};
	    results[v][v] = { distance: 0 };
	    nodes.forEach(function(w) {
	      if (v !== w) {
	        results[v][w] = { distance: Number.POSITIVE_INFINITY };
	      }
	    });
	    edgeFn(v).forEach(function(edge) {
	      var w = edge.v === v ? edge.w : edge.v;
	      var d = weightFn(edge);
	      results[v][w] = { distance: d, predecessor: v };
	    });
	  });

	  nodes.forEach(function(k) {
	    var rowK = results[k];
	    nodes.forEach(function(i) {
	      var rowI = results[i];
	      nodes.forEach(function(j) {
	        var ik = rowI[k];
	        var kj = rowK[j];
	        var ij = rowI[j];
	        var altDistance = ik.distance + kj.distance;
	        if (altDistance < ij.distance) {
	          ij.distance = altDistance;
	          ij.predecessor = kj.predecessor;
	        }
	      });
	    });
	  });

	  return results;
	}
	return floydWarshall_1;
}

var topsort_1;
var hasRequiredTopsort;

function requireTopsort () {
	if (hasRequiredTopsort) return topsort_1;
	hasRequiredTopsort = 1;
	function topsort(g) {
	  var visited = {};
	  var stack = {};
	  var results = [];

	  function visit(node) {
	    if (Object.hasOwn(stack, node)) {
	      throw new CycleException();
	    }

	    if (!Object.hasOwn(visited, node)) {
	      stack[node] = true;
	      visited[node] = true;
	      g.predecessors(node).forEach(visit);
	      delete stack[node];
	      results.push(node);
	    }
	  }

	  g.sinks().forEach(visit);

	  if (Object.keys(visited).length !== g.nodeCount()) {
	    throw new CycleException();
	  }

	  return results;
	}

	class CycleException extends Error {
	  constructor() {
	    super(...arguments);
	  }
	}

	topsort_1 = topsort;
	topsort.CycleException = CycleException;
	return topsort_1;
}

var isAcyclic_1;
var hasRequiredIsAcyclic;

function requireIsAcyclic () {
	if (hasRequiredIsAcyclic) return isAcyclic_1;
	hasRequiredIsAcyclic = 1;
	var topsort = requireTopsort();

	isAcyclic_1 = isAcyclic;

	function isAcyclic(g) {
	  try {
	    topsort(g);
	  } catch (e) {
	    if (e instanceof topsort.CycleException) {
	      return false;
	    }
	    throw e;
	  }
	  return true;
	}
	return isAcyclic_1;
}

var dfs_1;
var hasRequiredDfs;

function requireDfs () {
	if (hasRequiredDfs) return dfs_1;
	hasRequiredDfs = 1;
	dfs_1 = dfs;

	/*
	 * A helper that preforms a pre- or post-order traversal on the input graph
	 * and returns the nodes in the order they were visited. If the graph is
	 * undirected then this algorithm will navigate using neighbors. If the graph
	 * is directed then this algorithm will navigate using successors.
	 *
	 * If the order is not "post", it will be treated as "pre".
	 */
	function dfs(g, vs, order) {
	  if (!Array.isArray(vs)) {
	    vs = [vs];
	  }

	  var navigation = g.isDirected() ? v => g.successors(v) : v => g.neighbors(v);
	  var orderFunc = order === "post" ? postOrderDfs : preOrderDfs;

	  var acc = [];
	  var visited = {};
	  vs.forEach(v => {
	    if (!g.hasNode(v)) {
	      throw new Error("Graph does not have node: " + v);
	    }

	    orderFunc(v, navigation, visited, acc);
	  });

	  return acc;
	}

	function postOrderDfs(v, navigation, visited, acc) {
	  var stack = [[v, false]];
	  while (stack.length > 0) {
	    var curr = stack.pop();
	    if (curr[1]) {
	      acc.push(curr[0]);
	    } else {
	      if (!Object.hasOwn(visited, curr[0])) {
	        visited[curr[0]] = true;
	        stack.push([curr[0], true]);
	        forEachRight(navigation(curr[0]), w => stack.push([w, false]));
	      }
	    }
	  }
	}

	function preOrderDfs(v, navigation, visited, acc) {
	  var stack = [v];
	  while (stack.length > 0) {
	    var curr = stack.pop();
	    if (!Object.hasOwn(visited, curr)) {
	      visited[curr] = true;
	      acc.push(curr);
	      forEachRight(navigation(curr), w => stack.push(w));
	    }
	  }
	}

	function forEachRight(array, iteratee) {
	  var length = array.length;
	  while (length--) {
	    iteratee(array[length], length, array);
	  }

	  return array;
	}
	return dfs_1;
}

var postorder_1;
var hasRequiredPostorder;

function requirePostorder () {
	if (hasRequiredPostorder) return postorder_1;
	hasRequiredPostorder = 1;
	var dfs = requireDfs();

	postorder_1 = postorder;

	function postorder(g, vs) {
	  return dfs(g, vs, "post");
	}
	return postorder_1;
}

var preorder_1;
var hasRequiredPreorder;

function requirePreorder () {
	if (hasRequiredPreorder) return preorder_1;
	hasRequiredPreorder = 1;
	var dfs = requireDfs();

	preorder_1 = preorder;

	function preorder(g, vs) {
	  return dfs(g, vs, "pre");
	}
	return preorder_1;
}

var prim_1;
var hasRequiredPrim;

function requirePrim () {
	if (hasRequiredPrim) return prim_1;
	hasRequiredPrim = 1;
	var Graph = requireGraph();
	var PriorityQueue = requirePriorityQueue();

	prim_1 = prim;

	function prim(g, weightFunc) {
	  var result = new Graph();
	  var parents = {};
	  var pq = new PriorityQueue();
	  var v;

	  function updateNeighbors(edge) {
	    var w = edge.v === v ? edge.w : edge.v;
	    var pri = pq.priority(w);
	    if (pri !== undefined) {
	      var edgeWeight = weightFunc(edge);
	      if (edgeWeight < pri) {
	        parents[w] = v;
	        pq.decrease(w, edgeWeight);
	      }
	    }
	  }

	  if (g.nodeCount() === 0) {
	    return result;
	  }

	  g.nodes().forEach(function(v) {
	    pq.add(v, Number.POSITIVE_INFINITY);
	    result.setNode(v);
	  });

	  // Start from an arbitrary node
	  pq.decrease(g.nodes()[0], 0);

	  var init = false;
	  while (pq.size() > 0) {
	    v = pq.removeMin();
	    if (Object.hasOwn(parents, v)) {
	      result.setEdge(v, parents[v]);
	    } else if (init) {
	      throw new Error("Input graph is not connected: " + g);
	    } else {
	      init = true;
	    }

	    g.nodeEdges(v).forEach(updateNeighbors);
	  }

	  return result;
	}
	return prim_1;
}

var alg$1;
var hasRequiredAlg;

function requireAlg () {
	if (hasRequiredAlg) return alg$1;
	hasRequiredAlg = 1;
	alg$1 = {
	  components: requireComponents(),
	  dijkstra: requireDijkstra(),
	  dijkstraAll: requireDijkstraAll(),
	  findCycles: requireFindCycles(),
	  floydWarshall: requireFloydWarshall(),
	  isAcyclic: requireIsAcyclic(),
	  postorder: requirePostorder(),
	  preorder: requirePreorder(),
	  prim: requirePrim(),
	  tarjan: requireTarjan(),
	  topsort: requireTopsort()
	};
	return alg$1;
}

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var graphlib$1;
var hasRequiredGraphlib;

function requireGraphlib () {
	if (hasRequiredGraphlib) return graphlib$1;
	hasRequiredGraphlib = 1;
	var lib = requireLib();

	graphlib$1 = {
	  Graph: lib.Graph,
	  json: requireJson(),
	  alg: requireAlg(),
	  version: lib.version
	};
	return graphlib$1;
}

var graphlibExports = requireGraphlib();
var graphlib = /*@__PURE__*/getDefaultExportFromCjs(graphlibExports);

/**
 * Subhuti Grammar Validation - 
 *
 * 
 *
 * B - 
 *
 * 
 * 1. ****token
 *    - Level 0: token
 *    - Level 1: 
 *    - Level N: N
 *
 * 2. ****
 *    - cache.set("A", [])
 *    - 
 *
 * 3. ****
 *    - expansion[0]: 1
 *    - expansion[1]: 2
 *    - expansion[N]: N
 *
 * 4. ****
 *    - 3
 *    - 
 *    - 10000
 *
 *   []  
 *
 * 
 * - option(X)  many(X)  []0
 * -  []
 *
 * 
 * -  option/many 
 * - option(a)  First  = {, a}
 * -  First  = {a}
 *
 * 
 * 1. deduplicate
 *  *    - [] join(RuleJoinSymbol) = ""
 *    -  Set key
 *    - [[], [a], []]  [[], [a]]
 *
 * 2. cartesianProduct
 *    - [...seq, ...[]] = [...seq]
 *    - [...[], ...branch] = [...branch]
 *    - [[a]]  [[], [b]]  [[a], [a,b]]
 *
 * 3. truncateAndDeduplicate
 *    - [] slice(0, firstK) = []
 *    - [[], [a,b]], firstK=1  [[], [a]]
 *
 * 4. expandSequenceNode
 *    - 
 *
 * 5. expandOr
 *    - 
 *
 * 
 * -  []
 * - 
 * - 
 *
 * SubhutiConflictDetectorOr
 *
 * @version 2.0.0 - 
 */ function _define_property$5(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const { Graph, alg } = graphlib;
/**
 * 
 */ class PerformanceAnalyzer {
    // ID
    startMethod(methodName) {
        const callId = this.callStack.length;
        this.callStack.push({
            methodName,
            startTime: Date.now(),
            childTime: 0
        });
        return callId;
    }
    // 
    endMethod(callId, inputSize, outputSize) {
        const call = this.callStack[callId];
        if (!call) {
            throw new Error(`: callId ${callId} `);
        }
        const totalDuration = Date.now() - call.startTime;
        const netDuration = totalDuration - call.childTime;
        // 
        if (callId > 0) {
            const parentCall = this.callStack[callId - 1];
            parentCall.childTime += totalDuration;
        }
        // 
        if (!this.stats.has(call.methodName)) {
            this.stats.set(call.methodName, {
                count: 0,
                totalTime: 0,
                netTime: 0,
                maxTime: 0,
                minTime: Infinity,
                inputSizes: [],
                outputSizes: []
            });
        }
        const stat = this.stats.get(call.methodName);
        stat.count++;
        stat.totalTime += totalDuration;
        stat.netTime += netDuration;
        stat.maxTime = Math.max(stat.maxTime, netDuration);
        stat.minTime = Math.min(stat.minTime, netDuration);
        if (inputSize !== undefined) {
            stat.inputSizes.push(inputSize);
        }
        if (outputSize !== undefined) {
            stat.outputSizes.push(outputSize);
        }
        // 
        this.callStack.pop();
        return netDuration;
    }
    // 
    record(methodName, duration, inputSize, outputSize) {
        // 
        // 
        if (!this.stats.has(methodName)) {
            this.stats.set(methodName, {
                count: 0,
                totalTime: 0,
                netTime: 0,
                maxTime: 0,
                minTime: Infinity,
                inputSizes: [],
                outputSizes: []
            });
        }
        const stat = this.stats.get(methodName);
        stat.count++;
        stat.totalTime += duration;
        stat.netTime += duration; // 
        stat.maxTime = Math.max(stat.maxTime, duration);
        stat.minTime = Math.min(stat.minTime, duration);
        if (inputSize !== undefined) {
            stat.inputSizes.push(inputSize);
        }
        if (outputSize !== undefined) {
            stat.outputSizes.push(outputSize);
        }
    }
    // /
    recordCacheHit(cacheType) {
        this.cacheStats[cacheType].hit++;
        this.cacheStats[cacheType].total++;
    }
    recordCacheMiss(cacheType) {
        this.cacheStats[cacheType].miss++;
        this.cacheStats[cacheType].total++;
    }
    // 
    recordActualCompute() {
        this.cacheStats.actualCompute++;
    }
    // 
    report() {
        console.log('\n =====  =====\n');
        // 1. subRuleHandler 
        console.log(' subRuleHandler :');
        console.log(`   : ${this.cacheStats.subRuleHandlerTotal}`);
        console.log(`   : ${this.cacheStats.recursiveReturn}`);
        console.log(`   : ${this.cacheStats.levelLimitReturn}`);
        console.log(`   : ${this.cacheStats.subRuleHandlerTotal - this.cacheStats.recursiveReturn - this.cacheStats.levelLimitReturn}`);
        console.log('');
        // 2. 
        console.log(' :');
        console.log(`   DFS_First1 ( First(1)):`);
        console.log(`     : ${this.cacheStats.dfsFirst1.hit}`);
        console.log(`     : ${this.cacheStats.dfsFirst1.miss}`);
        console.log(`     : ${this.cacheStats.dfsFirst1.total}`);
        console.log(`     : ${this.cacheStats.dfsFirst1.total > 0 ? (this.cacheStats.dfsFirst1.hit / this.cacheStats.dfsFirst1.total * 100).toFixed(1) : 0}%`);
        console.log(`   DFS_FirstK ( First(K)):`);
        console.log(`     : ${this.cacheStats.dfsFirstK.hit}`);
        console.log(`     : ${this.cacheStats.dfsFirstK.miss}`);
        console.log(`     : ${this.cacheStats.dfsFirstK.total}`);
        console.log(`     : ${this.cacheStats.dfsFirstK.total > 0 ? (this.cacheStats.dfsFirstK.hit / this.cacheStats.dfsFirstK.total * 100).toFixed(1) : 0}%`);
        console.log(`   GetDirectChildren ():`);
        console.log(`     : ${this.cacheStats.getDirectChildren.hit}`);
        console.log(`     : ${this.cacheStats.getDirectChildren.miss}`);
        console.log(`     : ${this.cacheStats.getDirectChildren.total}`);
        console.log(`     : ${this.cacheStats.getDirectChildren.total > 0 ? (this.cacheStats.getDirectChildren.hit / this.cacheStats.getDirectChildren.total * 100).toFixed(1) : 0}%`);
        // BFS 
        if (this.cacheStats.bfsOptimization.totalCalls > 0) {
            console.log(`\n    BFS :`);
            console.log(`     : ${this.cacheStats.bfsOptimization.totalCalls}`);
            console.log(`      level 1 : ${this.cacheStats.bfsOptimization.fromLevel1} (${(this.cacheStats.bfsOptimization.fromLevel1 / this.cacheStats.bfsOptimization.totalCalls * 100).toFixed(1)}%)`);
            console.log(`     : ${this.cacheStats.bfsOptimization.fromCachedLevel} (${(this.cacheStats.bfsOptimization.fromCachedLevel / this.cacheStats.bfsOptimization.totalCalls * 100).toFixed(1)}%)`);
            console.log(`     : ${this.cacheStats.bfsOptimization.skippedLevels}`);
            if (this.cacheStats.bfsOptimization.fromCachedLevel > 0) {
                const avgSkipped = this.cacheStats.bfsOptimization.skippedLevels / this.cacheStats.bfsOptimization.fromCachedLevel;
                console.log(`     : ${avgSkipped.toFixed(2)} `);
            }
        }
        // 
        if (this.cacheStats.bfsLevel.total > 0) {
            console.log(`   BFS_Level (handleDFS: firstK=, maxLevel=1):`);
            console.log(`     : ${this.cacheStats.bfsLevel.hit}`);
            console.log(`     : ${this.cacheStats.bfsLevel.miss}`);
            console.log(`     : ${this.cacheStats.bfsLevel.total}`);
            console.log(`     : ${(this.cacheStats.bfsLevel.hit / this.cacheStats.bfsLevel.total * 100).toFixed(1)}%`);
        }
        if (this.cacheStats.expandOneLevel.total > 0) {
            console.log(`   ExpandOneLevel (BFS):`);
            console.log(`     : ${this.cacheStats.expandOneLevel.hit}`);
            console.log(`     : ${this.cacheStats.expandOneLevel.miss}`);
            console.log(`     : ${this.cacheStats.expandOneLevel.total}`);
            console.log(`     : ${(this.cacheStats.expandOneLevel.hit / this.cacheStats.expandOneLevel.total * 100).toFixed(1)}%`);
        }
        console.log(`    (getDirectChildren): ${this.cacheStats.actualCompute}`);
        console.log('');
        // 
        const expectedNormalProcess = this.cacheStats.subRuleHandlerTotal - this.cacheStats.recursiveReturn - this.cacheStats.levelLimitReturn;
        const actualCacheOperations = this.cacheStats.dfsFirst1.hit + this.cacheStats.dfsFirstK.hit + this.cacheStats.actualCompute;
        console.log(` :`);
        console.log(`   : ${expectedNormalProcess}`);
        console.log(`   : ${actualCacheOperations}`);
        console.log(`   : ${expectedNormalProcess - actualCacheOperations} (0)`);
        console.log('');
        // 2. 
        const sorted = Array.from(this.stats.entries()).sort((a, b)=>b[1].netTime - a[1].netTime).slice(0, 20) // 20
        ;
        // 
        const totalTime = Array.from(this.stats.values()).reduce((sum, stat)=>sum + stat.totalTime, 0);
        // 
        const totalNetTime = Array.from(this.stats.values()).reduce((sum, stat)=>sum + stat.netTime, 0);
        console.log('   (, Top 20):');
        console.log('='.repeat(80));
        for (const [method, stat] of sorted){
            const avgNetTime = stat.netTime / stat.count;
            const avgTotalTime = stat.totalTime / stat.count;
            const percentage = totalNetTime > 0 ? (stat.netTime / totalNetTime * 100).toFixed(1) : '0.0';
            const avgInput = stat.inputSizes.length > 0 ? stat.inputSizes.reduce((a, b)=>a + b, 0) / stat.inputSizes.length : 0;
            const avgOutput = stat.outputSizes.length > 0 ? stat.outputSizes.reduce((a, b)=>a + b, 0) / stat.outputSizes.length : 0;
            console.log(` ${method}:`);
            console.log(`   : ${stat.netTime.toFixed(0)}ms (${percentage}%) | : ${stat.totalTime.toFixed(0)}ms`);
            console.log(`   : ${stat.count}, : ${avgNetTime.toFixed(2)}ms, : ${avgTotalTime.toFixed(2)}ms`);
            console.log(`   : ${stat.maxTime.toFixed(0)}ms, : ${stat.minTime === Infinity ? 0 : stat.minTime.toFixed(0)}ms`);
            if (stat.inputSizes.length > 0 && stat.outputSizes.length > 0) {
                console.log(`   : ${avgInput.toFixed(1)}  ${avgOutput.toFixed(1)} (${(avgOutput / avgInput).toFixed(1)}x)`);
            }
            console.log('');
        }
        console.log(`  : ${totalNetTime.toFixed(2)}ms`);
        console.log(`  : ${totalTime.toFixed(2)}ms`);
        console.log('='.repeat(80));
        console.log('');
    }
    // 
    clear() {
        this.stats.clear();
        this.cacheStats = {
            subRuleHandlerTotal: 0,
            recursiveReturn: 0,
            levelLimitReturn: 0,
            // 
            dfsFirstKCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsAllCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsLevelCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            getDirectChildren: {
                hit: 0,
                miss: 0,
                total: 0
            },
            // 
            dfsFirst1: {
                hit: 0,
                miss: 0,
                total: 0
            },
            dfsFirstK: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsLevel: {
                hit: 0,
                miss: 0,
                total: 0
            },
            expandOneLevel: {
                hit: 0,
                miss: 0,
                total: 0
            },
            expandOneLevelTruncated: {
                hit: 0,
                miss: 0,
                total: 0
            },
            actualCompute: 0,
            bfsOptimization: {
                totalCalls: 0,
                skippedLevels: 0,
                fromLevel1: 0,
                fromCachedLevel: 0
            }
        };
    }
    constructor(){
        _define_property$5(this, "stats", new Map());
        // 
        _define_property$5(this, "callStack", []);
        // 
        _define_property$5(this, "cacheStats", {
            subRuleHandlerTotal: 0,
            recursiveReturn: 0,
            levelLimitReturn: 0,
            //  hit/miss/total
            dfsFirstKCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsAllCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsLevelCache: {
                hit: 0,
                miss: 0,
                total: 0
            },
            getDirectChildren: {
                hit: 0,
                miss: 0,
                total: 0
            },
            // 
            dfsFirst1: {
                hit: 0,
                miss: 0,
                total: 0
            },
            dfsFirstK: {
                hit: 0,
                miss: 0,
                total: 0
            },
            bfsLevel: {
                hit: 0,
                miss: 0,
                total: 0
            },
            expandOneLevel: {
                hit: 0,
                miss: 0,
                total: 0
            },
            expandOneLevelTruncated: {
                hit: 0,
                miss: 0,
                total: 0
            },
            actualCompute: 0,
            bfsOptimization: {
                totalCalls: 0,
                skippedLevels: 0,
                fromLevel1: 0,
                fromCachedLevel: 0 // 
            }
        });
    }
}
/**
 * 
 *
 * 
 * - MAX_LEVEL
 * - MAX_BRANCHES
 */ const EXPANSION_LIMITS = {
    FIRST_K: 3,
    FIRST_Max: 100,
    LEVEL_1: 1,
    LEVEL_K: 1,
    INFINITY: Infinity,
    RuleJoinSymbol: '\x1F',
    /**
     * 
     *
     *  
     * - 
     * -  SubhutiConflictDetector.detectOrConflicts 
     * - 
     *
     * 
     * - O(n)
     * - 1000  1000 = 100
     * - 1000 28260 = 8
     *
     * Infinity
     */ MAX_BRANCHES: Infinity
};
/**
 * 
 *
 * 
 * 1.  AST
 * 2. token
 * 3. 
 * 4. 
 *
 * 
 * - 310000
 * - 
 * - 
 */ class SubhutiGrammarAnalyzer {
    /**
     * 
     * 
     */ writeLog(message, depth) {
        if (this.currentLogFd !== null && this.currentRuleName) {
            const indent = '  '.repeat(depth !== undefined ? depth : this.currentDepth);
            const logFileName = `${this.currentRuleName}-.log`;
            const logLine = `${indent}[${logFileName}] ${message}\n`;
            try {
                // 
                fs__namespace.writeSync(this.currentLogFd, logLine, null, 'utf8');
            } catch (error) {
                console.error(`: ${logFileName}`, error);
            }
        }
    }
    /**
     * 
     */ startRuleLogging(ruleName) {
        console.log(` startRuleLogging : ${ruleName}`);
        // 
        this.endRuleLogging();
        // 
        this.currentRuleName = ruleName;
        this.currentDepth = 0;
        //  subhuti 
        //  subhuti 
        // ESM  import.meta.url
        const __filename = require$$0$2.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('language-server.cjs', document.baseURI).href)));
        const currentDir = path__namespace.dirname(__filename);
        let subhutiDir = currentDir;
        while(subhutiDir !== path__namespace.dirname(subhutiDir)){
            const dirName = path__namespace.basename(subhutiDir);
            if (dirName === 'subhuti') {
                break;
            }
            subhutiDir = path__namespace.dirname(subhutiDir);
        }
        const logDir = path__namespace.join(subhutiDir, 'logall');
        if (!fs__namespace.existsSync(logDir)) {
            fs__namespace.mkdirSync(logDir, {
                recursive: true
            });
            console.log(` : ${logDir}`);
        } else {
            console.log(` : ${logDir}`);
        }
        // 
        const logFilePath = path__namespace.join(logDir, `${ruleName}-.log`);
        this.currentLogFilePath = logFilePath;
        console.log(`[DEBUG] : ${logFilePath}`);
        // 
        try {
            console.log(`[DEBUG] ...`);
            const initialContent = `========== : ${ruleName} ==========\n: ${new Date().toISOString()}\n\n`;
            // 
            this.currentLogFd = fs__namespace.openSync(logFilePath, 'w');
            // 
            fs__namespace.writeSync(this.currentLogFd, initialContent, null, 'utf8');
            console.log(`[DEBUG] `);
            // 
            if (fs__namespace.existsSync(logFilePath)) {
                const stats = fs__namespace.statSync(logFilePath);
                console.log(` : ${logFilePath}, : ${stats.size} bytes`);
            } else {
                console.error(` : ${logFilePath}`);
                if (this.currentLogFd !== null) {
                    fs__namespace.closeSync(this.currentLogFd);
                    this.currentLogFd = null;
                }
                return;
            }
        } catch (error) {
            console.error(` : ${logFilePath}`);
            console.error(`: ${error?.constructor?.name || typeof error}`);
            console.error(`: ${error?.message || String(error)}`);
            if (error?.stack) {
                console.error(`:`, error.stack);
            }
            if (this.currentLogFd !== null) {
                try {
                    fs__namespace.closeSync(this.currentLogFd);
                } catch (e) {
                // 
                }
                this.currentLogFd = null;
            }
        }
    }
    /**
     * 
     */ endRuleLogging() {
        if (this.currentLogFd !== null && this.currentRuleName && this.currentLogFilePath) {
            this.writeLog('', 0);
            this.writeLog(`========== : ${this.currentRuleName} ==========`, 0);
            // 
            const ruleName = this.currentRuleName;
            const executingFilePath = this.currentLogFilePath;
            //  subhuti 
            // ESM  import.meta.url
            const __filename = require$$0$2.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('language-server.cjs', document.baseURI).href)));
            const currentDir = path__namespace.dirname(__filename);
            let subhutiDir = currentDir;
            while(subhutiDir !== path__namespace.dirname(subhutiDir)){
                const dirName = path__namespace.basename(subhutiDir);
                if (dirName === 'subhuti') {
                    break;
                }
                subhutiDir = path__namespace.dirname(subhutiDir);
            }
            const logDir = path__namespace.join(subhutiDir, 'logall');
            const completedFilePath = path__namespace.join(logDir, `${ruleName}-.log`);
            console.log(`[DEBUG] : ${ruleName}`);
            // 
            try {
                // 
                fs__namespace.closeSync(this.currentLogFd);
                this.currentLogFd = null;
                this.currentLogFilePath = null;
                console.log(`[DEBUG] `);
                console.log(`[DEBUG] : ${executingFilePath}`);
                console.log(`[DEBUG] : ${completedFilePath}`);
                // 
                if (fs__namespace.existsSync(executingFilePath)) {
                    console.log(`[DEBUG] `);
                    fs__namespace.renameSync(executingFilePath, completedFilePath);
                    console.log(` : ${ruleName}-.log -> ${ruleName}-.log`);
                } else {
                    console.error(` : ${executingFilePath}`);
                }
            } catch (error) {
                console.error(` : ${executingFilePath} -> ${completedFilePath}`, error);
            }
        }
        this.currentRuleName = null;
        this.currentDepth = 0;
        this.currentLogFd = null;
        this.currentLogFilePath = null;
    }
    /**
     *  get 
     *
     *  
     * -  get  total 
     * -  hit++ miss++
     * - total  hit + miss
     *
     * @param cacheType - 
     * @param key - 
     * @returns  undefined
     */ getCacheValue(cacheType, key) {
        // 
        let result;
        switch(cacheType){
            case 'dfsFirstKCache':
                result = this.dfsFirstKCache.get(key);
                break;
            case 'bfsAllCache':
                result = this.bfsAllCache.get(key);
                break;
            case 'bfsLevelCache':
                result = this.bfsLevelCache.get(key);
                break;
        }
        // /
        if (result !== undefined) {
            this.perfAnalyzer.recordCacheHit(cacheType);
        } else {
            this.perfAnalyzer.recordCacheMiss(cacheType);
        }
        return result;
    }
    getRuleNodeByAst(ruleName) {
        const ruleNode = this.ruleASTs.get(ruleName);
        if (!ruleNode) {
            throw new Error('');
        }
        return ruleNode;
    }
    /**
     *  Or  First(1) First(5)
     *
     * 
     * -  AST
     * -  Or 
     * -  First(1) 
     * -  First(5)
     *
     * @returns Or 
     */ /**
     *  Or  First(1) First(5)
     *
     * 
     * -  AST
     * -  Or 
     * -  First(1) 
     * -  First(5)
     *
     * @returns Or 
     */ checkAllOrConflicts() {
        const orConflictErrors = [];
        // 
        this.compareStats = {
            firstKDetected: 0,
            bothDetected: 0,
            firstKOnlyDetected: 0
        };
        // 
        const perfStats = {
            totalTime: 0,
            ruleStats: new Map()
        };
        const startTime = Date.now();
        // 
        for (const [ruleName, ruleAST] of this.ruleASTs.entries()){
            const ruleStartTime = Date.now();
            const ruleStats = {
                time: 0,
                orNodeCount: 0,
                pathCount: 0,
                maxPathCount: 0
            };
            const error = this.checkOrConflictsInNodeSmart(ruleName, ruleAST, ruleStats);
            if (error) {
                orConflictErrors.push(error);
            }
            ruleStats.time = Date.now() - ruleStartTime;
            perfStats.ruleStats.set(ruleName, ruleStats);
        }
        perfStats.totalTime = Date.now() - startTime;
        //  FirstK vs MaxLevel 
        console.log(`\n FirstK vs MaxLevel :`);
        console.log(`   FirstK : ${this.compareStats.firstKDetected} `);
        console.log(`   : ${this.compareStats.bothDetected} `);
        console.log(`    FirstK  (MaxLevel ): ${this.compareStats.firstKOnlyDetected} `);
        return orConflictErrors;
    }
    /**
     *  Or  First(1) First(5)
     *
     * @param ruleName 
     * @param node 
     * @param ruleStats 
     */ checkOrConflictsInNodeSmart(ruleName, node, ruleStats) {
        let error;
        switch(node.type){
            case 'or':
                //  Or 
                if (ruleStats) ruleStats.orNodeCount++;
                // 
                error = this.detectOrBranchConflictsWithCache(ruleName, node, ruleStats);
                if (error) return error;
                // 
                for (const alt of node.alternatives){
                    error = this.checkOrConflictsInNodeSmart(ruleName, alt, ruleStats);
                    if (error) return error;
                }
                break;
            case 'sequence':
                // 
                for (const child of node.nodes){
                    error = this.checkOrConflictsInNodeSmart(ruleName, child, ruleStats);
                    if (error) return error;
                }
                break;
            case 'option':
            case 'many':
            case 'atLeastOne':
                // 
                error = this.checkOrConflictsInNodeSmart(ruleName, node.node, ruleStats);
                if (error) return error;
                break;
        }
    }
    /**
     *  Or 
     *
     * 
     * 1. 
     * 2.  cache 
     * 3. 
     * 4. 
     *
     * @param orNode - Or 
     * @param firstK - First(K)  K 
     * @param cacheType - 
     * @returns 
     */ getOrNodeAllBranchRules(ruleName, orNode, firstK, cacheType) {
        // 
        let allOrs = [];
        //allor
        //  Or 
        for (const seqNode of orNode.alternatives){
            // 1
            // sequence(If, Expression, Block)  [['If', 'Expression', 'Block']]
            const nodeAllBranches = this.expandNode(seqNode, EXPANSION_LIMITS.INFINITY, 1, 1, false);
            const isMore = firstK === EXPANSION_LIMITS.INFINITY;
            if (isMore) {
                if ([
                    'ImportCall'
                ].includes(ruleName)) {
                    console.log(ruleName);
                    console.log(nodeAllBranches);
                }
            }
            let allBranchAllSeq = [];
            //allbranch/allSeq
            for (const branch of nodeAllBranches){
                //branch
                // 2 cache 
                // ['If', 'Expression']  [[If], [Expression]]
                const seqAllBranches = branch.map((rule)=>{
                    if (this.tokenCache.has(rule)) {
                        return [
                            [
                                rule
                            ]
                        ];
                    }
                    const paths = this.getCacheValue(cacheType, rule);
                    if (!paths) {
                        throw new Error('');
                    }
                    //  [[rule]]
                    return paths;
                });
                // 3
                // [[a,b], [c,d]]  [[e], [f,g]]  [[a,b,e], [a,b,f,g], [c,d,e], [c,d,f,g]]
                const branchAllSeq = this.cartesianProduct(seqAllBranches, firstK);
                if (isMore) {
                    if (branchAllSeq.length > 10000) {
                        console.log(ruleName);
                        console.log('branchAllSeq.length');
                        console.log(branchAllSeq.length);
                    }
                }
                // 
                allBranchAllSeq = allBranchAllSeq.concat(branchAllSeq);
            }
            allOrs.push(this.deduplicate(allBranchAllSeq));
        }
        // 
        return allOrs;
    }
    removeDuplicatePaths(pathsFront, pathsBehind) {
        // 
        if (pathsBehind.length === 0) {
            return [];
        }
        // 1 pathsFront  Set<string>
        const frontSet = new Set();
        for (const path of pathsFront){
            //  key
            const key = path.join(EXPANSION_LIMITS.RuleJoinSymbol);
            frontSet.add(key);
        }
        // 2 pathsBehind Set 
        const uniqueBehind = [];
        for (const path of pathsBehind){
            const key = path.join(EXPANSION_LIMITS.RuleJoinSymbol);
            if (!frontSet.has(key)) {
                uniqueBehind.push(path);
            }
        }
        return uniqueBehind;
    }
    /**
     * 
     *
     * @param pathsFront - 
     * @param pathsBehind - 
     * @returns  null
     */ findEqualPath(pathsFront, pathsBehind) {
        // O((m+n)*k)
        // O(m) - 
        const behindSet = new Set();
        for (const path of pathsBehind){
            behindSet.add(path.join(EXPANSION_LIMITS.RuleJoinSymbol)); // O(k)
        }
        for (const pathFront of pathsFront){
            const key = pathFront.join(EXPANSION_LIMITS.RuleJoinSymbol) // O(k)
            ;
            if (behindSet.has(key)) {
                return pathFront;
            }
        }
    }
    /**
     * 
     *
     * @param pathsFront - 
     * @param pathsBehind - 
     * @returns  { prefix, full } null
     */ trieTreeFindPrefixMatch(pathsFront, pathsBehind) {
        // 
        if (pathsBehind.length === 0 || pathsFront.length === 0) {
            return null;
        }
        //  pathsFront 
        const uniqueBehind = this.removeDuplicatePaths(pathsFront, pathsBehind);
        // 
        if (uniqueBehind.length === 0) {
            return null;
        }
        // 2O(m*k)m=pathsBehind.lengthk=
        const trie = new ArrayTrie();
        for (const path of uniqueBehind){
            // 
            trie.insert(path);
        }
        // 3O(n*k)n=pathsFront.length
        for (const pathFront of pathsFront){
            // 
            //  pathFront 
            const fullPath = trie.findPrefixMatch(pathFront);
            if (fullPath) {
                // 
                return {
                    prefix: pathFront,
                    full: fullPath
                };
            }
        }
        // 
        return null;
    }
    /**
     * 
     *
     * @param ruleName - 
     * @param branchA - A
     * @param branchB - B
     * @param conflict - 
     * @returns 
     */ getPrefixConflictSuggestion(ruleName, branchA, branchB, conflict) {
        if (conflict.type === 'equal') {
            return ` ${branchA + 1}  ${branchB + 1} 


- 
-  ${branchB + 1}  ${branchA + 1} 


or([A, A, B])  or([A, B])  // A`;
        }
        return ``;
    }
    /**
     * 1 First(K)  Or 
     *
     * 
     * -  firstKfindEqualPath
     * -  < firstKfindPrefixRelation
     *
     * dfsFirstKCacheFirst(K) 
     *
     * @param ruleName 
     * @param orNode - Or 
     * @param ruleStats
     */ detectOrBranchEqualWithFirstK(ruleName, orNode, ruleStats) {
        // 2
        if (orNode.alternatives.length < 2) {
            return;
        }
        //  First(K) 
        const branchPathSets = this.getOrNodeAllBranchRules(ruleName, orNode, EXPANSION_LIMITS.FIRST_K, 'dfsFirstKCache');
        const firstK = EXPANSION_LIMITS.FIRST_K;
        // 
        if (ruleStats) {
            const totalPaths = branchPathSets.reduce((sum, paths)=>sum + paths.length, 0);
            const maxPaths = Math.max(...branchPathSets.map((paths)=>paths.length));
            ruleStats.pathCount += totalPaths;
            ruleStats.maxPathCount = Math.max(ruleStats.maxPathCount, maxPaths);
        }
        // 
        for(let i = 0; i < branchPathSets.length; i++){
            for(let j = i + 1; j < branchPathSets.length; j++){
                const pathsFront = branchPathSets[i];
                const pathsBehind = branchPathSets[j];
                // 
                const equalPath = this.findEqualPath(pathsFront, pathsBehind);
                if (equalPath) {
                    const equalPathStr = equalPath.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    return {
                        level: 'ERROR',
                        type: 'or-identical-branches',
                        ruleName,
                        branchIndices: [
                            i,
                            j
                        ],
                        conflictPaths: {
                            pathA: equalPathStr,
                            pathB: equalPathStr
                        },
                        message: ` "${ruleName}"  Or  ${i + 1}  ${j + 1}  ${firstK}  token `,
                        suggestion: this.getEqualBranchSuggestion(ruleName, i, j, equalPathStr)
                    };
                }
                // 
                const prefixRelation = this.trieTreeFindPrefixMatch(pathsFront, pathsBehind);
                if (prefixRelation) {
                    const prefixStr = prefixRelation.prefix.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    const fullStr = prefixRelation.full.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    return {
                        level: 'ERROR',
                        type: 'prefix-conflict',
                        ruleName,
                        branchIndices: [
                            i,
                            j
                        ],
                        conflictPaths: {
                            pathA: prefixStr,
                            pathB: fullStr
                        },
                        message: ` "${ruleName}"  Or  ${i + 1}  ${j + 1} First(${firstK}) `,
                        suggestion: this.getPrefixConflictSuggestion(ruleName, i, j, {
                            prefix: prefixStr,
                            full: fullStr,
                            type: 'prefix'
                        })
                    };
                }
            }
        }
    }
    /**
     * 2 MaxLevel  Or 
     *
     * 
     * bfsAllCache
     * findPrefixRelation()
     * O(n) - 
     *
     * 
     * - 
     * - 
     *
     * @param ruleName - 
     * @param orNode - Or 
     */ detectOrBranchPrefixWithMaxLevel(ruleName, orNode, ruleStats) {
        // 2
        if (orNode.alternatives.length < 2) {
            return;
        }
        // 
        const branchPathSets = this.getOrNodeAllBranchRules(ruleName, orNode, EXPANSION_LIMITS.INFINITY, 'bfsAllCache');
        // MaxLevel 
        if (ruleStats) {
            branchPathSets.reduce((sum, paths)=>sum + paths.length, 0);
            Math.max(...branchPathSets.map((paths)=>paths.length));
        }
        // 
        for(let i = 0; i < branchPathSets.length; i++){
            for(let j = i + 1; j < branchPathSets.length; j++){
                const pathsFront = branchPathSets[i];
                const pathsBehind = branchPathSets[j];
                // O(n)
                const prefixRelation = this.trieTreeFindPrefixMatch(pathsFront, pathsBehind);
                if (prefixRelation) {
                    // 
                    const prefixStr = prefixRelation.prefix.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    const fullStr = prefixRelation.full.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    // 
                    return {
                        level: 'ERROR',
                        type: 'prefix-conflict',
                        ruleName,
                        branchIndices: [
                            i,
                            j
                        ],
                        conflictPaths: {
                            pathA: prefixStr,
                            pathB: fullStr
                        },
                        message: ` "${ruleName}"  Or  ${i + 1}  ${j + 1}`,
                        suggestion: this.getPrefixConflictSuggestion(ruleName, i, j, {
                            prefix: prefixStr,
                            full: fullStr,
                            type: 'prefix'
                        })
                    };
                }
            }
        }
    }
    /**
     * 
     */ getEqualBranchSuggestion(ruleName, branchA, branchB, equalPath) {
        return ` ${branchA + 1}  ${branchB + 1} 


  : ${equalPath}


- 
-  ${branchB + 1}  ${branchA + 1} 


1. ****
2. ****
3. ****


or([A, A, B])  or([A, B])  // A`;
    }
    detectOrBranchConflictsWithCache(ruleName, orNode, ruleStats) {
        //  1First(K) 
        let firstKError = this.detectOrBranchEqualWithFirstK(ruleName, orNode, ruleStats);
        // 1
        if (!firstKError) {
            // 
            return;
        }
        // FirstK 
        this.compareStats.firstKDetected++;
        // 2/
        const maxLevelError = this.detectOrBranchPrefixWithMaxLevel(ruleName, orNode, ruleStats);
        //  FirstK vs MaxLevel 
        if (maxLevelError) {
            this.compareStats.bothDetected++;
        } else {
            this.compareStats.firstKOnlyDetected++;
        }
        //   First(K) MaxLevel 
        if (firstKError.type === 'prefix-conflict') {
            if (!maxLevelError) {
                const errorMsg = `
 ==========  ==========
: ${ruleName}
: First(K)  MaxLevel 

First(K) :
  : ${firstKError.type}
  : ${firstKError.branchIndices[0] + 1}  ${firstKError.branchIndices[1] + 1}
  : ${firstKError.conflictPaths?.pathA}
  : ${firstKError.conflictPaths?.pathB}

MaxLevel : 

:
1. First(K) 
2. MaxLevel 
3. dfsFirstKCache  bfsAllCache 
==========================================`;
                console.error(errorMsg);
                throw new Error(`: First(K)  MaxLevel  (: ${ruleName})`);
            }
        }
        // 
        return maxLevelError;
    }
    findRuleDepth(ruleName) {
        // console.log('')
        // console.log(ruleName)
        // +1
        // curLevel++
        // ========================================
        // 2DFS 
        // ========================================
        // 
        if (this.recursiveDetectionSet.has(ruleName)) {
            // 1
            return 1;
        }
        // 
        this.recursiveDetectionSet.add(ruleName);
        try {
            const node = this.ruleASTs.get(ruleName);
            // node  SequenceNode findNodeDepth 
            const result = this.findNodeDepth(node);
            if (result > 1000000) {
                console.log(ruleName);
                console.log(result);
            }
            return result;
        } finally{
            // 
            this.recursiveDetectionSet.delete(ruleName);
        }
    }
    //01 12 
    manyAndOptionDepth(node) {
        const num = this.findNodeDepth(node.node);
        // option  many  0 
        return num + num;
    }
    atLeastOneDepth(node) {
        const num = this.findNodeDepth(node.node);
        return num + num;
    }
    seqDepth(seq) {
        if (seq.nodes.length < 1) {
            return 1;
        }
        let all = 1;
        for(let i = 0; i < seq.nodes.length; i++){
            const node = seq.nodes[i];
            const depth = this.findNodeDepth(node);
            all = all * depth;
        }
        return all;
    }
    orDepth(or) {
        if (or.alternatives.length < 1) {
            throw new Error('xitongcuowu');
        }
        let orPossibility = 0;
        for(let i = 0; i < or.alternatives.length; i++){
            const alternative = or.alternatives[i];
            const depth = this.findNodeDepth(alternative);
            orPossibility += depth;
        }
        if (orPossibility === 0) {
            throw new Error('');
        }
        return orPossibility;
    }
    findNodeDepth(node) {
        // 
        this.checkTimeout('findNodeDepth');
        const callId = this.perfAnalyzer.startMethod('findNodeDepth');
        // DFS 
        // 
        let result;
        switch(node.type){
            case 'consume':
                // Token  token 
                result = 1;
                break;
            case 'subrule':
                //  subRuleHandler 
                result = this.findRuleDepth(node.ruleName);
                break;
            case 'or':
                // Or 
                //  Or  isFirstPosition
                result = this.orDepth(node);
                break;
            case 'sequence':
                // Sequence 
                result = this.seqDepth(node);
                break;
            case 'option':
            case 'many':
            case 'atLeastOne':
                // Option/Many 0
                //  Option  isFirstPosition
                result = this.manyAndOptionDepth(node);
                break;
            default:
                // 
                throw new Error(`: ${node.type}`);
        }
        // 
        this.perfAnalyzer.endMethod(callId, undefined);
        // 
        return result;
    }
    deepDepth(node, depth) {
        // 
        this.checkTimeout('deepDepth');
        const callId = this.perfAnalyzer.startMethod('findNodeDepth');
        // DFS 
        // 
        let result;
        let tempary = [];
        switch(node.type){
            case 'consume':
                // Token  token 
                result = depth;
                break;
            case 'subrule':
                const ruleName = node.ruleName;
                if (this.depmap.has(ruleName)) {
                    return this.depmap.get(ruleName);
                }
                if (this.recursiveDetectionSet.has(ruleName)) {
                    // 1
                    return depth;
                }
                depth++;
                // 
                this.recursiveDetectionSet.add(ruleName);
                const subNode = this.ruleASTs.get(ruleName);
                result = this.deepDepth(subNode, depth);
                // 
                this.recursiveDetectionSet.delete(ruleName);
                break;
            case 'or':
                tempary = [];
                for (const alternative of node.alternatives){
                    tempary.push(this.deepDepth(alternative, depth));
                }
                result = Math.max(...tempary);
                break;
            case 'sequence':
                tempary = [];
                for (const alternative of node.nodes){
                    tempary.push(this.deepDepth(alternative, depth));
                }
                result = Math.max(...tempary);
                break;
            case 'option':
            case 'many':
            case 'atLeastOne':
                result = this.deepDepth(node.node, depth);
                break;
            default:
                // 
                throw new Error(`: ${node.type}`);
        }
        // 
        this.perfAnalyzer.endMethod(callId, undefined);
        // 
        return result;
    }
    // 
    collectDependencies(node, fromRule) {
        switch(node.type){
            case 'consume':
                this.graph.setEdge(fromRule, node.tokenName);
                break;
            case 'subrule':
                this.graph.setEdge(fromRule, node.ruleName);
                break;
            case 'sequence':
                node.nodes.forEach((n)=>this.collectDependencies(n, fromRule));
                break;
            case 'or':
                node.alternatives.forEach((alt)=>this.collectDependencies(alt, fromRule));
                break;
            case 'option':
            case 'many':
            case 'atLeastOne':
                this.collectDependencies(node.node, fromRule);
                break;
        }
    }
    graphToMermaid(g) {
        const lines = [
            'graph TD'
        ];
        for (const edge of g.edges()){
            lines.push(`    ${edge.v} --> ${edge.w}`);
        }
        return lines.join('\n');
    }
    grachScc() {
        this.graph = new Graph({
            directed: true
        });
        for (const [ruleName, node] of this.ruleASTs){
            this.graph.setNode(ruleName);
            this.collectDependencies(node, ruleName);
        }
        const dotString = write(this.graph);
        console.log(dotString);
        // Tarjan 
        const sccs = alg.tarjan(this.graph);
        console.log('===  ===');
        for (const scc of sccs){
            if (scc.length > 1) {
                //  SCC = 
                console.log('====================');
                console.log(`: `);
                console.log(`${scc.length}`);
            }
        }
    }
    computeRuleDepth() {
        for (const node of this.ruleASTs.values()){
            this.recursiveDetectionSet.clear();
            const result = this.deepDepth(node, 1);
            console.log(node.ruleName);
            console.log(result);
            this.depmap.set(node.ruleName, result);
        }
    }
    computeRulePossibility() {
        for (const node of this.ruleASTs.values()){
            this.recursiveDetectionSet.clear();
            const ruleName = node.ruleName;
            console.log('' + ruleName);
            const result = this.findNodeDepth(node);
            if (this.depthMap.has(ruleName)) {
                const num = this.depthMap.get(ruleName);
                if (result !== num) {
                    console.log('');
                    console.log(ruleName);
                    console.log('jiuzhi');
                    console.log(num);
                    console.log('');
                    console.log(result);
                    this.depthMap.set(ruleName, result);
                    throw new Error('');
                }
            } else {
                this.depthMap.set(ruleName, result);
                console.log('');
                console.log(ruleName);
                console.log(result);
            }
        }
    }
    /**
     * First 
     *
     *  AST 
     *
     * @returns { errors: , stats:  }
     */ initCacheAndCheckLeftRecursion() {
        // 20
        this.operationStartTime = Date.now();
        const totalStartTime = Date.now();
        // 
        const stats = {
            dfsFirstKTime: 0,
            bfsMaxLevelTime: 0,
            orDetectionTime: 0,
            leftRecursionCount: 0,
            orConflictCount: 0,
            totalTime: 0,
            dfsFirstKCacheSize: 0,
            bfsAllCacheSize: 0,
            firstK: 0,
            cacheUsage: {
                dfsFirstK: {
                    hit: 0,
                    miss: 0,
                    total: 0,
                    hitRate: 0
                },
                bfsLevelCache: {
                    hit: 0,
                    miss: 0,
                    total: 0,
                    hitRate: 0,
                    size: 0
                },
                getDirectChildren: {
                    hit: 0,
                    miss: 0,
                    total: 0,
                    hitRate: 0
                }
            }
        };
        //  Map
        this.detectedLeftRecursionErrors.clear();
        // 1.2BFS MaxLevel 
        //  BFS 
        this.operationStartTime = Date.now();
        const t1_2_start = Date.now();
        console.log(`\n ===== BFS MaxLevel  =====`);
        console.log(`: Level 1  Level ${EXPANSION_LIMITS.LEVEL_K}`);
        const ruleNames = Array.from(this.ruleASTs.keys());
        //
        for (const ruleName of ruleNames){
            this.recursiveDetectionSet.clear();
            this.expandPathsByDFSCache(ruleName, EXPANSION_LIMITS.FIRST_K, 0, EXPANSION_LIMITS.INFINITY, true);
        }
        const startLevel = EXPANSION_LIMITS.LEVEL_K;
        // BFS 
        //  level 1  level_k
        for(let level = startLevel; level <= EXPANSION_LIMITS.LEVEL_K; level++){
            console.log(`\n  Level ${level} ...`);
            for (const ruleName of ruleNames){
                const key = `${ruleName}:${level}`;
                // 
                if (this.bfsLevelCache.has(key)) {
                    continue;
                }
                // 
                const ruleStartTime = Date.now();
                // console.log(`  [${levelRuleIndex}/${ruleNames.length}] : ${ruleName}, Level ${level}, Key: ${key}`)
                // 
                this.expandPathsByBFSCache(ruleName, level);
                // 
                const ruleEndTime = Date.now();
                const ruleDuration = ruleEndTime - ruleStartTime;
                const cachedPaths = this.bfsLevelCache.get(key);
                const pathCount = cachedPaths ? cachedPaths.length : 0;
                //  10ms 
                if (ruleDuration > 10 || pathCount > 100) {
                    console.log(`   : ${ruleName}, Level ${level} (: ${ruleDuration}ms, : ${pathCount})`);
                }
            }
            console.log(` Level ${level} `);
        }
        //  bfsAllCache
        console.log(`\n  bfsAllCache...`);
        let aggregateIndex = 0;
        for (const ruleName of ruleNames){
            aggregateIndex++;
            const aggregateStartTime = Date.now();
            let allLevelPaths = [];
            // 
            for(let level = startLevel; level <= EXPANSION_LIMITS.LEVEL_K; level++){
                const key = `${ruleName}:${level}`;
                if (this.bfsLevelCache.has(key)) {
                    const levelPaths = this.getCacheValue('bfsLevelCache', key);
                    allLevelPaths = allLevelPaths.concat(levelPaths);
                }
            }
            //  bfsAllCache
            const deduplicated = this.deduplicate(allLevelPaths);
            this.bfsAllCache.set(ruleName, deduplicated);
            // 
            if (deduplicated.length > 1000) {
                const aggregateDuration = Date.now() - aggregateStartTime;
                console.log(`  [${aggregateIndex}/${ruleNames.length}] : ${ruleName} (: ${aggregateDuration}ms, : ${deduplicated.length})`);
            }
        }
        /*ass.forEach((ass1, index) => {
            console.log('fenzhi:' + index)
            let temp = ass1.map(string => this.expandPathsByBFSCache(string, 1))
            const fsaf = this.cartesianProduct(temp, EXPANSION_LIMITS.INFINITY)
            console.log('posible:' + fsaf.length)
            for (const fsafElement of fsaf) {
                console.log(fsafElement.join('->'))
            }
        })*/ // ass = this.expandPathsByBFSCache('LeftHandSideExpression', 1)
        // console.log(ass.length)
        // console.log(this.bfsAllCache.size)
        // for (const ruleName of ruleNames) {
        //     console.log(ruleName)
        //     console.log(this.bfsAllCache.get(ruleName))
        // }
        const t1_2_end = Date.now();
        stats.bfsMaxLevelTime = t1_2_end - t1_2_start;
        console.log(`\n BFS MaxLevel  (: ${stats.bfsMaxLevelTime}ms)`);
        console.log(`========================================\n`);
        // 
        this.operationStartTime = 0;
        //  suggestion
        for (const error of this.detectedLeftRecursionErrors.values()){
            const ruleAST = this.getRuleNodeByAst(error.ruleName);
            error.suggestion = this.getLeftRecursionSuggestion(error.ruleName, ruleAST, new Set([
                error.ruleName
            ]));
        }
        stats.leftRecursionCount = this.detectedLeftRecursionErrors.size;
        const leftRecursionErrors = Array.from(this.detectedLeftRecursionErrors.values());
        // 2. Or 
        const t2 = Date.now();
        // const orConflictErrors = []
        const orConflictErrors = this.checkAllOrConflicts();
        const t2End = Date.now();
        const stage2Time = t2End - t2;
        //  Or 
        stats.orDetectionTime = stage2Time;
        stats.orConflictCount = orConflictErrors.length;
        // 3. 
        const allErrors = [];
        allErrors.push(...leftRecursionErrors);
        allErrors.push(...orConflictErrors);
        // 5.  error 
        stats.totalTime = Date.now() - totalStartTime;
        stats.dfsFirstKCacheSize = this.dfsFirstKCache.size;
        stats.bfsAllCacheSize = this.bfsAllCache.size;
        stats.firstK = EXPANSION_LIMITS.FIRST_K;
        // 
        const dfsFirstKCacheStats = this.perfAnalyzer.cacheStats.dfsFirstKCache;
        const bfsAllCacheStats = this.perfAnalyzer.cacheStats.bfsAllCache;
        const bfsLevelCacheStats = this.perfAnalyzer.cacheStats.bfsLevelCache;
        const getDirectChildrenStats = this.perfAnalyzer.cacheStats.getDirectChildren;
        stats.cacheUsage = {
            dfsFirstK: {
                hit: dfsFirstKCacheStats.hit,
                miss: dfsFirstKCacheStats.miss,
                total: dfsFirstKCacheStats.total,
                hitRate: dfsFirstKCacheStats.total > 0 ? dfsFirstKCacheStats.hit / dfsFirstKCacheStats.total * 100 : 0,
                // total  getCacheValue  total
                getCount: dfsFirstKCacheStats.total
            },
            bfsAllCache: {
                hit: bfsAllCacheStats.hit,
                miss: bfsAllCacheStats.miss,
                total: bfsAllCacheStats.total,
                hitRate: bfsAllCacheStats.total > 0 ? bfsAllCacheStats.hit / bfsAllCacheStats.total * 100 : 0,
                getCount: bfsAllCacheStats.total,
                size: this.bfsAllCache.size
            },
            bfsLevelCache: {
                hit: bfsLevelCacheStats.hit,
                miss: bfsLevelCacheStats.miss,
                total: bfsLevelCacheStats.total,
                hitRate: bfsLevelCacheStats.total > 0 ? bfsLevelCacheStats.hit / bfsLevelCacheStats.total * 100 : 0,
                size: this.bfsLevelCache.size,
                getCount: bfsLevelCacheStats.total
            },
            getDirectChildren: {
                hit: getDirectChildrenStats.hit,
                miss: getDirectChildrenStats.miss,
                total: getDirectChildrenStats.total,
                hitRate: getDirectChildrenStats.total > 0 ? getDirectChildrenStats.hit / getDirectChildrenStats.total * 100 : 0
            }
        };
        // 
        this.perfAnalyzer.report();
        // 
        return {
            errors: allErrors,
            stats: stats
        };
    }
    cartesianProductInner1(arrays, firstK) {
        const callId = this.perfAnalyzer.startMethod('cartesianProduct');
        // 
        if (arrays.length === 0) {
            return [
                []
            ];
        }
        // 
        if (arrays.length === 1) {
            const inputSize = arrays[0].length;
            this.perfAnalyzer.endMethod(callId, inputSize, inputSize);
            return arrays[0];
        }
        // 
        const perfStats = {
            totalBranches: 0,
            skippedByLength: 0,
            skippedByDuplicate: 0,
            actualCombined: 0,
            maxResultSize: 0,
            movedToFinal: 0 // 
        };
        //
        const arrayFirst = arrays[0];
        //
        // 
        let result = arrayFirst.filter((item)=>item.length < firstK);
        let finalResult = arrayFirst.filter((item)=>item.length >= firstK).map((item)=>item.join(EXPANSION_LIMITS.RuleJoinSymbol));
        //  FIRST_K 
        const finalResultSet = new Set(finalResult);
        // 
        for(let i = 1; i < arrays.length; i++){
            this.checkTimeout(`cartesianProduct-${i}/${arrays.length}`);
            //
            const arrilen = arrays[i].length;
            // 
            const currentArray = this.deduplicate(arrays[i]);
            if (arrilen > currentArray.length) {
                throw new Error('');
            }
            const temp = [];
            // 
            let seqIndex = 0;
            const totalSeqs = result.length;
            const shouldLogProgress = totalSeqs > 1000 || currentArray.length > 1000;
            if (shouldLogProgress) {
                totalSeqs * currentArray.length;
            }
            for (const seq of result){
                currentArray.length * seq.length;
                seqIndex++;
                // 1000seq
                if (seqIndex % 1000 === 0 || seqIndex === totalSeqs) {
                    this.checkTimeout(`cartesianProduct-seq${seqIndex}/${totalSeqs}`);
                    if (shouldLogProgress) {
                        (seqIndex / totalSeqs * 100).toFixed(1);
                    }
                }
                //  seq 
                const availableLength = firstK - seq.length;
                // 2seq  firstK
                if (availableLength < 0) {
                    throw new Error('');
                } else if (availableLength === 0) {
                    // 1seq  firstK
                    const seqKey = seq.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    finalResultSet.add(seqKey);
                    perfStats.movedToFinal++;
                    perfStats.skippedByLength += currentArray.length;
                    continue; // 
                }
                // seq 
                const seqDeduplicateSet = new Set();
                // 3seq  < FIRST_K
                //   seq  join  FIRST_K 
                const seqLength = seq.length;
                const seqKey = seqLength > 0 ? seq.join(EXPANSION_LIMITS.RuleJoinSymbol) : '';
                for (const branch of currentArray){
                    perfStats.totalBranches++;
                    //   slice
                    //  branch.length <= availableLength branch slice 
                    const branchLength = branch.length;
                    const truncatedBranch = branchLength <= availableLength ? branch : branch.slice(0, availableLength);
                    const truncatedLength = truncatedBranch.length;
                    //   join
                    //  truncatedBranch === branch join
                    const branchKey = truncatedBranch.join(EXPANSION_LIMITS.RuleJoinSymbol);
                    // seq 
                    if (seqDeduplicateSet.has(branchKey)) {
                        perfStats.skippedByDuplicate++;
                        continue;
                    }
                    seqDeduplicateSet.add(branchKey);
                    //  
                    const combinedLength = seqLength + truncatedLength;
                    // 
                    if (combinedLength > firstK) {
                        throw new Error('');
                    }
                    //  firstK
                    if (combinedLength === firstK) {
                        // 
                        //   seqKey  branchKey join
                        const combinedKey = seqKey ? seqKey + EXPANSION_LIMITS.RuleJoinSymbol + branchKey : branchKey;
                        finalResultSet.add(combinedKey);
                        perfStats.movedToFinal++;
                    } else {
                        //  temp 
                        //   +  concat 
                        const combined = new Array(combinedLength);
                        for(let j = 0; j < seqLength; j++){
                            combined[j] = seq[j];
                        }
                        for(let j = 0; j < truncatedLength; j++){
                            combined[seqLength + j] = truncatedBranch[j];
                        }
                        temp.push(combined);
                    }
                    perfStats.actualCombined++;
                }
            }
            result = this.deduplicate(temp);
            // 
            perfStats.maxResultSize = Math.max(perfStats.maxResultSize, result.length + finalResultSet.size);
            // 
            if (result.length + finalResultSet.size > 100000) {
                console.warn(` : temp=${result.length}, final=${finalResultSet.size} ( ${i}/${arrays.length - 1})`);
            }
            //  result 
            if (result.length === 0 && finalResultSet.size > 0) {
                break;
            }
        }
        // finalResultSet + result
        let finalArray = [];
        // 1.  Set 
        for (const seqStr of finalResultSet){
            if (seqStr === '') {
                finalArray.push([]); // 
            } else {
                finalArray.push(seqStr.split(EXPANSION_LIMITS.RuleJoinSymbol));
            }
        }
        // 2.  FIRST_K 
        finalArray = finalArray.concat(result);
        const deduplicatedFinalArray = this.deduplicate(finalArray);
        // 
        for (const resultElement of deduplicatedFinalArray){
            if (resultElement.length > firstK) {
                throw new Error('');
            }
        }
        // 
        const inputSize = arrays.reduce((sum, arr)=>sum + arr.length, 0);
        this.perfAnalyzer.endMethod(callId, inputSize, deduplicatedFinalArray.length);
        return deduplicatedFinalArray;
    }
    /**
     *  + seq + 
     * [[a1, a2], [b1, b2]]  [[a1, b1], [a1, b2], [a2, b1], [a2, b2]]
     *
     *  
     * -  [] 
     * - [...seq, ...[]] = [...seq] seq
     * - [[a]]  [[], [b]]  [[a], [a,b]]
     * -  option/many 
     *
     *  
     * 1. 
     * 2. seq 
     * 3. 
     * 4.  firstK 
     * 5.  firstK 
     */ cartesianProduct(arrays, firstK) {
        //  split 
        //  firstK 
        let deduplicatedFinalArray = this.cartesianProductInner1(arrays, firstK);
        // let deduplicatedFinalArray = this.cartesianProductInner2(arrays,firstK)
        return deduplicatedFinalArray;
    }
    cartesianProductInner2(arrays, firstK) {
        const callId = this.perfAnalyzer.startMethod('cartesianProduct');
        const tempr = fastCartesian(arrays);
        //  split 
        //  firstK 
        let deduplicatedFinalArray = tempr.map((item)=>{
            // item  string[] join 
            //  split  flat 
            const combinedPath = item.flat();
            //  firstK 
            return combinedPath;
        });
        const inputSize = arrays.reduce((sum, arr)=>sum + arr.length, 0);
        this.perfAnalyzer.endMethod(callId, inputSize, deduplicatedFinalArray.length);
        return deduplicatedFinalArray;
    }
    /**
     * DFS - Depth-First Search
     *
     *  token
     *
     * 
     * - maxLevel = INFINITY
     * - token
     * -  First(K) + 
     *
     * 
     * - AST
     * - 
     * -  firstK 
     *
     * @param node - AST 
     * @param ruleName - 
     * @param firstK -  K 
     * @param curLevel -  0
     * @param maxLevel -  Infinity
     * @param isFirstPosition - 
     * @returns  string[][]
     *
     * 
     * - expandPathsByDFS(node, null, firstK, curLevel, maxLevel) - 
     * - expandPathsByDFS(null, ruleName, firstK, curLevel, maxLevel) - 
     *
     *  AST 
     * - consume:  [[tokenName]]
     * - subrule: 
     * - sequence: 
     * - or: 
     * - option/many: 
     */ expandNode(node, firstK, curLevel, maxLevel, isFirstPosition = false) {
        const callId = this.perfAnalyzer.startMethod('expandNode');
        // DFS 
        // 
        let result;
        switch(node.type){
            case 'consume':
                // Token  token 
                result = [
                    [
                        node.tokenName
                    ]
                ];
                break;
            case 'subrule':
                //  subRuleHandler 
                result = this.expandPathsByDFSCache(node.ruleName, firstK, curLevel, maxLevel, isFirstPosition);
                break;
            case 'or':
                // Or 
                //  Or  isFirstPosition
                result = this.expandOr(node.alternatives, firstK, curLevel, maxLevel, isFirstPosition);
                break;
            case 'sequence':
                // Sequence 
                result = this.expandSequenceNode(node, firstK, curLevel, maxLevel, isFirstPosition);
                break;
            case 'option':
            case 'many':
                // Option/Many 0
                //  Option  isFirstPosition
                result = this.expandOption(node.node, firstK, curLevel, maxLevel, isFirstPosition);
                break;
            case 'atLeastOne':
                // AtLeastOne 1 double 
                //  AtLeastOne  isFirstPosition
                result = this.expandAtLeastOne(node.node, firstK, curLevel, maxLevel, isFirstPosition);
                break;
            default:
                // 
                throw new Error(`: ${node.type}`);
        }
        // 
        this.perfAnalyzer.endMethod(callId, undefined, result.length);
        return result;
    }
    checkTimeout(location) {
        if (!this.operationStartTime) return;
        const elapsed = (Date.now() - this.operationStartTime) / 1000;
        this.timeoutSeconds - elapsed;
        if (elapsed > this.timeoutSeconds) {
            const errorMsg = `
 ==========  ==========
: ${location}
: ${this.currentProcessingRule}
: ${elapsed.toFixed(2)}
: ${this.timeoutSeconds}


1. 
2. 
3. 
================================`;
            console.error(errorMsg);
            throw new Error(`: ${elapsed.toFixed(2)} (: ${location})`);
        }
    }
    expandSequenceNode(node, firstK, curLevel, maxLevel, isFirstPosition = true) {
        const callId = this.perfAnalyzer.startMethod('expandSequenceNode');
        this.checkTimeout('expandSequenceNode-');
        // 
        if (node.nodes.length === 0) {
            // 
            return [
                []
            ];
        }
        // First(K)
        //  
        //
        // 1 - slice(0, firstK)
        // -  firstK 
        // - firstK=22
        //
        // 2 -  firstK 
        // -  = 
        // -  >= firstK
        // - 1
        //
        // 1sequence([a,b,c], [d], [e], [f])  firstK=2
        //   1slice(0,2)   [a,b,c], [d]
        //   2
        //     1. [a,b,c]  [[a,b,c]]=3
        //        3 >= 2  1
        //   [[a,b,c]]
        //   2[[a,b]]
        //
        // 2sequence([a], or([b]/[c,d]), [e])  firstK=3
        //   1slice(0,3)  3
        //   2
        //     1. [a]  [[a]]=1=1 < 3
        //     2. or([b]/[c,d])  [[b],[c,d]]=1=2 < 3
        //     3. [e]  [[e]]=1=3 >= 3  
        //   [[a]]  [[b],[c,d]]  [[e]] = [[a,b,e],[a,c,d,e]]
        //   3[[a,b,e],[a,c,d]]
        //
        // 3 sequence([a], option([b]), [c,d])  firstK=2
        //   1slice(0,2)  2
        //   2
        //     1. [a]  [[a]]=1=1 < 2
        //     2. option([b])  [[],[b]]=0=1 < 2
        //   3 slice(0,2) 
        //   [[a]]  [[],[b]] = [[a],[a,b]]
        //   2[[a],[a,b]]
        //
        //  
        // -  firstK 1
        // -  1 2
        // -  < firstK 
        //  
        // 1. slice(0, firstK) -  firstK 
        // 2.  -  firstK 
        //   option/many 
        let requiredCount = 0 //  option/many 
        ;
        let expandToIndex = node.nodes.length // 
        ;
        //  firstK 
        for(let i = 0; i < node.nodes.length; i++){
            const child = node.nodes[i];
            //  option/many 
            if (child.type !== 'option' && child.type !== 'many') {
                requiredCount++;
                //  firstK 
                if (requiredCount >= firstK) {
                    //  i + 1
                    expandToIndex = i + 1;
                    break;
                }
            }
        }
        //  firstK
        // const nodesToExpand = node.nodes.slice(0, firstK)
        const nodesToExpand = node.nodes.slice(0, expandToIndex);
        const allBranches = [];
        let minLengthSum = 0 // 
        ;
        //  firstK 
        for(let i = 0; i < nodesToExpand.length; i++){
            this.checkTimeout(`expandSequenceNode-${i + 1}`);
            // 
            //  1 AND 1
            let branches = this.expandNode(nodesToExpand[i], firstK, curLevel, maxLevel, isFirstPosition && i === 0 // 1 true
            );
            //  branches 
            if (branches.length === 0) {
                // 
                return [];
            }
            branches = branches.map((item)=>item.slice(0, firstK));
            allBranches.push(branches);
            // 
            let minLength = Infinity;
            for (const b of branches){
                const len = b.length;
                if (len < minLength) {
                    minLength = len;
                    if (minLength === 0) break; // 
                }
            }
            minLengthSum += minLength;
            //  >= firstK
            if (minLengthSum >= firstK) {
                break;
            }
        }
        // 
        if (allBranches.length === 0) {
            // 
            return [];
        }
        // 
        this.checkTimeout('expandSequenceNode-');
        const result = this.cartesianProduct(allBranches, firstK);
        this.checkTimeout('expandSequenceNode-');
        // 
        const finalResult = this.truncateAndDeduplicate(result, firstK);
        // 
        this.perfAnalyzer.endMethod(callId, node.nodes.length, finalResult.length);
        return finalResult;
    }
    /**
     * BFS - Breadth-First Search
     *
     *  
     *   -  level 1 
     *
     * 
     * - maxLevel =  3, 5
     * - 
     * -  First() + 
     *
     * 
     * - BFS firstK=
     * - 
     * - 
     *
     * 
     * - level3 = level2 + 1
     * -  maxLevel-1  maxLevel-2  ...  level 1
     * - 
     *
     * @param ruleName 
     * @param maxLevel 
     * @returns 
     *
     * 
     * 1. maxLevel-1, maxLevel-2, ..., 1
     * 2.  level 1
     * 3. 1 expandSinglePath
     * 4. token
     * 5. 
     * 6. 
     *
     * 
     *  level 4
     *   -  level 3    
     *   - level 3 + 1 = level 4
     *   - level 123 
     */ /**
     * BFS 
     *
     * 
     * 1.  level 3
     * 2. 
     * 3. 
     *
     *  A:10 A:3
     * -  A:3 = [a1, B, c1]
     * -  B  expandPathsByBFSCache(B, 7, [B])
     *   -  B:3 = [b1, C, c1]
     *   -  C  expandPathsByBFSCache(C, 4, [C])
     *     -  C:3 = [c1, D, c3]
     *     -  D  expandPathsByBFSCache(D, 1, [D])
     *       -  getDirectChildren(D)
     *     -  C:4 
     *   -  B:7 
     * -  A:10 
     *
     * BFS 
     *
     * 
     * 1.  ruleName 
     * 2. 
     * 3. 
     *
     *  A:10 A:3
     * -  A:10   A:3 = [[a1, B, c1]]
     * -  B expandPathsByBFSCacheClean(B, 7)
     *   -  B:7   B:3 = [[b1, C, d1]]
     *   -  C expandPathsByBFSCacheClean(C, 4)
     *     -  C:4   C:3 = [[c1, D, e1]]
     *     -  D expandPathsByBFSCacheClean(D, 1)
     *         getDirectChildren(D)
     *     -  C:4 
     *   -  B:7 
     * -  A:10 
     *
     * @param ruleName 
     * @param targetLevel 
     * @returns 
     */ expandPathsByBFSCache(ruleName, targetLevel) {
        const depth = this.currentDepth;
        // 
        if (targetLevel === 0) {
            throw new Error('');
        }
        // token
        //   token  getDirectChildren 
        const tokenNode = this.tokenCache?.get(ruleName);
        if (tokenNode && tokenNode.type === 'consume') {
            const result = [
                [
                    ruleName
                ]
            ];
            return result;
        }
        // level 1
        if (targetLevel === EXPANSION_LIMITS.LEVEL_1) {
            this.writeLog(` getDirectChildren(${ruleName}) []`, depth);
            this.currentDepth = depth + 1;
            const result = this.getDirectChildren(ruleName);
            this.currentDepth = depth;
            this.writeLog(` getDirectChildren(${ruleName}) []`, depth);
            this.writeLog(` : expandPathsByBFSCache(${ruleName}, targetLevel=1), : ${result.length} []`, depth);
            return result;
        }
        const key = `${ruleName}:${targetLevel}`;
        // 
        this.currentProcessingRule = `${ruleName}:Level${targetLevel}`;
        // 
        this.checkTimeout(`expandPathsByBFSCache-${ruleName}-Level${targetLevel}`);
        // 
        if (this.bfsLevelCache.has(key)) {
            const cached = this.getCacheValue('bfsLevelCache', key);
            this.writeLog(` BFS: ${key}, : ${cached.length}`, depth);
            this.writeLog(` : expandPathsByBFSCache(${ruleName}, targetLevel=${targetLevel}), , : ${cached.length} []`, depth);
            return cached;
        }
        this.writeLog(` BFS: ${key}`, depth);
        //  ruleName 
        let cachedLevel = 1;
        let cachedBranches = null;
        for(let level = Math.min(targetLevel, EXPANSION_LIMITS.LEVEL_K); level >= 2; level--){
            const cacheKey = `${ruleName}:${level}`;
            if (this.bfsLevelCache.has(cacheKey)) {
                cachedLevel = level;
                cachedBranches = this.getCacheValue('bfsLevelCache', cacheKey);
                this.writeLog(` : ${cacheKey}, : ${cachedBranches.length}`, depth);
                // 
                if (level === targetLevel) {
                    this.writeLog(` : expandPathsByBFSCache(${ruleName}, targetLevel=${targetLevel}), , : ${cachedBranches.length} []`, depth);
                    return cachedBranches;
                }
                break;
            } else {
                this.writeLog(` : ${cacheKey}`, depth);
            }
        }
        // 
        if (!cachedBranches) {
            this.writeLog(` getDirectChildren(${ruleName}) []`, depth);
            cachedLevel = EXPANSION_LIMITS.LEVEL_1;
            this.currentDepth = depth + 1;
            cachedBranches = this.getDirectChildren(ruleName);
            this.currentDepth = depth;
            this.writeLog(` getDirectChildren(${ruleName}) []`, depth);
        }
        // 
        const remainingLevels = targetLevel - cachedLevel;
        // 
        if (remainingLevels <= 0) {
            throw new Error('');
        }
        //  cachedPaths 
        let expandedPaths = [];
        const totalPaths = cachedBranches.length;
        // 
        const branchResults = [];
        for(let branchIndex = 0; branchIndex < cachedBranches.length; branchIndex++){
            const branchSeqRules = cachedBranches[branchIndex];
            // 
            if (branchIndex % 10 === 0 || branchIndex === cachedBranches.length - 1) {
                this.checkTimeout(`expandPathsByBFSCache-${ruleName}-${branchIndex + 1}/${totalPaths}`);
            }
            const branchAllRuleBranchSeqs = [];
            // 
            for(let ruleIndex = 0; ruleIndex < branchSeqRules.length; ruleIndex++){
                const subRuleName = branchSeqRules[ruleIndex];
                // 
                this.checkTimeout(`expandPathsByBFSCache-${ruleName}-${ruleIndex + 1}/${branchSeqRules.length}:${subRuleName}`);
                //  
                // 
                // AssignmentExpression  LeftHandSideExpression Assign AssignmentExpression
                //        AssignmentExpression AssignmentExpression
                if (branchSeqRules.includes(subRuleName) && branchSeqRules.indexOf(subRuleName) < ruleIndex) {
                    // 
                    this.writeLog(` : ${subRuleName} `, depth);
                    branchAllRuleBranchSeqs.push([
                        [
                            subRuleName
                        ]
                    ]);
                    continue;
                }
                //  bfsLevelCache 
                this.writeLog(`: ${subRuleName}, : ${remainingLevels} []`, depth);
                this.currentDepth = depth + 1;
                const result = this.expandPathsByBFSCache(subRuleName, remainingLevels);
                this.currentDepth = depth;
                branchAllRuleBranchSeqs.push(result);
                this.writeLog(`: ${subRuleName}, : ${remainingLevels} [], : ${result.length}`, depth);
            }
            // 
            const branchSizes = branchAllRuleBranchSeqs.map((b)=>b.length);
            const estimatedCombinations = branchSizes.reduce((a, b)=>a * b, 1);
            const totalInputSize = branchSizes.reduce((a, b)=>a + b, 0);
            this.writeLog(` []: : ${branchAllRuleBranchSeqs.length}, : [${branchSizes.join(', ')}], : ${estimatedCombinations}, : ${totalInputSize}`, depth);
            const pathResult = this.cartesianProduct(branchAllRuleBranchSeqs, EXPANSION_LIMITS.INFINITY);
            this.writeLog(` []: : ${pathResult.length}, : ${estimatedCombinations}`, depth);
            // 
            this.checkTimeout(`expandPathsByBFSCache-${ruleName}-${branchIndex + 1}-`);
            // 
            if (targetLevel === EXPANSION_LIMITS.LEVEL_K) {
                const branchName = branchSeqRules.join(' ');
                branchResults.push({
                    branchName: branchName,
                    paths: pathResult
                });
            }
            expandedPaths = expandedPaths.concat(pathResult);
        }
        this.checkTimeout(`expandPathsByBFSCache-${ruleName}-`);
        const finalResult = this.deduplicate(expandedPaths);
        // 
        //  key 
        if (this.bfsLevelCache.has(key)) {
            throw new Error('');
        }
        //  
        const shouldCache = !this.isRuleNameOnly(finalResult, ruleName);
        if (shouldCache) {
            this.bfsLevelCache.set(key, finalResult);
            this.writeLog(` : ${key}, : ${finalResult.length}`, depth);
        } else {
            this.writeLog(` : ${key}`, depth);
        }
        // 
        if (targetLevel === EXPANSION_LIMITS.LEVEL_K) {
            // 
            this.writeLog(``, depth);
            this.writeLog(`  ( ${finalResult.length} , ${branchResults.length} ):`, depth);
            this.writeLog(`${'='.repeat(80)}`, depth);
            for(let i = 0; i < branchResults.length; i++){
                const branch = branchResults[i];
                this.writeLog(``, depth);
                this.writeLog(` ${i + 1}: ${branch.branchName} (${branch.paths.length} )`, depth);
                this.writeLog(`${'-'.repeat(80)}`, depth);
                branch.paths.forEach((path, index)=>{
                    this.writeLog(`   ${(index + 1).toString().padStart(4, ' ')}. ${path.join(' ')}`, depth);
                });
            }
            this.writeLog(`${'='.repeat(80)}`, depth);
            this.writeLog(``, depth);
        }
        this.writeLog(` : expandPathsByBFSCache(${ruleName}, targetLevel=${targetLevel}), : ${finalResult.length} []`, depth);
        return finalResult;
    }
    /**
     * 1
     *
     * @param ruleName 
     * @returns 1
     *
     * 
     * 1.  bfsLevelCache  "ruleName:1"
     * 2. 
     *
     * 
     * - Statement  [[BlockStatement], [IfStatement], [ExpressionStatement], ...]
     * - IfStatement  [[If, LParen, Expression, RParen, Statement]]
     */ getDirectChildren(ruleName) {
        const maxLevel = EXPANSION_LIMITS.LEVEL_1;
        // 1.  bfsLevelCache  level 1 
        const key = `${ruleName}:${maxLevel}`;
        const depth = this.currentDepth;
        if (this.bfsLevelCache.has(key)) {
            this.perfAnalyzer.recordCacheHit('getDirectChildren');
            const cached = this.getCacheValue('bfsLevelCache', key);
            this.writeLog(` getDirectChildren: ${key}, : ${cached.length}`, depth);
            this.writeLog(` : getDirectChildren(${ruleName}), , : ${cached.length} []`, depth);
            return cached;
        }
        // 
        this.perfAnalyzer.recordCacheMiss('getDirectChildren');
        this.writeLog(` getDirectChildren: ${key}`, depth);
        // 2.  token
        const tokenNode = this.tokenCache?.get(ruleName);
        if (tokenNode && tokenNode.type === 'consume') {
            const result = [
                [
                    ruleName
                ]
            ];
            this.writeLog(` : getDirectChildren(${ruleName}), Token, : 1 []`, depth);
            return result;
        }
        // 3.  AST 
        const subNode = this.getRuleNodeByAst(ruleName);
        if (!subNode) {
            throw new Error(`: ${ruleName}`);
        }
        const result = this.expandPathsByDFSCache(ruleName, EXPANSION_LIMITS.INFINITY, 0, maxLevel, false);
        // 
        //  
        const shouldCache = !this.isRuleNameOnly(result, ruleName);
        if (shouldCache && !this.bfsLevelCache.has(key)) {
            this.bfsLevelCache.set(key, result);
            this.writeLog(` BFS: ${key}, : ${result.length}`, depth);
        } else if (!shouldCache) {
            this.writeLog(` : ${key}`, depth);
        }
        this.writeLog(` : getDirectChildren(${ruleName}), : ${result.length} []`, depth);
        return result;
    }
    /**
     *  DFS 
     *
     * @param ruleName 
     * @param firstK 
     * @param curLevel 
     * @param maxLevel
     * @param isFirstPosition 
     * @returns 
     */ expandPathsByDFSCache(ruleName, firstK, curLevel, maxLevel, isFirstPosition) {
        // 
        const t0 = Date.now();
        this.perfAnalyzer.cacheStats.subRuleHandlerTotal++;
        // 
        if (!ruleName) {
            throw new Error('');
        }
        // BFS 
        if (curLevel === maxLevel) {
            // 
            this.perfAnalyzer.cacheStats.levelLimitReturn++;
            return [
                [
                    ruleName
                ]
            ];
        } else if (curLevel > maxLevel) {
            throw new Error('');
        }
        // +1
        curLevel++;
        // ========================================
        // 1DFS 
        // ========================================
        if (firstK === EXPANSION_LIMITS.FIRST_K) {
            //  firstK getCacheValue /
            const cached = this.getCacheValue('dfsFirstKCache', ruleName);
            if (cached !== undefined) {
                // DFS 
                const duration = Date.now() - t0;
                this.perfAnalyzer.record('subRuleHandler', duration);
                return cached;
            }
        // 
        } else if (firstK === EXPANSION_LIMITS.INFINITY) {
            if (maxLevel !== EXPANSION_LIMITS.LEVEL_1) {
                throw new Error(` firstK=${firstK}, maxLevel=${maxLevel}`);
            }
        }
        // ========================================
        // 2DFS 
        // ========================================
        // 
        if (this.recursiveDetectionSet.has(ruleName)) {
            // 
            if (isFirstPosition) {
                //   
                // 
                if (!this.detectedLeftRecursionErrors.has(ruleName)) {
                    // 
                    const error = {
                        level: 'FATAL',
                        type: 'left-recursion',
                        ruleName,
                        branchIndices: [],
                        conflictPaths: {
                            pathA: '',
                            pathB: ''
                        },
                        message: ` "${ruleName}" `,
                        suggestion: '' // 
                    };
                    //  Map
                    this.detectedLeftRecursionErrors.set(ruleName, error);
                }
                // 
                this.perfAnalyzer.cacheStats.recursiveReturn++;
                return [
                    [
                        ruleName
                    ]
                ];
            } else {
                //   
                // 
                this.perfAnalyzer.cacheStats.recursiveReturn++;
                return [
                    [
                        ruleName
                    ]
                ];
            }
        }
        // 
        this.recursiveDetectionSet.add(ruleName);
        try {
            // ========================================
            // 3DFS 
            // ========================================
            this.perfAnalyzer.recordActualCompute();
            //  DFS  token
            const expandCallId = this.perfAnalyzer.startMethod('expandPathsByDFSCache');
            const subNode = this.getRuleNodeByAst(ruleName);
            const finalResult = this.expandNode(subNode, firstK, curLevel, maxLevel, isFirstPosition);
            this.perfAnalyzer.endMethod(expandCallId, undefined, finalResult.length);
            // ========================================
            // 4DFS 
            // ========================================
            //  
            // 
            const shouldCache = !this.isRuleNameOnly(finalResult, ruleName);
            if (firstK === EXPANSION_LIMITS.FIRST_K) {
                // DFS  firstK
                if (shouldCache && !this.dfsFirstKCache.has(ruleName)) {
                    //   recordCacheMiss
                    this.dfsFirstKCache.set(ruleName, finalResult);
                }
            } else if (firstK === EXPANSION_LIMITS.INFINITY) {
                if (maxLevel === EXPANSION_LIMITS.LEVEL_1) {
                    const key = ruleName + `:${EXPANSION_LIMITS.LEVEL_1}`;
                    if (shouldCache && !this.bfsLevelCache.has(key)) {
                        this.bfsLevelCache.set(key, finalResult);
                    }
                }
            }
            return finalResult;
        } finally{
            // 
            this.recursiveDetectionSet.delete(ruleName);
        }
    }
    /**
     * 
     *
     * [[ruleName]] - 
     *
     * @param result 
     * @param ruleName 
     * @returns  true false
     */ isRuleNameOnly(result, ruleName) {
        // [[ruleName]] - 
        if (result.length === 1 && result[0].length === 1 && result[0][0] === ruleName) {
            return true;
        }
        return false;
    }
    /**
     * 
     *
     * [[a,b], [c,d], [a,b]]  [[a,b], [c,d]]
     *
     *  
     * -  []  ""
     * - 
     * - [[], [a], []]  [[], [a]]
     */ deduplicate(branches) {
        const callId = this.perfAnalyzer.startMethod('deduplicate');
        // 
        const seen = new Set();
        // 
        const result = [];
        // 
        for (const branch of branches){
            //  Set  key
            //   []  ""
            const key = branch.join(EXPANSION_LIMITS.RuleJoinSymbol);
            // 
            if (!seen.has(key)) {
                //  Set 
                //   [] 
                seen.add(key);
                result.push(branch);
            }
        // 
        }
        //  []
        // 
        this.perfAnalyzer.endMethod(callId, branches.length, result.length);
        return result;
    }
    /**
     *  firstK
     *
     * 
     *
     * [[a,b,c], [d,e,f]], firstK=2  [[a,b], [d,e]]
     *
     *  
     * -  [] slice(0, firstK)  []
     * - 
     * - [[], [a,b,c]], firstK=2  [[], [a,b]]
     *
     *   firstK=INFINITY
     */ truncateAndDeduplicate(branches, firstK) {
        const callId = this.perfAnalyzer.startMethod('truncateAndDeduplicate');
        //  firstK  INFINITY
        if (firstK === EXPANSION_LIMITS.INFINITY) {
            const result = this.deduplicate(branches);
            this.perfAnalyzer.endMethod(callId, branches.length, result.length);
            return result;
        }
        //  firstK
        const truncated = branches.map((branch)=>branch.slice(0, firstK));
        // 
        const result = this.deduplicate(truncated);
        // 
        this.perfAnalyzer.endMethod(callId, branches.length, result.length);
        return result;
    }
    /**
     *  Or 
     *
     * 
     *
     * or(abc / de) firstK=2
     *    abc  [[a,b]]
     *    de  [[d,e]]
     *     [[a,b], [d,e]]
     *
     *   or 
     * -  option/many []
     * - or(option(a) / b)
     *    option(a)  [[], [a]]
     *    b  [[b]]
     *     [[], [a], [b]]
     * - 
     *
     * firstK
     *
     *  Or ""
     * -  PEG 
     * - Or 
     * - A  A '+' B | C
     *   -  A '+' B A 
     *   -  C C 
     */ expandOr(alternatives, firstK, curLevel, maxLevel, isFirstPosition = true //  Or 
    ) {
        const callId = this.perfAnalyzer.startMethod('expandOr');
        //  or 
        if (alternatives.length === 0) {
            throw new Error('Or ');
        }
        // 
        let result = [];
        //  Or 
        for (const alt of alternatives){
            //   Or 
            const branches = this.expandNode(alt, firstK, curLevel, maxLevel, isFirstPosition);
            result = result.concat(branches);
        }
        // 
        if (result.length === 0) {
            throw new Error('Or ');
        }
        // 
        const finalResult = this.deduplicate(result);
        // 
        this.perfAnalyzer.endMethod(callId, alternatives.length, finalResult.length);
        return finalResult;
    }
    /**
     *  Option/Many 
     *
     * option(X) =  | X01
     * many(X) =  | X | XX | XXX...0
     *
     * First 
     * First(option(X)) = {}  First(X)
     * First(many(X)) = {}  First(X)
     *
     * option(abc) firstK=2
     *    abc  [[a,b]]
     *     [[], [a,b]] + 
     *
     *   []  
     * -  []  option/many 0
     * - 
     *   1. deduplicate[] join(',') = ""
     *   2. cartesianProduct[...seq, ...[]] = [...seq]
     *   3. truncateAndDeduplicate[] slice(0,k) = []
     * -  option/many 
     *
     * firstK
     *
     *  Option 
     * -  option(X) 
     * - A  option(A) B
     *   - option(A)  A 
     */ expandOption(node, firstK, curLevel, maxLevel, isFirstPosition = true //  Option 
    ) {
        const callId = this.perfAnalyzer.startMethod('expandOption');
        // 
        const innerBranches = this.expandNode(node, firstK, curLevel, maxLevel, isFirstPosition);
        //   [] 0
        // PEG 
        const result = [
            [],
            ...innerBranches
        ];
        // 
        const finalResult = this.deduplicate(result);
        // 
        this.perfAnalyzer.endMethod(callId, undefined, finalResult.length);
        return finalResult;
    }
    /**
     *  AtLeastOne 
     *
     * atLeastOne(X) = X | XX | XXX...1
     *
     * First 
     * First(atLeastOne(X)) = First(X)  First(XX)
     *
     * atLeastOne(ab) firstK=3
     *    ab  [[a,b]]
     *    1[[a,b]]
     *    2[[a,b,a,b]] 3  [[a,b,a]]
     *     [[a,b], [a,b,a]]
     *
     *  
     * - atLeastOne 1 []
     * -  option/many atLeastOne  []
     * -  option/many
     *   atLeastOne(option(a))
     *    option(a)  [[], [a]]
     *    1[[], [a]]
     *    2[[], [a]]  2  [[], [a]]
     *     [[], [a]]
     * - 
     *
     * doubleBranches  firstK
     *
     *  AtLeastOne 
     */ expandAtLeastOne(node, firstK, curLevel, maxLevel, isFirstPosition = true //  AtLeastOne 
    ) {
        const callId = this.perfAnalyzer.startMethod('expandAtLeastOne');
        // 1
        const innerBranches = this.expandNode(node, firstK, curLevel, maxLevel, isFirstPosition);
        //  doubleBranches2
        const doubleBranches = innerBranches.map((branch)=>{
            // [a,b]  [a,b,a,b]
            //   branch  [] [...[], ...[]] = []
            const doubled = [
                ...branch,
                ...branch
            ];
            //  firstK
            //   [] slice(0, firstK)  []
            return doubled.slice(0, firstK);
        });
        // 12 []
        const result = [
            ...innerBranches,
            ...doubleBranches
        ];
        // 
        //  deduplicate  []
        const finalResult = this.deduplicate(result);
        // 
        this.perfAnalyzer.endMethod(callId, undefined, finalResult.length);
        return finalResult;
    }
    /**
     * 
     *
     * @param ruleName 
     * @param node 
     * @param firstSet First 
     * @returns 
     */ getLeftRecursionSuggestion(ruleName, node, firstSet) {
        // 
        if (node.type === 'or') {
            return `PEG  Many/AtLeastOne


   
     ${ruleName}  ${ruleName} '+' Term | Term

   
     ${ruleName}  Term ('+' Term)*

   Many
     ${ruleName}  Term
     ${ruleName}Suffix  '+' Term
       ${ruleName} ${ruleName}Suffix*

First(${ruleName}) = {${Array.from(firstSet).slice(0, 5).join(', ')}${firstSet.size > 5 ? ', ...' : ''}}
 ${ruleName} `;
        }
        return `PEG 

First(${ruleName}) = {${Array.from(firstSet).slice(0, 5).join(', ')}${firstSet.size > 5 ? ', ...' : ''}}
 ${ruleName} `;
    }
    /**
     * 
     *
     * @param ruleASTs   AST 
     * @param tokenCache
     * @param options 
     */ constructor(ruleASTs, tokenCache, options){
        _define_property$5(this, "ruleASTs", void 0);
        _define_property$5(this, "tokenCache", void 0);
        /**  */ _define_property$5(this, "recursiveDetectionSet", void 0);
        /**  */ _define_property$5(this, "currentRuleName", void 0);
        /**  */ _define_property$5(this, "currentLogFd", void 0);
        /**  */ _define_property$5(this, "currentLogFilePath", void 0);
        /**  */ _define_property$5(this, "currentDepth", void 0);
        // ========================================
        // DFS
        // maxLevel = INFINITYtoken
        // ========================================
        /** DFS key="ruleName"First(K) +  */ _define_property$5(this, "dfsFirstKCache", void 0);
        // ========================================
        // BFS
        // maxLevel = 
        // BFS 
        // ========================================
        //todo bfs
        /** BFS key="ruleName" */ _define_property$5(this, "bfsAllCache", void 0);
        /** BFS key="ruleName:level" */ _define_property$5(this, "bfsLevelCache", void 0);
        /**  */ _define_property$5(this, "perfAnalyzer", void 0);
        /**  Map  */ _define_property$5(this, "detectedLeftRecursionErrors", void 0);
        /**  */ _define_property$5(this, "options", void 0);
        /**
     *  Or - 
     *
     * 
     * 1. 1 First(K) 
     * 2. "" MaxLevel 
     * 3. ""
     *
     * 
     * -  First(K) MaxLevel 
     * - 
     *
     * @param ruleName - 
     * @param orNode - Or 
     * @returns  undefined
     */ /**
     *  Or First(K)  + MaxLevel 
     *
     * 
     * 1. First(K) /
     * 2.    MaxLevel 
     * 3.  First(K) MaxLevel 
     * 4.  MaxLevel  First(K) 
     *
     * @param ruleName - 
     * @param orNode - Or 
     * @returns  undefined
     */ // FirstK vs MaxLevel 
        _define_property$5(this, "compareStats", void 0);
        _define_property$5(this, "depthMap", void 0);
        _define_property$5(this, "depmap", void 0);
        _define_property$5(this, "graph", void 0);
        /**
     *  Sequence 
     *
     * 
     * - First(1)1
     * - First(K)
     *
     *   sequence 
     * -  [] option/many
     * - [[a]]  [[], [b]]  [[a], [a,b]]
     * - 
     *
     * @param node
     * @param firstK
     * @param curLevel
     * @param maxLevel
     * @param isFirstPosition 
     */ // 
        _define_property$5(this, "operationStartTime", void 0);
        _define_property$5(this, "currentProcessingRule", void 0);
        _define_property$5(this, "timeoutSeconds", void 0);
        this.ruleASTs = ruleASTs;
        this.tokenCache = tokenCache;
        this.recursiveDetectionSet = new Set();
        this.currentRuleName = null;
        this.currentLogFd = null;
        this.currentLogFilePath = null;
        this.currentDepth = 0;
        this.dfsFirstKCache = new Map();
        this.bfsAllCache = new Map();
        this.bfsLevelCache = new Map();
        this.perfAnalyzer = new PerformanceAnalyzer();
        this.detectedLeftRecursionErrors = new Map();
        this.compareStats = {
            firstKDetected: 0,
            bothDetected: 0,
            firstKOnlyDetected: 0
        };
        this.depthMap = new Map();
        this.depmap = new Map();
        this.operationStartTime = 0;
        this.currentProcessingRule = '';
        this.timeoutSeconds = 1000;
        this.options = {
            maxLevel: options?.maxLevel ?? 5
        };
    }
}

/**
 * Subhuti Grammar Validation - 
 *
 * 
 *
 * @version 1.0.0
 */ // ============================================
// 
// ============================================
/**
 * 
 */ function _define_property$4(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * 
 */ class SubhutiGrammarValidationError extends Error {
    /**
     * 
     */ toString() {
        const lines = [];
        // 
        for (const error of this.errors){
            // 
            let title = '';
            if (error.type === 'prefix-conflict' && error.branchIndices.length === 2) {
                //  j  i 
                const [i, j] = error.branchIndices;
                title = `[${error.level}]  ${j}  ${i} `;
            } else if (error.type === 'or-identical-branches' && error.branchIndices.length === 2) {
                //  i  j 
                const [i, j] = error.branchIndices;
                title = `[${error.level}]  ${i}  ${j} `;
            } else {
                //  message
                title = `[${error.level}] ${error.message}`;
            }
            lines.push(title);
            lines.push(`  Rule: ${error.ruleName}`);
            lines.push(`  Branches: [${error.branchIndices.join(', ')}]`);
            // conflictPaths 
            if (error.conflictPaths) {
                lines.push(`  Path A: ${error.conflictPaths.pathA}`);
                lines.push(`  Path B: ${error.conflictPaths.pathB}`);
            }
            //  Suggestion
            if (error.type === 'prefix-conflict' && error.branchIndices.length === 2) {
                const [i, j] = error.branchIndices;
                lines.push(`  Suggestion:  ${j}  ${i} `);
            } else {
                lines.push(`  Suggestion: ${error.suggestion}`);
            }
            lines.push('');
        }
        // 
        if (this.stats) {
            const s = this.stats;
            lines.push('');
            lines.push('='.repeat(60));
            lines.push(' ==========  ==========');
            lines.push('='.repeat(60));
            lines.push('');
            lines.push('  ');
            lines.push(`   : ${s.totalTime}ms`);
            lines.push(`    First(K) : ${s.dfsFirstKTime}ms (${(s.dfsFirstKTime / s.totalTime * 100).toFixed(1)}%)`);
            lines.push(`    MaxLevel : ${s.bfsMaxLevelTime}ms (${(s.bfsMaxLevelTime / s.totalTime * 100).toFixed(1)}%)`);
            lines.push(`    Or : ${s.orDetectionTime}ms (${(s.orDetectionTime / s.totalTime * 100).toFixed(1)}%)`);
            lines.push('');
            lines.push(' ');
            lines.push(`    : ${s.leftRecursionCount} `);
            lines.push(`    Or : ${s.orConflictCount} `);
            lines.push(`   : ${this.errors.length} `);
            lines.push('');
            lines.push(' ');
            lines.push(`    dfsFirstKCache: ${s.dfsFirstKCacheSize}  (First(${s.firstK}))`);
            lines.push(`    bfsAllCache: ${s.bfsAllCacheSize}  (MaxLevel)`);
            // 
            if (s.cacheUsage) {
                lines.push('');
                lines.push(' ');
                // dfsFirstKCache
                const dfs = s.cacheUsage.dfsFirstK;
                lines.push(`   dfsFirstKCache:`);
                lines.push(`      : ${dfs.getCount}`);
                lines.push(`      : ${dfs.hit}`);
                lines.push(`      : ${dfs.miss}`);
                lines.push(`      : ${dfs.hitRate.toFixed(1)}%`);
                lines.push(`      : ${s.dfsFirstKCacheSize}`);
                // bfsAllCache
                const bfsAll = s.cacheUsage.bfsAllCache;
                lines.push(`   bfsAllCache:`);
                lines.push(`      : ${bfsAll.getCount}`);
                lines.push(`      : ${bfsAll.hit}`);
                lines.push(`      : ${bfsAll.miss}`);
                lines.push(`      : ${bfsAll.total > 0 ? bfsAll.hitRate.toFixed(1) : '0.0'}%`);
                lines.push(`      : ${bfsAll.size}`);
                // bfsLevelCache
                const bfsLevel = s.cacheUsage.bfsLevelCache;
                lines.push(`   bfsLevelCache:`);
                lines.push(`      : ${bfsLevel.getCount}`);
                lines.push(`      : ${bfsLevel.hit}`);
                lines.push(`      : ${bfsLevel.miss}`);
                lines.push(`      : ${bfsLevel.total > 0 ? bfsLevel.hitRate.toFixed(1) : 'N/A'}%`);
                lines.push(`      : ${bfsLevel.size}`);
                // getDirectChildren
                const gdc = s.cacheUsage.getDirectChildren;
                if (gdc.total > 0) {
                    lines.push(`   getDirectChildren ():`);
                    lines.push(`      : ${gdc.total}`);
                    lines.push(`      : ${gdc.hit}`);
                    lines.push(`      : ${gdc.miss}`);
                    lines.push(`      : ${gdc.hitRate.toFixed(1)}%`);
                    lines.push(`      :  bfsLevelCache `);
                }
            }
            lines.push('');
            lines.push('='.repeat(60));
        }
        return lines.join('\n');
    }
    constructor(errors, stats){
        super('Grammar validation failed'), _define_property$4(this, "errors", void 0), _define_property$4(this, "stats", void 0), this.errors = errors, this.stats = stats;
        this.name = 'SubhutiGrammarValidationError';
    }
}

class SubhutiGrammarValidator {
    /**
     * 
     *
     * 
     * 1.  Proxy  AST
     * 2.  First 
     * 3. Level 0:  (FATAL) - 
     * 4. Level 1 & 2: Or  (FATAL/ERROR)
     * 5.  SubhutiGrammarValidationError
     *
     * @param parser Parser 
     * @param maxLevel  MAX_LEVEL
     * @throws SubhutiGrammarValidationError 
     */ static validate(parser) {
        // 1.  AST Proxy Parser 
        const ruleASTs = SubhutiRuleCollector.collectRules(parser);
        // 2. 
        const analyzer = new SubhutiGrammarAnalyzer(ruleASTs.cstMap, ruleASTs.tokenMap);
        // 3. First 
        //  Or 
        const result = analyzer.initCacheAndCheckLeftRecursion();
        // 4.  toString() 
        if (result.errors.length > 0) {
            const error = new SubhutiGrammarValidationError(result.errors, result.stats);
            console.error('\n' + error.toString());
        }
    }
}

function _define_property$3(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// ============================================
// 
// ============================================
function Subhuti(target, context) {
    //  context.metadata tsdown/rolldown 
    return target;
}
function SubhutiRule(targetFun, context) {
    const ruleName = targetFun.name;
    //  this.constructor.name 
    const wrappedFunction = function(...args) {
        const className = this.constructor.name;
        return this.executeRuleWrapper(targetFun, ruleName, className, ...args);
    };
    Object.defineProperty(wrappedFunction, 'name', {
        value: ruleName
    });
    //   SubhutiRuleCollector 
    Object.defineProperty(wrappedFunction, '__originalFunction__', {
        value: targetFun,
        writable: false,
        enumerable: false,
        configurable: false
    });
    //  
    Object.defineProperty(wrappedFunction, '__isSubhutiRule__', {
        value: true,
        writable: false,
        enumerable: false,
        configurable: false
    });
    return wrappedFunction;
}
class SubhutiParser extends SubhutiTokenLookahead {
    /**
     *  Token
     */ setSyncTokens(tokens) {
        this._syncTokens = new Set(tokens);
        return this;
    }
    /**
     *  Token
     */ addSyncTokens(tokens) {
        for (const token of tokens){
            this._syncTokens.add(token);
        }
        return this;
    }
    /**
     * 
     */ enableErrorRecovery() {
        this._errorRecoveryMode = true;
        return this;
    }
    /**
     * 
     */ get errorRecoveryMode() {
        return this._errorRecoveryMode;
    }
    getRuleStack() {
        return this.cstStack.map((item)=>item.name);
    }
    /**
     *  tokens 
     */ get unparsedTokens() {
        return this._unparsedTokens;
    }
    /**
     *  tokens
     */ get hasUnparsedTokens() {
        return this._unparsedTokens.length > 0;
    }
    /**
     *  token 
     */ get parsedTokens() {
        return this._parsedTokens;
    }
    /**
     *  token 
     * @returns token  token  -1
     */ get lastTokenIndex() {
        return this._parsedTokens.length - 1;
    }
    /**
     *  token  consume  token
     * @returns  token 
     */ get currentTokenIndex() {
        return this._parsedTokens.length;
    }
    // ============================================
    // 
    // ============================================
    /**
     *  token
     *
     * @param codeIndex 
     * @param line 
     * @param column 
     * @param goal 
     * @returns TokenCacheEntry  nullEOF
     */ _getOrParseToken(codeIndex, line, column, goal) {
        if (!this._lexer) return null;
        // 1. 
        const positionCache = this._tokenCache.get(codeIndex);
        if (positionCache?.has(goal)) {
            return positionCache.get(goal);
        }
        // 2.  token
        const entry = this._lexer.readTokenAt(this._sourceCode, codeIndex, line, column, goal, this._lastTokenName, this._templateDepth);
        if (!entry) return null // EOF
        ;
        // 3. 
        if (!positionCache) {
            this._tokenCache.set(codeIndex, new Map());
        }
        this._tokenCache.get(codeIndex).set(goal, entry);
        return entry;
    }
    /**
     * LA (LookAhead) -  token
     *
     * @param offset 1 =  token2 = ...
     * @param goals 
     * @returns token  undefinedEOF
     */ LA(offset = 1, goals) {
        let currentIndex = this._codeIndex;
        let currentLine = this._codeLine;
        let currentColumn = this._codeColumn;
        for(let i = 0; i < offset; i++){
            //  token 
            const goal = goals?.[i] ?? this._defaultGoal;
            // 
            const entry = this._getOrParseToken(currentIndex, currentLine, currentColumn, goal);
            if (!entry) return undefined // EOF
            ;
            //  token
            if (i === offset - 1) {
                return entry.token;
            }
            // 
            currentIndex = entry.nextCodeIndex;
            currentLine = entry.nextLine;
            currentColumn = entry.nextColumn;
        }
        return undefined;
    }
    /**
     * peek -  token
     */ peek(offset = 1, goals) {
        return this.LA(offset, goals);
    }
    /**
     *  token
     */ get curToken() {
        return this.LA(1);
    }
    // ============================================
    //  TokenConsumer 
    // ============================================
    /**
     *  TokenConsumer  consume 
     * @param tokenName token 
     * @param goal 
     */ _consumeToken(tokenName, goal) {
        return this.consume(tokenName, goal);
    }
    /**
     *  TokenConsumer 
     * 
     */ _markParseFail() {
        this._parseSuccess = false;
    }
    // ============================================
    // Parser  Getter
    // ============================================
    get curCst() {
        return this.cstStack[this.cstStack.length - 1];
    }
    // 
    cache(enable = true) {
        this.enableMemoization = enable;
        return this;
    }
    /**
     * 
     * @param showRulePath -  true
     *                        false  CST 
     */ debug(showRulePath = true) {
        setShowRulePath(showRulePath);
        this._debugger = new SubhutiTraceDebugger(this._parsedTokens);
        return this;
    }
    errorHandler(enable = true) {
        this._errorHandler.setDetailed(enable);
        return this;
    }
    /**
     * 
     *
     * 
     * - 
     * - 
     * -  Token 
     * -  EOF 
     *
     * @internal  SubhutiRuleCollector 
     */ enableAnalysisMode() {
        this._analysisMode = true;
    }
    /**
     * 
     *
     * @internal  SubhutiRuleCollector 
     */ disableAnalysisMode() {
        this._analysisMode = false;
    }
    /**
     *  Or 
     *
     * 
     * ```typescript
     * const parser = new Es2025Parser(tokens).validate()
     * const cst = parser.Script()
     * ```
     *
     * @returns this - 
     * @throws SubhutiGrammarValidationError - 
     */ validate() {
        SubhutiGrammarValidator.validate(this);
        return this;
    }
    /**
     * 
     *
     *  
     *   Or  false 
     *
     * @param ruleName 
     * @param ruleStack 
     * @returns true: , false: 
     */ isDirectLeftRecursion(ruleName, ruleStack) {
        //  >= 2 
        // 
        const ruleCounts = new Map();
        for (const rule of ruleStack){
            ruleCounts.set(rule, (ruleCounts.get(rule) || 0) + 1);
        }
        //  >= 2 
        for (const count of ruleCounts.values()){
            if (count >= 2) {
                return true //  
                ;
            }
        }
        // 
        // Or 
        return false //  
        ;
    }
    /**
     * 
     *
     * @param ruleName 
     */ throwLoopError(ruleName) {
        //  
        if (this._analysisMode) {
            //  RuleCollector 
            this._parseSuccess = false;
            return undefined;
        }
        //  token 
        const currentToken = this.curToken;
        //  parsedTokens  2  token
        const tokenContext = this.getTokenContext(2);
        // 
        const cacheStatsReport = this._cache.getStatsReport();
        //   vs Or 
        const ruleStack = this.getRuleStack();
        const isDirectLeftRecursion = this.isDirectLeftRecursion(ruleName, ruleStack);
        const errorType = isDirectLeftRecursion ? 'left-recursion' : 'or-branch-shadowing';
        // 
        throw this._errorHandler.createError({
            type: errorType,
            expected: '',
            found: currentToken,
            position: {
                tokenIndex: this.currentTokenIndex,
                codeIndex: this._codeIndex,
                line: currentToken?.rowNum || this._codeLine,
                column: currentToken?.columnStartNum || this._codeColumn
            },
            ruleStack: [
                ...ruleStack
            ],
            loopRuleName: ruleName,
            loopDetectionSet: Array.from(this.loopDetectionSet),
            loopCstDepth: this.cstStack.length,
            loopCacheStats: {
                hits: cacheStatsReport.hits,
                misses: cacheStatsReport.misses,
                hitRate: cacheStatsReport.hitRate,
                currentSize: cacheStatsReport.currentSize
            },
            loopTokenContext: tokenContext,
            hint: ' token'
        });
    }
    /**
     *  @SubhutiRule 
     *     Packrat     
     */ executeRuleWrapper(targetFun, ruleName, className, ...args) {
        if (this.checkRuleIsThisClass(ruleName, className)) {
            return;
        }
        const isTopLevel = this.cstStack.length === 0;
        if (isTopLevel) {
            this.initTopLevelData();
        }
        if (this.parserFail) {
            return;
        }
        const tokenIndex = this.currentTokenIndex;
        const key = `${ruleName}:${tokenIndex}`;
        // O(1) 
        if (this.loopDetectionSet.has(key)) {
            this.throwLoopError(ruleName);
        }
        // 
        this.loopDetectionSet.add(key);
        try {
            const startTime = this._debugger?.onRuleEnter(ruleName, tokenIndex);
            // Packrat Parsing 
            if (this.enableMemoization) {
                const cached = this._cache.get(ruleName, tokenIndex);
                if (cached !== undefined) {
                    this._debugger?.onRuleExit(ruleName, true, startTime);
                    //  endTokenIndex
                    if (this.errorRecoveryMode && cached.endTokenIndex > tokenIndex) {
                        //  children
                        const recordNode = {
                            name: ruleName,
                            startTokenIndex: tokenIndex,
                            endTokenIndex: cached.endTokenIndex,
                            children: cached.recordNode?.children ? [
                                ...cached.recordNode.children
                            ] : []
                        };
                        const recordParent = this._parseRecordStack[this._parseRecordStack.length - 1];
                        if (recordParent) {
                            recordParent.children.push(recordNode);
                        }
                        //  endTokenIndex
                        for(let i = this._parseRecordStack.length - 1; i >= 0; i--){
                            const ancestor = this._parseRecordStack[i];
                            if (cached.endTokenIndex > ancestor.endTokenIndex) {
                                ancestor.endTokenIndex = cached.endTokenIndex;
                            }
                        }
                    }
                    const cst = this.applyCachedResult(cached);
                    if (!cst.children?.length) {
                        cst.children = undefined;
                    }
                    return cst;
                }
            }
            // 
            const startTokenIndex = tokenIndex;
            //  executeRuleCore 
            let recordNode = null;
            if (this.errorRecoveryMode) {
                recordNode = {
                    name: ruleName,
                    children: [],
                    startTokenIndex: tokenIndex,
                    endTokenIndex: tokenIndex
                };
                this._parseRecordStack.push(recordNode);
            }
            const cst = this.executeRuleCore(ruleName, targetFun, ...args);
            //  token 
            if (this.errorRecoveryMode && recordNode) {
                this._parseRecordStack.pop();
                if (recordNode.endTokenIndex > recordNode.startTokenIndex) {
                    const recordParent = this._parseRecordStack[this._parseRecordStack.length - 1];
                    if (recordParent) {
                        recordParent.children.push(recordNode);
                    }
                }
            }
            // 
            if (this.enableMemoization) {
                const endTokenIndex = this.currentTokenIndex;
                const finalEndIndex = recordNode ? Math.max(recordNode.endTokenIndex, endTokenIndex) : endTokenIndex;
                //  token
                const consumedTokens = this._parseSuccess ? this._parsedTokens.slice(startTokenIndex) : undefined;
                this._cache.set(ruleName, startTokenIndex, {
                    endTokenIndex: finalEndIndex,
                    cst: cst,
                    parseSuccess: this._parseSuccess,
                    recordNode: recordNode,
                    parsedTokens: consumedTokens
                });
            }
            this.onRuleExitDebugHandler(ruleName, cst, isTopLevel, startTime);
            // 
            if (isTopLevel && this._parseSuccess) {
                if (!this.isEof) {
                    const nextToken = this.LA(1);
                    throw new Error(`Parser internal error: parsing succeeded but source code remains unconsumed. ` + `Next token: "${nextToken?.tokenValue}" (${nextToken?.tokenName}) at position ${this._codeIndex}`);
                }
            }
            // 
            if (isTopLevel && this.parserFail) {
                this.handleTopLevelError(ruleName, startTokenIndex);
            }
            if (!cst.children?.length) {
                cst.children = undefined;
            }
            return cst;
        } finally{
            // return
            this.loopDetectionSet.delete(key);
        }
    }
    initTopLevelData() {
        // 
        this._parseSuccess = true;
        this.cstStack.length = 0;
        this.loopDetectionSet.clear();
        this._codeIndex = 0;
        this._codeLine = 1;
        this._codeColumn = 1;
        this._parsedTokens = [];
        this._tokenCache.clear();
        // 
        this._debugger?.resetForNewParse?.(this._parsedTokens);
    }
    checkRuleIsThisClass(ruleName, className) {
        if (this.hasOwnProperty(ruleName)) {
            if (className !== this.className) {
                return true;
            }
        }
    }
    onRuleExitDebugHandler(ruleName, cst, isTopLevel, startTime) {
        if (cst && !cst.children?.length) {
            cst.children = undefined;
        }
        if (!isTopLevel) {
            this._debugger?.onRuleExit(ruleName, false, startTime);
        } else {
            // 
            if (this._debugger) {
                if ('setCst' in this._debugger) {
                    this._debugger.setCst(cst);
                }
                this._debugger?.autoOutput?.();
            }
        }
    }
    /**
     * 
     *  CST    
     */ executeRuleCore(ruleName, targetFun, ...args) {
        const cst = new SubhutiCst();
        cst.name = ruleName;
        cst.children = [];
        this.cstStack.push(cst);
        // 
        targetFun.apply(this, args);
        this.cstStack.pop();
        // 
        if (this._parseSuccess) {
            const parentCst = this.cstStack[this.cstStack.length - 1];
            if (parentCst) {
                parentCst.children.push(cst);
            }
            this.setLocation(cst);
        }
        return cst;
    }
    setLocation(cst) {
        if (cst.children && cst.children[0]?.loc) {
            const lastChild = cst.children[cst.children.length - 1];
            cst.loc = {
                type: cst.name,
                start: cst.children[0].loc.start,
                end: lastChild?.loc?.end || cst.children[0].loc.end
            };
        }
    }
    /**
     * Or  - PEG 
     *
     * 
     * - 
     * - 
     *
     *  token  = 
     */ Or(alternatives) {
        if (this.parserFail) {
            return;
        }
        const savedState = this.saveState();
        const startCodeIndex = this._codeIndex;
        const totalCount = alternatives.length;
        const parentRuleName = this.curCst?.name || 'Unknown';
        //  Or Or 
        this._debugger?.onOrEnter?.(parentRuleName, startCodeIndex);
        for(let i = 0; i < totalCount; i++){
            const alt = alternatives[i];
            const isLast = i === totalCount - 1;
            //  Or 
            this._debugger?.onOrBranch?.(i, totalCount, parentRuleName);
            alt.alt();
            //  Or 
            this._debugger?.onOrBranchExit?.(parentRuleName, i);
            if (this._parseSuccess) {
                //  Or Or 
                this._debugger?.onOrExit?.(parentRuleName);
                return;
            }
            //  N-1 
            if (!isLast) {
                this.recordPartialMatchAndRestore(savedState, startCodeIndex);
                this._parseSuccess = true;
            }
        // 
        }
        //  Or Or 
        this._debugger?.onOrExit?.(parentRuleName);
    }
    /**
     * Many  - 0EBNF { ... }
     *
     *  token
     */ Many(fn) {
        while(this.tryAndRestore(fn)){
        // 
        }
    }
    /**
     *  Many 
     * -  errorRecoveryMode 
     * - 
     * -  CST
     * @param fn 
     */ ManyWithRecovery(fn) {
        if (!this.errorRecoveryMode) {
            throw new Error(' ManyWithRecovery');
        }
        // 
        this._unparsedTokens.length = 0;
        while(!this.parserFailOrIsEof){
            const startTokenIndex = this.currentTokenIndex;
            // 
            this._parseRecordRoot = {
                name: '__ParseRecordRoot__',
                children: [],
                startTokenIndex: startTokenIndex,
                endTokenIndex: startTokenIndex
            };
            this._parseRecordStack = [
                this._parseRecordRoot
            ];
            const success = this.tryAndRestore(fn);
            if (success) {
                // 
                this._parseRecordRoot = null;
                this._parseRecordStack = [];
                continue;
            }
            // 
            const syncIndex = this.findNextSyncPoint(this._codeIndex + 1);
            const recoveredCST = this.recoverFromParseRecord(this._parseRecordRoot, syncIndex);
            if (recoveredCST && recoveredCST.children && recoveredCST.children.length > 0) {
                //  CST 
                const currentCst = this.curCst;
                if (currentCst) {
                    currentCst.children.push(...recoveredCST.children);
                }
                //  parsedTokens  codeIndex
                const maxTokenIndex = this.getParseRecordMaxEndIndex(this._parseRecordRoot, syncIndex);
                if (maxTokenIndex > 0 && maxTokenIndex <= this._parsedTokens.length) {
                    const lastToken = this._parsedTokens[maxTokenIndex - 1];
                    this._codeIndex = lastToken.index + lastToken.tokenValue.length;
                }
            } else {
                // 
                this._codeIndex++;
            }
            // 
            this._parseRecordRoot = null;
            this._parseRecordStack = [];
            this._parseSuccess = true;
        }
        //  tokens
        if (this._unparsedTokens.length > 0) {
            this._parseSuccess = false;
        }
    }
    /**
     *  CST
     *  endTokenIndex <= maxIndex  CST
     */ recoverFromParseRecord(root, maxIndex) {
        if (!root || root.children.length === 0) {
            return null;
        }
        const cst = new SubhutiCst();
        cst.name = root.name;
        cst.children = this.parseRecordChildrenToCST(root.children, maxIndex);
        if (!cst.children || cst.children.length === 0) {
            return null;
        }
        return cst;
    }
    /**
     *  CST 
     *
     * 
     * 1.  startTokenIndex  Or 
     * 2.  endTokenIndex <= maxIndex 
     * 3. 
     */ parseRecordChildrenToCST(nodes, maxIndex) {
        //  startTokenIndex 
        const groups = new Map();
        for (const node of nodes){
            // 
            if (node.endTokenIndex > maxIndex) {
                continue;
            }
            const key = node.startTokenIndex;
            if (!groups.has(key)) {
                groups.set(key, []);
            }
            groups.get(key).push(node);
        }
        // 
        const selectedNodes = [];
        for (const [startIdx, group] of groups){
            //  endTokenIndex 
            let best = null;
            for (const node of group){
                if (!best || node.endTokenIndex >= best.endTokenIndex) {
                    best = node;
                }
            }
            if (best) {
                selectedNodes.push(best);
            }
        }
        //  startTokenIndex 
        selectedNodes.sort((a, b)=>a.startTokenIndex - b.startTokenIndex);
        //  CST
        return selectedNodes.map((node)=>this.parseRecordNodeToCST(node, maxIndex));
    }
    /**
     *  CST 
     */ parseRecordNodeToCST(node, maxIndex) {
        const cst = new SubhutiCst();
        cst.name = node.name;
        //  token 
        if (node.token) {
            cst.value = node.value;
            cst.loc = {
                type: node.token.tokenName,
                value: node.token.tokenValue,
                start: {
                    index: node.token.index || 0,
                    line: node.token.rowNum || 0,
                    column: node.token.columnStartNum || 0
                },
                end: {
                    index: (node.token.index || 0) + node.token.tokenValue.length,
                    line: node.token.rowNum || 0,
                    column: node.token.columnEndNum || 0
                }
            };
        }
        // 
        if (node.children.length > 0) {
            cst.children = this.parseRecordChildrenToCST(node.children, maxIndex);
            if (cst.children.length === 0) {
                cst.children = undefined;
            } else {
                // 
                this.setLocation(cst);
            }
        }
        return cst;
    }
    /**
     *  <= maxIndex  endTokenIndex
     */ getParseRecordMaxEndIndex(root, maxIndex) {
        let maxEnd = root.endTokenIndex <= maxIndex ? root.endTokenIndex : 0;
        for (const child of root.children){
            const childMax = this.getParseRecordMaxEndIndex(child, maxIndex);
            if (childMax > maxEnd) {
                maxEnd = childMax;
            }
        }
        return maxEnd;
    }
    /**
     *  token
     * @param fromIndex 
     * @returns 
     */ findNextSyncPoint(fromIndex) {
        //  token
        for(let i = fromIndex; i < this._sourceCode.length; i++){
            const entry = this._getOrParseToken(i, this._codeLine, this._codeColumn, this._defaultGoal);
            if (entry && this._syncTokens.has(entry.token.tokenName)) {
                return i;
            }
        }
        return this._sourceCode.length // 
        ;
    }
    /**
     *  ErrorNode token
     * @param startIndex 
     * @param endIndex 
     * @returns ErrorNode CST 
     */ createErrorNode(startIndex, endIndex) {
        const errorNode = new SubhutiCst();
        errorNode.name = 'ErrorNode';
        errorNode.children = [];
        //  parsedTokens  tokens
        for (const token of this._parsedTokens){
            if (token.index >= startIndex && token.index < endIndex) {
                const tokenNode = new SubhutiCst();
                tokenNode.name = token.tokenName;
                tokenNode.value = token.tokenValue;
                tokenNode.loc = {
                    type: token.tokenName,
                    value: token.tokenValue,
                    start: {
                        index: token.index,
                        line: token.rowNum,
                        column: token.columnStartNum
                    },
                    end: {
                        index: token.index + (token.tokenValue?.length || 0),
                        line: token.rowNum,
                        column: token.columnEndNum
                    }
                };
                errorNode.children.push(tokenNode);
            }
        }
        //  ErrorNode 
        if (errorNode.children.length > 0) {
            const first = errorNode.children[0];
            const last = errorNode.children[errorNode.children.length - 1];
            errorNode.loc = {
                type: 'ErrorNode',
                start: first.loc.start,
                end: last.loc.end
            };
        }
        return errorNode;
    }
    /**
     * Option  - 01EBNF [ ... ]
     *
     * 
     */ Option(fn) {
        this.tryAndRestore(fn);
    }
    /**
     * AtLeastOne  - 1
     *
     * 
     */ AtLeastOne(fn) {
        if (this.parserFail) {
            return;
        }
        fn();
        while(this.tryAndRestore(fn)){
        // 
        }
    }
    /**
     * 
     *
     * @param ruleName 
     * @param startIndex 
     */ handleTopLevelError(ruleName, startIndex) {
        // 
        if (this._analysisMode) {
            return;
        }
        // 
        const noTokenConsumed = this.currentTokenIndex === startIndex;
        const found = this.curToken;
        throw this._errorHandler.createError({
            type: 'parsing',
            expected: noTokenConsumed ? 'valid syntax' : 'EOF (end of file)',
            found: found,
            position: {
                tokenIndex: this.currentTokenIndex,
                codeIndex: this._codeIndex,
                line: found?.rowNum ?? this._codeLine,
                column: found?.columnStartNum ?? this._codeColumn
            },
            ruleStack: this.getRuleStack().length > 0 ? this.getRuleStack() : [
                ruleName
            ]
        });
    }
    get parserFailOrIsEof() {
        return this.parserFail || this.isEof;
    }
    /**
     *  token
     * -  undefined
     * - 
     */ consume(tokenName, goal) {
        if (this.parserFail) {
            return;
        }
        if (this.isEof) {
            this._parseSuccess = false;
            return;
        }
        //  token
        const actualGoal = goal ?? this._defaultGoal;
        const entry = this._getOrParseToken(this._codeIndex, this._codeLine, this._codeColumn, actualGoal);
        if (!entry) {
            this._parseSuccess = false;
            return;
        }
        const token = entry.token;
        if (token.tokenName !== tokenName) {
            this._parseSuccess = false;
            this._debugger?.onTokenConsume(this._codeIndex, token.tokenValue, token.tokenName, tokenName, false);
            return;
        }
        this._debugger?.onTokenConsume(this._codeIndex, token.tokenValue, token.tokenName, tokenName, true);
        const cst = this.generateCstByToken(token);
        // 
        if (token.tokenName === 'TemplateHead') {
            this._templateDepth++;
        } else if (token.tokenName === 'TemplateTail') {
            this._templateDepth--;
        }
        // 
        this._codeIndex = entry.nextCodeIndex;
        this._codeLine = entry.nextLine;
        this._codeColumn = entry.nextColumn;
        this._lastTokenName = entry.lastTokenName;
        // 
        this._parsedTokens.push(token);
        return cst;
    }
    generateCstByToken(token) {
        const cst = new SubhutiCst();
        cst.name = token.tokenName;
        cst.value = token.tokenValue;
        cst.loc = {
            type: token.tokenName,
            value: token.tokenValue,
            start: {
                index: token.index || 0,
                line: token.rowNum || 0,
                column: token.columnStartNum || 0
            },
            end: {
                index: (token.index || 0) + token.tokenValue.length,
                line: token.rowNum || 0,
                column: token.columnEndNum || 0
            }
        };
        //  CST
        const currentCst = this.curCst;
        if (currentCst) {
            currentCst.children.push(cst);
        }
        //  token  endTokenIndex
        if (this.errorRecoveryMode) {
            const newEndIndex = this.currentTokenIndex // consume  +1
            ;
            const tokenNode = {
                name: token.tokenName,
                children: [],
                startTokenIndex: this.lastTokenIndex,
                endTokenIndex: newEndIndex,
                token: token,
                value: token.tokenValue
            };
            const recordCurrent = this._parseRecordStack[this._parseRecordStack.length - 1];
            if (recordCurrent) {
                recordCurrent.children.push(tokenNode);
            }
            //  endTokenIndex
            for (const ancestor of this._parseRecordStack){
                ancestor.endTokenIndex = newEndIndex;
            }
        }
        return cst;
    }
    // 
    saveState() {
        const currentCst = this.curCst;
        return {
            codeIndex: this._codeIndex,
            codeLine: this._codeLine,
            codeColumn: this._codeColumn,
            lastTokenName: this._lastTokenName,
            curCstChildrenLength: currentCst?.children?.length || 0,
            parsedTokensLength: this._parsedTokens.length
        };
    }
    restoreState(backData) {
        const fromIndex = this._codeIndex;
        const toIndex = backData.codeIndex;
        if (fromIndex !== toIndex) {
            this._debugger?.onBacktrack?.(fromIndex, toIndex);
        }
        this._codeIndex = backData.codeIndex;
        this._codeLine = backData.codeLine;
        this._codeColumn = backData.codeColumn;
        this._lastTokenName = backData.lastTokenName;
        //  parsedTokens
        this._parsedTokens.length = backData.parsedTokensLength;
        const currentCst = this.curCst;
        if (currentCst) {
            currentCst.children.length = backData.curCstChildrenLength;
        }
    }
    /**
     * 
     * -  _parseRecordRoot 
     * -  CST
     *
     * @param savedState 
     * @param startCodeIndex 
     */ recordPartialMatchAndRestore(savedState, startCodeIndex) {
        this.restoreState(savedState);
    }
    /**
     * 
     */ get isEof() {
        const entry = this._getOrParseToken(this._codeIndex, this._codeLine, this._codeColumn, this._defaultGoal);
        return entry === null;
    }
    /**
     * 
     *
     * @param fn 
     * @returns true:  tokenfalse:  token
     */ tryAndRestore(fn) {
        if (this.parserFailOrIsEof) {
            return false;
        }
        const savedState = this.saveState();
        const startIndex = this._codeIndex;
        fn();
        if (this.parserFail) {
            // 
            this.recordPartialMatchAndRestore(savedState, startIndex);
            this._parseSuccess = true;
            return false;
        }
        //  token   false
        return this._codeIndex !== startIndex;
    }
    /**
     * 
     */ applyCachedResult(cached) {
        //  token
        if (cached.parsedTokens && cached.parsedTokens.length > 0) {
            this._parsedTokens.push(...cached.parsedTokens);
            //  token 
            const lastToken = cached.parsedTokens[cached.parsedTokens.length - 1];
            this._codeIndex = lastToken.index + lastToken.tokenValue.length;
            this._codeLine = lastToken.rowNum;
            this._codeColumn = lastToken.columnEndNum;
            this._lastTokenName = lastToken.tokenName;
        }
        this._parseSuccess = cached.parseSuccess;
        // 
        if (cached.parseSuccess) {
            const parentCst = this.cstStack[this.cstStack.length - 1];
            if (parentCst) {
                parentCst.children.push(cached.cst);
            }
        }
        return cached.cst;
    }
    // ============================================
    // Error Helper Methods
    // ============================================
    /**
     *  token  parsedTokens  N  token
     *
     * @param contextSize -  2
     * @returns token 
     */ getTokenContext(contextSize = 2) {
        const tokens = this._parsedTokens;
        const len = tokens.length;
        const start = Math.max(0, len - contextSize);
        return tokens.slice(start);
    }
    /**
     * 
     *
     * @returns 
     */ formatCurrentRulePath() {
        if (!this._debugger) {
            // 
            return this.formatSimpleRulePath();
        }
        // 
        const ruleStack = this._debugger.ruleStack;
        if (!ruleStack || ruleStack.length === 0) {
            return [
                '  (empty)'
            ];
        }
        return SubhutiDebugRuleTracePrint.formatPendingOutputs_NonCache_Impl(ruleStack);
    }
    /**
     * 
     */ formatSimpleRulePath() {
        const ruleStack = this.getRuleStack();
        if (ruleStack.length === 0) {
            return [
                '  (empty)'
            ];
        }
        const lines = [];
        for(let i = 0; i < ruleStack.length; i++){
            const rule = ruleStack[i];
            const isLast = i === ruleStack.length - 1;
            const indent = '  '.repeat(i);
            const connector = i === 0 ? '' : ' ';
            const marker = isLast ? '  ' : '';
            lines.push(`  ${indent}${connector}${rule}${marker}`);
        }
        return lines;
    }
    /**
     * 
     *
     * @param ruleName - 
     * @param hint - 
     * @returns ParsingError  null
     */ createInfiniteLoopError(ruleName, hint) {
        //   null
        if (this._analysisMode) {
            this._parseSuccess = false;
            return null; // 
        }
        // 
        const rulePathLines = this.formatCurrentRulePath();
        const rulePath = rulePathLines.join('\n');
        //  
        const ruleStack = this.getRuleStack();
        const isLeftRecursion = this.isDirectLeftRecursion(ruleName, ruleStack);
        //   'left-recursion' 
        //   'infinite-loop' Or 
        const errorType = isLeftRecursion ? 'left-recursion' : 'infinite-loop';
        return this._errorHandler.createError({
            type: errorType,
            expected: '',
            found: this.curToken,
            position: {
                tokenIndex: this.currentTokenIndex,
                codeIndex: this._codeIndex,
                line: this.curToken?.rowNum || this._codeLine,
                column: this.curToken?.columnStartNum || this._codeColumn
            },
            ruleStack: [
                ...ruleStack
            ],
            loopRuleName: ruleName,
            loopDetectionSet: [],
            loopCstDepth: this.cstStack.length,
            loopTokenContext: this.getTokenContext(2),
            hint: hint,
            rulePath: rulePath
        });
    }
    /**
     *  - 
     *
     * @param sourceCode 
     * @param options 
     */ constructor(sourceCode = '', options){
        super(), // 
        _define_property$3(this, "tokenConsumer", void 0), _define_property$3(this, "cstStack", []), _define_property$3(this, "className", void 0), // ============================================
        // 
        // ============================================
        /**  */ _define_property$3(this, "_lexer", null), /**  */ _define_property$3(this, "_sourceCode", ''), /**  */ _define_property$3(this, "_codeIndex", 0), /**  */ _define_property$3(this, "_codeLine", 1), /**  */ _define_property$3(this, "_codeColumn", 1), /**  token  */ _define_property$3(this, "_lastTokenName", null), /**  */ _define_property$3(this, "_templateDepth", 0), /**  */ _define_property$3(this, "_defaultGoal", LexicalGoal.InputElementDiv), /** Token      */ _define_property$3(this, "_tokenCache", new Map()), /**  token  */ _define_property$3(this, "_parsedTokens", []), /**
     * 
     * - true: 
     * - false: 
     */ _define_property$3(this, "_analysisMode", false), /**
     * 
     * - true:  token 
     * - false: 
     */ _define_property$3(this, "_errorRecoveryMode", false), /**
     *  Token 
     *  token 
     */ _define_property$3(this, "_syncTokens", new Set([
            'LetTok',
            'ConstTok',
            'VarTok',
            'FunctionTok',
            'ClassTok',
            'AsyncTok',
            'IfTok',
            'ForTok',
            'WhileTok',
            'DoTok',
            'SwitchTok',
            'TryTok',
            'ThrowTok',
            'ReturnTok',
            'BreakTok',
            'ContinueTok',
            'ImportTok',
            'ExportTok',
            'DebuggerTok',
            'Semicolon'
        ])), // 
        _define_property$3(this, "_debugger", void 0), _define_property$3(this, "_errorHandler", new SubhutiErrorHandler()), // 
        /**
     * O(1)  (rule, position) 
     * : "ruleName:position"
     */ _define_property$3(this, "loopDetectionSet", new Set()), // Packrat Parsing LRU 
        _define_property$3(this, "enableMemoization", true), _define_property$3(this, "_cache", void 0), /**
     * 
     *  token  CST 
     */ _define_property$3(this, "_partialMatchCandidates", []), /**
     *  tokens 
     * 
     */ _define_property$3(this, "_unparsedTokens", []), // ============================================
        // 
        // ============================================
        /**  */ _define_property$3(this, "_parseRecordRoot", null), /**  */ _define_property$3(this, "_parseRecordStack", []);
        this.className = this.constructor.name;
        this._cache = new SubhutiPackratCache();
        // 
        this._sourceCode = sourceCode;
        this._codeIndex = 0;
        this._codeLine = 1;
        this._codeColumn = 1;
        this._lastTokenName = null;
        this._templateDepth = 0;
        this._tokenCache = new Map();
        this._parsedTokens = [];
        // 
        if (options?.tokenDefinitions) {
            this._lexer = new SubhutiLexer(options.tokenDefinitions);
        }
        //  TokenConsumer
        if (options?.tokenConsumer) {
            this.tokenConsumer = new options.tokenConsumer(this);
        } else {
            this.tokenConsumer = new SubhutiTokenConsumer(this);
        }
    }
}

function applyDecs2203RFactory$1() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r$1(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r$1 = applyDecs2203RFactory$1())(targetClass, memberDecs, classDecs, parentClass);
}
var _initClass$1, _SubhutiParser, _initProto$1;
// ============================================
//  Identifier 
// ============================================
/**
 * ES2025 
 * ECMAScript 2025  12.7.2 Keywords and Reserved Words
 *
 * 
 * 1. 
 *    break, case, catch, class, const, continue, debugger, default,
 *    delete, do, else, enum, export, extends, false, finally, for, function,
 *    if, import, in, instanceof, new, null, return, super, switch, this,
 *    throw, true, try, typeof, var, void, while, with, await, yield
 *    createKeywordToken +  Token
 *
 * 2. 
 *    async, let, static, as, get, set, of, from, target, meta
 *    - async:  `let async = 1`
 *    - let, static: 
 *    - : 
 *     IdentifierName + consumeIdentifierValue()
 *
 *  Parser 
 *  isKeyword=true  token 
 */ const ReservedWords = new Set(slimeTokens.filter((token)=>token.isKeyword) //  token
.map((token)=>token.value) //  value'await', 'break' 
);
// ============================================
// Unicode 
//  Acorn https://github.com/acornjs/acorn
//
//  ECMAScript  12.7:
// - IdentifierStart: UnicodeIDStart | $ | _ | \ UnicodeEscapeSequence
// - IdentifierPart: UnicodeIDContinue | $ | \ UnicodeEscapeSequence | ZWNJ | ZWJ
//
//  \uXXXX  \u{XXXXX} 
//  ID_Start ID_Continue
// ============================================
// ID_Start  ID_Continue  Unicode 
const ID_START_REGEX = /^[\p{ID_Start}$_]$/u;
const ID_CONTINUE_REGEX = /^[\p{ID_Continue}$\u200C\u200D]$/u;
/**
 *  Unicode 
 *  \uXXXX  \u{XXXXX} 
 */ function decodeUnicodeEscape(escape) {
    if (escape.startsWith('\\u{') && escape.endsWith('}')) {
        // \u{XXXXX} 
        const hex = escape.slice(3, -1);
        const codePoint = parseInt(hex, 16);
        if (isNaN(codePoint) || codePoint > 0x10FFFF) return null;
        return codePoint;
    } else if (escape.startsWith('\\u') && escape.length === 6) {
        // \uXXXX 
        const hex = escape.slice(2);
        const codePoint = parseInt(hex, 16);
        if (isNaN(codePoint)) return null;
        return codePoint;
    }
    return null;
}
/**
 *  Unicode 
 *  null
 */ function decodeIdentifier(name) {
    // 
    const chars = [];
    let i = 0;
    while(i < name.length){
        if (name[i] === '\\' && name[i + 1] === 'u') {
            // Unicode 
            if (name[i + 2] === '{') {
                // \u{XXXXX} 
                const endBrace = name.indexOf('}', i + 3);
                if (endBrace === -1) return null;
                const escape = name.slice(i, endBrace + 1);
                const codePoint = decodeUnicodeEscape(escape);
                if (codePoint === null) return null;
                chars.push(String.fromCodePoint(codePoint));
                i = endBrace + 1;
            } else {
                // \uXXXX 
                if (i + 6 > name.length) return null;
                const escape = name.slice(i, i + 6);
                const codePoint = decodeUnicodeEscape(escape);
                if (codePoint === null) return null;
                chars.push(String.fromCodePoint(codePoint));
                i += 6;
            }
        } else {
            //  Unicode
            const codePoint = name.codePointAt(i);
            chars.push(String.fromCodePoint(codePoint));
            i += codePoint > 0xFFFF ? 2 : 1;
        }
    }
    return chars.join('');
}
/**
 *  Unicode 
 *
 *  ECMAScript Unicode 
 * - ID_Start | $ | _
 * - ID_Continue | $ | ZWNJ | ZWJ
 *
 *  for...of  Unicode 
 */ function isValidIdentifierWithEscapes(name) {
    const decoded = decodeIdentifier(name);
    if (decoded === null || decoded.length === 0) return false;
    //  for...of  Unicode 
    let isFirst = true;
    for (const char of decoded){
        if (isFirst) {
            //  ID_Start
            if (!ID_START_REGEX.test(char)) {
                return false;
            }
            isFirst = false;
        } else {
            //  ID_Continue
            if (!ID_CONTINUE_REGEX.test(char)) {
                return false;
            }
        }
    }
    return true;
}
let _SlimeParser$1;
class SlimeParser extends (_SubhutiParser = SubhutiParser) {
    // ============================================
    // Token  (Token Matching)
    //  Babel/Acorn  match/isContextual 
    // ============================================
    /**
     *  token 
     * @param value  SlimeContextualKeywordTokenTypes.LET
     */ isContextual(value) {
        return this.match(SlimeTokenType.IdentifierName) && this.curToken?.tokenValue === value;
    }
    /**
     *  +  token 
     * @param contextualValue 
     * @param nextTokenNames  token 
     */ isContextualSequence(contextualValue, ...nextTokenNames) {
        if (!this.isContextual(contextualValue)) return false;
        for(let i = 0; i < nextTokenNames.length; i++){
            const token = this.peek(i + 1);
            if (token?.tokenName !== nextTokenNames[i]) return false;
        }
        return true;
    }
    /**
     *  +  token 
     * @param contextualValue 
     * @param nextTokenNames  token 
     */ isContextualSequenceNoLT(contextualValue, ...nextTokenNames) {
        if (!this.isContextual(contextualValue)) return false;
        for(let i = 0; i < nextTokenNames.length; i++){
            const token = this.peek(i + 1);
            if (token?.tokenName !== nextTokenNames[i]) return false;
            if (token.hasLineBreakBefore) return false;
        }
        return true;
    }
    /**
     *  token 
     * @param value 
     */ assertNotContextual(value) {
        if (!this._parseSuccess) return false;
        if (this.isContextual(value)) {
            this._parseSuccess = false;
            return false;
        }
        return true;
    }
    /**
     *  +  token 
     * @param contextualValue 
     * @param nextTokenNames  token 
     */ assertNotContextualSequence(contextualValue, ...nextTokenNames) {
        if (!this._parseSuccess) return false;
        if (this.isContextualSequence(contextualValue, ...nextTokenNames)) {
            this._parseSuccess = false;
            return false;
        }
        return true;
    }
    /**
     *  +  token 
     * @param contextualValue 
     * @param nextTokenNames  token 
     */ assertNotContextualSequenceNoLT(contextualValue, ...nextTokenNames) {
        if (!this._parseSuccess) return false;
        if (this.isContextualSequenceNoLT(contextualValue, ...nextTokenNames)) {
            this._parseSuccess = false;
            return false;
        }
        return true;
    }
    /**
     * 
     *  [lookahead  {async of}] 
     * @param first 
     * @param second 
     */ isContextualPair(first, second) {
        if (!this.isContextual(first)) return false;
        const nextToken = this.peek(1);
        return nextToken?.tokenName === SlimeTokenType.IdentifierName && nextToken.tokenValue === second;
    }
    /**
     * 
     * @param first 
     * @param second 
     */ assertNotContextualPair(first, second) {
        if (!this._parseSuccess) return false;
        if (this.isContextualPair(first, second)) {
            this._parseSuccess = false;
            return false;
        }
        return true;
    }
    // ============================================
    //  (RegExp Rescan)
    //  `/` 
    // ============================================
    /**
     *  Slash  DivideAssign token  RegularExpressionLiteral
     *
     * 
     * :
     *   `if(1)/  foo/`  `/  foo/`  Slash, foo, Slash
     *   `} /42/i`  `/42/i`  Slash, 42, Slash, i
     *   `x = /=foo/g`  `/=foo/g`  DivideAssign, foo, Slash, g
     *
     * 
     * 1.  token 
     * 2.  tokens
     * 3.  tokens  RegularExpressionLiteral
     *
     * @returns 
     */ rescanSlashAsRegExp() {
        const curToken = this.curToken;
        if (!curToken || curToken.tokenName !== SlimeTokenType.Slash && curToken.tokenName !== SlimeTokenType.DivideAssign) {
            return false;
        }
        // 1. 
        const sourceFromSlash = this._sourceCode.slice(curToken.index);
        const regexpMatch = matchRegExpLiteral(sourceFromSlash);
        if (!regexpMatch) {
            return false;
        }
        // 2. 
        const regexpEndIndex = curToken.index + regexpMatch.length;
        // 3.  tokens regexpEndIndex  tokens
        const startTokenIndex = this.tokenIndex;
        let tokensToReplace = 1;
        for(let i = startTokenIndex + 1; i < this._tokens.length; i++){
            const token = this._tokens[i];
            //  token 
            if (token.index < regexpEndIndex) {
                tokensToReplace++;
            } else {
                break;
            }
        }
        // 4.  RegularExpressionLiteral token
        const newToken = {
            tokenName: SlimeTokenType.RegularExpressionLiteral,
            tokenValue: regexpMatch,
            index: curToken.index,
            rowNum: curToken.rowNum,
            columnStartNum: curToken.columnStartNum,
            columnEndNum: curToken.columnStartNum + regexpMatch.length - 1,
            hasLineBreakBefore: curToken.hasLineBreakBefore
        };
        // 5.  tokens 
        this._tokens.splice(startTokenIndex, tokensToReplace, newToken);
        return true;
    }
    // ============================================
    // A.2 Expressions
    // ============================================
    // ----------------------------------------
    // A.2.1 Identifier References
    // ----------------------------------------
    /**
     * IdentifierReference[Yield, Await] :
     *     Identifier
     *     [~Yield] yield
     *     [~Await] await
     */ IdentifierReference(params = {}) {
        const { Yield = false, Await = false } = params;
        return this.Or([
            // Identifier ()
            {
                alt: ()=>this.Identifier()
            },
            // [~Yield] yield - 
            ...!Yield ? [
                {
                    alt: ()=>this.tokenConsumer.Yield()
                }
            ] : [],
            // [~Await] await - 
            ...!Await ? [
                {
                    alt: ()=>this.tokenConsumer.Await()
                }
            ] : []
        ]);
    }
    /**
     * BindingIdentifier[Yield, Await] :
     *     Identifier
     *     yield
     *     await
     *
     *  ES2025 BindingIdentifier  yield  await 
     *  LabelIdentifier  [~Yield]/[~Await] 
     * yield/await Static Semantics
     */ BindingIdentifier(params = {}) {
        return this.Or([
            {
                alt: ()=>this.Identifier()
            },
            {
                alt: ()=>this.tokenConsumer.Yield()
            },
            {
                alt: ()=>this.tokenConsumer.Await()
            }
        ]);
    }
    /**
     * LabelIdentifier[Yield, Await] :
     *     Identifier
     *     [~Yield] yield
     *     [~Await] await
     */ LabelIdentifier(params = {}) {
        const { Yield = false, Await = false } = params;
        return this.Or([
            {
                alt: ()=>this.Identifier()
            },
            // [~Yield] yield - 
            ...!Yield ? [
                {
                    alt: ()=>this.tokenConsumer.Yield()
                }
            ] : [],
            // [~Await] await - 
            ...!Await ? [
                {
                    alt: ()=>this.tokenConsumer.Await()
                }
            ] : []
        ]);
    }
    /**
     * Identifier :
     *     IdentifierName but not ReservedWord
     *
     *  ECMAScript  12.7 Unicode 
     *  ID_Start ID_Continue
     *  Acorn 
     */ Identifier() {
        const cst = this.tokenConsumer.IdentifierName();
        if (!cst) return undefined;
        const value = cst.value;
        //  token
        //  bug
        if (ReservedWords.has(value)) {
            throw new Error(`[Lexer Bug]  "${value}"  IdentifierName token`);
        }
        //  Unicode 
        if (value.includes('\\u')) {
            // 
            if (!isValidIdentifierWithEscapes(value)) {
                return this.setParseFail();
            }
            //  bre\u0061k -> break
            const decoded = decodeIdentifier(value);
            if (decoded !== null && ReservedWords.has(decoded)) {
                return this.setParseFail();
            }
        }
        return cst;
    }
    /**
     * IdentifierName - 
     *
     *  ES2025 IdentifierName 
     * ModuleExportName 
     *
     *  IdentifierName token 
     *  token
     *
     *  Unicode 
     */ IdentifierName() {
        return this.Or([
            //  Unicode 
            {
                alt: ()=>{
                    const cst = this.tokenConsumer.IdentifierName();
                    if (!cst) return undefined;
                    const value = cst.value;
                    //  Unicode 
                    if (value.includes('\\u')) {
                        if (!isValidIdentifierWithEscapes(value)) {
                            return this.setParseFail();
                        }
                    }
                    return cst;
                }
            },
            //  ReservedWord  IdentifierName
            {
                alt: ()=>this.tokenConsumer.Await()
            },
            {
                alt: ()=>this.tokenConsumer.Break()
            },
            {
                alt: ()=>this.tokenConsumer.Case()
            },
            {
                alt: ()=>this.tokenConsumer.Catch()
            },
            {
                alt: ()=>this.tokenConsumer.Class()
            },
            {
                alt: ()=>this.tokenConsumer.Const()
            },
            {
                alt: ()=>this.tokenConsumer.Continue()
            },
            {
                alt: ()=>this.tokenConsumer.Debugger()
            },
            {
                alt: ()=>this.tokenConsumer.Default()
            },
            {
                alt: ()=>this.tokenConsumer.Delete()
            },
            {
                alt: ()=>this.tokenConsumer.Do()
            },
            {
                alt: ()=>this.tokenConsumer.Else()
            },
            {
                alt: ()=>this.tokenConsumer.Enum()
            },
            {
                alt: ()=>this.tokenConsumer.Export()
            },
            {
                alt: ()=>this.tokenConsumer.Extends()
            },
            {
                alt: ()=>this.tokenConsumer.False()
            },
            {
                alt: ()=>this.tokenConsumer.Finally()
            },
            {
                alt: ()=>this.tokenConsumer.For()
            },
            {
                alt: ()=>this.tokenConsumer.Function()
            },
            {
                alt: ()=>this.tokenConsumer.If()
            },
            {
                alt: ()=>this.tokenConsumer.Import()
            },
            {
                alt: ()=>this.tokenConsumer.In()
            },
            {
                alt: ()=>this.tokenConsumer.Instanceof()
            },
            {
                alt: ()=>this.tokenConsumer.New()
            },
            {
                alt: ()=>this.tokenConsumer.NullLiteral()
            },
            {
                alt: ()=>this.tokenConsumer.Return()
            },
            {
                alt: ()=>this.tokenConsumer.Super()
            },
            {
                alt: ()=>this.tokenConsumer.Switch()
            },
            {
                alt: ()=>this.tokenConsumer.This()
            },
            {
                alt: ()=>this.tokenConsumer.Throw()
            },
            {
                alt: ()=>this.tokenConsumer.True()
            },
            {
                alt: ()=>this.tokenConsumer.Try()
            },
            {
                alt: ()=>this.tokenConsumer.Typeof()
            },
            {
                alt: ()=>this.tokenConsumer.Var()
            },
            {
                alt: ()=>this.tokenConsumer.Void()
            },
            {
                alt: ()=>this.tokenConsumer.While()
            },
            {
                alt: ()=>this.tokenConsumer.With()
            },
            {
                alt: ()=>this.tokenConsumer.Yield()
            },
            //  keyword token
            {
                alt: ()=>this.tokenConsumer.Async()
            },
            {
                alt: ()=>this.tokenConsumer.Let()
            },
            {
                alt: ()=>this.tokenConsumer.Static()
            },
            {
                alt: ()=>this.tokenConsumer.As()
            }
        ]);
    }
    // ----------------------------------------
    // A.2.2 Primary Expressions
    // ----------------------------------------
    // PrivateIdentifier A.1 Lexical Grammar
    //  tokenConsumer.PrivateIdentifier()  token
    /**
     * PrimaryExpression[Yield, Await] :
     *     this
     *     IdentifierReference[?Yield, ?Await]
     *     Literal
     *     ArrayLiteral[?Yield, ?Await]
     *     ObjectLiteral[?Yield, ?Await]
     *     FunctionExpression
     *     ClassExpression[?Yield, ?Await]
     *     GeneratorExpression
     *     AsyncFunctionExpression
     *     AsyncGeneratorExpression
     *     RegularExpressionLiteral
     *     TemplateLiteral[?Yield, ?Await, ~Tagged]
     *     CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
     */ PrimaryExpression(params = {}) {
        //  PrimaryExpression  InputElementRegExp 
        //  `/` 
        //  LA(1, [InputElementRegExp]) 
        return this.Or([
            // === 1. ===
            {
                alt: ()=>this.tokenConsumer.This()
            },
            // === 2. async  IdentifierReference ===
            // async function*  async function 
            {
                alt: ()=>this.AsyncGeneratorExpression()
            },
            {
                alt: ()=>this.AsyncFunctionExpression()
            },
            // === 3. ===
            {
                alt: ()=>this.IdentifierReference(params)
            },
            // === 4. null/true/false / token===
            {
                alt: ()=>this.Literal()
            },
            // === 5. function ===
            {
                alt: ()=>this.GeneratorExpression()
            },
            {
                alt: ()=>this.FunctionExpression()
            },
            // === 6. class ===
            {
                alt: ()=>this.ClassExpression(params)
            },
            // === 7.  token===
            {
                alt: ()=>this.ArrayLiteral(params)
            },
            {
                alt: ()=>this.ObjectLiteral(params)
            },
            // RegularExpressionLiteral -  InputElementRegExp 
            {
                alt: ()=>this.consumeRegularExpressionLiteral()
            },
            {
                alt: ()=>this.TemplateLiteral({
                        ...params,
                        Tagged: false
                    })
            },
            {
                alt: ()=>this.CoverParenthesizedExpressionAndArrowParameterList(params)
            }
        ]);
    }
    /**
     *  InputElementRegExp 
     */ consumeRegularExpressionLiteral() {
        return this.consume(SlimeTokenType.RegularExpressionLiteral, LexicalGoal.InputElementRegExp);
    }
    /**
     * CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
     *     ( Expression[+In, ?Yield, ?Await] )
     *     ( Expression[+In, ?Yield, ?Await] , )
     *     ( )
     *     ( ... BindingIdentifier[?Yield, ?Await] )
     *     ( ... BindingPattern[?Yield, ?Await] )
     *     ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
     *     ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )
     */ CoverParenthesizedExpressionAndArrowParameterList(params = {}) {
        return this.Or([
            // ( Expression[+In, ?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                }
            },
            // ( Expression[+In, ?Yield, ?Await] , )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.RParen();
                }
            },
            // ( )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.RParen();
                }
            },
            // ( ... BindingIdentifier[?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Ellipsis();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.RParen();
                }
            },
            // ( ... BindingPattern[?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Ellipsis();
                    this.BindingPattern(params);
                    this.tokenConsumer.RParen();
                }
            },
            // ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.Ellipsis();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.RParen();
                }
            },
            // ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.Ellipsis();
                    this.BindingPattern(params);
                    this.tokenConsumer.RParen();
                }
            }
        ]);
    }
    /**
     * ParenthesizedExpression[Yield, Await] :
     *     ( Expression[+In, ?Yield, ?Await] )
     *
     * Supplemental Syntax:
     * When processing PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList,
     * the interpretation is refined using this rule.
     *
     *  Cover Grammar 
     */ ParenthesizedExpression(params = {}) {
        this.tokenConsumer.LParen();
        this.Expression({
            ...params,
            In: true
        });
        return this.tokenConsumer.RParen();
    }
    // ----------------------------------------
    // A.2.3 Literals
    // ----------------------------------------
    /**
     * Literal :
     *     NullLiteral
     *     BooleanLiteral
     *     NumericLiteral
     *     StringLiteral
     *
     * NullLiteralNumericLiteralStringLiteral A.1 Lexical Grammar
     *  tokenConsumer  token
     */ Literal() {
        return this.Or([
            // NullLiteral A.1 Lexical Grammar token
            {
                alt: ()=>this.tokenConsumer.NullLiteral()
            },
            {
                alt: ()=>this.BooleanLiteral()
            },
            // NumericLiteral  token
            {
                alt: ()=>this.tokenConsumer.NumericLiteral()
            },
            // StringLiteral  token
            {
                alt: ()=>this.tokenConsumer.StringLiteral()
            }
        ]);
    }
    /**
     * BooleanLiteral :
     *     true
     *     false
     */ BooleanLiteral() {
        return this.Or([
            {
                alt: ()=>this.tokenConsumer.True()
            },
            {
                alt: ()=>this.tokenConsumer.False()
            }
        ]);
    }
    /**
     * ArrayLiteral[Yield, Await] :
     *     [ Elision_opt ]
     *     [ ElementList[?Yield, ?Await] ]
     *     [ ElementList[?Yield, ?Await] , Elision_opt ]
     */ ArrayLiteral(params = {}) {
        return this.Or([
            // [ Elision_opt ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.Option(()=>this.Elision());
                    this.tokenConsumer.RBracket();
                }
            },
            // [ ElementList[?Yield, ?Await] , Elision_opt ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.ElementList(params);
                    this.tokenConsumer.Comma();
                    this.Option(()=>this.Elision());
                    this.tokenConsumer.RBracket();
                }
            },
            // [ ElementList[?Yield, ?Await] ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.ElementList(params);
                    this.tokenConsumer.RBracket();
                }
            }
        ]);
    }
    /**
     * ElementList[Yield, Await] :
     *     Elision_opt AssignmentExpression[+In, ?Yield, ?Await]
     *     Elision_opt SpreadElement[?Yield, ?Await]
     *     ElementList[?Yield, ?Await] , Elision_opt AssignmentExpression[+In, ?Yield, ?Await]
     *     ElementList[?Yield, ?Await] , Elision_opt SpreadElement[?Yield, ?Await]
     */ ElementList(params = {}) {
        // 
        this.Option(()=>this.Elision());
        this.Or([
            {
                alt: ()=>this.AssignmentExpression({
                        ...params,
                        In: true
                    })
            },
            {
                alt: ()=>this.SpreadElement(params)
            }
        ]);
        //  (0)
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.Option(()=>this.Elision());
            this.Or([
                {
                    alt: ()=>this.AssignmentExpression({
                            ...params,
                            In: true
                        })
                },
                {
                    alt: ()=>this.SpreadElement(params)
                }
            ]);
        });
        return this.curCst;
    }
    /**
     * Elision :
     *     ,
     *     Elision ,
     */ Elision() {
        this.tokenConsumer.Comma();
        this.Many(()=>this.tokenConsumer.Comma());
        return this.curCst;
    }
    /**
     * SpreadElement[Yield, Await] :
     *     ... AssignmentExpression[+In, ?Yield, ?Await]
     */ SpreadElement(params = {}) {
        this.tokenConsumer.Ellipsis();
        return this.AssignmentExpression({
            ...params,
            In: true
        });
    }
    /**
     * ObjectLiteral[Yield, Await] :
     *     { }
     *     { PropertyDefinitionList[?Yield, ?Await] }
     *     { PropertyDefinitionList[?Yield, ?Await] , }
     */ ObjectLiteral(params = {}) {
        return this.Or([
            // { }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            // { PropertyDefinitionList[?Yield, ?Await] , }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.PropertyDefinitionList(params);
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.RBrace();
                }
            },
            // { PropertyDefinitionList[?Yield, ?Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.PropertyDefinitionList(params);
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * PropertyDefinitionList[Yield, Await] :
     *     PropertyDefinition[?Yield, ?Await]
     *     PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await]
     */ PropertyDefinitionList(params = {}) {
        this.PropertyDefinition(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.PropertyDefinition(params);
        });
        return this.curCst;
    }
    /**
     * PropertyDefinition[Yield, Await] :
     *     IdentifierReference[?Yield, ?Await]
     *     CoverInitializedName[?Yield, ?Await]
     *     PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await]
     *     MethodDefinition[?Yield, ?Await]
     *     ... AssignmentExpression[+In, ?Yield, ?Await]
     *
     *  Or 
     *  PEG 
     * 1. ... AssignmentExpression -  `...` 
     * 2. PropertyName : AssignmentExpression -  `:` 
     * 3. CoverInitializedName -  `=` 
     * 4. MethodDefinition - 
     * 5. IdentifierReference - 
     */ PropertyDefinition(params = {}) {
        return this.Or([
            // 1. ... AssignmentExpression - 
            {
                alt: ()=>{
                    this.tokenConsumer.Ellipsis();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                }
            },
            // 2. PropertyName : AssignmentExpression -  : 
            {
                alt: ()=>{
                    this.PropertyName(params);
                    this.tokenConsumer.Colon();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                }
            },
            // 3. CoverInitializedName -  = 
            {
                alt: ()=>this.CoverInitializedName(params)
            },
            // 4. MethodDefinition - 
            {
                alt: ()=>this.MethodDefinition(params)
            },
            // 5. IdentifierReference - 
            {
                alt: ()=>this.IdentifierReference(params)
            }
        ]);
    }
    /**
     * PropertyName[Yield, Await] :
     *     LiteralPropertyName
     *     ComputedPropertyName[?Yield, ?Await]
     */ PropertyName(params = {}) {
        return this.Or([
            {
                alt: ()=>this.LiteralPropertyName()
            },
            {
                alt: ()=>this.ComputedPropertyName(params)
            }
        ]);
    }
    /**
     * LiteralPropertyName :
     *     IdentifierName
     *     StringLiteral
     *     NumericLiteral
     *
     * StringLiteralNumericLiteral A.1 Lexical Grammar token
     */ LiteralPropertyName() {
        return this.Or([
            {
                alt: ()=>this.IdentifierName()
            },
            // StringLiteral  token
            {
                alt: ()=>this.tokenConsumer.StringLiteral()
            },
            // NumericLiteral  token
            {
                alt: ()=>this.tokenConsumer.NumericLiteral()
            }
        ]);
    }
    /**
     * ComputedPropertyName[Yield, Await] :
     *     [ AssignmentExpression[+In, ?Yield, ?Await] ]
     */ ComputedPropertyName(params = {}) {
        this.tokenConsumer.LBracket();
        this.AssignmentExpression({
            ...params,
            In: true
        });
        return this.tokenConsumer.RBracket();
    }
    /**
     * CoverInitializedName[Yield, Await] :
     *     IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]
     */ CoverInitializedName(params = {}) {
        this.IdentifierReference(params);
        return this.Initializer({
            ...params,
            In: true
        });
    }
    /**
     * Initializer[In, Yield, Await] :
     *     = AssignmentExpression[?In, ?Yield, ?Await]
     */ Initializer(params = {}) {
        this.tokenConsumer.Assign();
        return this.AssignmentExpression(params);
    }
    // ----------------------------------------
    // A.2.4 Template Literals
    // ----------------------------------------
    /**
     * TemplateLiteral[Yield, Await, Tagged] :
     *     NoSubstitutionTemplate
     *     SubstitutionTemplate[?Yield, ?Await, ?Tagged]
     */ TemplateLiteral(params = {}) {
        return this.Or([
            // NoSubstitutionTemplate  token
            {
                alt: ()=>this.tokenConsumer.NoSubstitutionTemplate()
            },
            {
                alt: ()=>this.SubstitutionTemplate(params)
            }
        ]);
    }
    // A.1 Lexical Grammar tokenConsumer  token
    // - NoSubstitutionTemplate -> tokenConsumer.NoSubstitutionTemplate()
    // - TemplateHead -> tokenConsumer.TemplateHead()
    // - TemplateTail -> tokenConsumer.TemplateTail()
    // - TemplateMiddle -> tokenConsumer.TemplateMiddle()
    /**
     * SubstitutionTemplate[Yield, Await, Tagged] :
     *     TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
     */ SubstitutionTemplate(params = {}) {
        // TemplateHead  token
        this.tokenConsumer.TemplateHead();
        this.Expression({
            ...params,
            In: true
        });
        return this.TemplateSpans(params);
    }
    /**
     * TemplateSpans[Yield, Await, Tagged] :
     *     TemplateTail
     *     TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail
     */ TemplateSpans(params = {}) {
        return this.Or([
            // TemplateTail  token
            {
                alt: ()=>this.tokenConsumer.TemplateTail()
            },
            {
                alt: ()=>{
                    this.TemplateMiddleList(params);
                    // TemplateTail  token
                    this.tokenConsumer.TemplateTail();
                }
            }
        ]);
    }
    /**
     * TemplateMiddleList[Yield, Await, Tagged] :
     *     TemplateMiddle Expression[+In, ?Yield, ?Await]
     *     TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
     */ TemplateMiddleList(params = {}) {
        // TemplateMiddle  token
        this.tokenConsumer.TemplateMiddle();
        this.Expression({
            ...params,
            In: true
        });
        this.Many(()=>{
            // TemplateMiddle  token
            this.tokenConsumer.TemplateMiddle();
            this.Expression({
                ...params,
                In: true
            });
        });
        return this.curCst;
    }
    // ----------------------------------------
    // A.2.5 Member Expressions
    // ----------------------------------------
    /**
     * MemberExpression[Yield, Await] :
     *     PrimaryExpression[?Yield, ?Await]
     *     MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
     *     MemberExpression[?Yield, ?Await] . IdentifierName
     *     MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
     *     SuperProperty[?Yield, ?Await]
     *     MetaProperty
     *     new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
     *     MemberExpression[?Yield, ?Await] . PrivateIdentifier
     */ MemberExpression(params = {}) {
        // 
        this.Or([
            {
                alt: ()=>this.PrimaryExpression(params)
            },
            {
                alt: ()=>this.SuperProperty(params)
            },
            {
                alt: ()=>this.MetaProperty()
            },
            {
                alt: ()=>{
                    this.tokenConsumer.New();
                    this.MemberExpression(params);
                    this.Arguments(params);
                }
            }
        ]);
        //  InputElementDiv
        //  (0)
        this.Many(()=>this.Or([
                // [ Expression[+In, ?Yield, ?Await] ]
                {
                    alt: ()=>{
                        this.tokenConsumer.LBracket();
                        this.Expression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RBracket();
                    }
                },
                // . IdentifierName
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.IdentifierName();
                    }
                },
                // TemplateLiteral[?Yield, ?Await, +Tagged]
                {
                    alt: ()=>this.TemplateLiteral({
                            ...params,
                            Tagged: true
                        })
                },
                // . PrivateIdentifier
                // PrivateIdentifier A.1 Lexical Grammar token
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.tokenConsumer.PrivateIdentifier();
                    }
                }
            ]));
        return this.curCst;
    }
    /**
     * SuperProperty[Yield, Await] :
     *     super [ Expression[+In, ?Yield, ?Await] ]
     *     super . IdentifierName
     */ SuperProperty(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Super();
                    this.tokenConsumer.LBracket();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RBracket();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Super();
                    this.tokenConsumer.Dot();
                    this.IdentifierName();
                }
            }
        ]);
    }
    /**
     * MetaProperty :
     *     NewTarget
     *     ImportMeta
     */ MetaProperty() {
        return this.Or([
            {
                alt: ()=>this.NewTarget()
            },
            {
                alt: ()=>this.ImportMeta()
            }
        ]);
    }
    /**
     * NewTarget :
     *     new . target
     */ NewTarget() {
        this.tokenConsumer.New();
        this.tokenConsumer.Dot();
        return this.tokenConsumer.Target();
    }
    /**
     * ImportMeta :
     *     import . meta
     */ ImportMeta() {
        this.tokenConsumer.Import();
        this.tokenConsumer.Dot();
        return this.tokenConsumer.Meta();
    }
    /**
     * NewExpression[Yield, Await] :
     *     MemberExpression[?Yield, ?Await]
     *     new NewExpression[?Yield, ?Await]
     */ NewExpression(params = {}) {
        return this.Or([
            {
                alt: ()=>this.MemberExpression(params)
            },
            {
                alt: ()=>{
                    this.tokenConsumer.New();
                    this.NewExpression(params);
                }
            }
        ]);
    }
    // ----------------------------------------
    // A.2.6 Call Expressions
    // ----------------------------------------
    /**
     * CallExpression[Yield, Await] :
     *     CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
     *     SuperCall[?Yield, ?Await]
     *     ImportCall[?Yield, ?Await]
     *     CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
     *     CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
     *     CallExpression[?Yield, ?Await] . IdentifierName
     *     CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
     *     CallExpression[?Yield, ?Await] . PrivateIdentifier
     */ CallExpression(params = {}) {
        // 
        this.Or([
            {
                alt: ()=>this.CoverCallExpressionAndAsyncArrowHead(params)
            },
            {
                alt: ()=>this.SuperCall(params)
            },
            {
                alt: ()=>this.ImportCall(params)
            }
        ]);
        //  (0)
        this.Many(()=>this.Or([
                // Arguments[?Yield, ?Await]
                {
                    alt: ()=>this.Arguments(params)
                },
                // [ Expression[+In, ?Yield, ?Await] ]
                {
                    alt: ()=>{
                        this.tokenConsumer.LBracket();
                        this.Expression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RBracket();
                    }
                },
                // . IdentifierName
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.IdentifierName();
                    }
                },
                // TemplateLiteral[?Yield, ?Await, +Tagged]
                {
                    alt: ()=>this.TemplateLiteral({
                            ...params,
                            Tagged: true
                        })
                },
                // . PrivateIdentifier
                // PrivateIdentifier A.1 Lexical Grammar token
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.tokenConsumer.PrivateIdentifier();
                    }
                }
            ]));
        return this.curCst;
    }
    /**
     * CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
     *     MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
     *
     *  Cover Grammar
     * 1. func(args)
     * 2. Async async (args) => {}
     */ CoverCallExpressionAndAsyncArrowHead(params = {}) {
        this.MemberExpression(params);
        return this.Arguments(params);
    }
    /**
     * CallMemberExpression[Yield, Await] :
     *     MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
     *
     * Supplemental Syntax:
     * When processing CallExpression : CoverCallExpressionAndAsyncArrowHead,
     * the interpretation is refined using this rule.
     *
     *  CoverCallExpressionAndAsyncArrowHead 
     *  ES2025 
     *  CallMemberExpression  Supplemental Syntax Cover Grammar
     */ CallMemberExpression(params = {}) {
        this.MemberExpression(params);
        return this.Arguments(params);
    }
    /**
     * SuperCall[Yield, Await] :
     *     super Arguments[?Yield, ?Await]
     */ SuperCall(params = {}) {
        this.tokenConsumer.Super();
        return this.Arguments(params);
    }
    /**
     * ImportCall[Yield, Await] :
     *     import ( AssignmentExpression[+In, ?Yield, ?Await] ,_opt )
     *     import ( AssignmentExpression[+In, ?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await] ,_opt )
     */ ImportCall(params = {}) {
        return this.Or([
            // import ( AssignmentExpression[+In, ?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await] ,_opt )
            {
                alt: ()=>{
                    this.tokenConsumer.Import();
                    this.tokenConsumer.LParen();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.Comma();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.Option(()=>this.tokenConsumer.Comma());
                    this.tokenConsumer.RParen();
                }
            },
            // import ( AssignmentExpression[+In, ?Yield, ?Await] ,_opt )
            {
                alt: ()=>{
                    this.tokenConsumer.Import();
                    this.tokenConsumer.LParen();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.Option(()=>this.tokenConsumer.Comma());
                    this.tokenConsumer.RParen();
                }
            }
        ]);
    }
    /**
     * Arguments[Yield, Await] :
     *     ( )
     *     ( ArgumentList[?Yield, ?Await] )
     *     ( ArgumentList[?Yield, ?Await] , )
     */ Arguments(params = {}) {
        return this.Or([
            // ( )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.RParen();
                }
            },
            // ( ArgumentList[?Yield, ?Await] , )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.ArgumentList(params);
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.RParen();
                }
            },
            // ( ArgumentList[?Yield, ?Await] )
            {
                alt: ()=>{
                    this.tokenConsumer.LParen();
                    this.ArgumentList(params);
                    this.tokenConsumer.RParen();
                }
            }
        ]);
    }
    /**
     * ArgumentList[Yield, Await] :
     *     AssignmentExpression[+In, ?Yield, ?Await]
     *     ... AssignmentExpression[+In, ?Yield, ?Await]
     *     ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await]
     *     ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await]
     */ ArgumentList(params = {}) {
        // 
        this.Or([
            {
                alt: ()=>this.AssignmentExpression({
                        ...params,
                        In: true
                    })
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Ellipsis();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                }
            }
        ]);
        //  (0)
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.Or([
                {
                    alt: ()=>this.AssignmentExpression({
                            ...params,
                            In: true
                        })
                },
                {
                    alt: ()=>{
                        this.tokenConsumer.Ellipsis();
                        this.AssignmentExpression({
                            ...params,
                            In: true
                        });
                    }
                }
            ]);
        });
        return this.curCst;
    }
    // ----------------------------------------
    // A.2.7 Optional Chaining
    // ----------------------------------------
    /**
     * OptionalExpression[Yield, Await] :
     *     MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
     *     CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
     *     OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
     *
     * PEG 
     * - CallExpression  MemberExpression  CallExpression  Arguments
     * -  `fn()?.value`CallExpression  `fn()` OptionalChain  `?.value`
     * -  MemberExpression  `fn` `()` 
     */ OptionalExpression(params = {}) {
        this.Or([
            {
                alt: ()=>this.CallExpression(params)
            },
            {
                alt: ()=>this.MemberExpression(params)
            } // MemberExpression 
        ]);
        this.OptionalChain(params);
        this.Many(()=>this.OptionalChain(params));
        return this.curCst;
    }
    /**
     * OptionalChain[Yield, Await] :
     *     ?. Arguments[?Yield, ?Await]
     *     ?. [ Expression[+In, ?Yield, ?Await] ]
     *     ?. IdentifierName
     *     ?. TemplateLiteral[?Yield, ?Await, +Tagged]
     *     ?. PrivateIdentifier
     *     OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
     *     OptionalChain[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
     *     OptionalChain[?Yield, ?Await] . IdentifierName
     *     OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
     *     OptionalChain[?Yield, ?Await] . PrivateIdentifier
     */ OptionalChain(params = {}) {
        //  ?. 
        this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.OptionalChaining();
                    this.Arguments(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.OptionalChaining();
                    this.tokenConsumer.LBracket();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RBracket();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.OptionalChaining();
                    this.IdentifierName();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.OptionalChaining();
                    this.TemplateLiteral({
                        ...params,
                        Tagged: true
                    });
                }
            },
            // PrivateIdentifier A.1 Lexical Grammar token
            {
                alt: ()=>{
                    this.tokenConsumer.OptionalChaining();
                    this.tokenConsumer.PrivateIdentifier();
                }
            }
        ]);
        //  (0)
        this.Many(()=>this.Or([
                {
                    alt: ()=>this.Arguments(params)
                },
                {
                    alt: ()=>{
                        this.tokenConsumer.LBracket();
                        this.Expression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RBracket();
                    }
                },
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.IdentifierName();
                    }
                },
                {
                    alt: ()=>this.TemplateLiteral({
                            ...params,
                            Tagged: true
                        })
                },
                // PrivateIdentifier A.1 Lexical Grammar token
                {
                    alt: ()=>{
                        this.tokenConsumer.Dot();
                        this.tokenConsumer.PrivateIdentifier();
                    }
                }
            ]));
        return this.curCst;
    }
    /**
     * LeftHandSideExpression[Yield, Await] :
     *     NewExpression[?Yield, ?Await]
     *     CallExpression[?Yield, ?Await]
     *     OptionalExpression[?Yield, ?Await]
     *
     * PEG 
     *
     * 
     * - CallExpression:  Arguments `()`
     * - OptionalExpression:  OptionalChain `?.`
     * - NewExpression:  Arguments  OptionalChain
     *
     *  PEG 
     * - NewExpression  MemberExpression `console.log`
     * -  NewExpression `(x)` 
     * - 
     *
     * ""
     * - OptionalExpression  CallExpression/MemberExpression + OptionalChain
     *   `fn()?.value``obj?.method()`
     * - CallExpression  Arguments `console.log(x)`
     * - NewExpression  `this``obj.prop`
     *
     *  PEG 
     */ LeftHandSideExpression(params = {}) {
        return this.Or([
            {
                alt: ()=>this.OptionalExpression(params)
            },
            {
                alt: ()=>this.CallExpression(params)
            },
            {
                alt: ()=>this.NewExpression(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.2.8 Update Expressions
    // ----------------------------------------
    /**
     * UpdateExpression[Yield, Await] :
     *     LeftHandSideExpression[?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
     *     LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
     *     ++ UnaryExpression[?Yield, ?Await]
     *     -- UnaryExpression[?Yield, ?Await]
     */ UpdateExpression(params = {}) {
        return this.Or([
            // LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    // [no LineTerminator here]
                    this.assertNoLineBreak();
                    this.tokenConsumer.Increment();
                }
            },
            // LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    // [no LineTerminator here]
                    this.assertNoLineBreak();
                    this.tokenConsumer.Decrement();
                }
            },
            // ++ UnaryExpression[?Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Increment();
                    this.UnaryExpression(params);
                }
            },
            // -- UnaryExpression[?Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Decrement();
                    this.UnaryExpression(params);
                }
            },
            // LeftHandSideExpression[?Yield, ?Await]
            {
                alt: ()=>this.LeftHandSideExpression(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.2.9 Unary Expressions
    // ----------------------------------------
    /**
     * UnaryExpression[Yield, Await] :
     *     UpdateExpression[?Yield, ?Await]
     *     delete UnaryExpression[?Yield, ?Await]
     *     void UnaryExpression[?Yield, ?Await]
     *     typeof UnaryExpression[?Yield, ?Await]
     *     + UnaryExpression[?Yield, ?Await]
     *     - UnaryExpression[?Yield, ?Await]
     *     ~ UnaryExpression[?Yield, ?Await]
     *     ! UnaryExpression[?Yield, ?Await]
     *     [+Await] AwaitExpression[?Yield]
     */ UnaryExpression(params = {}) {
        const { Await = false } = params;
        return this.Or([
            {
                alt: ()=>this.UpdateExpression(params)
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Delete();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Void();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Typeof();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Plus();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Minus();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.BitwiseNot();
                    this.UnaryExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.LogicalNot();
                    this.UnaryExpression(params);
                }
            },
            // [+Await] AwaitExpression - 
            ...Await ? [
                {
                    alt: ()=>this.AwaitExpression(params)
                }
            ] : []
        ]);
    }
    /**
     * AwaitExpression[Yield] :
     *     await UnaryExpression[?Yield, +Await]
     */ AwaitExpression(params = {}) {
        this.tokenConsumer.Await();
        return this.UnaryExpression({
            ...params,
            Await: true
        });
    }
    // ----------------------------------------
    // A.2.10 Binary Expressions
    // ----------------------------------------
    /**
     * ExponentiationExpression[Yield, Await] :
     *     UnaryExpression[?Yield, ?Await]
     *     UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await]
     */ ExponentiationExpression(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.UpdateExpression(params);
                    this.tokenConsumer.Exponentiation();
                    this.ExponentiationExpression(params);
                }
            },
            {
                alt: ()=>this.UnaryExpression(params)
            }
        ]);
    }
    /**
     * MultiplicativeExpression[Yield, Await] :
     *     ExponentiationExpression[?Yield, ?Await]
     *     MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]
     */ MultiplicativeExpression(params = {}) {
        this.ExponentiationExpression(params);
        this.Many(()=>{
            this.MultiplicativeOperator();
            this.ExponentiationExpression(params);
        });
        return this.curCst;
    }
    /**
     * MultiplicativeOperator : one of
     *     * / %
     */ MultiplicativeOperator() {
        return this.Or([
            {
                alt: ()=>this.tokenConsumer.Asterisk()
            },
            {
                alt: ()=>this.tokenConsumer.Slash()
            },
            {
                alt: ()=>this.tokenConsumer.Modulo()
            }
        ]);
    }
    /**
     * AdditiveExpression[Yield, Await] :
     *     MultiplicativeExpression[?Yield, ?Await]
     *     AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
     *     AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]
     */ AdditiveExpression(params = {}) {
        this.MultiplicativeExpression(params);
        this.Many(()=>{
            this.Or([
                {
                    alt: ()=>this.tokenConsumer.Plus()
                },
                {
                    alt: ()=>this.tokenConsumer.Minus()
                }
            ]);
            this.MultiplicativeExpression(params);
        });
        return this.curCst;
    }
    /**
     * ShiftExpression[Yield, Await] :
     *     AdditiveExpression[?Yield, ?Await]
     *     ShiftExpression[?Yield, ?Await] << AdditiveExpression[?Yield, ?Await]
     *     ShiftExpression[?Yield, ?Await] >> AdditiveExpression[?Yield, ?Await]
     *     ShiftExpression[?Yield, ?Await] >>> AdditiveExpression[?Yield, ?Await]
     */ ShiftExpression(params = {}) {
        this.AdditiveExpression(params);
        this.Many(()=>{
            this.Or([
                {
                    alt: ()=>this.tokenConsumer.LeftShift()
                },
                {
                    alt: ()=>this.tokenConsumer.RightShift()
                },
                {
                    alt: ()=>this.tokenConsumer.UnsignedRightShift()
                }
            ]);
            this.AdditiveExpression(params);
        });
        return this.curCst;
    }
    /**
     * RelationalExpression[In, Yield, Await] :
     *     ShiftExpression[?Yield, ?Await]
     *     RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
     *     RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
     *     RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
     *     RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
     *     RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
     *     [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]
     *     [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]
     */ RelationalExpression(params = {}) {
        const { In = false } = params;
        //  [+In] PrivateIdentifier in ShiftExpression
        // PrivateIdentifier A.1 Lexical Grammar token
        if (In && this.lookahead(SlimeTokenType.PrivateIdentifier, 1)) {
            this.tokenConsumer.PrivateIdentifier();
            this.tokenConsumer.In();
            this.ShiftExpression(params);
            return this.curCst;
        }
        this.ShiftExpression(params);
        this.Many(()=>{
            this.Or([
                {
                    alt: ()=>this.tokenConsumer.Less()
                },
                {
                    alt: ()=>this.tokenConsumer.Greater()
                },
                {
                    alt: ()=>this.tokenConsumer.LessEqual()
                },
                {
                    alt: ()=>this.tokenConsumer.GreaterEqual()
                },
                {
                    alt: ()=>this.tokenConsumer.Instanceof()
                },
                // [+In] in -  In=true 
                ...In ? [
                    {
                        alt: ()=>this.tokenConsumer.In()
                    }
                ] : []
            ]);
            this.ShiftExpression(params);
        });
        return this.curCst;
    }
    /**
     * EqualityExpression[In, Yield, Await] :
     *     RelationalExpression[?In, ?Yield, ?Await]
     *     EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
     *     EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
     *     EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
     *     EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]
     */ EqualityExpression(params = {}) {
        this.RelationalExpression(params);
        this.Many(()=>{
            this.Or([
                {
                    alt: ()=>this.tokenConsumer.StrictEqual()
                },
                {
                    alt: ()=>this.tokenConsumer.StrictNotEqual()
                },
                {
                    alt: ()=>this.tokenConsumer.Equal()
                },
                {
                    alt: ()=>this.tokenConsumer.NotEqual()
                }
            ]);
            this.RelationalExpression(params);
        });
        return this.curCst;
    }
    /**
     * BitwiseANDExpression[In, Yield, Await] :
     *     EqualityExpression[?In, ?Yield, ?Await]
     *     BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]
     */ BitwiseANDExpression(params = {}) {
        this.EqualityExpression(params);
        this.Many(()=>{
            this.tokenConsumer.BitwiseAnd();
            this.EqualityExpression(params);
        });
        return this.curCst;
    }
    /**
     * BitwiseXORExpression[In, Yield, Await] :
     *     BitwiseANDExpression[?In, ?Yield, ?Await]
     *     BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]
     */ BitwiseXORExpression(params = {}) {
        this.BitwiseANDExpression(params);
        this.Many(()=>{
            this.tokenConsumer.BitwiseXor();
            this.BitwiseANDExpression(params);
        });
        return this.curCst;
    }
    /**
     * BitwiseORExpression[In, Yield, Await] :
     *     BitwiseXORExpression[?In, ?Yield, ?Await]
     *     BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]
     */ BitwiseORExpression(params = {}) {
        this.BitwiseXORExpression(params);
        this.Many(()=>{
            this.tokenConsumer.BitwiseOr();
            this.BitwiseXORExpression(params);
        });
        return this.curCst;
    }
    /**
     * LogicalANDExpression[In, Yield, Await] :
     *     BitwiseORExpression[?In, ?Yield, ?Await]
     *     LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]
     */ LogicalANDExpression(params = {}) {
        this.BitwiseORExpression(params);
        this.Many(()=>{
            this.tokenConsumer.LogicalAnd();
            this.BitwiseORExpression(params);
        });
        return this.curCst;
    }
    /**
     * LogicalORExpression[In, Yield, Await] :
     *     LogicalANDExpression[?In, ?Yield, ?Await]
     *     LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]
     *
     *  PEG 
     *
     * LogicalORExpression  CoalesceExpression  BitwiseORExpression 
     *  PEG  LogicalORExpression
     *  ??  CoalesceExpression 
     *
     *  ShortCircuitExpression 
     *   1. LogicalANDExpression
     *   2.  token||  ??
     *
     *  ShortCircuitExpression + LogicalORExpressionTail 
     */ LogicalORExpression(params = {}) {
        throw new Error('LogicalORExpression  PEG  ShortCircuitExpression ');
    }
    /**
     * LogicalORExpressionTail - LogicalORExpression 
     *
     * ( || LogicalANDExpression )+
     *  ShortCircuitExpression 
     */ LogicalORExpressionTail(params = {}) {
        return this.AtLeastOne(()=>{
            this.tokenConsumer.LogicalOr();
            this.LogicalANDExpression(params);
        });
    }
    /**
     * CoalesceExpression[In, Yield, Await] :
     *     CoalesceExpressionHead[?In, ?Yield, ?Await] ?? BitwiseORExpression[?In, ?Yield, ?Await]
     *
     *  PEG 
     *
     *  LogicalORExpression  ShortCircuitExpression 
     *  LogicalORExpression 
     */ CoalesceExpression(params = {}) {
        throw new Error('CoalesceExpression  PEG  ShortCircuitExpression ');
    }
    /**
     * CoalesceExpressionTail - CoalesceExpression 
     *
     * ( ?? BitwiseORExpression )+
     *  ShortCircuitExpression 
     */ CoalesceExpressionTail(params = {}) {
        return this.AtLeastOne(()=>{
            this.tokenConsumer.NullishCoalescing();
            this.BitwiseORExpression(params);
        });
    }
    /**
     * CoalesceExpressionHead[In, Yield, Await] :
     *     CoalesceExpression[?In, ?Yield, ?Await]
     *     BitwiseORExpression[?In, ?Yield, ?Await]
     *
     *  PEG 
     *  PEG 
     */ CoalesceExpressionHead(params = {}) {
        throw new Error('CoalesceExpressionHead  PEG ');
    }
    /**
     * ShortCircuitExpression[In, Yield, Await] :
     *     LogicalORExpression[?In, ?Yield, ?Await]
     *     CoalesceExpression[?In, ?Yield, ?Await]
     *
     *  PEG 
     *
     * LogicalORExpression  CoalesceExpression BitwiseORExpression
     *  PEG  token 
     *
     * 
     *   ShortCircuitExpression  LogicalANDExpression ShortCircuitExpressionTail?
     *   ShortCircuitExpressionTail  LogicalORExpressionTail | CoalesceExpressionTail
     *   LogicalORExpressionTail  ( || LogicalANDExpression )+
     *   CoalesceExpressionTail  ( ?? BitwiseORExpression )+
     */ ShortCircuitExpression(params = {}) {
        // LogicalANDExpression  BitwiseORExpression
        this.LogicalANDExpression(params);
        //  token 
        this.Option(()=>this.ShortCircuitExpressionTail(params));
        return this.curCst;
    }
    /**
     * ShortCircuitExpressionTail - 
     *
     *  token||  ?? LogicalOR  Coalesce 
     */ ShortCircuitExpressionTail(params = {}) {
        return this.Or([
            // || LogicalORExpressionTail
            {
                alt: ()=>this.LogicalORExpressionTail(params)
            },
            // ?? CoalesceExpressionTail
            {
                alt: ()=>this.CoalesceExpressionTail(params)
            }
        ]);
    }
    /**
     * ConditionalExpression[In, Yield, Await] :
     *     ShortCircuitExpression[?In, ?Yield, ?Await]
     *     ShortCircuitExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await]
     */ ConditionalExpression(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.ShortCircuitExpression(params);
                    this.tokenConsumer.Question();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.Colon();
                    this.AssignmentExpression(params);
                }
            },
            {
                alt: ()=>this.ShortCircuitExpression(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.2.11 Assignment Expressions
    // ----------------------------------------
    /**
     * AssignmentExpression[In, Yield, Await] :
     *     ConditionalExpression[?In, ?Yield, ?Await]
     *     [+Yield] YieldExpression[?In, ?Await]
     *     ArrowFunction[?In, ?Yield, ?Await]
     *     AsyncArrowFunction[?In, ?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] &&= AssignmentExpression[?In, ?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]
     *     LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]
     */ AssignmentExpression(params = {}) {
        const { Yield = false } = params;
        return this.Or([
            //   ConditionalExpression 
            //  (a, b) 
            //  => 
            {
                alt: ()=>this.ArrowFunction(params)
            },
            {
                alt: ()=>this.AsyncArrowFunction(params)
            },
            // [+Yield] YieldExpression
            ...Yield ? [
                {
                    alt: ()=>this.YieldExpression(params)
                }
            ] : [],
            //  ConditionalExpression  LeftHandSideExpression
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.Assign();
                    this.AssignmentExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    this.AssignmentOperator();
                    this.AssignmentExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.LogicalAndAssign();
                    this.AssignmentExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.LogicalOrAssign();
                    this.AssignmentExpression(params);
                }
            },
            {
                alt: ()=>{
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.NullishCoalescingAssign();
                    this.AssignmentExpression(params);
                }
            },
            // 
            {
                alt: ()=>this.ConditionalExpression(params)
            }
        ]);
    }
    /**
     * AssignmentOperator : one of
     *     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
     */ AssignmentOperator() {
        return this.Or([
            {
                alt: ()=>this.tokenConsumer.MultiplyAssign()
            },
            {
                alt: ()=>this.tokenConsumer.DivideAssign()
            },
            {
                alt: ()=>this.tokenConsumer.ModuloAssign()
            },
            {
                alt: ()=>this.tokenConsumer.PlusAssign()
            },
            {
                alt: ()=>this.tokenConsumer.MinusAssign()
            },
            {
                alt: ()=>this.tokenConsumer.LeftShiftAssign()
            },
            {
                alt: ()=>this.tokenConsumer.RightShiftAssign()
            },
            {
                alt: ()=>this.tokenConsumer.UnsignedRightShiftAssign()
            },
            {
                alt: ()=>this.tokenConsumer.BitwiseAndAssign()
            },
            {
                alt: ()=>this.tokenConsumer.BitwiseXorAssign()
            },
            {
                alt: ()=>this.tokenConsumer.BitwiseOrAssign()
            },
            {
                alt: ()=>this.tokenConsumer.ExponentiationAssign()
            }
        ]);
    }
    // ----------------------------------------
    // A.2.12 Comma Expression
    // ----------------------------------------
    /**
     * Expression[In, Yield, Await] :
     *     AssignmentExpression[?In, ?Yield, ?Await]
     *     Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]
     */ Expression(params = {}) {
        this.AssignmentExpression(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.AssignmentExpression(params);
        });
        return this.curCst;
    }
    // ============================================
    // A.3 Statements
    // ============================================
    // ----------------------------------------
    // A.3.1 General
    // ----------------------------------------
    /**
     * Statement[Yield, Await, Return] :
     *     BlockStatement[?Yield, ?Await, ?Return]
     *     VariableStatement[?Yield, ?Await]
     *     EmptyStatement
     *     ExpressionStatement[?Yield, ?Await]
     *     IfStatement[?Yield, ?Await, ?Return]
     *     BreakableStatement[?Yield, ?Await, ?Return]
     *     ContinueStatement[?Yield, ?Await]
     *     BreakStatement[?Yield, ?Await]
     *     [+Return] ReturnStatement[?Yield, ?Await]
     *     WithStatement[?Yield, ?Await, ?Return]
     *     LabelledStatement[?Yield, ?Await, ?Return]
     *     ThrowStatement[?Yield, ?Await]
     *     TryStatement[?Yield, ?Await, ?Return]
     *     DebuggerStatement
     */ Statement(params = {}) {
        const { Return = false } = params;
        return this.Or([
            {
                alt: ()=>this.BlockStatement(params)
            },
            {
                alt: ()=>this.VariableStatement(params)
            },
            {
                alt: ()=>this.EmptyStatement()
            },
            {
                alt: ()=>this.ExpressionStatement(params)
            },
            {
                alt: ()=>this.IfStatement(params)
            },
            {
                alt: ()=>this.BreakableStatement(params)
            },
            {
                alt: ()=>this.ContinueStatement(params)
            },
            {
                alt: ()=>this.BreakStatement(params)
            },
            // [+Return] ReturnStatement - 
            ...Return ? [
                {
                    alt: ()=>this.ReturnStatement(params)
                }
            ] : [],
            {
                alt: ()=>this.WithStatement(params)
            },
            {
                alt: ()=>this.LabelledStatement(params)
            },
            {
                alt: ()=>this.ThrowStatement(params)
            },
            {
                alt: ()=>this.TryStatement(params)
            },
            {
                alt: ()=>this.DebuggerStatement()
            }
        ]);
    }
    /**
     * Declaration[Yield, Await] :
     *     HoistableDeclaration[?Yield, ?Await, ~Default]
     *     ClassDeclaration[?Yield, ?Await, ~Default]
     *     LexicalDeclaration[+In, ?Yield, ?Await]
     */ Declaration(params = {}) {
        return this.Or([
            {
                alt: ()=>this.HoistableDeclaration({
                        ...params,
                        Default: false
                    })
            },
            {
                alt: ()=>this.ClassDeclaration({
                        ...params,
                        Default: false
                    })
            },
            {
                alt: ()=>this.LexicalDeclaration({
                        ...params,
                        In: true
                    })
            }
        ]);
    }
    /**
     * HoistableDeclaration[Yield, Await, Default] :
     *     FunctionDeclaration[?Yield, ?Await, ?Default]
     *     GeneratorDeclaration[?Yield, ?Await, ?Default]
     *     AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
     *     AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]
     */ HoistableDeclaration(params = {}) {
        return this.Or([
            {
                alt: ()=>this.FunctionDeclaration(params)
            },
            {
                alt: ()=>this.GeneratorDeclaration(params)
            },
            {
                alt: ()=>this.AsyncFunctionDeclaration(params)
            },
            {
                alt: ()=>this.AsyncGeneratorDeclaration(params)
            }
        ]);
    }
    /**
     * BreakableStatement[Yield, Await, Return] :
     *     IterationStatement[?Yield, ?Await, ?Return]
     *     SwitchStatement[?Yield, ?Await, ?Return]
     */ BreakableStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>this.IterationStatement(params)
            },
            {
                alt: ()=>this.SwitchStatement(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.3.2 Block
    // ----------------------------------------
    /**
     * BlockStatement[Yield, Await, Return] :
     *     Block[?Yield, ?Await, ?Return]
     */ BlockStatement(params = {}) {
        return this.Block(params);
    }
    /**
     * Block[Yield, Await, Return] :
     *     { StatementList[?Yield, ?Await, ?Return]_opt }
     */ Block(params = {}) {
        this.tokenConsumer.LBrace();
        this.Option(()=>this.StatementList(params));
        return this.tokenConsumer.RBrace();
    }
    /**
     * StatementList[Yield, Await, Return] :
     *     StatementListItem[?Yield, ?Await, ?Return]
     *     StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]
     */ StatementList(params = {}) {
        // 
        if (this.errorRecoveryMode) {
            this.ManyWithRecovery(()=>this.StatementListItem(params));
        } else {
            this.Many(()=>this.StatementListItem(params));
        }
        return this.curCst;
    }
    /**
     * StatementListItem[Yield, Await, Return] :
     *     Statement[?Yield, ?Await, ?Return]
     *     Declaration[?Yield, ?Await]
     *
     * PEG Declaration  Statement 
     * let  ExpressionStatement 
     *  Statement`let { a } = 1` 
     */ StatementListItem(params = {}) {
        return this.Or([
            {
                alt: ()=>this.Declaration(params)
            },
            {
                alt: ()=>this.Statement(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.3.3 Variable Declarations
    // ----------------------------------------
    /**
     * LexicalDeclaration[In, Yield, Await] :
     *     LetOrConst BindingList[?In, ?Yield, ?Await] ;
     */ LexicalDeclaration(params = {}) {
        this.LetOrConst();
        this.BindingList(params);
        return this.SemicolonASI();
    }
    /**
     * LetOrConst :
     *     let
     *     const
     */ LetOrConst() {
        return this.Or([
            {
                alt: ()=>this.tokenConsumer.Let()
            },
            {
                alt: ()=>this.tokenConsumer.Const()
            }
        ]);
    }
    /**
     * BindingList[In, Yield, Await] :
     *     LexicalBinding[?In, ?Yield, ?Await]
     *     BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]
     */ BindingList(params = {}) {
        this.LexicalBinding(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.LexicalBinding(params);
        });
        return this.curCst;
    }
    /**
     * LexicalBinding[In, Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]_opt
     *     BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
     */ LexicalBinding(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.BindingIdentifier(params);
                    this.Option(()=>this.Initializer(params));
                }
            },
            {
                alt: ()=>{
                    this.BindingPattern(params);
                    this.Initializer(params);
                }
            }
        ]);
    }
    /**
     * VariableStatement[Yield, Await] :
     *     var VariableDeclarationList[+In, ?Yield, ?Await] ;
     */ VariableStatement(params = {}) {
        this.tokenConsumer.Var();
        this.VariableDeclarationList({
            ...params,
            In: true
        });
        return this.SemicolonASI();
    }
    /**
     * VariableDeclarationList[In, Yield, Await] :
     *     VariableDeclaration[?In, ?Yield, ?Await]
     *     VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await]
     */ VariableDeclarationList(params = {}) {
        this.VariableDeclaration(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.VariableDeclaration(params);
        });
        return this.curCst;
    }
    /**
     * VariableDeclaration[In, Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]_opt
     *     BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
     */ VariableDeclaration(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.BindingIdentifier(params);
                    this.Option(()=>this.Initializer(params));
                }
            },
            {
                alt: ()=>{
                    this.BindingPattern(params);
                    this.Initializer(params);
                }
            }
        ]);
    }
    // ----------------------------------------
    // A.3.4 Binding Patterns
    // ----------------------------------------
    /**
     * BindingPattern[Yield, Await] :
     *     ObjectBindingPattern[?Yield, ?Await]
     *     ArrayBindingPattern[?Yield, ?Await]
     */ BindingPattern(params = {}) {
        return this.Or([
            {
                alt: ()=>this.ObjectBindingPattern(params)
            },
            {
                alt: ()=>this.ArrayBindingPattern(params)
            }
        ]);
    }
    /**
     * ObjectBindingPattern[Yield, Await] :
     *     { }
     *     { BindingRestProperty[?Yield, ?Await] }
     *     { BindingPropertyList[?Yield, ?Await] }
     *     { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await]_opt }
     */ ObjectBindingPattern(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.BindingRestProperty(params);
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.BindingPropertyList(params);
                    this.tokenConsumer.Comma();
                    this.Option(()=>this.BindingRestProperty(params));
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.BindingPropertyList(params);
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * ArrayBindingPattern[Yield, Await] :
     *     [ Elision_opt BindingRestElement[?Yield, ?Await]_opt ]
     *     [ BindingElementList[?Yield, ?Await] ]
     *     [ BindingElementList[?Yield, ?Await] , Elision_opt BindingRestElement[?Yield, ?Await]_opt ]
     */ ArrayBindingPattern(params = {}) {
        return this.Or([
            // [ Elision_opt BindingRestElement_opt ] -  rest
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.Option(()=>this.Elision());
                    this.Option(()=>this.BindingRestElement(params));
                    this.tokenConsumer.RBracket();
                }
            },
            // [ BindingElementList ] - 
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.BindingElementList(params);
                    this.tokenConsumer.RBracket();
                }
            },
            // [ BindingElementList , Elision_opt BindingRestElement_opt ] - 
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.BindingElementList(params);
                    this.tokenConsumer.Comma();
                    this.Option(()=>this.Elision());
                    this.Option(()=>this.BindingRestElement(params));
                    this.tokenConsumer.RBracket();
                }
            }
        ]);
    }
    /**
     * BindingRestProperty[Yield, Await] :
     *     ... BindingIdentifier[?Yield, ?Await]
     */ BindingRestProperty(params = {}) {
        this.tokenConsumer.Ellipsis();
        return this.BindingIdentifier(params);
    }
    /**
     * BindingPropertyList[Yield, Await] :
     *     BindingProperty[?Yield, ?Await]
     *     BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await]
     */ BindingPropertyList(params = {}) {
        this.BindingProperty(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.BindingProperty(params);
        });
        return this.curCst;
    }
    /**
     * BindingElementList[Yield, Await] :
     *     BindingElisionElement[?Yield, ?Await]
     *     BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await]
     */ BindingElementList(params = {}) {
        this.BindingElisionElement(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.BindingElisionElement(params);
        });
        return this.curCst;
    }
    /**
     * BindingElisionElement[Yield, Await] :
     *     Elision_opt BindingElement[?Yield, ?Await]
     */ BindingElisionElement(params = {}) {
        this.Option(()=>this.Elision());
        return this.BindingElement(params);
    }
    /**
     * BindingProperty[Yield, Await] :
     *     SingleNameBinding[?Yield, ?Await]
     *     PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await]
     */ BindingProperty(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.PropertyName(params);
                    this.tokenConsumer.Colon();
                    this.BindingElement(params);
                }
            },
            {
                alt: ()=>this.SingleNameBinding(params)
            }
        ]);
    }
    /**
     * BindingElement[Yield, Await] :
     *     SingleNameBinding[?Yield, ?Await]
     *     BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
     */ BindingElement(params = {}) {
        return this.Or([
            {
                alt: ()=>this.SingleNameBinding(params)
            },
            {
                alt: ()=>{
                    this.BindingPattern(params);
                    this.Option(()=>this.Initializer({
                            ...params,
                            In: true
                        }));
                }
            }
        ]);
    }
    /**
     * SingleNameBinding[Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
     */ SingleNameBinding(params = {}) {
        this.BindingIdentifier(params);
        this.Option(()=>this.Initializer({
                ...params,
                In: true
            }));
        return this.curCst;
    }
    /**
     * BindingRestElement[Yield, Await] :
     *     ... BindingIdentifier[?Yield, ?Await]
     *     ... BindingPattern[?Yield, ?Await]
     */ BindingRestElement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Ellipsis();
                    this.BindingIdentifier(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Ellipsis();
                    this.BindingPattern(params);
                }
            }
        ]);
    }
    // ----------------------------------------
    // A.3.5 Simple Statements
    // ----------------------------------------
    /**
     * Automatic Semicolon Insertion (ASI)
     *
     * ECMAScript  11.9: Automatic Semicolon Insertion
     *
     * 
     * 1. Line Terminator
     * 2. EOF
     * 3.  }
     *
     * 
     * - 
     * -  ASI 
     * -  ASI 
     */ SemicolonASI() {
        //  token 
        if (this.match(SlimeTokenType.Semicolon)) {
            this.tokenConsumer.Semicolon();
            return this.curCst;
        }
        //  ASI 
        const canInsertSemicolon = this.canAutoInsertSemicolon();
        if (!canInsertSemicolon) {
            //  ASI 
            return this.setParseFail();
        }
        //  ASI 
        return this.curCst;
    }
    /**
     * 
     *
     * ASI 
     * 1.  token 
     * 2.  token  }
     * 3. EOF
     */ canAutoInsertSemicolon() {
        //  3EOF
        if (this.isEof) {
            return true;
        }
        if (!this.curToken) {
            return true;
        }
        //  1 token 
        if (this.curToken.hasLineBreakBefore) {
            return true;
        }
        //  2 token  }
        if (this.match(SlimeTokenType.RBrace)) {
            return true;
        }
        return false;
    }
    /**
     * EmptyStatement :
     *     ;
     */ EmptyStatement() {
        return this.tokenConsumer.Semicolon();
    }
    /**
     * ExpressionStatement[Yield, Await] :
     *     [lookahead  {{, function, async [no LineTerminator here] function, class, let [}]
     *     Expression[+In, ?Yield, ?Await] ;
     */ ExpressionStatement(params = {}) {
        // [lookahead  {{, function, async [no LineTerminator here] function, class, let [}]
        this.assertLookaheadNotIn([
            SlimeTokenType.LBrace,
            SlimeTokenType.Function,
            SlimeTokenType.Class
        ]);
        this.assertNotContextualSequenceNoLT(SlimeContextualKeywordTokenTypes.Async, SlimeTokenType.Function);
        this.assertNotContextualSequence(SlimeContextualKeywordTokenTypes.Let, SlimeTokenType.LBracket);
        this.Expression({
            ...params,
            In: true
        });
        return this.SemicolonASI();
    }
    // ----------------------------------------
    // A.3.6 If Statement
    // ----------------------------------------
    /**
     * IfStatement[Yield, Await, Return] :
     *     if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return]
     *     if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [lookahead  else]
     *
     * Annex B.3.4:
     *     if ( Expression ) FunctionDeclaration else Statement
     *     if ( Expression ) Statement else FunctionDeclaration
     *     if ( Expression ) FunctionDeclaration else FunctionDeclaration
     *     if ( Expression ) FunctionDeclaration [lookahead  else]
     */ IfStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.If();
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.IfStatementBody(params);
                    this.tokenConsumer.Else();
                    this.IfStatementBody(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.If();
                    this.tokenConsumer.LParen();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.IfStatementBody(params);
                    this.assertLookaheadNot(SlimeTokenType.Else); // [lookahead  else]
                }
            }
        ]);
    }
    /**
     * IfStatementBody - 
     *
     *   ECMAScript 
     *  Annex B.3.4Web 
     *
     * Annex B.3.4  Web 
     * IfStatement  body  FunctionDeclaration
     *
     *   if ( Expression ) FunctionDeclaration else Statement
     *   if ( Expression ) Statement else FunctionDeclaration
     *   if ( Expression ) FunctionDeclaration else FunctionDeclaration
     *   if ( Expression ) FunctionDeclaration [lookahead  else]
     *
     * 
     *
     * ECMAScript 2025 Annex B.3.4 FunctionDeclarations in IfStatement Statement Clauses
     */ IfStatementBody(params = {}) {
        return this.Or([
            {
                alt: ()=>this.Statement(params)
            },
            // Annex B.3.4:  FunctionDeclaration
            {
                alt: ()=>this.FunctionDeclaration({
                        ...params,
                        Default: false
                    })
            }
        ]);
    }
    // ----------------------------------------
    // A.3.7 Iteration Statements
    // ----------------------------------------
    /**
     * IterationStatement[Yield, Await, Return] :
     *     DoWhileStatement[?Yield, ?Await, ?Return]
     *     WhileStatement[?Yield, ?Await, ?Return]
     *     ForStatement[?Yield, ?Await, ?Return]
     *     ForInOfStatement[?Yield, ?Await, ?Return]
     */ IterationStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>this.DoWhileStatement(params)
            },
            {
                alt: ()=>this.WhileStatement(params)
            },
            {
                alt: ()=>this.ForStatement(params)
            },
            {
                alt: ()=>this.ForInOfStatement(params)
            }
        ]);
    }
    /**
     * DoWhileStatement[Yield, Await, Return] :
     *     do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ;
     *
     *  ECMAScript  11.9.1 ASI 
     * "The previous token is ) and the inserted semicolon would then be parsed as
     *  the terminating semicolon of a do-while statement"
     *  do-while  ASI token  ASI 
     */ DoWhileStatement(params = {}) {
        this.tokenConsumer.Do();
        this.Statement(params);
        this.tokenConsumer.While();
        this.tokenConsumer.LParen();
        this.Expression({
            ...params,
            In: true
        });
        this.tokenConsumer.RParen();
        // do-while  ASI 
        // 
        this.Option(()=>this.tokenConsumer.Semicolon());
        return this.curCst;
    }
    /**
     * WhileStatement[Yield, Await, Return] :
     *     while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     */ WhileStatement(params = {}) {
        this.tokenConsumer.While();
        this.tokenConsumer.LParen();
        this.Expression({
            ...params,
            In: true
        });
        this.tokenConsumer.RParen();
        return this.Statement(params);
    }
    /**
     * ForStatement[Yield, Await, Return] :
     *     for ( [lookahead  let [] Expression[~In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
     *     for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
     *     for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
     */ ForStatement(params = {}) {
        return this.Or([
            // for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Var();
                    this.VariableDeclarationList({
                        ...params,
                        In: false
                    });
                    this.tokenConsumer.Semicolon();
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.Semicolon();
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.LexicalDeclaration({
                        ...params,
                        In: false
                    });
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.Semicolon();
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( [lookahead  let [] Expression[~In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ; Expression[+In, ?Yield, ?Await]_opt ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    // [lookahead  let []
                    this.assertNotContextualSequence(SlimeContextualKeywordTokenTypes.Let, SlimeTokenType.LBracket);
                    this.Option(()=>this.Expression({
                            ...params,
                            In: false
                        }));
                    this.tokenConsumer.Semicolon();
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.Semicolon();
                    this.Option(()=>this.Expression({
                            ...params,
                            In: true
                        }));
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            }
        ]);
    }
    /**
     * ForInOfStatement[Yield, Await, Return] :
     *     for ( [lookahead  let [] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     for ( [lookahead  {let, async of}] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     [+Await] for await ( [lookahead  let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *     [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     *
     * B.3.5 Initializers in ForIn Statement Heads ():
     *     for ( var BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     */ ForInOfStatement(params = {}) {
        const { Await = false } = params;
        return this.Or([
            // B.3.5: for ( var BindingIdentifier Initializer in Expression ) Statement
            //  Annex B  for-in 
            // for (var a = 1 in obj) { ... }
            //  "for ( var ForBinding in ...)"  Initializer
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Var();
                    this.BindingIdentifier(params);
                    this.Initializer({
                        ...params,
                        In: false
                    }); // Initializer[~In]
                    this.tokenConsumer.In();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Var();
                    this.ForBinding(params);
                    this.tokenConsumer.In();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( [lookahead  let [] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.assertNotContextualSequence(SlimeContextualKeywordTokenTypes.Let, SlimeTokenType.LBracket);
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.In();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.ForDeclaration(params);
                    this.tokenConsumer.In();
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.Var();
                    this.ForBinding(params);
                    this.tokenConsumer.Of();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    this.ForDeclaration(params);
                    this.tokenConsumer.Of();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // for ( [lookahead  {let, async of}] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            {
                alt: ()=>{
                    this.tokenConsumer.For();
                    this.tokenConsumer.LParen();
                    // [lookahead  {let, async of}]
                    this.assertNotContextual(SlimeContextualKeywordTokenTypes.Let);
                    this.assertNotContextualPair(SlimeContextualKeywordTokenTypes.Async, SlimeContextualKeywordTokenTypes.Of);
                    this.LeftHandSideExpression(params);
                    this.tokenConsumer.Of();
                    this.AssignmentExpression({
                        ...params,
                        In: true
                    });
                    this.tokenConsumer.RParen();
                    this.Statement(params);
                }
            },
            // [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            ...Await ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.For();
                        this.tokenConsumer.Await();
                        this.tokenConsumer.LParen();
                        this.tokenConsumer.Var();
                        this.ForBinding(params);
                        this.tokenConsumer.Of();
                        this.AssignmentExpression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RParen();
                        this.Statement(params);
                    }
                }
            ] : [],
            // [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            ...Await ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.For();
                        this.tokenConsumer.Await();
                        this.tokenConsumer.LParen();
                        this.ForDeclaration(params);
                        this.tokenConsumer.Of();
                        this.AssignmentExpression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RParen();
                        this.Statement(params);
                    }
                }
            ] : [],
            // [+Await] for await ( [lookahead  let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
            ...Await ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.For();
                        this.tokenConsumer.Await();
                        this.tokenConsumer.LParen();
                        // [lookahead  let]
                        this.assertNotContextual(SlimeContextualKeywordTokenTypes.Let);
                        this.LeftHandSideExpression(params);
                        this.tokenConsumer.Of();
                        this.AssignmentExpression({
                            ...params,
                            In: true
                        });
                        this.tokenConsumer.RParen();
                        this.Statement(params);
                    }
                }
            ] : []
        ]);
    }
    /**
     * ForDeclaration[Yield, Await] :
     *     LetOrConst ForBinding[?Yield, ?Await]
     */ ForDeclaration(params = {}) {
        this.LetOrConst();
        return this.ForBinding(params);
    }
    /**
     * ForBinding[Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await]
     *     BindingPattern[?Yield, ?Await]
     */ ForBinding(params = {}) {
        return this.Or([
            {
                alt: ()=>this.BindingIdentifier(params)
            },
            {
                alt: ()=>this.BindingPattern(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.3.8 Control Flow Statements
    // ----------------------------------------
    /**
     * ContinueStatement[Yield, Await] :
     *     continue ;
     *     continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
     */ ContinueStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Continue();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.LabelIdentifier(params);
                    this.SemicolonASI();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Continue();
                    this.SemicolonASI();
                }
            }
        ]);
    }
    /**
     * BreakStatement[Yield, Await] :
     *     break ;
     *     break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
     */ BreakStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Break();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.LabelIdentifier(params);
                    this.SemicolonASI();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Break();
                    this.SemicolonASI();
                }
            }
        ]);
    }
    /**
     * ReturnStatement[Yield, Await] :
     *     return ;
     *     return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
     */ ReturnStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Return();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.Expression({
                        ...params,
                        In: true
                    });
                    this.SemicolonASI();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Return();
                    this.SemicolonASI();
                }
            }
        ]);
    }
    // ----------------------------------------
    // A.3.9 With Statement
    // ----------------------------------------
    /**
     * WithStatement[Yield, Await, Return] :
     *     with ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
     */ WithStatement(params = {}) {
        this.tokenConsumer.With();
        this.tokenConsumer.LParen();
        this.Expression({
            ...params,
            In: true
        });
        this.tokenConsumer.RParen();
        return this.Statement(params);
    }
    // ----------------------------------------
    // A.3.10 Switch Statement
    // ----------------------------------------
    /**
     * SwitchStatement[Yield, Await, Return] :
     *     switch ( Expression[+In, ?Yield, ?Await] ) CaseBlock[?Yield, ?Await, ?Return]
     */ SwitchStatement(params = {}) {
        this.tokenConsumer.Switch();
        this.tokenConsumer.LParen();
        this.Expression({
            ...params,
            In: true
        });
        this.tokenConsumer.RParen();
        return this.CaseBlock(params);
    }
    /**
     * CaseBlock[Yield, Await, Return] :
     *     { CaseClauses[?Yield, ?Await, ?Return]_opt }
     *     { CaseClauses[?Yield, ?Await, ?Return]_opt DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]_opt }
     */ CaseBlock(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.Option(()=>this.CaseClauses(params));
                    this.DefaultClause(params);
                    this.Option(()=>this.CaseClauses(params));
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.Option(()=>this.CaseClauses(params));
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * CaseClauses[Yield, Await, Return] :
     *     CaseClause[?Yield, ?Await, ?Return]
     *     CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]
     */ CaseClauses(params = {}) {
        this.AtLeastOne(()=>this.CaseClause(params));
        return this.curCst;
    }
    /**
     * CaseClause[Yield, Await, Return] :
     *     case Expression[+In, ?Yield, ?Await] : StatementList[?Yield, ?Await, ?Return]_opt
     */ CaseClause(params = {}) {
        this.tokenConsumer.Case();
        this.Expression({
            ...params,
            In: true
        });
        this.tokenConsumer.Colon();
        this.Option(()=>this.StatementList(params));
        return this.curCst;
    }
    /**
     * DefaultClause[Yield, Await, Return] :
     *     default : StatementList[?Yield, ?Await, ?Return]_opt
     */ DefaultClause(params = {}) {
        this.tokenConsumer.Default();
        this.tokenConsumer.Colon();
        this.Option(()=>this.StatementList(params));
        return this.curCst;
    }
    // ----------------------------------------
    // A.3.11 Labelled Statement
    // ----------------------------------------
    /**
     * LabelledStatement[Yield, Await, Return] :
     *     LabelIdentifier[?Yield, ?Await] : LabelledItem[?Yield, ?Await, ?Return]
     */ LabelledStatement(params = {}) {
        this.LabelIdentifier(params);
        this.tokenConsumer.Colon();
        return this.LabelledItem(params);
    }
    /**
     * LabelledItem[Yield, Await, Return] :
     *     Statement[?Yield, ?Await, ?Return]
     *     FunctionDeclaration[?Yield, ?Await, ~Default]
     */ LabelledItem(params = {}) {
        return this.Or([
            {
                alt: ()=>this.Statement(params)
            },
            {
                alt: ()=>this.FunctionDeclaration({
                        ...params,
                        Default: false
                    })
            }
        ]);
    }
    // ----------------------------------------
    // A.3.12 Throw Statement
    // ----------------------------------------
    /**
     * ThrowStatement[Yield, Await] :
     *     throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
     */ ThrowStatement(params = {}) {
        this.tokenConsumer.Throw();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.Expression({
            ...params,
            In: true
        });
        return this.SemicolonASI();
    }
    // ----------------------------------------
    // A.3.13 Try Statement
    // ----------------------------------------
    /**
     * TryStatement[Yield, Await, Return] :
     *     try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
     *     try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
     *     try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
     */ TryStatement(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Try();
                    this.Block(params);
                    this.Catch(params);
                    this.Finally(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Try();
                    this.Block(params);
                    this.Catch(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Try();
                    this.Block(params);
                    this.Finally(params);
                }
            }
        ]);
    }
    /**
     * Catch[Yield, Await, Return] :
     *     catch ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?Return]
     *     catch Block[?Yield, ?Await, ?Return]
     */ Catch(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.Catch();
                    this.tokenConsumer.LParen();
                    this.CatchParameter(params);
                    this.tokenConsumer.RParen();
                    this.Block(params);
                }
            },
            {
                alt: ()=>{
                    this.tokenConsumer.Catch();
                    this.Block(params);
                }
            }
        ]);
    }
    /**
     * Finally[Yield, Await, Return] :
     *     finally Block[?Yield, ?Await, ?Return]
     */ Finally(params = {}) {
        this.tokenConsumer.Finally();
        return this.Block(params);
    }
    /**
     * CatchParameter[Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await]
     *     BindingPattern[?Yield, ?Await]
     */ CatchParameter(params = {}) {
        return this.Or([
            {
                alt: ()=>this.BindingIdentifier(params)
            },
            {
                alt: ()=>this.BindingPattern(params)
            }
        ]);
    }
    // ----------------------------------------
    // A.3.14 Debugger Statement
    // ----------------------------------------
    /**
     * DebuggerStatement :
     *     debugger ;
     */ DebuggerStatement() {
        this.tokenConsumer.Debugger();
        return this.SemicolonASI();
    }
    // ============================================
    // A.4 Functions and Classes
    // ============================================
    /**
     * YieldExpression[In, Await] :
     *     yield
     *     yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
     *     yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
     */ YieldExpression(params = {}) {
        return this.Or([
            // yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Yield();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.tokenConsumer.Asterisk();
                    this.AssignmentExpression({
                        ...params,
                        Yield: true
                    });
                }
            },
            // yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Yield();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.AssignmentExpression({
                        ...params,
                        Yield: true
                    });
                }
            },
            // yield
            {
                alt: ()=>this.tokenConsumer.Yield()
            }
        ]);
    }
    /**
     * ArrowFunction[In, Yield, Await] :
     *     ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]
     */ ArrowFunction(params = {}) {
        this.ArrowParameters(params);
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.tokenConsumer.Arrow();
        this.ConciseBody(params);
        return this.curCst;
    }
    /**
     * ArrowParameters[Yield, Await] :
     *     BindingIdentifier[?Yield, ?Await]
     *     CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
     */ ArrowParameters(params = {}) {
        return this.Or([
            {
                alt: ()=>this.BindingIdentifier(params)
            },
            {
                alt: ()=>this.CoverParenthesizedExpressionAndArrowParameterList(params)
            }
        ]);
    }
    /**
     * ArrowFormalParameters[Yield, Await] :
     *     ( UniqueFormalParameters[?Yield, ?Await] )
     *
     * Supplemental Syntax:
     * When processing ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList,
     * the interpretation is refined using this rule.
     *
     *  Cover Grammar 
     */ ArrowFormalParameters(params = {}) {
        this.tokenConsumer.LParen();
        this.UniqueFormalParameters(params);
        return this.tokenConsumer.RParen();
    }
    /**
     * ConciseBody[In] :
     *     [lookahead  {] ExpressionBody[?In, ~Await]
     *     { FunctionBody[~Yield, ~Await] }
     */ ConciseBody(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.FunctionBody({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    // [lookahead  {]
                    this.assertLookaheadNot(SlimeTokenType.LBrace);
                    this.ExpressionBody({
                        ...params,
                        Await: false
                    });
                }
            }
        ]);
    }
    /**
     * ExpressionBody[In, Await] :
     *     AssignmentExpression[?In, ~Yield, ?Await]
     */ ExpressionBody(params = {}) {
        return this.AssignmentExpression({
            ...params,
            Yield: false
        });
    }
    /**
     * AsyncArrowFunction[In, Yield, Await] :
     *     async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
     *     CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]
     */ AsyncArrowFunction(params = {}) {
        return this.Or([
            // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
            {
                alt: ()=>{
                    this.tokenConsumer.Async();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.AsyncArrowBindingIdentifier(params);
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.tokenConsumer.Arrow();
                    this.AsyncConciseBody(params);
                }
            },
            // CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]
            {
                alt: ()=>{
                    this.CoverCallExpressionAndAsyncArrowHead(params);
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.tokenConsumer.Arrow();
                    this.AsyncConciseBody(params);
                }
            }
        ]);
    }
    /**
     * AsyncArrowBindingIdentifier[Yield] :
     *     BindingIdentifier[?Yield, +Await]
     */ AsyncArrowBindingIdentifier(params = {}) {
        return this.BindingIdentifier({
            ...params,
            Await: true
        });
    }
    /**
     * AsyncConciseBody[In] :
     *     [lookahead  {] ExpressionBody[?In, +Await]
     *     { AsyncFunctionBody }
     */ AsyncConciseBody(params = {}) {
        return this.Or([
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.AsyncFunctionBody();
                    this.tokenConsumer.RBrace();
                }
            },
            {
                alt: ()=>{
                    // [lookahead  {]
                    this.assertLookaheadNot(SlimeTokenType.LBrace);
                    this.ExpressionBody({
                        ...params,
                        Await: true
                    });
                }
            }
        ]);
    }
    /**
     * AsyncArrowHead :
     *     async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
     *
     * Supplemental Syntax:
     * When processing AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead [no LineTerminator here] => AsyncConciseBody,
     * the interpretation is refined using this rule.
     *
     *  Cover Grammar 
     */ AsyncArrowHead() {
        this.tokenConsumer.Async();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.ArrowFormalParameters({
            Yield: false,
            Await: true
        });
        return this.curCst;
    }
    // ============================================
    // Function Parameters
    // ============================================
    /**
     * UniqueFormalParameters[Yield, Await] :
     *     FormalParameters[?Yield, ?Await]
     */ UniqueFormalParameters(params = {}) {
        return this.FormalParameters(params);
    }
    /**
     * FormalParameters[Yield, Await] :
     *     [empty]
     *     FunctionRestParameter[?Yield, ?Await]
     *     FormalParameterList[?Yield, ?Await]
     *     FormalParameterList[?Yield, ?Await] ,
     *     FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await]
     */ FormalParameters(params = {}) {
        return this.Or([
            // FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await]
            {
                alt: ()=>{
                    this.FormalParameterList(params);
                    this.tokenConsumer.Comma();
                    this.FunctionRestParameter(params);
                }
            },
            // FormalParameterList[?Yield, ?Await] ,
            {
                alt: ()=>{
                    this.FormalParameterList(params);
                    this.tokenConsumer.Comma();
                }
            },
            // FormalParameterList[?Yield, ?Await]
            {
                alt: ()=>this.FormalParameterList(params)
            },
            // FunctionRestParameter[?Yield, ?Await]
            {
                alt: ()=>this.FunctionRestParameter(params)
            },
            // [empty]
            {
                alt: ()=>this.curCst
            }
        ]);
    }
    /**
     * FormalParameterList[Yield, Await] :
     *     FormalParameter[?Yield, ?Await]
     *     FormalParameterList[?Yield, ?Await] , FormalParameter[?Yield, ?Await]
     */ FormalParameterList(params = {}) {
        this.FormalParameter(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.FormalParameter(params);
        });
        return this.curCst;
    }
    /**
     * FunctionRestParameter[Yield, Await] :
     *     BindingRestElement[?Yield, ?Await]
     */ FunctionRestParameter(params = {}) {
        return this.BindingRestElement(params);
    }
    /**
     * FormalParameter[Yield, Await] :
     *     BindingElement[?Yield, ?Await]
     */ FormalParameter(params = {}) {
        return this.BindingElement(params);
    }
    // ============================================
    // Function Definitions
    // ============================================
    /**
     * FunctionBody[Yield, Await] :
     *     FunctionStatementList[?Yield, ?Await]
     */ FunctionBody(params = {}) {
        return this.FunctionStatementList(params);
    }
    /**
     * FunctionStatementList[Yield, Await] :
     *     StatementList[?Yield, ?Await, +Return]_opt
     */ FunctionStatementList(params = {}) {
        //  Return: true 
        const statementParams = {
            Yield: params.Yield,
            Await: params.Await,
            Return: true // FunctionStatementList  Return: true
        };
        this.Option(()=>this.StatementList(statementParams));
        return this.curCst;
    }
    /**
     * FunctionExpression :
     *     function BindingIdentifier[~Yield, ~Await]_opt ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
     */ FunctionExpression() {
        this.tokenConsumer.Function();
        this.Option(()=>this.BindingIdentifier({
                Yield: false,
                Await: false
            }));
        this.tokenConsumer.LParen();
        this.FormalParameters({
            Yield: false,
            Await: false
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.FunctionBody({
            Yield: false,
            Await: false
        });
        return this.tokenConsumer.RBrace();
    }
    /**
     * FunctionDeclaration[Yield, Await, Default] :
     *     function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
     *     [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
     */ FunctionDeclaration(params = {}) {
        const { Default = false } = params;
        return this.Or([
            // function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.Function();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.LParen();
                    this.FormalParameters({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.FunctionBody({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RBrace();
                }
            },
            // [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] } - 
            ...Default ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.Function();
                        this.tokenConsumer.LParen();
                        this.FormalParameters({
                            Yield: false,
                            Await: false
                        });
                        this.tokenConsumer.RParen();
                        this.tokenConsumer.LBrace();
                        this.FunctionBody({
                            Yield: false,
                            Await: false
                        });
                        this.tokenConsumer.RBrace();
                    }
                }
            ] : []
        ]);
    }
    // ============================================
    // Generator Functions
    // ============================================
    /**
     * GeneratorDeclaration[Yield, Await, Default] :
     *     function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
     *     [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
     */ GeneratorDeclaration(params = {}) {
        const { Default = false } = params;
        return this.Or([
            // function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
            {
                alt: ()=>{
                    this.tokenConsumer.Function();
                    this.tokenConsumer.Asterisk();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.LParen();
                    this.FormalParameters({
                        Yield: true,
                        Await: false
                    });
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.GeneratorBody();
                    this.tokenConsumer.RBrace();
                }
            },
            // [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody } - 
            ...Default ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.Function();
                        this.tokenConsumer.Asterisk();
                        this.tokenConsumer.LParen();
                        this.FormalParameters({
                            Yield: true,
                            Await: false
                        });
                        this.tokenConsumer.RParen();
                        this.tokenConsumer.LBrace();
                        this.GeneratorBody();
                        this.tokenConsumer.RBrace();
                    }
                }
            ] : []
        ]);
    }
    /**
     * GeneratorExpression :
     *     function * BindingIdentifier[+Yield, ~Await]_opt ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
     */ GeneratorExpression() {
        this.tokenConsumer.Function();
        this.tokenConsumer.Asterisk();
        this.Option(()=>this.BindingIdentifier({
                Yield: true,
                Await: false
            }));
        this.tokenConsumer.LParen();
        this.FormalParameters({
            Yield: true,
            Await: false
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.GeneratorBody();
        return this.tokenConsumer.RBrace();
    }
    /**
     * GeneratorMethod[Yield, Await] :
     *     * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, ~Await] ) { GeneratorBody }
     */ GeneratorMethod(params = {}) {
        this.tokenConsumer.Asterisk();
        this.ClassElementName(params);
        this.tokenConsumer.LParen();
        this.UniqueFormalParameters({
            Yield: true,
            Await: false
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.GeneratorBody();
        return this.tokenConsumer.RBrace();
    }
    /**
     * GeneratorBody :
     *     FunctionBody[+Yield, ~Await]
     */ GeneratorBody() {
        return this.FunctionBody({
            Yield: true,
            Await: false
        });
    }
    // ============================================
    // Async Functions
    // ============================================
    /**
     * AsyncFunctionDeclaration[Yield, Await, Default] :
     *     async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
     *     [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
     */ AsyncFunctionDeclaration(params = {}) {
        const { Default = false } = params;
        return this.Or([
            // async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
            {
                alt: ()=>{
                    this.tokenConsumer.Async();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.tokenConsumer.Function();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.LParen();
                    this.FormalParameters({
                        Yield: false,
                        Await: true
                    });
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.AsyncFunctionBody();
                    this.tokenConsumer.RBrace();
                }
            },
            // [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody } - 
            ...Default ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.Async();
                        this.assertNoLineBreak(); // [no LineTerminator here]
                        this.tokenConsumer.Function();
                        this.tokenConsumer.LParen();
                        this.FormalParameters({
                            Yield: false,
                            Await: true
                        });
                        this.tokenConsumer.RParen();
                        this.tokenConsumer.LBrace();
                        this.AsyncFunctionBody();
                        this.tokenConsumer.RBrace();
                    }
                }
            ] : []
        ]);
    }
    /**
     * AsyncFunctionExpression :
     *     async [no LineTerminator here] function BindingIdentifier[~Yield, +Await]_opt ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
     */ AsyncFunctionExpression() {
        this.tokenConsumer.Async();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.tokenConsumer.Function();
        this.Option(()=>this.BindingIdentifier({
                Yield: false,
                Await: true
            }));
        this.tokenConsumer.LParen();
        this.FormalParameters({
            Yield: false,
            Await: true
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.AsyncFunctionBody();
        this.tokenConsumer.RBrace();
        return this.curCst;
    }
    /**
     * AsyncMethod[Yield, Await] :
     *     async [no LineTerminator here] ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
     */ AsyncMethod(params = {}) {
        this.tokenConsumer.Async();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.ClassElementName(params);
        this.tokenConsumer.LParen();
        this.UniqueFormalParameters({
            Yield: false,
            Await: true
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.AsyncFunctionBody();
        this.tokenConsumer.RBrace();
        return this.curCst;
    }
    /**
     * AsyncFunctionBody :
     *     FunctionBody[~Yield, +Await]
     */ AsyncFunctionBody() {
        return this.FunctionBody({
            Yield: false,
            Await: true
        });
    }
    // ============================================
    // Async Generator Functions
    // ============================================
    /**
     * AsyncGeneratorDeclaration[Yield, Await, Default] :
     *     async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
     *     [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
     */ AsyncGeneratorDeclaration(params = {}) {
        const { Default = false } = params;
        return this.Or([
            // async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
            {
                alt: ()=>{
                    this.tokenConsumer.Async();
                    this.assertNoLineBreak(); // [no LineTerminator here]
                    this.tokenConsumer.Function();
                    this.tokenConsumer.Asterisk();
                    this.BindingIdentifier(params);
                    this.tokenConsumer.LParen();
                    this.FormalParameters({
                        Yield: true,
                        Await: true
                    });
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.AsyncGeneratorBody();
                    this.tokenConsumer.RBrace();
                }
            },
            // [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody } - 
            ...Default ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.Async();
                        this.assertNoLineBreak(); // [no LineTerminator here]
                        this.tokenConsumer.Function();
                        this.tokenConsumer.Asterisk();
                        this.tokenConsumer.LParen();
                        this.FormalParameters({
                            Yield: true,
                            Await: true
                        });
                        this.tokenConsumer.RParen();
                        this.tokenConsumer.LBrace();
                        this.AsyncGeneratorBody();
                        this.tokenConsumer.RBrace();
                    }
                }
            ] : []
        ]);
    }
    /**
     * AsyncGeneratorExpression :
     *     async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await]_opt ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
     */ AsyncGeneratorExpression() {
        this.tokenConsumer.Async();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.tokenConsumer.Function();
        this.tokenConsumer.Asterisk();
        this.Option(()=>this.BindingIdentifier({
                Yield: true,
                Await: true
            }));
        this.tokenConsumer.LParen();
        this.FormalParameters({
            Yield: true,
            Await: true
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.AsyncGeneratorBody();
        this.tokenConsumer.RBrace();
        return this.curCst;
    }
    /**
     * AsyncGeneratorMethod[Yield, Await] :
     *     async [no LineTerminator here] * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
     */ AsyncGeneratorMethod(params = {}) {
        this.tokenConsumer.Async();
        this.assertNoLineBreak(); // [no LineTerminator here]
        this.tokenConsumer.Asterisk();
        this.ClassElementName(params);
        this.tokenConsumer.LParen();
        this.UniqueFormalParameters({
            Yield: true,
            Await: true
        });
        this.tokenConsumer.RParen();
        this.tokenConsumer.LBrace();
        this.AsyncGeneratorBody();
        this.tokenConsumer.RBrace();
        return this.curCst;
    }
    /**
     * AsyncGeneratorBody :
     *     FunctionBody[+Yield, +Await]
     */ AsyncGeneratorBody() {
        return this.FunctionBody({
            Yield: true,
            Await: true
        });
    }
    // ============================================
    // Method Definitions
    // ============================================
    /**
     * MethodDefinition[Yield, Await] :
     *     ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
     *     GeneratorMethod[?Yield, ?Await]
     *     AsyncMethod[?Yield, ?Await]
     *     AsyncGeneratorMethod[?Yield, ?Await]
     *     get ClassElementName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] }
     *     set ClassElementName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }
     */ MethodDefinition(params = {}) {
        return this.Or([
            // GeneratorMethod[?Yield, ?Await]
            {
                alt: ()=>this.GeneratorMethod(params)
            },
            // AsyncGeneratorMethod[?Yield, ?Await]
            {
                alt: ()=>this.AsyncGeneratorMethod(params)
            },
            // AsyncMethod[?Yield, ?Await]
            {
                alt: ()=>this.AsyncMethod(params)
            },
            // get ClassElementName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.Get();
                    this.ClassElementName(params);
                    this.tokenConsumer.LParen();
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.FunctionBody({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RBrace();
                }
            },
            // set ClassElementName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.Set();
                    this.ClassElementName(params);
                    this.tokenConsumer.LParen();
                    this.PropertySetParameterList();
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.FunctionBody({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RBrace();
                }
            },
            // ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
            {
                alt: ()=>{
                    this.ClassElementName(params);
                    this.tokenConsumer.LParen();
                    this.UniqueFormalParameters({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RParen();
                    this.tokenConsumer.LBrace();
                    this.FunctionBody({
                        Yield: false,
                        Await: false
                    });
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * PropertySetParameterList :
     *     FormalParameter[~Yield, ~Await]
     *
     * ES2025  PropertySetParameterList  FormalParameter
     *  FormalParameters setter 
     * V8SpiderMonkeyBabelAcorn
     * ES2017 setter 
     * set foo(a,) {} 
     */ PropertySetParameterList() {
        this.FormalParameter({
            Yield: false,
            Await: false
        });
        this.Option(()=>this.tokenConsumer.Comma()); // 
        return this.curCst;
    }
    // ============================================
    // Class Definitions
    // ============================================
    /**
     * ClassDeclaration[Yield, Await, Default] :
     *     class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
     *     [+Default] class ClassTail[?Yield, ?Await]
     */ ClassDeclaration(params = {}) {
        const { Default = false } = params;
        return this.Or([
            // class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Class();
                    this.BindingIdentifier(params);
                    this.ClassTail(params);
                }
            },
            // [+Default] class ClassTail[?Yield, ?Await] - 
            ...Default ? [
                {
                    alt: ()=>{
                        this.tokenConsumer.Class();
                        this.ClassTail(params);
                    }
                }
            ] : []
        ]);
    }
    /**
     * ClassExpression[Yield, Await] :
     *     class BindingIdentifier[?Yield, ?Await]_opt ClassTail[?Yield, ?Await]
     */ ClassExpression(params = {}) {
        this.tokenConsumer.Class();
        this.Option(()=>this.BindingIdentifier(params));
        return this.ClassTail(params);
    }
    /**
     * ClassTail[Yield, Await] :
     *     ClassHeritage[?Yield, ?Await]_opt { ClassBody[?Yield, ?Await]_opt }
     */ ClassTail(params = {}) {
        this.Option(()=>this.ClassHeritage(params));
        this.tokenConsumer.LBrace();
        this.Option(()=>this.ClassBody(params));
        return this.tokenConsumer.RBrace();
    }
    /**
     * ClassHeritage[Yield, Await] :
     *     extends LeftHandSideExpression[?Yield, ?Await]
     */ ClassHeritage(params = {}) {
        this.tokenConsumer.Extends();
        return this.LeftHandSideExpression(params);
    }
    /**
     * ClassBody[Yield, Await] :
     *     ClassElementList[?Yield, ?Await]
     */ ClassBody(params = {}) {
        return this.ClassElementList(params);
    }
    /**
     * ClassElementList[Yield, Await] :
     *     ClassElement[?Yield, ?Await]
     *     ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]
     */ ClassElementList(params = {}) {
        this.AtLeastOne(()=>this.ClassElement(params));
        return this.curCst;
    }
    /**
     * ClassElement[Yield, Await] :
     *     MethodDefinition[?Yield, ?Await]
     *     static MethodDefinition[?Yield, ?Await]
     *     FieldDefinition[?Yield, ?Await] ;
     *     static FieldDefinition[?Yield, ?Await] ;
     *     ClassStaticBlock
     *     ;
     *
     *  MethodDefinition  FieldDefinition 
     *  getter/setter  get/set  FieldDefinition
     *  get/set  "get\na"  getter
     */ ClassElement(params = {}) {
        return this.Or([
            // MethodDefinition[?Yield, ?Await]
            {
                alt: ()=>this.MethodDefinition(params)
            },
            // static MethodDefinition[?Yield, ?Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Static();
                    this.MethodDefinition(params);
                }
            },
            // FieldDefinition[?Yield, ?Await] ;
            {
                alt: ()=>{
                    this.FieldDefinition(params);
                    this.SemicolonASI(); //  ASI
                }
            },
            // static FieldDefinition[?Yield, ?Await] ;
            {
                alt: ()=>{
                    this.tokenConsumer.Static();
                    this.FieldDefinition(params);
                    this.SemicolonASI(); //  ASI
                }
            },
            // ClassStaticBlock
            {
                alt: ()=>this.ClassStaticBlock()
            },
            // ;
            {
                alt: ()=>this.tokenConsumer.Semicolon()
            }
        ]);
    }
    /**
     * FieldDefinition[Yield, Await] :
     *     ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
     *
     *  ECMAScript Early Errors
     *  Initializer  await  AwaitExpression
     * 
     *  Initializer  Await  false
     *  await Yield 
     *
     *  ClassElementName ComputedPropertyName Await 
     *  await 
     */ FieldDefinition(params = {}) {
        this.ClassElementName(params);
        // Initializer  await/yield 
        this.Option(()=>this.Initializer({
                ...params,
                In: true,
                Yield: false,
                Await: false
            }));
        return this.curCst;
    }
    /**
     * ClassElementName[Yield, Await] :
     *     PropertyName[?Yield, ?Await]
     *     PrivateIdentifier
     *
     * PrivateIdentifier A.1 Lexical Grammar token
     */ ClassElementName(params = {}) {
        return this.Or([
            {
                alt: ()=>this.PropertyName(params)
            },
            // PrivateIdentifier  token
            {
                alt: ()=>this.tokenConsumer.PrivateIdentifier()
            }
        ]);
    }
    /**
     * ClassStaticBlock :
     *     static { ClassStaticBlockBody }
     */ ClassStaticBlock() {
        this.tokenConsumer.Static();
        this.tokenConsumer.LBrace();
        this.ClassStaticBlockBody();
        return this.tokenConsumer.RBrace();
    }
    /**
     * ClassStaticBlockBody :
     *     ClassStaticBlockStatementList
     */ ClassStaticBlockBody() {
        return this.ClassStaticBlockStatementList();
    }
    /**
     * ClassStaticBlockStatementList :
     *     StatementList[~Yield, +Await, ~Return]_opt
     */ ClassStaticBlockStatementList() {
        this.Option(()=>this.StatementList({
                Yield: false,
                Await: true,
                Return: false
            }));
        return this.curCst;
    }
    // ============================================
    // A.5 Scripts and Modules
    // ============================================
    /**
     * Program - 
     *
     *  sourceType  Script  Module 
     * Hashbang  Acorn/Babel 
     *
     * @param sourceType - 'script' | 'module' 'module'
     */ Program(sourceType = 'module') {
        // Hashbang 
        this.Option(()=>this.tokenConsumer.HashbangComment());
        if (sourceType === 'module') {
            // ModuleBody_opt
            this.Option(()=>this.ModuleBody());
        } else {
            // ScriptBody_opt
            this.Option(()=>this.ScriptBody());
        }
        return this.curCst;
    }
    /**
     * Script :
     *     ScriptBody_opt
     */ Script() {
        // Hashbang 
        this.Option(()=>this.tokenConsumer.HashbangComment());
        // ScriptBody_opt
        this.Option(()=>this.ScriptBody());
        return this.curCst;
    }
    /**
     * ScriptBody :
     *     StatementList[~Yield, ~Await, ~Return]
     */ ScriptBody() {
        return this.StatementList({
            Yield: false,
            Await: false,
            Return: false
        });
    }
    /**
     * Module :
     *     ModuleBody_opt
     */ Module() {
        // Hashbang 
        this.Option(()=>this.tokenConsumer.HashbangComment());
        // ModuleBody_opt
        this.Option(()=>this.ModuleBody());
        return this.curCst;
    }
    /**
     * ModuleBody :
     *     ModuleItemList
     */ ModuleBody() {
        return this.ModuleItemList();
    }
    /**
     * ModuleItemList :
     *     ModuleItem
     *     ModuleItemList ModuleItem
     */ ModuleItemList() {
        // 
        if (this.errorRecoveryMode) {
            this.ManyWithRecovery(()=>this.ModuleItem());
        } else {
            this.Many(()=>this.ModuleItem());
        }
        return this.curCst;
    }
    /**
     * ModuleItem :
     *     ImportDeclaration
     *     ExportDeclaration
     *     StatementListItem[~Yield, +Await, ~Return]
     */ ModuleItem() {
        return this.Or([
            {
                alt: ()=>this.ImportDeclaration()
            },
            {
                alt: ()=>this.ExportDeclaration()
            },
            {
                alt: ()=>this.StatementListItem({
                        Yield: false,
                        Await: true,
                        Return: false
                    })
            }
        ]);
    }
    // ============================================
    // A.5.3 Imports
    // ============================================
    /**
     * ImportDeclaration :
     *     import ImportClause FromClause WithClause_opt ;
     *     import ModuleSpecifier WithClause_opt ;
     */ ImportDeclaration() {
        return this.Or([
            // import ImportClause FromClause WithClause_opt ;
            {
                alt: ()=>{
                    this.tokenConsumer.Import();
                    this.ImportClause();
                    this.FromClause();
                    this.Option(()=>this.WithClause());
                    this.SemicolonASI();
                }
            },
            // import ModuleSpecifier WithClause_opt ;
            {
                alt: ()=>{
                    this.tokenConsumer.Import();
                    this.ModuleSpecifier();
                    this.Option(()=>this.WithClause());
                    this.SemicolonASI();
                }
            }
        ]);
    }
    /**
     * ImportClause :
     *     ImportedDefaultBinding
     *     NameSpaceImport
     *     NamedImports
     *     ImportedDefaultBinding , NameSpaceImport
     *     ImportedDefaultBinding , NamedImports
     */ ImportClause() {
        return this.Or([
            // ImportedDefaultBinding , NameSpaceImport
            {
                alt: ()=>{
                    this.ImportedDefaultBinding();
                    this.tokenConsumer.Comma();
                    this.NameSpaceImport();
                }
            },
            // ImportedDefaultBinding , NamedImports
            {
                alt: ()=>{
                    this.ImportedDefaultBinding();
                    this.tokenConsumer.Comma();
                    this.NamedImports();
                }
            },
            // ImportedDefaultBinding
            {
                alt: ()=>this.ImportedDefaultBinding()
            },
            // NameSpaceImport
            {
                alt: ()=>this.NameSpaceImport()
            },
            // NamedImports
            {
                alt: ()=>this.NamedImports()
            }
        ]);
    }
    /**
     * ImportedDefaultBinding :
     *     ImportedBinding
     */ ImportedDefaultBinding() {
        return this.ImportedBinding();
    }
    /**
     * NameSpaceImport :
     *     * as ImportedBinding
     */ NameSpaceImport() {
        this.tokenConsumer.Asterisk();
        this.tokenConsumer.As();
        return this.ImportedBinding();
    }
    /**
     * NamedImports :
     *     { }
     *     { ImportsList }
     *     { ImportsList , }
     */ NamedImports() {
        return this.Or([
            // { }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            // { ImportsList , }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.ImportsList();
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.RBrace();
                }
            },
            // { ImportsList }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.ImportsList();
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * FromClause :
     *     from ModuleSpecifier
     */ FromClause() {
        this.tokenConsumer.From();
        return this.ModuleSpecifier();
    }
    /**
     * ImportsList :
     *     ImportSpecifier
     *     ImportsList , ImportSpecifier
     */ ImportsList() {
        this.ImportSpecifier();
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.ImportSpecifier();
        });
        return this.curCst;
    }
    /**
     * ImportSpecifier :
     *     ImportedBinding
     *     ModuleExportName as ImportedBinding
     */ ImportSpecifier() {
        return this.Or([
            // ModuleExportName as ImportedBinding
            {
                alt: ()=>{
                    this.ModuleExportName();
                    this.tokenConsumer.As();
                    this.ImportedBinding();
                }
            },
            // ImportedBinding
            {
                alt: ()=>this.ImportedBinding()
            }
        ]);
    }
    /**
     * ModuleSpecifier :
     *     StringLiteral
     *
     * StringLiteral A.1 Lexical Grammar token
     */ ModuleSpecifier() {
        return this.tokenConsumer.StringLiteral();
    }
    /**
     * ImportedBinding :
     *     BindingIdentifier[~Yield, +Await]
     */ ImportedBinding() {
        return this.BindingIdentifier({
            Yield: false,
            Await: true
        });
    }
    /**
     * WithClause :
     *     with { }
     *     with { WithEntries ,_opt }
     */ WithClause() {
        return this.Or([
            // with { }
            {
                alt: ()=>{
                    this.tokenConsumer.With();
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            // with { WithEntries ,_opt }
            {
                alt: ()=>{
                    this.tokenConsumer.With();
                    this.tokenConsumer.LBrace();
                    this.WithEntries();
                    this.Option(()=>this.tokenConsumer.Comma());
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * WithEntries :
     *     AttributeKey : StringLiteral
     *     AttributeKey : StringLiteral , WithEntries
     *
     * StringLiteral A.1 Lexical Grammar token
     */ WithEntries() {
        this.AttributeKey();
        this.tokenConsumer.Colon();
        // StringLiteral  token
        this.tokenConsumer.StringLiteral();
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.AttributeKey();
            this.tokenConsumer.Colon();
            // StringLiteral  token
            this.tokenConsumer.StringLiteral();
        });
        return this.curCst;
    }
    /**
     * AttributeKey :
     *     IdentifierName
     *     StringLiteral
     *
     * StringLiteral A.1 Lexical Grammar token
     */ AttributeKey() {
        return this.Or([
            {
                alt: ()=>this.IdentifierName()
            },
            // StringLiteral  token
            {
                alt: ()=>this.tokenConsumer.StringLiteral()
            }
        ]);
    }
    // ============================================
    // A.5.4 Exports
    // ============================================
    /**
     * ExportDeclaration :
     *     export ExportFromClause FromClause WithClause_opt ;
     *     export NamedExports ;
     *     export VariableStatement[~Yield, +Await]
     *     export Declaration[~Yield, +Await]
     *     export default HoistableDeclaration[~Yield, +Await, +Default]
     *     export default ClassDeclaration[~Yield, +Await, +Default]
     *     export default [lookahead  {function, async [no LineTerminator here] function, class}] AssignmentExpression[+In, ~Yield, +Await] ;
     */ ExportDeclaration() {
        return this.Or([
            // export ExportFromClause FromClause WithClause_opt ;
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.ExportFromClause();
                    this.FromClause();
                    this.Option(()=>this.WithClause());
                    this.SemicolonASI();
                }
            },
            // export NamedExports ;
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.NamedExports();
                    this.SemicolonASI();
                }
            },
            // export VariableStatement[~Yield, +Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.VariableStatement({
                        Yield: false,
                        Await: true
                    });
                }
            },
            // export Declaration[~Yield, +Await]
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.Declaration({
                        Yield: false,
                        Await: true
                    });
                }
            },
            // export default HoistableDeclaration[~Yield, +Await, +Default]
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.tokenConsumer.Default();
                    this.HoistableDeclaration({
                        Yield: false,
                        Await: true,
                        Default: true
                    });
                }
            },
            // export default ClassDeclaration[~Yield, +Await, +Default]
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.tokenConsumer.Default();
                    this.ClassDeclaration({
                        Yield: false,
                        Await: true,
                        Default: true
                    });
                }
            },
            // export default [lookahead  {function, async [no LineTerminator here] function, class}] AssignmentExpression[+In, ~Yield, +Await] ;
            {
                alt: ()=>{
                    this.tokenConsumer.Export();
                    this.tokenConsumer.Default();
                    // [lookahead  {function, async [no LineTerminator here] function, class}]
                    this.assertLookaheadNotIn([
                        SlimeTokenType.Function,
                        SlimeTokenType.Class
                    ]);
                    this.assertNotContextualSequenceNoLT(SlimeContextualKeywordTokenTypes.Async, SlimeTokenType.Function);
                    this.AssignmentExpression({
                        In: true,
                        Yield: false,
                        Await: true
                    });
                    this.SemicolonASI();
                }
            }
        ]);
    }
    /**
     * ExportFromClause :
     *     *
     *     * as ModuleExportName
     *     NamedExports
     */ ExportFromClause() {
        return this.Or([
            // * as ModuleExportName
            {
                alt: ()=>{
                    this.tokenConsumer.Asterisk();
                    this.tokenConsumer.As();
                    this.ModuleExportName();
                }
            },
            // *
            {
                alt: ()=>this.tokenConsumer.Asterisk()
            },
            // NamedExports
            {
                alt: ()=>this.NamedExports()
            }
        ]);
    }
    /**
     * NamedExports :
     *     { }
     *     { ExportsList }
     *     { ExportsList , }
     */ NamedExports() {
        return this.Or([
            // { }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            // { ExportsList , }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.ExportsList();
                    this.tokenConsumer.Comma();
                    this.tokenConsumer.RBrace();
                }
            },
            // { ExportsList }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.ExportsList();
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * ExportsList :
     *     ExportSpecifier
     *     ExportsList , ExportSpecifier
     */ ExportsList() {
        this.ExportSpecifier();
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.ExportSpecifier();
        });
        return this.curCst;
    }
    /**
     * ExportSpecifier :
     *     ModuleExportName
     *     ModuleExportName as ModuleExportName
     */ ExportSpecifier() {
        return this.Or([
            // ModuleExportName as ModuleExportName
            {
                alt: ()=>{
                    this.ModuleExportName();
                    this.tokenConsumer.As();
                    this.ModuleExportName();
                }
            },
            // ModuleExportName
            {
                alt: ()=>this.ModuleExportName()
            }
        ]);
    }
    /**
     * ModuleExportName :
     *     IdentifierName
     *     StringLiteral
     *
     * StringLiteral A.1 Lexical Grammar token
     */ ModuleExportName() {
        return this.Or([
            {
                alt: ()=>this.IdentifierName()
            },
            // StringLiteral  token
            {
                alt: ()=>this.tokenConsumer.StringLiteral()
            }
        ]);
    }
    // ============================================
    // AssignmentPattern (Supplemental Syntax)
    // ============================================
    /**
     * AssignmentPattern[Yield, Await] :
     *     ObjectAssignmentPattern[?Yield, ?Await]
     *     ArrayAssignmentPattern[?Yield, ?Await]
     */ AssignmentPattern(params = {}) {
        return this.Or([
            {
                alt: ()=>this.ObjectAssignmentPattern(params)
            },
            {
                alt: ()=>this.ArrayAssignmentPattern(params)
            }
        ]);
    }
    /**
     * ObjectAssignmentPattern[Yield, Await] :
     *     { }
     *     { AssignmentRestProperty[?Yield, ?Await] }
     *     { AssignmentPropertyList[?Yield, ?Await] }
     *     { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]_opt }
     */ ObjectAssignmentPattern(params = {}) {
        return this.Or([
            // { }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.tokenConsumer.RBrace();
                }
            },
            // { AssignmentRestProperty[?Yield, ?Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.AssignmentRestProperty(params);
                    this.tokenConsumer.RBrace();
                }
            },
            // { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]_opt }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.AssignmentPropertyList(params);
                    this.tokenConsumer.Comma();
                    this.Option(()=>this.AssignmentRestProperty(params));
                    this.tokenConsumer.RBrace();
                }
            },
            // { AssignmentPropertyList[?Yield, ?Await] }
            {
                alt: ()=>{
                    this.tokenConsumer.LBrace();
                    this.AssignmentPropertyList(params);
                    this.tokenConsumer.RBrace();
                }
            }
        ]);
    }
    /**
     * ArrayAssignmentPattern[Yield, Await] :
     *     [ Elision_opt AssignmentRestElement[?Yield, ?Await]_opt ]
     *     [ AssignmentElementList[?Yield, ?Await] ]
     *     [ AssignmentElementList[?Yield, ?Await] , Elision_opt AssignmentRestElement[?Yield, ?Await]_opt ]
     */ ArrayAssignmentPattern(params = {}) {
        return this.Or([
            // [ Elision_opt AssignmentRestElement[?Yield, ?Await]_opt ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.Option(()=>this.Elision());
                    this.Option(()=>this.AssignmentRestElement(params));
                    this.tokenConsumer.RBracket();
                }
            },
            // [ AssignmentElementList[?Yield, ?Await] , Elision_opt AssignmentRestElement[?Yield, ?Await]_opt ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.AssignmentElementList(params);
                    this.tokenConsumer.Comma();
                    this.Option(()=>this.Elision());
                    this.Option(()=>this.AssignmentRestElement(params));
                    this.tokenConsumer.RBracket();
                }
            },
            // [ AssignmentElementList[?Yield, ?Await] ]
            {
                alt: ()=>{
                    this.tokenConsumer.LBracket();
                    this.AssignmentElementList(params);
                    this.tokenConsumer.RBracket();
                }
            }
        ]);
    }
    /**
     * AssignmentRestProperty[Yield, Await] :
     *     ... DestructuringAssignmentTarget[?Yield, ?Await]
     */ AssignmentRestProperty(params = {}) {
        this.tokenConsumer.Ellipsis();
        return this.DestructuringAssignmentTarget(params);
    }
    /**
     * AssignmentPropertyList[Yield, Await] :
     *     AssignmentProperty[?Yield, ?Await]
     *     AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]
     */ AssignmentPropertyList(params = {}) {
        this.AssignmentProperty(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.AssignmentProperty(params);
        });
        return this.curCst;
    }
    /**
     * AssignmentElementList[Yield, Await] :
     *     AssignmentElisionElement[?Yield, ?Await]
     *     AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]
     */ AssignmentElementList(params = {}) {
        this.AssignmentElisionElement(params);
        this.Many(()=>{
            this.tokenConsumer.Comma();
            this.AssignmentElisionElement(params);
        });
        return this.curCst;
    }
    /**
     * AssignmentElisionElement[Yield, Await] :
     *     Elision_opt AssignmentElement[?Yield, ?Await]
     */ AssignmentElisionElement(params = {}) {
        this.Option(()=>this.Elision());
        return this.AssignmentElement(params);
    }
    /**
     * AssignmentProperty[Yield, Await] :
     *     IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
     *     PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]
     */ AssignmentProperty(params = {}) {
        return this.Or([
            // PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]
            {
                alt: ()=>{
                    this.PropertyName(params);
                    this.tokenConsumer.Colon();
                    this.AssignmentElement(params);
                }
            },
            // IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
            {
                alt: ()=>{
                    this.IdentifierReference(params);
                    this.Option(()=>this.Initializer({
                            ...params,
                            In: true
                        }));
                }
            }
        ]);
    }
    /**
     * AssignmentElement[Yield, Await] :
     *     DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]_opt
     */ AssignmentElement(params = {}) {
        this.DestructuringAssignmentTarget(params);
        this.Option(()=>this.Initializer({
                ...params,
                In: true
            }));
        return this.curCst;
    }
    /**
     * AssignmentRestElement[Yield, Await] :
     *     ... DestructuringAssignmentTarget[?Yield, ?Await]
     */ AssignmentRestElement(params = {}) {
        this.tokenConsumer.Ellipsis();
        return this.DestructuringAssignmentTarget(params);
    }
    /**
     * DestructuringAssignmentTarget[Yield, Await] :
     *     LeftHandSideExpression[?Yield, ?Await]
     */ DestructuringAssignmentTarget(params = {}) {
        return this.LeftHandSideExpression(params);
    }
    /**
     * 
     * @param sourceCode 
     * @param options  tokenConsumer  tokenDefinitions
     */ constructor(sourceCode = '', options){
        // On-Demand Lexing
        // Parser  token  Lexer InputElementDiv  InputElementRegExp
        const defaultTokenConsumer = SlimeTokenConsumer;
        super(sourceCode, {
            tokenConsumer: options?.tokenConsumer ?? defaultTokenConsumer,
            tokenDefinitions: options?.tokenDefinitions ?? slimeTokens
        }), _initProto$1(this);
    }
} /**
 * === ES2025 Parser  ===
 *
 *  Parser  ECMAScript 2025 https://tc39.es/ecma262/2025/#sec-grammar-summary
 *
 *  
 *
 * A.2 Expressions
 * - IdentifierReferenceBindingIdentifierLabelIdentifier
 * - PrimaryExpressionthisLiteralArrayLiteralObjectLiteral 
 * - TemplateLiteral
 * - MemberExpressionNewExpressionCallExpression
 * - OptionalExpression
 * - UpdateExpressionUnaryExpression
 * - 
 * - ConditionalExpression
 * - AssignmentExpression
 * - YieldExpressionArrowFunctionAsyncArrowFunction
 * - Expression
 *
 * A.3 Statements
 * - BlockStatementVariableStatementEmptyStatement
 * - ExpressionStatementIfStatement
 * - IterationStatementDoWhileWhileForForInOf
 * - ContinueStatementBreakStatementReturnStatement
 * - WithStatementSwitchStatementLabelledStatement
 * - ThrowStatementTryStatementDebuggerStatement
 * - LexicalDeclarationVariableDeclaration
 * - BindingPattern
 *
 * A.4 Functions and Classes
 * - FormalParametersUniqueFormalParameters
 * - FunctionBodyFunctionExpressionFunctionDeclaration
 * - GeneratorExpressionGeneratorDeclarationGeneratorBody
 * - AsyncFunctionExpressionAsyncFunctionDeclarationAsyncFunctionBody
 * - AsyncGeneratorExpressionAsyncGeneratorDeclarationAsyncGeneratorBody
 * - ArrowFunctionAsyncArrowFunction
 * - MethodDefinitionGeneratorAsyncAsyncGeneratorgettersetter
 * - ClassExpressionClassDeclarationClassTailClassBody
 * - ClassElementFieldDefinitionClassStaticBlock
 *
 * A.5 Scripts and Modules
 * - ScriptModuleModuleItem
 * - ImportDeclarationImportClauseNameSpaceImportNamedImports
 * - ExportDeclarationExportFromClauseNamedExports
 * - WithClauseImport Assertions
 *
 * Supplemental Syntax
 * - AssignmentPatternObjectAssignmentPatternArrayAssignmentPattern
 * - AssignmentPropertyAssignmentElementDestructuringAssignmentTarget
 *
 *  
 * 1.  [Yield, Await, In, Return, Default, Tagged]
 * 2.  [lookahead =, , , ] 
 * 3.  [no LineTerminator here] 
 * 4. Cover Grammar CoverParenthesizedExpressionCoverCallExpression 
 *
 *  
 * 1.  ES2025 
 * 2.  SubhutiParser  PEG Or, Many, Option, AtLeastOne
 * 3.  TokenConsumer 
 * 4.  SubhutiTokenLookahead 
 * 5.  JavaScript async/awaitclassmoduleoptional chaining 
 *
 *  
 * - 
 * - 
 * -  @SubhutiRule 
 * - 
 *
 * @version 2.0.0 - 
 * @specification ECMAScript 2025 Language Specification
 * @url https://tc39.es/ecma262/2025/#sec-grammar-summary
 */ 
({ e: [_initProto$1], c: [_SlimeParser$1, _initClass$1] } = _apply_decs_2203_r$1(SlimeParser, [
    [
        SubhutiRule,
        2,
        "IdentifierReference"
    ],
    [
        SubhutiRule,
        2,
        "BindingIdentifier"
    ],
    [
        SubhutiRule,
        2,
        "LabelIdentifier"
    ],
    [
        SubhutiRule,
        2,
        "Identifier"
    ],
    [
        SubhutiRule,
        2,
        "IdentifierName"
    ],
    [
        SubhutiRule,
        2,
        "PrimaryExpression"
    ],
    [
        SubhutiRule,
        2,
        "CoverParenthesizedExpressionAndArrowParameterList"
    ],
    [
        SubhutiRule,
        2,
        "ParenthesizedExpression"
    ],
    [
        SubhutiRule,
        2,
        "Literal"
    ],
    [
        SubhutiRule,
        2,
        "BooleanLiteral"
    ],
    [
        SubhutiRule,
        2,
        "ArrayLiteral"
    ],
    [
        SubhutiRule,
        2,
        "ElementList"
    ],
    [
        SubhutiRule,
        2,
        "Elision"
    ],
    [
        SubhutiRule,
        2,
        "SpreadElement"
    ],
    [
        SubhutiRule,
        2,
        "ObjectLiteral"
    ],
    [
        SubhutiRule,
        2,
        "PropertyDefinitionList"
    ],
    [
        SubhutiRule,
        2,
        "PropertyDefinition"
    ],
    [
        SubhutiRule,
        2,
        "PropertyName"
    ],
    [
        SubhutiRule,
        2,
        "LiteralPropertyName"
    ],
    [
        SubhutiRule,
        2,
        "ComputedPropertyName"
    ],
    [
        SubhutiRule,
        2,
        "CoverInitializedName"
    ],
    [
        SubhutiRule,
        2,
        "Initializer"
    ],
    [
        SubhutiRule,
        2,
        "TemplateLiteral"
    ],
    [
        SubhutiRule,
        2,
        "SubstitutionTemplate"
    ],
    [
        SubhutiRule,
        2,
        "TemplateSpans"
    ],
    [
        SubhutiRule,
        2,
        "TemplateMiddleList"
    ],
    [
        SubhutiRule,
        2,
        "MemberExpression"
    ],
    [
        SubhutiRule,
        2,
        "SuperProperty"
    ],
    [
        SubhutiRule,
        2,
        "MetaProperty"
    ],
    [
        SubhutiRule,
        2,
        "NewTarget"
    ],
    [
        SubhutiRule,
        2,
        "ImportMeta"
    ],
    [
        SubhutiRule,
        2,
        "NewExpression"
    ],
    [
        SubhutiRule,
        2,
        "CallExpression"
    ],
    [
        SubhutiRule,
        2,
        "CoverCallExpressionAndAsyncArrowHead"
    ],
    [
        SubhutiRule,
        2,
        "CallMemberExpression"
    ],
    [
        SubhutiRule,
        2,
        "SuperCall"
    ],
    [
        SubhutiRule,
        2,
        "ImportCall"
    ],
    [
        SubhutiRule,
        2,
        "Arguments"
    ],
    [
        SubhutiRule,
        2,
        "ArgumentList"
    ],
    [
        SubhutiRule,
        2,
        "OptionalExpression"
    ],
    [
        SubhutiRule,
        2,
        "OptionalChain"
    ],
    [
        SubhutiRule,
        2,
        "LeftHandSideExpression"
    ],
    [
        SubhutiRule,
        2,
        "UpdateExpression"
    ],
    [
        SubhutiRule,
        2,
        "UnaryExpression"
    ],
    [
        SubhutiRule,
        2,
        "AwaitExpression"
    ],
    [
        SubhutiRule,
        2,
        "ExponentiationExpression"
    ],
    [
        SubhutiRule,
        2,
        "MultiplicativeExpression"
    ],
    [
        SubhutiRule,
        2,
        "MultiplicativeOperator"
    ],
    [
        SubhutiRule,
        2,
        "AdditiveExpression"
    ],
    [
        SubhutiRule,
        2,
        "ShiftExpression"
    ],
    [
        SubhutiRule,
        2,
        "RelationalExpression"
    ],
    [
        SubhutiRule,
        2,
        "EqualityExpression"
    ],
    [
        SubhutiRule,
        2,
        "BitwiseANDExpression"
    ],
    [
        SubhutiRule,
        2,
        "BitwiseXORExpression"
    ],
    [
        SubhutiRule,
        2,
        "BitwiseORExpression"
    ],
    [
        SubhutiRule,
        2,
        "LogicalANDExpression"
    ],
    [
        SubhutiRule,
        2,
        "LogicalORExpression"
    ],
    [
        SubhutiRule,
        2,
        "LogicalORExpressionTail"
    ],
    [
        SubhutiRule,
        2,
        "CoalesceExpression"
    ],
    [
        SubhutiRule,
        2,
        "CoalesceExpressionTail"
    ],
    [
        SubhutiRule,
        2,
        "CoalesceExpressionHead"
    ],
    [
        SubhutiRule,
        2,
        "ShortCircuitExpression"
    ],
    [
        SubhutiRule,
        2,
        "ShortCircuitExpressionTail"
    ],
    [
        SubhutiRule,
        2,
        "ConditionalExpression"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentExpression"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentOperator"
    ],
    [
        SubhutiRule,
        2,
        "Expression"
    ],
    [
        SubhutiRule,
        2,
        "Statement"
    ],
    [
        SubhutiRule,
        2,
        "Declaration"
    ],
    [
        SubhutiRule,
        2,
        "HoistableDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "BreakableStatement"
    ],
    [
        SubhutiRule,
        2,
        "BlockStatement"
    ],
    [
        SubhutiRule,
        2,
        "Block"
    ],
    [
        SubhutiRule,
        2,
        "StatementList"
    ],
    [
        SubhutiRule,
        2,
        "StatementListItem"
    ],
    [
        SubhutiRule,
        2,
        "LexicalDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "LetOrConst"
    ],
    [
        SubhutiRule,
        2,
        "BindingList"
    ],
    [
        SubhutiRule,
        2,
        "LexicalBinding"
    ],
    [
        SubhutiRule,
        2,
        "VariableStatement"
    ],
    [
        SubhutiRule,
        2,
        "VariableDeclarationList"
    ],
    [
        SubhutiRule,
        2,
        "VariableDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "BindingPattern"
    ],
    [
        SubhutiRule,
        2,
        "ObjectBindingPattern"
    ],
    [
        SubhutiRule,
        2,
        "ArrayBindingPattern"
    ],
    [
        SubhutiRule,
        2,
        "BindingRestProperty"
    ],
    [
        SubhutiRule,
        2,
        "BindingPropertyList"
    ],
    [
        SubhutiRule,
        2,
        "BindingElementList"
    ],
    [
        SubhutiRule,
        2,
        "BindingElisionElement"
    ],
    [
        SubhutiRule,
        2,
        "BindingProperty"
    ],
    [
        SubhutiRule,
        2,
        "BindingElement"
    ],
    [
        SubhutiRule,
        2,
        "SingleNameBinding"
    ],
    [
        SubhutiRule,
        2,
        "BindingRestElement"
    ],
    [
        SubhutiRule,
        2,
        "SemicolonASI"
    ],
    [
        SubhutiRule,
        2,
        "EmptyStatement"
    ],
    [
        SubhutiRule,
        2,
        "ExpressionStatement"
    ],
    [
        SubhutiRule,
        2,
        "IfStatement"
    ],
    [
        SubhutiRule,
        2,
        "IfStatementBody"
    ],
    [
        SubhutiRule,
        2,
        "IterationStatement"
    ],
    [
        SubhutiRule,
        2,
        "DoWhileStatement"
    ],
    [
        SubhutiRule,
        2,
        "WhileStatement"
    ],
    [
        SubhutiRule,
        2,
        "ForStatement"
    ],
    [
        SubhutiRule,
        2,
        "ForInOfStatement"
    ],
    [
        SubhutiRule,
        2,
        "ForDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "ForBinding"
    ],
    [
        SubhutiRule,
        2,
        "ContinueStatement"
    ],
    [
        SubhutiRule,
        2,
        "BreakStatement"
    ],
    [
        SubhutiRule,
        2,
        "ReturnStatement"
    ],
    [
        SubhutiRule,
        2,
        "WithStatement"
    ],
    [
        SubhutiRule,
        2,
        "SwitchStatement"
    ],
    [
        SubhutiRule,
        2,
        "CaseBlock"
    ],
    [
        SubhutiRule,
        2,
        "CaseClauses"
    ],
    [
        SubhutiRule,
        2,
        "CaseClause"
    ],
    [
        SubhutiRule,
        2,
        "DefaultClause"
    ],
    [
        SubhutiRule,
        2,
        "LabelledStatement"
    ],
    [
        SubhutiRule,
        2,
        "LabelledItem"
    ],
    [
        SubhutiRule,
        2,
        "ThrowStatement"
    ],
    [
        SubhutiRule,
        2,
        "TryStatement"
    ],
    [
        SubhutiRule,
        2,
        "Catch"
    ],
    [
        SubhutiRule,
        2,
        "Finally"
    ],
    [
        SubhutiRule,
        2,
        "CatchParameter"
    ],
    [
        SubhutiRule,
        2,
        "DebuggerStatement"
    ],
    [
        SubhutiRule,
        2,
        "YieldExpression"
    ],
    [
        SubhutiRule,
        2,
        "ArrowFunction"
    ],
    [
        SubhutiRule,
        2,
        "ArrowParameters"
    ],
    [
        SubhutiRule,
        2,
        "ArrowFormalParameters"
    ],
    [
        SubhutiRule,
        2,
        "ConciseBody"
    ],
    [
        SubhutiRule,
        2,
        "ExpressionBody"
    ],
    [
        SubhutiRule,
        2,
        "AsyncArrowFunction"
    ],
    [
        SubhutiRule,
        2,
        "AsyncArrowBindingIdentifier"
    ],
    [
        SubhutiRule,
        2,
        "AsyncConciseBody"
    ],
    [
        SubhutiRule,
        2,
        "AsyncArrowHead"
    ],
    [
        SubhutiRule,
        2,
        "UniqueFormalParameters"
    ],
    [
        SubhutiRule,
        2,
        "FormalParameters"
    ],
    [
        SubhutiRule,
        2,
        "FormalParameterList"
    ],
    [
        SubhutiRule,
        2,
        "FunctionRestParameter"
    ],
    [
        SubhutiRule,
        2,
        "FormalParameter"
    ],
    [
        SubhutiRule,
        2,
        "FunctionBody"
    ],
    [
        SubhutiRule,
        2,
        "FunctionStatementList"
    ],
    [
        SubhutiRule,
        2,
        "FunctionExpression"
    ],
    [
        SubhutiRule,
        2,
        "FunctionDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "GeneratorDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "GeneratorExpression"
    ],
    [
        SubhutiRule,
        2,
        "GeneratorMethod"
    ],
    [
        SubhutiRule,
        2,
        "GeneratorBody"
    ],
    [
        SubhutiRule,
        2,
        "AsyncFunctionDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "AsyncFunctionExpression"
    ],
    [
        SubhutiRule,
        2,
        "AsyncMethod"
    ],
    [
        SubhutiRule,
        2,
        "AsyncFunctionBody"
    ],
    [
        SubhutiRule,
        2,
        "AsyncGeneratorDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "AsyncGeneratorExpression"
    ],
    [
        SubhutiRule,
        2,
        "AsyncGeneratorMethod"
    ],
    [
        SubhutiRule,
        2,
        "AsyncGeneratorBody"
    ],
    [
        SubhutiRule,
        2,
        "MethodDefinition"
    ],
    [
        SubhutiRule,
        2,
        "PropertySetParameterList"
    ],
    [
        SubhutiRule,
        2,
        "ClassDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "ClassExpression"
    ],
    [
        SubhutiRule,
        2,
        "ClassTail"
    ],
    [
        SubhutiRule,
        2,
        "ClassHeritage"
    ],
    [
        SubhutiRule,
        2,
        "ClassBody"
    ],
    [
        SubhutiRule,
        2,
        "ClassElementList"
    ],
    [
        SubhutiRule,
        2,
        "ClassElement"
    ],
    [
        SubhutiRule,
        2,
        "FieldDefinition"
    ],
    [
        SubhutiRule,
        2,
        "ClassElementName"
    ],
    [
        SubhutiRule,
        2,
        "ClassStaticBlock"
    ],
    [
        SubhutiRule,
        2,
        "ClassStaticBlockBody"
    ],
    [
        SubhutiRule,
        2,
        "ClassStaticBlockStatementList"
    ],
    [
        SubhutiRule,
        2,
        "Program"
    ],
    [
        SubhutiRule,
        2,
        "Script"
    ],
    [
        SubhutiRule,
        2,
        "ScriptBody"
    ],
    [
        SubhutiRule,
        2,
        "Module"
    ],
    [
        SubhutiRule,
        2,
        "ModuleBody"
    ],
    [
        SubhutiRule,
        2,
        "ModuleItemList"
    ],
    [
        SubhutiRule,
        2,
        "ModuleItem"
    ],
    [
        SubhutiRule,
        2,
        "ImportDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "ImportClause"
    ],
    [
        SubhutiRule,
        2,
        "ImportedDefaultBinding"
    ],
    [
        SubhutiRule,
        2,
        "NameSpaceImport"
    ],
    [
        SubhutiRule,
        2,
        "NamedImports"
    ],
    [
        SubhutiRule,
        2,
        "FromClause"
    ],
    [
        SubhutiRule,
        2,
        "ImportsList"
    ],
    [
        SubhutiRule,
        2,
        "ImportSpecifier"
    ],
    [
        SubhutiRule,
        2,
        "ModuleSpecifier"
    ],
    [
        SubhutiRule,
        2,
        "ImportedBinding"
    ],
    [
        SubhutiRule,
        2,
        "WithClause"
    ],
    [
        SubhutiRule,
        2,
        "WithEntries"
    ],
    [
        SubhutiRule,
        2,
        "AttributeKey"
    ],
    [
        SubhutiRule,
        2,
        "ExportDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "ExportFromClause"
    ],
    [
        SubhutiRule,
        2,
        "NamedExports"
    ],
    [
        SubhutiRule,
        2,
        "ExportsList"
    ],
    [
        SubhutiRule,
        2,
        "ExportSpecifier"
    ],
    [
        SubhutiRule,
        2,
        "ModuleExportName"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentPattern"
    ],
    [
        SubhutiRule,
        2,
        "ObjectAssignmentPattern"
    ],
    [
        SubhutiRule,
        2,
        "ArrayAssignmentPattern"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentRestProperty"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentPropertyList"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentElementList"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentElisionElement"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentProperty"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentElement"
    ],
    [
        SubhutiRule,
        2,
        "AssignmentRestElement"
    ],
    [
        SubhutiRule,
        2,
        "DestructuringAssignmentTarget"
    ]
], [
    Subhuti
], _SubhutiParser));
_initClass$1();

function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initClass, _SlimeParser, _initProto;
/**
 * OVS 
 *  JavaScript  + 
 *  OvsRenderFunction 
 */ const OVS_TAG_BLACKLIST = new Set([
    ...ReservedWords,
    ...Object.values(SlimeContextualKeywordTokenTypes)
]);
let _OvsParser;
class OvsParser extends (_SlimeParser = _SlimeParser$1) {
    /**
     * OvsRenderFunction - OVS 
     * : IdentifierReference [no LineTerminator here] Arguments? { StatementList? }
     *
     * 
     * 1.  JavaScript  + 
     * 2.  { 
     *
     * 
     * -  IdentifierReference  params
     * -  async await 
     * -  async await 
     */ OvsRenderFunction(params = {}) {
        //  IdentifierReference  params
        const idRef = this.IdentifierReference(params);
        //  1 JavaScript 
        const tagName = idRef?.children?.[0]?.children?.[0]?.value;
        this.assertCondition(!OVS_TAG_BLACKLIST.has(tagName));
        this.Option(()=>{
            //   params
            //  ES  Arguments[?Yield, ?Await] Yield/Await 
            //  async  await
            this.Arguments(params);
        });
        //  2 {  [no LineTerminator here]
        this.assertNoLineBreak();
        this.tokenConsumer.LBrace();
        this.Option(()=>{
            //   params
            // OvsRenderFunction  body  FunctionBody Yield/Await 
            //  async  await generator  yield
            this.StatementList(params);
        });
        this.tokenConsumer.RBrace();
        return this.curCst;
    }
    /**
     * ClassHeritage -  OvsRenderFunction
     *
     *  `class A extends B {}` `B {}`  OvsRenderFunction
     *  DisableOvsRender: true 
     */ ClassHeritage(params = {}) {
        this.tokenConsumer.Extends();
        return this.LeftHandSideExpression({
            ...params,
            DisableOvsRender: true
        });
    }
    /**
     * OvsViewDeclaration - OVS 
     * : ovsView Identifier (params)? : OvsRenderFunction
     *
     *  
     *  ES  FunctionDeclaration Yield/Await 
     * 
     * - FunctionDeclaration  FunctionBody[~Yield, ~Await]
     * - AsyncFunctionDeclaration  AsyncFunctionBody ( FunctionBody[~Yield, +Await])
     *
     * OvsViewDeclaration  OvsRenderFunction 
     *  {Yield: false, Await: false}
     *  async  async ovsView 
     */ OvsViewDeclaration() {
        // ovsView + ovsRenderDomClassDeclaration + OvsRenderDomViewDeclaration
        this.tokenConsumer.OvsViewToken();
        this.OvsRenderDomClassDeclaration(); // Identifier, FunctionFormalParameters?, Colon
        //   {Yield: false, Await: false} 
        // OvsViewDeclaration  FunctionDeclaration async/generator 
        this.OvsRenderFunction({
            Yield: false,
            Await: false
        });
    }
    /**
     * ovsView 
     * : ComponentName(params)?:
     *
     *  ArrowFormalParameters() 
     *  ES  ArrowFormalParameters[Yield, Await]
     * OvsViewDeclaration  async/generator 
     * FunctionDeclaration  FormalParameters[~Yield, ~Await]
     */ OvsRenderDomClassDeclaration() {
        this.tokenConsumer.IdentifierName();
        this.Option(()=>{
            //  ArrowFormalParameters  FormalParameters
            //  ovsView MyCard(state): div {} 
            //   {Yield: false, Await: false} 
            //  FunctionDeclaration  FormalParameters[~Yield, ~Await]
            this.ArrowFormalParameters({
                Yield: false,
                Await: false
            });
        });
        this.tokenConsumer.Colon();
    }
    /**
     * NoRenderBlock - 
     * : #{ StatementList? }
     *
     *  NoRenderBlock  params
     * NoRenderBlock  Statement  Yield/Await 
     *  async  #{ await something }  await
     */ NoRenderBlock(params = {}) {
        // #{ statements } - 
        this.tokenConsumer.Hash();
        this.tokenConsumer.LBrace();
        this.Option(()=>{
            //   params Yield/Await/Return 
            this.StatementList(params);
        });
        this.tokenConsumer.RBrace();
    }
    /**
     * Statement -  NoRenderBlock 
     *
     * 
     * - NoRenderBlock(params):   params Yield/Await/Return 
     * - EmptyStatement():  
     * - DebuggerStatement():  debugger 
     */ Statement(params = {}) {
        const { Return = false } = params;
        return this.Or([
            {
                alt: ()=>this.NoRenderBlock(params)
            },
            {
                alt: ()=>this.BlockStatement(params)
            },
            {
                alt: ()=>this.VariableStatement(params)
            },
            {
                alt: ()=>this.EmptyStatement()
            },
            {
                alt: ()=>this.ExpressionStatement(params)
            },
            {
                alt: ()=>this.IfStatement(params)
            },
            {
                alt: ()=>this.BreakableStatement(params)
            },
            {
                alt: ()=>this.ContinueStatement(params)
            },
            {
                alt: ()=>this.BreakStatement(params)
            },
            ...Return ? [
                {
                    alt: ()=>this.ReturnStatement(params)
                }
            ] : [],
            {
                alt: ()=>this.WithStatement(params)
            },
            {
                alt: ()=>this.LabelledStatement(params)
            },
            {
                alt: ()=>this.ThrowStatement(params)
            },
            {
                alt: ()=>this.TryStatement(params)
            },
            {
                alt: ()=>this.DebuggerStatement()
            } //  DebuggerStatement 
        ]);
    }
    /**
     * Declaration -  OvsViewDeclaration 
     */ Declaration(params = {}) {
        return this.Or([
            {
                alt: ()=>this.OvsViewDeclaration()
            },
            {
                alt: ()=>this.HoistableDeclaration({
                        ...params,
                        Default: false
                    })
            },
            {
                alt: ()=>this.ClassDeclaration({
                        ...params,
                        Default: false
                    })
            },
            {
                alt: ()=>this.LexicalDeclaration({
                        ...params,
                        In: true
                    })
            }
        ]);
    }
    /**
     * PrimaryExpression -  OvsRenderFunction 
     * OvsRenderFunction  IdentifierReference  IdentifierName 
     *  Or OvsRenderFunction  IdentifierReference
     *
     *  DisableOvsRender  true  OvsRenderFunction 
     *  ClassHeritage  `class A extends B {}`  `B {}` 
     */ PrimaryExpression(params = {}) {
        const { DisableOvsRender = false } = params;
        return this.Or([
            // === 1. ===
            {
                alt: ()=>this.tokenConsumer.This()
            },
            // === 2. async  IdentifierReference ===
            {
                alt: ()=>this.AsyncGeneratorExpression()
            },
            {
                alt: ()=>this.AsyncFunctionExpression()
            },
            // === 3. OvsRenderFunctionOVS  IdentifierReference ===
            //  div { }  IdentifierName  OvsRenderFunction
            //  DisableOvsRender  true 
            //  params  await/yield 
            ...!DisableOvsRender ? [
                {
                    alt: ()=>this.OvsRenderFunction(params)
                }
            ] : [],
            // === 4. ===
            {
                alt: ()=>this.IdentifierReference(params)
            },
            // === 5. null/true/false / token===
            {
                alt: ()=>this.Literal()
            },
            // === 6. function ===
            {
                alt: ()=>this.GeneratorExpression()
            },
            {
                alt: ()=>this.FunctionExpression()
            },
            // === 7. class ===
            {
                alt: ()=>this.ClassExpression(params)
            },
            // === 8.  token===
            {
                alt: ()=>this.ArrayLiteral(params)
            },
            {
                alt: ()=>this.ObjectLiteral(params)
            },
            // RegularExpressionLiteral -  InputElementRegExp 
            {
                alt: ()=>this.consumeRegularExpressionLiteral()
            },
            {
                alt: ()=>this.TemplateLiteral({
                        ...params,
                        Tagged: false
                    })
            },
            {
                alt: ()=>this.CoverParenthesizedExpressionAndArrowParameterList(params)
            }
        ]);
    }
    /**
     *  - 
     * @param sourceCode 
     */ constructor(sourceCode = ''){
        super(sourceCode, {
            tokenConsumer: OvsTokenConsumer,
            tokenDefinitions: ovs6Tokens
        }), _initProto(this);
    }
}
({ e: [_initProto], c: [_OvsParser, _initClass] } = _apply_decs_2203_r(OvsParser, [
    [
        SubhutiRule,
        2,
        "OvsRenderFunction"
    ],
    [
        SubhutiRule,
        2,
        "ClassHeritage"
    ],
    [
        SubhutiRule,
        2,
        "OvsViewDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "OvsRenderDomClassDeclaration"
    ],
    [
        SubhutiRule,
        2,
        "NoRenderBlock"
    ],
    [
        SubhutiRule,
        2,
        "Statement"
    ],
    [
        SubhutiRule,
        2,
        "Declaration"
    ],
    [
        SubhutiRule,
        2,
        "PrimaryExpression"
    ]
], [
    Subhuti
], _SlimeParser));
_initClass();

/** Program source type */ const SlimeProgramSourceType = {
    Script: "script",
    Module: "module"
};

class SlimeNodeCreate {
    // ============================================
    // 
    // ============================================
    commonLocType(node) {
        if (!node.loc) {
            node.loc = {
                value: null,
                type: node.type,
                start: {
                    index: 0,
                    line: 0,
                    column: 0
                },
                end: {
                    index: 0,
                    line: 0,
                    column: 0
                }
            };
        }
        return node;
    }
    // ============================================
    // Program
    // ============================================
    createProgram(body, sourceType = SlimeProgramSourceType.Script) {
        return this.commonLocType({
            type: SlimeNodeType.Program,
            sourceType: sourceType,
            body: body
        });
    }
    // ============================================
    // Expressions
    // ============================================
    createMemberExpression(object, dot, property) {
        return this.commonLocType({
            type: SlimeNodeType.MemberExpression,
            object: object,
            dot: dot,
            property: property,
            computed: false,
            optional: false,
            loc: object.loc
        });
    }
    createArrayExpression(elements, loc, lBracketToken, rBracketToken) {
        return this.commonLocType({
            type: SlimeNodeType.ArrayExpression,
            elements: elements || [],
            lBracketToken: lBracketToken,
            rBracketToken: rBracketToken,
            loc: loc
        });
    }
    /**  */ createArrayElement(element, commaToken) {
        return {
            element,
            commaToken
        };
    }
    createPropertyAst(key, value) {
        return this.commonLocType({
            type: SlimeNodeType.Property,
            key: key,
            value: value,
            kind: "init",
            method: false,
            shorthand: false,
            computed: false
        });
    }
    createObjectExpression(properties = [], loc, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.ObjectExpression,
            properties: properties,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    /**  */ createObjectPropertyItem(property, commaToken) {
        return {
            property,
            commaToken
        };
    }
    createParenthesizedExpression(expression, loc) {
        return this.commonLocType({
            type: SlimeNodeType.ParenthesizedExpression,
            expression: expression,
            loc: loc
        });
    }
    createClassExpression(id, superClass, body, loc) {
        return this.commonLocType({
            type: SlimeNodeType.ClassExpression,
            id: id,
            body: body,
            superClass: superClass,
            loc: loc // 
        });
    }
    createCallExpression(callee, args, loc, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.CallExpression,
            callee: callee,
            arguments: args,
            optional: false,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    /**  */ createCallArgument(argument, commaToken) {
        return {
            argument,
            commaToken
        };
    }
    /**  */ createFunctionParam(param, commaToken) {
        return {
            param,
            commaToken
        };
    }
    createThisExpression(loc) {
        return this.commonLocType({
            type: SlimeNodeType.ThisExpression,
            loc: loc
        });
    }
    createChainExpression(expression, loc) {
        return this.commonLocType({
            type: SlimeNodeType.ChainExpression,
            expression: expression,
            loc: loc
        });
    }
    createSequenceExpression(expressions, loc) {
        return this.commonLocType({
            type: SlimeNodeType.SequenceExpression,
            expressions: expressions,
            loc: loc
        });
    }
    createUnaryExpression(operator, argument, loc) {
        return this.commonLocType({
            type: SlimeNodeType.UnaryExpression,
            operator: operator,
            prefix: true,
            argument: argument,
            loc: loc
        });
    }
    createBinaryExpression(operator, left, right, loc) {
        return this.commonLocType({
            type: SlimeNodeType.BinaryExpression,
            operator: operator,
            left: left,
            right: right,
            loc: loc
        });
    }
    createAssignmentExpression(operator, left, right, loc) {
        return this.commonLocType({
            type: SlimeNodeType.AssignmentExpression,
            operator: operator,
            left: left,
            right: right,
            loc: loc
        });
    }
    createUpdateExpression(operator, argument, prefix, loc) {
        return this.commonLocType({
            type: SlimeNodeType.UpdateExpression,
            operator: operator,
            argument: argument,
            prefix: prefix,
            loc: loc
        });
    }
    createLogicalExpression(operator, left, right, loc) {
        return this.commonLocType({
            type: SlimeNodeType.LogicalExpression,
            operator: operator,
            left: left,
            right: right,
            loc: loc
        });
    }
    createConditionalExpression(test, consequent, alternate, loc, questionToken, colonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ConditionalExpression,
            test: test,
            consequent: consequent,
            alternate: alternate,
            questionToken: questionToken,
            colonToken: colonToken,
            loc: loc
        });
    }
    createNewExpression(callee, args, loc, newToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.NewExpression,
            callee: callee,
            arguments: args,
            newToken: newToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createArrowFunctionExpression(body, params, expression, async = false, loc, arrowToken, asyncToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.ArrowFunctionExpression,
            body: body,
            params: params,
            expression: expression,
            async: async,
            arrowToken: arrowToken,
            asyncToken: asyncToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createYieldExpression(argument, delegate = false, loc, yieldToken, asteriskToken) {
        return this.commonLocType({
            type: SlimeNodeType.YieldExpression,
            argument: argument,
            delegate: delegate,
            yieldToken: yieldToken,
            asteriskToken: asteriskToken,
            loc: loc
        });
    }
    createTaggedTemplateExpression(tag, quasi, loc) {
        return this.commonLocType({
            type: SlimeNodeType.TaggedTemplateExpression,
            tag: tag,
            quasi: quasi,
            loc: loc
        });
    }
    createAwaitExpression(argument, loc, awaitToken) {
        return this.commonLocType({
            type: SlimeNodeType.AwaitExpression,
            argument: argument,
            awaitToken: awaitToken,
            loc: loc
        });
    }
    createMetaProperty(meta, property, loc) {
        return this.commonLocType({
            type: SlimeNodeType.MetaProperty,
            meta: meta,
            property: property,
            loc: loc
        });
    }
    createImportExpression(source, loc, importToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.ImportExpression,
            source: source,
            importToken: importToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createSuper(loc) {
        return this.commonLocType({
            type: SlimeNodeType.Super,
            loc: loc
        });
    }
    createPrivateIdentifier(name, loc) {
        return this.commonLocType({
            type: SlimeNodeType.PrivateIdentifier,
            name: name,
            loc: loc
        });
    }
    // ============================================
    // Statements
    // ============================================
    createBlockStatement(body, loc, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.BlockStatement,
            body: body,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    createEmptyStatement(loc, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.EmptyStatement,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createExpressionStatement(expression, loc, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ExpressionStatement,
            expression: expression,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createIfStatement(test, consequent, alternate, loc, ifToken, elseToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate,
            ifToken: ifToken,
            elseToken: elseToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createLabeledStatement(label, body, loc) {
        return this.commonLocType({
            type: SlimeNodeType.LabeledStatement,
            label: label,
            body: body,
            loc: loc
        });
    }
    createBreakStatement(label, loc, breakToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.BreakStatement,
            label: label,
            breakToken: breakToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createContinueStatement(label, loc, continueToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ContinueStatement,
            label: label,
            continueToken: continueToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createWithStatement(object, body, loc, withToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.WithStatement,
            object: object,
            body: body,
            withToken: withToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createSwitchStatement(discriminant, cases, loc, switchToken, lParenToken, rParenToken, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.SwitchStatement,
            discriminant: discriminant,
            cases: cases,
            switchToken: switchToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    createReturnStatement(argument, loc, returnToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ReturnStatement,
            argument: argument,
            returnToken: returnToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createThrowStatement(argument, loc, throwToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ThrowStatement,
            argument: argument,
            throwToken: throwToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createTryStatement(block, handler, finalizer, loc, tryToken, finallyToken) {
        return this.commonLocType({
            type: SlimeNodeType.TryStatement,
            block: block,
            handler: handler,
            finalizer: finalizer,
            tryToken: tryToken,
            finallyToken: finallyToken,
            loc: loc
        });
    }
    createWhileStatement(test, body, loc, whileToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.WhileStatement,
            test: test,
            body: body,
            whileToken: whileToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createDoWhileStatement(body, test, loc, doToken, whileToken, lParenToken, rParenToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.DoWhileStatement,
            body: body,
            test: test,
            doToken: doToken,
            whileToken: whileToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createForStatement(body, init, test, update, loc, forToken, lParenToken, rParenToken, semicolon1Token, semicolon2Token) {
        return this.commonLocType({
            type: SlimeNodeType.ForStatement,
            init: init,
            test: test,
            update: update,
            body: body,
            forToken: forToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            semicolon1Token: semicolon1Token,
            semicolon2Token: semicolon2Token,
            loc: loc
        });
    }
    createForInStatement(left, right, body, loc, forToken, inToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.ForInStatement,
            left: left,
            right: right,
            body: body,
            forToken: forToken,
            inToken: inToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createForOfStatement(left, right, body, isAwait = false, loc, forToken, ofToken, awaitToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.ForOfStatement,
            left: left,
            right: right,
            body: body,
            await: isAwait,
            forToken: forToken,
            ofToken: ofToken,
            awaitToken: awaitToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createDebuggerStatement(loc, debuggerToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.DebuggerStatement,
            debuggerToken: debuggerToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createSwitchCase(consequent, test, loc, caseToken, defaultToken, colonToken) {
        return this.commonLocType({
            type: SlimeNodeType.SwitchCase,
            test: test,
            consequent: consequent,
            caseToken: caseToken,
            defaultToken: defaultToken,
            colonToken: colonToken,
            loc: loc
        });
    }
    createCatchClause(body, param, loc, catchToken, lParenToken, rParenToken) {
        return this.commonLocType({
            type: SlimeNodeType.CatchClause,
            param: param,
            body: body,
            catchToken: catchToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: loc
        });
    }
    createStaticBlock(body, loc, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.StaticBlock,
            body: body,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    // ============================================
    // Functions
    // ============================================
    createFunctionExpression(body, id, params, generator, async, loc, functionToken, asyncToken, asteriskToken, lParenToken, rParenToken, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.FunctionExpression,
            params: params || [],
            id: id,
            body: body,
            generator: generator || false,
            async: async || false,
            functionToken: functionToken,
            asyncToken: asyncToken,
            asteriskToken: asteriskToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    // ============================================
    // Declarations
    // ============================================
    createVariableDeclaration(kind, declarations, loc) {
        return this.commonLocType({
            type: SlimeNodeType.VariableDeclaration,
            declarations: declarations,
            kind: kind,
            loc: loc
        });
    }
    createVariableDeclarator(id, assignToken, init, loc) {
        return this.commonLocType({
            type: SlimeNodeType.VariableDeclarator,
            id: id,
            assignToken: assignToken,
            init: init,
            loc: loc
        });
    }
    // ============================================
    // Patterns
    // ============================================
    createRestElement(argument, loc, ellipsisToken) {
        return this.commonLocType({
            type: SlimeNodeType.RestElement,
            argument: argument,
            ellipsisToken: ellipsisToken,
            loc: loc
        });
    }
    createSpreadElement(argument, loc, ellipsisToken) {
        return this.commonLocType({
            type: SlimeNodeType.SpreadElement,
            argument: argument,
            ellipsisToken: ellipsisToken,
            loc: loc
        });
    }
    createObjectPattern(properties, loc, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.ObjectPattern,
            properties: properties,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    /**  */ createObjectPatternProperty(property, commaToken) {
        return {
            property,
            commaToken
        };
    }
    createArrayPattern(elements, loc, lBracketToken, rBracketToken) {
        return this.commonLocType({
            type: SlimeNodeType.ArrayPattern,
            elements: elements,
            lBracketToken: lBracketToken,
            rBracketToken: rBracketToken,
            loc: loc
        });
    }
    /**  */ createArrayPatternElement(element, commaToken) {
        return {
            element,
            commaToken
        };
    }
    createAssignmentPattern(left, right, loc) {
        return this.commonLocType({
            type: SlimeNodeType.AssignmentPattern,
            left: left,
            right: right,
            loc: loc
        });
    }
    createAssignmentProperty(key, value, shorthand = false, computed = false, loc, colonToken, lBracketToken, rBracketToken) {
        return this.commonLocType({
            type: SlimeNodeType.Property,
            key: key,
            value: value,
            kind: "init",
            method: false,
            shorthand: shorthand,
            computed: computed,
            colonToken: colonToken,
            lBracketToken: lBracketToken,
            rBracketToken: rBracketToken,
            loc: loc
        });
    }
    // ============================================
    // Modules
    // ============================================
    createImportDeclaration(specifiers, source, loc, importToken, fromToken, lBraceToken, rBraceToken, semicolonToken, attributes, withToken) {
        const decl = {
            type: SlimeNodeType.ImportDeclaration,
            source: source,
            specifiers: specifiers,
            importToken: importToken,
            fromToken: fromToken,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            semicolonToken: semicolonToken,
            loc: loc
        };
        // ES2025:  attributes withToken attributes 
        if (withToken) {
            decl.attributes = attributes || [];
            decl.withToken = withToken;
        }
        return this.commonLocType(decl);
    }
    /**  import specifier  */ createImportSpecifierItem(specifier, commaToken) {
        return {
            specifier,
            commaToken
        };
    }
    createImportSpecifier(local, imported, loc, asToken) {
        return this.commonLocType({
            type: SlimeNodeType.ImportSpecifier,
            local: local,
            imported: imported,
            asToken: asToken,
            loc: loc
        });
    }
    createImportDefaultSpecifier(local, loc) {
        return this.commonLocType({
            type: SlimeNodeType.ImportDefaultSpecifier,
            local: local,
            loc: loc
        });
    }
    createImportNamespaceSpecifier(local, loc, asteriskToken, asToken) {
        return this.commonLocType({
            type: SlimeNodeType.ImportNamespaceSpecifier,
            local: local,
            asteriskToken: asteriskToken,
            asToken: asToken,
            loc: loc
        });
    }
    createExportDefaultDeclaration(declaration, loc, exportToken, defaultToken) {
        return this.commonLocType({
            type: SlimeNodeType.ExportDefaultDeclaration,
            declaration: declaration,
            exportToken: exportToken,
            defaultToken: defaultToken,
            loc: loc
        });
    }
    createExportNamedDeclaration(declaration, specifiers, source, loc, exportToken, fromToken, lBraceToken, rBraceToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ExportNamedDeclaration,
            declaration: declaration,
            specifiers: specifiers,
            source: source,
            exportToken: exportToken,
            fromToken: fromToken,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    /**  export specifier  */ createExportSpecifierItem(specifier, commaToken) {
        return {
            specifier,
            commaToken
        };
    }
    createExportSpecifier(local, exported, loc, asToken) {
        return this.commonLocType({
            type: SlimeNodeType.ExportSpecifier,
            local: local,
            exported: exported,
            asToken: asToken,
            loc: loc
        });
    }
    createExportAllDeclaration(source, exported, loc, exportToken, asteriskToken, asToken, fromToken, semicolonToken) {
        return this.commonLocType({
            type: SlimeNodeType.ExportAllDeclaration,
            source: source,
            exported: exported,
            exportToken: exportToken,
            asteriskToken: asteriskToken,
            asToken: asToken,
            fromToken: fromToken,
            semicolonToken: semicolonToken,
            loc: loc
        });
    }
    createDirective(expression, directive, loc) {
        return this.commonLocType({
            type: SlimeNodeType.ExpressionStatement,
            expression: expression,
            directive: directive,
            loc: loc
        });
    }
    // ============================================
    // Classes
    // ============================================
    createClassDeclaration(id, body, superClass, loc, classToken, extendsToken) {
        return this.commonLocType({
            type: SlimeNodeType.ClassDeclaration,
            id: id,
            body: body,
            superClass: superClass,
            classToken: classToken,
            extendsToken: extendsToken,
            loc: loc
        });
    }
    createClassBody(body, loc, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.ClassBody,
            body: body,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    createFunctionDeclaration(id, params, body, generator = false, async = false, loc, functionToken, asyncToken, asteriskToken, lParenToken, rParenToken, lBraceToken, rBraceToken) {
        return this.commonLocType({
            type: SlimeNodeType.FunctionDeclaration,
            id: id,
            params: params,
            body: body,
            generator: generator,
            async: async,
            functionToken: functionToken,
            asyncToken: asyncToken,
            asteriskToken: asteriskToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            lBraceToken: lBraceToken,
            rBraceToken: rBraceToken,
            loc: loc
        });
    }
    createIdentifier(name, loc) {
        return this.commonLocType({
            type: SlimeNodeType.Identifier,
            name: name,
            loc: loc
        });
    }
    createLiteral(value) {
        let ast;
        if (value === undefined) ; else if (typeof value === "string") {
            ast = this.createStringLiteral(value);
        } else if (typeof value === "number") {
            ast = this.createNumericLiteral(value);
        }
        return ast;
    }
    createNullLiteralToken() {
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            value: null
        });
    }
    createStringLiteral(value, loc, raw) {
        //  value 
        const hasQuotes = /^['"].*['"]$/.test(value);
        const cleanValue = value.replace(/^['"]|['"]$/g, '');
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            value: cleanValue,
            raw: raw || (hasQuotes ? value : `'${value}'`),
            loc: loc
        });
    }
    createNumericLiteral(value, raw) {
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            value: value,
            raw: raw || String(value) //  0xFF
        });
    }
    createBooleanLiteral(value, loc) {
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            value: value,
            loc: loc
        });
    }
    createRegExpLiteral(pattern, flags, raw, loc) {
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            regex: {
                pattern: pattern,
                flags: flags
            },
            raw: raw || `/${pattern}/${flags}`,
            loc: loc
        });
    }
    createBigIntLiteral(bigint, raw, loc) {
        return this.commonLocType({
            type: SlimeNodeType.Literal,
            bigint: bigint,
            raw: raw || `${bigint}n`,
            loc: loc
        });
    }
    createTemplateLiteral(quasis, expressions, loc) {
        return this.commonLocType({
            type: SlimeNodeType.TemplateLiteral,
            quasis: quasis,
            expressions: expressions,
            loc: loc
        });
    }
    createTemplateElement(tail, raw, cooked, loc) {
        return this.commonLocType({
            type: SlimeNodeType.TemplateElement,
            tail: tail,
            value: {
                raw: raw,
                cooked: cooked !== undefined ? cooked : raw
            },
            loc: loc
        });
    }
    createMethodDefinition(key, value, kind = "method", computed = false, isStatic = false, loc, staticToken, getToken, setToken, asyncToken, asteriskToken) {
        return this.commonLocType({
            type: SlimeNodeType.MethodDefinition,
            key: key,
            value: value,
            kind: kind,
            computed: computed,
            static: isStatic,
            staticToken: staticToken,
            getToken: getToken,
            setToken: setToken,
            asyncToken: asyncToken,
            asteriskToken: asteriskToken,
            loc: loc
        });
    }
    createPropertyDefinition(key, value, computed = false, isStatic = false, loc) {
        return this.commonLocType({
            type: SlimeNodeType.PropertyDefinition,
            key: key,
            value: value ?? null,
            computed: computed,
            static: isStatic,
            loc: loc
        });
    }
}
const SlimeAstCreateUtil = new SlimeNodeCreate();

class SlimeTokenFactory {
    // ============================================
    //  Token
    // ============================================
    createVarToken(loc) {
        return {
            type: SlimeTokenType.Var,
            value: "var",
            loc
        };
    }
    createLetToken(loc) {
        return {
            type: SlimeTokenType.Let,
            value: "let",
            loc
        };
    }
    createConstToken(loc) {
        return {
            type: SlimeTokenType.Const,
            value: "const",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    createAssignToken(loc) {
        return {
            type: SlimeTokenType.Assign,
            value: "=",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    createLParenToken(loc) {
        return {
            type: SlimeTokenType.LParen,
            value: "(",
            loc
        };
    }
    createRParenToken(loc) {
        return {
            type: SlimeTokenType.RParen,
            value: ")",
            loc
        };
    }
    createLBraceToken(loc) {
        return {
            type: SlimeTokenType.LBrace,
            value: "{",
            loc
        };
    }
    createRBraceToken(loc) {
        return {
            type: SlimeTokenType.RBrace,
            value: "}",
            loc
        };
    }
    createLBracketToken(loc) {
        return {
            type: SlimeTokenType.LBracket,
            value: "[",
            loc
        };
    }
    createRBracketToken(loc) {
        return {
            type: SlimeTokenType.RBracket,
            value: "]",
            loc
        };
    }
    createSemicolonToken(loc) {
        return {
            type: SlimeTokenType.Semicolon,
            value: ";",
            loc
        };
    }
    createCommaToken(loc) {
        return {
            type: SlimeTokenType.Comma,
            value: ",",
            loc
        };
    }
    createDotToken(loc) {
        return {
            type: SlimeTokenType.Dot,
            value: ".",
            loc
        };
    }
    createSpreadToken(loc) {
        return {
            type: SlimeTokenType.Ellipsis,
            value: "...",
            loc
        };
    }
    createArrowToken(loc) {
        return {
            type: SlimeTokenType.Arrow,
            value: "=>",
            loc
        };
    }
    createQuestionToken(loc) {
        return {
            type: SlimeTokenType.Question,
            value: "?",
            loc
        };
    }
    createColonToken(loc) {
        return {
            type: SlimeTokenType.Colon,
            value: ":",
            loc
        };
    }
    createEllipsisToken(loc) {
        return {
            type: SlimeTokenType.Ellipsis,
            value: "...",
            loc
        };
    }
    createOptionalChainingToken(loc) {
        return {
            type: SlimeTokenType.OptionalChaining,
            value: "?.",
            loc
        };
    }
    createAsteriskToken(loc) {
        return {
            type: SlimeTokenType.Asterisk,
            value: "*",
            loc
        };
    }
    // ============================================
    // / Token
    // ============================================
    createFunctionToken(loc) {
        return {
            type: SlimeTokenType.Function,
            value: "function",
            loc
        };
    }
    createAsyncToken(loc) {
        return {
            type: SlimeTokenType.Async,
            value: "async",
            loc
        };
    }
    createClassToken(loc) {
        return {
            type: SlimeTokenType.Class,
            value: "class",
            loc
        };
    }
    createExtendsToken(loc) {
        return {
            type: SlimeTokenType.Extends,
            value: "extends",
            loc
        };
    }
    createStaticToken(loc) {
        return {
            type: SlimeTokenType.Static,
            value: "static",
            loc
        };
    }
    createGetToken(loc) {
        return {
            type: SlimeTokenType.Get,
            value: "get",
            loc
        };
    }
    createSetToken(loc) {
        return {
            type: SlimeTokenType.Set,
            value: "set",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    createIfToken(loc) {
        return {
            type: SlimeTokenType.If,
            value: "if",
            loc
        };
    }
    createElseToken(loc) {
        return {
            type: SlimeTokenType.Else,
            value: "else",
            loc
        };
    }
    createSwitchToken(loc) {
        return {
            type: SlimeTokenType.Switch,
            value: "switch",
            loc
        };
    }
    createCaseToken(loc) {
        return {
            type: SlimeTokenType.Case,
            value: "case",
            loc
        };
    }
    createDefaultToken(loc) {
        return {
            type: SlimeTokenType.Default,
            value: "default",
            loc
        };
    }
    createForToken(loc) {
        return {
            type: SlimeTokenType.For,
            value: "for",
            loc
        };
    }
    createWhileToken(loc) {
        return {
            type: SlimeTokenType.While,
            value: "while",
            loc
        };
    }
    createDoToken(loc) {
        return {
            type: SlimeTokenType.Do,
            value: "do",
            loc
        };
    }
    createOfToken(loc) {
        return {
            type: SlimeTokenType.Of,
            value: "of",
            loc
        };
    }
    createBreakToken(loc) {
        return {
            type: SlimeTokenType.Break,
            value: "break",
            loc
        };
    }
    createContinueToken(loc) {
        return {
            type: SlimeTokenType.Continue,
            value: "continue",
            loc
        };
    }
    createReturnToken(loc) {
        return {
            type: SlimeTokenType.Return,
            value: "return",
            loc
        };
    }
    createThrowToken(loc) {
        return {
            type: SlimeTokenType.Throw,
            value: "throw",
            loc
        };
    }
    createTryToken(loc) {
        return {
            type: SlimeTokenType.Try,
            value: "try",
            loc
        };
    }
    createCatchToken(loc) {
        return {
            type: SlimeTokenType.Catch,
            value: "catch",
            loc
        };
    }
    createFinallyToken(loc) {
        return {
            type: SlimeTokenType.Finally,
            value: "finally",
            loc
        };
    }
    createWithToken(loc) {
        return {
            type: SlimeTokenType.With,
            value: "with",
            loc
        };
    }
    createDebuggerToken(loc) {
        return {
            type: SlimeTokenType.Debugger,
            value: "debugger",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    createNewToken(loc) {
        return {
            type: SlimeTokenType.New,
            value: "new",
            loc
        };
    }
    createYieldToken(loc) {
        return {
            type: SlimeTokenType.Yield,
            value: "yield",
            loc
        };
    }
    createAwaitToken(loc) {
        return {
            type: SlimeTokenType.Await,
            value: "await",
            loc
        };
    }
    createTypeofToken(loc) {
        return {
            type: SlimeTokenType.Typeof,
            value: "typeof",
            loc
        };
    }
    createVoidToken(loc) {
        return {
            type: SlimeTokenType.Void,
            value: "void",
            loc
        };
    }
    createDeleteToken(loc) {
        return {
            type: SlimeTokenType.Delete,
            value: "delete",
            loc
        };
    }
    createInstanceofToken(loc) {
        return {
            type: SlimeTokenType.Instanceof,
            value: "instanceof",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    createImportToken(loc) {
        return {
            type: SlimeTokenType.Import,
            value: "import",
            loc
        };
    }
    createExportToken(loc) {
        return {
            type: SlimeTokenType.Export,
            value: "export",
            loc
        };
    }
    createFromToken(loc) {
        return {
            type: SlimeTokenType.From,
            value: "from",
            loc
        };
    }
    createAsToken(loc) {
        return {
            type: SlimeTokenType.As,
            value: "as",
            loc
        };
    }
    createInToken(loc) {
        return {
            type: SlimeTokenType.In,
            value: "in",
            loc
        };
    }
    // ============================================
    //  Token
    // ============================================
    /**
     *  Token
     * : == != === !== < <= > >= << >> >>> + - * / % ** | ^ & in instanceof
     */ createBinaryOperatorToken(operator, loc) {
        const typeMap = {
            "==": SlimeBinaryOperatorTokenTypes.Equal,
            "!=": SlimeBinaryOperatorTokenTypes.NotEqual,
            "===": SlimeBinaryOperatorTokenTypes.StrictEqual,
            "!==": SlimeBinaryOperatorTokenTypes.StrictNotEqual,
            "<": SlimeBinaryOperatorTokenTypes.Less,
            "<=": SlimeBinaryOperatorTokenTypes.LessEqual,
            ">": SlimeBinaryOperatorTokenTypes.Greater,
            ">=": SlimeBinaryOperatorTokenTypes.GreaterEqual,
            "<<": SlimeBinaryOperatorTokenTypes.LeftShift,
            ">>": SlimeBinaryOperatorTokenTypes.RightShift,
            ">>>": SlimeBinaryOperatorTokenTypes.UnsignedRightShift,
            "+": SlimeBinaryOperatorTokenTypes.Plus,
            "-": SlimeBinaryOperatorTokenTypes.Minus,
            "*": SlimeBinaryOperatorTokenTypes.Asterisk,
            "/": SlimeBinaryOperatorTokenTypes.Slash,
            "%": SlimeBinaryOperatorTokenTypes.Modulo,
            "**": SlimeBinaryOperatorTokenTypes.Exponentiation,
            "|": SlimeBinaryOperatorTokenTypes.BitwiseOr,
            "^": SlimeBinaryOperatorTokenTypes.BitwiseXor,
            "&": SlimeBinaryOperatorTokenTypes.BitwiseAnd,
            "in": SlimeBinaryOperatorTokenTypes.In,
            "instanceof": SlimeBinaryOperatorTokenTypes.Instanceof
        };
        return {
            type: typeMap[operator],
            value: operator,
            loc
        };
    }
    /**
     *  Token
     * : - + ! ~ typeof void delete
     */ createUnaryOperatorToken(operator, loc) {
        const typeMap = {
            "-": SlimeUnaryOperatorTokenTypes.Minus,
            "+": SlimeUnaryOperatorTokenTypes.Plus,
            "!": SlimeUnaryOperatorTokenTypes.LogicalNot,
            "~": SlimeUnaryOperatorTokenTypes.BitwiseNot,
            "typeof": SlimeUnaryOperatorTokenTypes.Typeof,
            "void": SlimeUnaryOperatorTokenTypes.Void,
            "delete": SlimeUnaryOperatorTokenTypes.Delete
        };
        return {
            type: typeMap[operator],
            value: operator,
            loc
        };
    }
    /**
     *  Token
     * : || && ??
     */ createLogicalOperatorToken(operator, loc) {
        const typeMap = {
            "||": SlimeLogicalOperatorTokenTypes.LogicalOr,
            "&&": SlimeLogicalOperatorTokenTypes.LogicalAnd,
            "??": SlimeLogicalOperatorTokenTypes.NullishCoalescing
        };
        return {
            type: typeMap[operator],
            value: operator,
            loc
        };
    }
    /**
     *  Token
     * : = += -= *= /= %= **= <<= >>= >>>= |= ^= &= ||= &&= ??=
     */ createAssignmentOperatorToken(operator, loc) {
        const typeMap = {
            "=": SlimeAssignmentOperatorTokenTypes.Assign,
            "+=": SlimeAssignmentOperatorTokenTypes.PlusAssign,
            "-=": SlimeAssignmentOperatorTokenTypes.MinusAssign,
            "*=": SlimeAssignmentOperatorTokenTypes.MultiplyAssign,
            "/=": SlimeAssignmentOperatorTokenTypes.DivideAssign,
            "%=": SlimeAssignmentOperatorTokenTypes.ModuloAssign,
            "**=": SlimeAssignmentOperatorTokenTypes.ExponentiationAssign,
            "<<=": SlimeAssignmentOperatorTokenTypes.LeftShiftAssign,
            ">>=": SlimeAssignmentOperatorTokenTypes.RightShiftAssign,
            ">>>=": SlimeAssignmentOperatorTokenTypes.UnsignedRightShiftAssign,
            "|=": SlimeAssignmentOperatorTokenTypes.BitwiseOrAssign,
            "^=": SlimeAssignmentOperatorTokenTypes.BitwiseXorAssign,
            "&=": SlimeAssignmentOperatorTokenTypes.BitwiseAndAssign,
            "||=": SlimeAssignmentOperatorTokenTypes.LogicalOrAssign,
            "&&=": SlimeAssignmentOperatorTokenTypes.LogicalAndAssign,
            "??=": SlimeAssignmentOperatorTokenTypes.NullishCoalescingAssign
        };
        return {
            type: typeMap[operator],
            value: operator,
            loc
        };
    }
    /**
     *  Token
     * : ++ --
     */ createUpdateOperatorToken(operator, loc) {
        const typeMap = {
            "++": SlimeUpdateOperatorTokenTypes.Increment,
            "--": SlimeUpdateOperatorTokenTypes.Decrement
        };
        return {
            type: typeMap[operator],
            value: operator,
            loc
        };
    }
}
const SlimeTokenCreate = new SlimeTokenFactory();

function _define_property$2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// ============================================
// Unicode 
// ES2025  12.9.4 - ?\uXXXX ?\u{XXXXX} ?
// BabelAcornTypeScript
// ============================================
/**
 * ?Unicode ?
 *  \uXXXX ?\u{XXXXX} 
 *
 * @param str  Unicode 
 * @returns ?
 */ function decodeUnicodeEscapes(str) {
    // ?
    if (!str || !str.includes('\\u')) {
        return str || '';
    }
    return str.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([0-9a-fA-F]{4})/g, (match, braceCode, fourDigitCode)=>{
        const codePoint = parseInt(braceCode || fourDigitCode, 16);
        return String.fromCodePoint(codePoint);
    });
}
function checkCstName$1(cst, cstName) {
    if (cst.name !== cstName) {
        throwNewError$1(cst.name);
    }
    return cstName;
}
function throwNewError$1(errorMsg = 'syntax error') {
    throw new Error(errorMsg);
}
/**
 * CST ?AST ?
 *
 * ## 
 *
 * ### AST ?(SlimeNodeCreate.ts / SlimeAstUtil)
 * - ?ESTree AST ?
 * - ?CST 
 * - createIdentifier(name, loc) ?SlimeIdentifier
 *
 * ### CST ?()
 * - ?CST ?(createXxxAst)
 * -  CST  AST ?
 * - createAstFromCst(cst) - 
 *
 * ## 
 *
 * |  |  |  |
 * |----------|----------|------|
 * | CST  | createXxxAst | ?@SubhutiRule  |
 * | AST  | createXxxAst | CST ??AST  |
 * |  | private createXxxAst | ES2025 ?|
 * |  | convertXxx / isXxx |  |
 *
 * ## 
 *
 * ?CST ?createXxxAst?Xxx ?CST ?
 *  SlimeNodeCreate / SlimeAstUtil  AST ?
 *
 * ?
 * - createArrayLiteralAst (CST ? ? createArrayExpression (AST ?
 * - createObjectLiteralAst (CST ? ? createObjectExpression (AST ?
 * - createCatchAst (CST ? ? createCatchClause (AST ?
 *
 * ## 
 * - createAstFromCst: ?CST ?
 * - createStatementDeclarationAst: /
 *
 * ## 
 * - toProgram: Program 
 */ class SlimeCstToAst {
    /**
     * ?CST 
     *
     *  CST ?AST 
     * - AST ?(SlimeNodeCreate.ts) - ?AST 
     * - CST ?() -  CST ?AST ?
     *
     * @param cst CST 
     * @returns ?AST 
     */ createAstFromCst(cst) {
        const name = cst.name;
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.IdentifierReference?.name) return this.createIdentifierReferenceAst(cst);
        if (name === _SlimeParser$1.prototype.BindingIdentifier?.name) return this.createBindingIdentifierAst(cst);
        if (name === _SlimeParser$1.prototype.LabelIdentifier?.name) return this.createLabelIdentifierAst(cst);
        if (name === _SlimeParser$1.prototype.Identifier?.name) return this.createIdentifierAst(cst);
        if (name === _SlimeParser$1.prototype.IdentifierName?.name) return this.createIdentifierNameAst(cst);
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.Literal?.name) return this.createLiteralAst(cst);
        if (name === _SlimeParser$1.prototype.BooleanLiteral?.name) return this.createBooleanLiteralAst(cst);
        if (name === _SlimeParser$1.prototype.ArrayLiteral?.name) return this.createArrayLiteralAst(cst);
        if (name === _SlimeParser$1.prototype.ObjectLiteral?.name) return this.createObjectLiteralAst(cst);
        if (name === _SlimeParser$1.prototype.TemplateLiteral?.name) return this.createTemplateLiteralAst(cst);
        if (name === _SlimeParser$1.prototype.LiteralPropertyName?.name) return this.createLiteralPropertyNameAst(cst);
        if (name === SlimeTokenConsumer.prototype.NumericLiteral?.name) return this.createNumericLiteralAst(cst);
        if (name === SlimeTokenConsumer.prototype.StringLiteral?.name) return this.createStringLiteralAst(cst);
        if (name === SlimeTokenConsumer.prototype.RegularExpressionLiteral?.name) return this.createRegExpLiteralAst(cst);
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.PrimaryExpression?.name) return this.createPrimaryExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.Expression?.name) return this.createExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentExpression?.name) return this.createAssignmentExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.ConditionalExpression?.name) return this.createConditionalExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.ShortCircuitExpression?.name) return this.createShortCircuitExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.LogicalORExpression?.name) return this.createLogicalORExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.LogicalANDExpression?.name) return this.createLogicalANDExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.BitwiseORExpression?.name) return this.createBitwiseORExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.BitwiseXORExpression?.name) return this.createBitwiseXORExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.BitwiseANDExpression?.name) return this.createBitwiseANDExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.EqualityExpression?.name) return this.createEqualityExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.RelationalExpression?.name) return this.createRelationalExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.ShiftExpression?.name) return this.createShiftExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.AdditiveExpression?.name) return this.createAdditiveExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.MultiplicativeExpression?.name) return this.createMultiplicativeExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.ExponentiationExpression?.name) return this.createExponentiationExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.UnaryExpression?.name) return this.createUnaryExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.UpdateExpression?.name) return this.createUpdateExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.LeftHandSideExpression?.name) return this.createLeftHandSideExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.NewExpression?.name) return this.createNewExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.CallExpression?.name) return this.createCallExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.CallMemberExpression?.name) return this.createCallMemberExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.MemberExpression?.name) return this.createMemberExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.OptionalExpression?.name) return this.createOptionalExpressionAst(cst);
        // OptionalChain  object  OptionalExpression 
        if (name === _SlimeParser$1.prototype.CoalesceExpression?.name) return this.createCoalesceExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.CoalesceExpressionHead?.name) return this.createCoalesceExpressionHeadAst(cst);
        // ShortCircuitExpressionTail  left  ShortCircuitExpression 
        if (name === _SlimeParser$1.prototype.ParenthesizedExpression?.name) return this.createParenthesizedExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.AwaitExpression?.name) return this.createAwaitExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.YieldExpression?.name) return this.createYieldExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.MetaProperty?.name) return this.createMetaPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.SuperProperty?.name) return this.createSuperPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.SuperCall?.name) return this.createSuperCallAst(cst);
        if (name === _SlimeParser$1.prototype.ImportCall?.name) return this.createImportCallAst(cst);
        if (name === _SlimeParser$1.prototype.SpreadElement?.name) return this.createSpreadElementAst(cst);
        if (name === _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name) return this.createCoverParenthesizedExpressionAndArrowParameterListAst(cst);
        if (name === _SlimeParser$1.prototype.CoverCallExpressionAndAsyncArrowHead?.name) return this.createCoverCallExpressionAndAsyncArrowHeadAst(cst);
        if (name === _SlimeParser$1.prototype.CoverInitializedName?.name) return this.createCoverInitializedNameAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.Statement?.name) return this.createStatementAst(cst);
        if (name === _SlimeParser$1.prototype.StatementList?.name) return this.createStatementListAst(cst);
        if (name === _SlimeParser$1.prototype.StatementListItem?.name) return this.createStatementListItemAst(cst);
        if (name === _SlimeParser$1.prototype.Block?.name) return this.createBlockAst(cst);
        if (name === _SlimeParser$1.prototype.BlockStatement?.name) return this.createBlockStatementAst(cst);
        if (name === _SlimeParser$1.prototype.EmptyStatement?.name) return this.createEmptyStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ExpressionStatement?.name) return this.createExpressionStatementAst(cst);
        if (name === _SlimeParser$1.prototype.IfStatement?.name) return this.createIfStatementAst(cst);
        if (name === _SlimeParser$1.prototype.IfStatementBody?.name) return this.createIfStatementBodyAst(cst);
        if (name === _SlimeParser$1.prototype.BreakableStatement?.name) return this.createBreakableStatementAst(cst);
        if (name === _SlimeParser$1.prototype.IterationStatement?.name) return this.createIterationStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ForStatement?.name) return this.createForStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ForInOfStatement?.name) return this.createForInOfStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ForDeclaration?.name) return this.createForDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.ForBinding?.name) return this.createForBindingAst(cst);
        if (name === _SlimeParser$1.prototype.WhileStatement?.name) return this.createWhileStatementAst(cst);
        if (name === _SlimeParser$1.prototype.DoWhileStatement?.name) return this.createDoWhileStatementAst(cst);
        if (name === _SlimeParser$1.prototype.SwitchStatement?.name) return this.createSwitchStatementAst(cst);
        if (name === _SlimeParser$1.prototype.CaseBlock?.name) return this.createCaseBlockAst(cst);
        if (name === _SlimeParser$1.prototype.CaseClauses?.name) return this.createCaseClausesAst(cst);
        if (name === _SlimeParser$1.prototype.CaseClause?.name) return this.createCaseClauseAst(cst);
        if (name === _SlimeParser$1.prototype.DefaultClause?.name) return this.createDefaultClauseAst(cst);
        if (name === _SlimeParser$1.prototype.BreakStatement?.name) return this.createBreakStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ContinueStatement?.name) return this.createContinueStatementAst(cst);
        if (name === _SlimeParser$1.prototype.ReturnStatement?.name) return this.createReturnStatementAst(cst);
        if (name === _SlimeParser$1.prototype.WithStatement?.name) return this.createWithStatementAst(cst);
        if (name === _SlimeParser$1.prototype.LabelledStatement?.name) return this.createLabelledStatementAst(cst);
        if (name === _SlimeParser$1.prototype.LabelledItem?.name) return this.createLabelledItemAst(cst);
        if (name === _SlimeParser$1.prototype.ThrowStatement?.name) return this.createThrowStatementAst(cst);
        if (name === _SlimeParser$1.prototype.TryStatement?.name) return this.createTryStatementAst(cst);
        if (name === _SlimeParser$1.prototype.Catch?.name) return this.createCatchAst(cst);
        if (name === _SlimeParser$1.prototype.CatchParameter?.name) return this.createCatchParameterAst(cst);
        if (name === _SlimeParser$1.prototype.Finally?.name) return this.createFinallyAst(cst);
        if (name === _SlimeParser$1.prototype.DebuggerStatement?.name) return this.createDebuggerStatementAst(cst);
        if (name === _SlimeParser$1.prototype.SemicolonASI?.name) return this.createSemicolonASIAst(cst);
        if (name === _SlimeParser$1.prototype.ExpressionBody?.name) return this.createExpressionBodyAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.Declaration?.name) return this.createDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.HoistableDeclaration?.name) return this.createHoistableDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.VariableStatement?.name) return this.createVariableStatementAst(cst);
        if (name === _SlimeParser$1.prototype.VariableDeclaration?.name) return this.createVariableDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.VariableDeclarationList?.name) return this.createVariableDeclarationListAst(cst);
        if (name === _SlimeParser$1.prototype.LexicalDeclaration?.name) return this.createLexicalDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.LetOrConst?.name) return this.createLetOrConstAst(cst);
        if (name === _SlimeParser$1.prototype.LexicalBinding?.name) return this.createLexicalBindingAst(cst);
        if (name === _SlimeParser$1.prototype.Initializer?.name) return this.createInitializerAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.FunctionDeclaration?.name) return this.createFunctionDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.FunctionExpression?.name) return this.createFunctionExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.FunctionBody?.name) return this.createFunctionBodyAst(cst);
        if (name === _SlimeParser$1.prototype.FunctionStatementList?.name) return this.createFunctionStatementListAst(cst);
        if (name === _SlimeParser$1.prototype.FormalParameters?.name) return this.createFormalParametersAst(cst);
        if (name === _SlimeParser$1.prototype.FormalParameterList?.name) return this.createFormalParameterListAst(cst);
        if (name === _SlimeParser$1.prototype.FormalParameter?.name) return this.createFormalParameterAst(cst);
        if (name === _SlimeParser$1.prototype.FunctionRestParameter?.name) return this.createFunctionRestParameterAst(cst);
        if (name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) return this.createUniqueFormalParametersAst(cst);
        if (name === _SlimeParser$1.prototype.ArrowFunction?.name) return this.createArrowFunctionAst(cst);
        if (name === _SlimeParser$1.prototype.ArrowParameters?.name) return this.createArrowParametersAst(cst);
        if (name === _SlimeParser$1.prototype.ArrowFormalParameters?.name) return this.createArrowFormalParametersAst(cst);
        if (name === _SlimeParser$1.prototype.ConciseBody?.name) return this.createConciseBodyAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncFunctionDeclaration?.name) return this.createAsyncFunctionDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncFunctionExpression?.name) return this.createAsyncFunctionExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncFunctionBody?.name) return this.createAsyncFunctionBodyAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncArrowFunction?.name) return this.createAsyncArrowFunctionAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncArrowHead?.name) return this.createAsyncArrowHeadAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncArrowBindingIdentifier?.name) return this.createAsyncArrowBindingIdentifierAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncConciseBody?.name) return this.createAsyncConciseBodyAst(cst);
        if (name === _SlimeParser$1.prototype.GeneratorDeclaration?.name) return this.createGeneratorDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.GeneratorExpression?.name) return this.createGeneratorExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.GeneratorBody?.name) return this.createGeneratorBodyAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncGeneratorDeclaration?.name) return this.createAsyncGeneratorDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncGeneratorExpression?.name) return this.createAsyncGeneratorExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncGeneratorBody?.name) return this.createAsyncGeneratorBodyAst(cst);
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.ClassDeclaration?.name) return this.createClassDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.ClassExpression?.name) return this.createClassExpressionAst(cst);
        if (name === _SlimeParser$1.prototype.ClassTail?.name) return this.createClassTailAst(cst);
        if (name === _SlimeParser$1.prototype.ClassHeritage?.name) return this.createClassHeritageAst(cst);
        if (name === _SlimeParser$1.prototype.ClassBody?.name) return this.createClassBodyAst(cst);
        if (name === _SlimeParser$1.prototype.ClassElementList?.name) return this.createClassElementListAst(cst);
        if (name === _SlimeParser$1.prototype.ClassElement?.name) return this.createClassElementAst(cst);
        if (name === _SlimeParser$1.prototype.ClassElementName?.name) return this.createClassElementNameAst(cst);
        if (name === _SlimeParser$1.prototype.ClassStaticBlock?.name) return this.createClassStaticBlockAst(cst);
        if (name === _SlimeParser$1.prototype.ClassStaticBlockBody?.name) return this.createClassStaticBlockBodyAst(cst);
        if (name === _SlimeParser$1.prototype.ClassStaticBlockStatementList?.name) return this.createClassStaticBlockStatementListAst(cst);
        if (name === _SlimeParser$1.prototype.MethodDefinition?.name) return this.createMethodDefinitionAst(null, cst);
        if (name === _SlimeParser$1.prototype.FieldDefinition?.name) return this.createFieldDefinitionAst(null, cst);
        if (name === _SlimeParser$1.prototype.GeneratorMethod?.name) return this.createGeneratorMethodAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncMethod?.name) return this.createAsyncMethodAst(cst);
        if (name === _SlimeParser$1.prototype.AsyncGeneratorMethod?.name) return this.createAsyncGeneratorMethodAst(cst);
        if (name === 'PrivateIdentifier') return this.createPrivateIdentifierAst(cst);
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.PropertyDefinition?.name) return this.createPropertyDefinitionAst(cst);
        if (name === _SlimeParser$1.prototype.PropertyName?.name) return this.createPropertyNameAst(cst);
        if (name === _SlimeParser$1.prototype.ComputedPropertyName?.name) return this.createComputedPropertyNameAst(cst);
        if (name === _SlimeParser$1.prototype.PropertySetParameterList?.name) return this.createPropertySetParameterListAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.BindingPattern?.name) return this.createBindingPatternAst(cst);
        if (name === _SlimeParser$1.prototype.ObjectBindingPattern?.name) return this.createObjectBindingPatternAst(cst);
        if (name === _SlimeParser$1.prototype.ArrayBindingPattern?.name) return this.createArrayBindingPatternAst(cst);
        if (name === _SlimeParser$1.prototype.BindingPropertyList?.name) return this.createBindingPropertyListAst(cst);
        if (name === _SlimeParser$1.prototype.BindingProperty?.name) return this.createBindingPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.BindingElementList?.name) return this.createBindingElementListAst(cst);
        if (name === _SlimeParser$1.prototype.BindingElisionElement?.name) return this.createBindingElisionElementAst(cst);
        if (name === _SlimeParser$1.prototype.BindingElement?.name) return this.createBindingElementAst(cst);
        if (name === _SlimeParser$1.prototype.BindingRestElement?.name) return this.createBindingRestElementAst(cst);
        if (name === _SlimeParser$1.prototype.BindingRestProperty?.name) return this.createBindingRestPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.SingleNameBinding?.name) return this.createSingleNameBindingAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentPattern?.name) return this.createAssignmentPatternAst(cst);
        if (name === _SlimeParser$1.prototype.ObjectAssignmentPattern?.name) return this.createObjectAssignmentPatternAst(cst);
        if (name === _SlimeParser$1.prototype.ArrayAssignmentPattern?.name) return this.createArrayAssignmentPatternAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentPropertyList?.name) return this.createAssignmentPropertyListAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentProperty?.name) return this.createAssignmentPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentElementList?.name) return this.createAssignmentElementListAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentElisionElement?.name) return this.createAssignmentElisionElementAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentElement?.name) return this.createAssignmentElementAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentRestElement?.name) return this.createAssignmentRestElementAst(cst);
        if (name === _SlimeParser$1.prototype.AssignmentRestProperty?.name) return this.createAssignmentRestPropertyAst(cst);
        if (name === _SlimeParser$1.prototype.Elision?.name) return this.createElisionAst(cst);
        if (name === _SlimeParser$1.prototype.ElementList?.name) return this.createElementListAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.Module?.name) return this.createModuleAst(cst);
        if (name === _SlimeParser$1.prototype.ModuleBody?.name) return this.createModuleBodyAst(cst);
        if (name === _SlimeParser$1.prototype.ModuleItem?.name) return this.createModuleItemAst(cst);
        if (name === _SlimeParser$1.prototype.ModuleItemList?.name) return this.createModuleItemListAst(cst);
        if (name === _SlimeParser$1.prototype.ImportDeclaration?.name) return this.createImportDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.ImportClause?.name) return this.createImportClauseAst(cst);
        if (name === _SlimeParser$1.prototype.ImportedDefaultBinding?.name) return this.createImportedDefaultBindingAst(cst);
        if (name === _SlimeParser$1.prototype.NameSpaceImport?.name) return this.createNameSpaceImportAst(cst);
        if (name === _SlimeParser$1.prototype.NamedImports?.name) return this.createNamedImportsAst(cst);
        if (name === _SlimeParser$1.prototype.ImportsList?.name) return this.createImportsListAst(cst);
        if (name === _SlimeParser$1.prototype.ImportSpecifier?.name) return this.createImportSpecifierAst(cst);
        if (name === _SlimeParser$1.prototype.ImportedBinding?.name) return this.createImportedBindingAst(cst);
        if (name === _SlimeParser$1.prototype.ModuleSpecifier?.name) return this.createModuleSpecifierAst(cst);
        if (name === _SlimeParser$1.prototype.FromClause?.name) return this.createFromClauseAst(cst);
        if (name === _SlimeParser$1.prototype.ModuleExportName?.name) return this.createModuleExportNameAst(cst);
        if (name === _SlimeParser$1.prototype.ExportDeclaration?.name) return this.createExportDeclarationAst(cst);
        if (name === _SlimeParser$1.prototype.ExportFromClause?.name) return this.createExportFromClauseAst(cst);
        if (name === _SlimeParser$1.prototype.NamedExports?.name) return this.createNamedExportsAst(cst);
        if (name === _SlimeParser$1.prototype.ExportsList?.name) return this.createExportsListAst(cst);
        if (name === _SlimeParser$1.prototype.ExportSpecifier?.name) return this.createExportSpecifierAst(cst);
        if (name === _SlimeParser$1.prototype.WithClause?.name) return this.createWithClauseAst(cst);
        if (name === _SlimeParser$1.prototype.WithEntries?.name) return this.createWithEntriesAst(cst);
        if (name === _SlimeParser$1.prototype.AttributeKey?.name) return this.createAttributeKeyAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.Program?.name) return this.createProgramAst(cst);
        if (name === _SlimeParser$1.prototype.Script?.name) return this.createScriptAst(cst);
        if (name === _SlimeParser$1.prototype.ScriptBody?.name) return this.createScriptBodyAst(cst);
        // ====================  ====================
        if (name === _SlimeParser$1.prototype.Arguments?.name) return this.createArgumentsAst(cst);
        if (name === _SlimeParser$1.prototype.ArgumentList?.name) return this.createArgumentListAst(cst);
        // ==================== ?====================
        if (name === _SlimeParser$1.prototype.AssignmentOperator?.name) return this.createAssignmentOperatorAst(cst);
        if (name === _SlimeParser$1.prototype.MultiplicativeOperator?.name) return this.createMultiplicativeOperatorAst(cst);
        // ==================== ?CST  ====================
        if (cst.children && cst.children.length === 1) {
            return this.createAstFromCst(cst.children[0]);
        }
        throw new Error(`No conversion method found for CST node: ${name}`);
    }
    /**
     *  IdentifierReference ?AST
     *
     * IdentifierReference -> Identifier | yield | await
     *
     * IdentifierReference  Identifier 
     * ?ES ?
     */ createIdentifierReferenceAst(cst) {
        const expectedName = _SlimeParser$1.prototype.IdentifierReference?.name || 'IdentifierReference';
        if (cst.name !== expectedName && cst.name !== 'IdentifierReference') {
            throw new Error(`Expected IdentifierReference, got ${cst.name}`);
        }
        // IdentifierReference -> Identifier | yield | await
        const child = cst.children?.[0];
        if (!child) {
            throw new Error('IdentifierReference has no children');
        }
        return this.createIdentifierAst(child);
    }
    /**
     *  LabelIdentifier ?AST
     *
     * LabelIdentifier -> Identifier | [~Yield] yield | [~Await] await
     *
     * LabelIdentifier  break/continue  LabelledStatement ?
     * ?IdentifierReference ?
     */ createLabelIdentifierAst(cst) {
        const expectedName = _SlimeParser$1.prototype.LabelIdentifier?.name || 'LabelIdentifier';
        if (cst.name !== expectedName && cst.name !== 'LabelIdentifier') {
            throw new Error(`Expected LabelIdentifier, got ${cst.name}`);
        }
        // LabelIdentifier -> Identifier | yield | await
        const child = cst.children?.[0];
        if (!child) {
            throw new Error('LabelIdentifier has no children');
        }
        return this.createIdentifierAst(child);
    }
    createIdentifierAst(cst) {
        // Support Identifier, IdentifierName, and contextual keywords (yield, await) used as identifiers
        const expectedName = _SlimeParser$1.prototype.Identifier?.name || 'Identifier';
        const isIdentifier = cst.name === expectedName || cst.name === 'Identifier';
        const isIdentifierName = cst.name === 'IdentifierName' || cst.name === _SlimeParser$1.prototype.IdentifierName?.name;
        const isYield = cst.name === 'Yield';
        const isAwait = cst.name === 'Await';
        // ES2025 Parser: Identifier  IdentifierNameTok()
        // ?CST Identifier -> IdentifierNameTok (token with value)
        let value;
        let tokenLoc = undefined;
        //  yield/await 
        if (isYield || isAwait) {
            // ?token?
            value = cst.value || cst.name.toLowerCase();
            tokenLoc = cst.loc;
        } else if (isIdentifierName) {
            // IdentifierName IdentifierName -> token (with value)
            if (cst.value !== undefined && cst.value !== null) {
                value = cst.value;
                tokenLoc = cst.loc;
            } else if (cst.children && cst.children.length > 0) {
                const tokenCst = cst.children[0];
                if (tokenCst.value !== undefined) {
                    value = tokenCst.value;
                    tokenLoc = tokenCst.loc || cst.loc;
                } else {
                    throw new Error(`createIdentifierAst: Cannot extract value from IdentifierName CST`);
                }
            } else {
                throw new Error(`createIdentifierAst: Invalid IdentifierName CST structure`);
            }
        } else if (!isIdentifier) {
            throw new Error(`Expected Identifier, got ${cst.name}`);
        } else if (cst.value !== undefined && cst.value !== null) {
            // ?token
            value = cst.value;
            tokenLoc = cst.loc;
        } else if (cst.children && cst.children.length > 0) {
            // ES2025: Identifier ?IdentifierNameTok
            const tokenCst = cst.children[0];
            if (tokenCst.value !== undefined) {
                value = tokenCst.value;
                tokenLoc = tokenCst.loc || cst.loc;
            } else {
                throw new Error(`createIdentifierAst: Cannot extract value from Identifier CST`);
            }
        } else {
            throw new Error(`createIdentifierAst: Invalid Identifier CST structure`);
        }
        //  Unicode  \u0061 -> a?
        const decodedName = decodeUnicodeEscapes(value);
        //  token ?loc loc
        const identifier = SlimeAstCreateUtil.createIdentifier(decodedName, tokenLoc || cst.loc);
        return identifier;
    }
    /**
     * [] ?CST ?Program AST
     *
     * ?ModuleScriptProgram  CST?
     */ toProgram(cst) {
        // Support both Module and Script entry points
        const isModule = cst.name === _SlimeParser$1.prototype.Module?.name || cst.name === 'Module';
        const isScript = cst.name === _SlimeParser$1.prototype.Script?.name || cst.name === 'Script';
        const isProgram = cst.name === _SlimeParser$1.prototype.Program?.name || cst.name === 'Program';
        if (!isModule && !isScript && !isProgram) {
            throw new Error(`Expected CST name 'Module', 'Script' or 'Program', but got '${cst.name}'`);
        }
        let program;
        let hashbangComment = null;
        // If children is empty, return empty program
        if (!cst.children || cst.children.length === 0) {
            return SlimeAstCreateUtil.createProgram([], isModule ? 'module' : 'script');
        }
        //  HashbangComment ?
        let bodyChild = null;
        for (const child of cst.children){
            if (child.name === 'HashbangComment') {
                //  Hashbang ?
                hashbangComment = child.value || child.children?.[0]?.value || null;
            } else if (child.name === 'ModuleBody' || child.name === 'ScriptBody' || child.name === 'ModuleItemList' || child.name === _SlimeParser$1.prototype.ModuleItemList?.name || child.name === 'StatementList' || child.name === _SlimeParser$1.prototype.StatementList?.name) {
                bodyChild = child;
            }
        }
        // 
        if (bodyChild) {
            if (bodyChild.name === 'ModuleBody') {
                const moduleItemList = bodyChild.children?.[0];
                if (moduleItemList && (moduleItemList.name === 'ModuleItemList' || moduleItemList.name === _SlimeParser$1.prototype.ModuleItemList?.name)) {
                    const body = this.createModuleItemListAst(moduleItemList);
                    program = SlimeAstCreateUtil.createProgram(body, 'module');
                } else {
                    program = SlimeAstCreateUtil.createProgram([], 'module');
                }
            } else if (bodyChild.name === _SlimeParser$1.prototype.ModuleItemList?.name || bodyChild.name === 'ModuleItemList') {
                const body = this.createModuleItemListAst(bodyChild);
                program = SlimeAstCreateUtil.createProgram(body, 'module');
            } else if (bodyChild.name === 'ScriptBody') {
                const statementList = bodyChild.children?.[0];
                if (statementList && (statementList.name === 'StatementList' || statementList.name === _SlimeParser$1.prototype.StatementList?.name)) {
                    const body = this.createStatementListAst(statementList);
                    program = SlimeAstCreateUtil.createProgram(body, 'script');
                } else {
                    program = SlimeAstCreateUtil.createProgram([], 'script');
                }
            } else if (bodyChild.name === _SlimeParser$1.prototype.StatementList?.name || bodyChild.name === 'StatementList') {
                const body = this.createStatementListAst(bodyChild);
                program = SlimeAstCreateUtil.createProgram(body, 'script');
            } else {
                throw new Error(`Unexpected body child: ${bodyChild.name}`);
            }
        } else {
            // ?HashbangComment?
            program = SlimeAstCreateUtil.createProgram([], isModule ? 'module' : 'script');
        }
        //  hashbang 
        if (hashbangComment) {
            program.hashbang = hashbangComment;
        }
        program.loc = cst.loc;
        return program;
    }
    createModuleItemListAst(cst) {
        const asts = cst.children.map((item)=>{
            // Es2025Parser uses ModuleItem wrapper
            if (item.name === _SlimeParser$1.prototype.ModuleItem?.name || item.name === 'ModuleItem') {
                const innerItem = item.children?.[0];
                if (!innerItem) return undefined;
                return this.createModuleItemAst(innerItem);
            }
            // Fallback: direct type
            return this.createModuleItemAst(item);
        }).filter((ast)=>ast !== undefined);
        return asts.flat();
    }
    // ====================  ====================
    /**
     * Program CST ?AST
     *
     * Program ?Script ?Module ?
     */ createProgramAst(cst) {
        //  Program -> Script | Module
        const firstChild = cst.children?.[0];
        if (firstChild) {
            if (firstChild.name === 'Script' || firstChild.name === _SlimeParser$1.prototype.Script?.name) {
                return this.createScriptAst(firstChild);
            } else if (firstChild.name === 'Module' || firstChild.name === _SlimeParser$1.prototype.Module?.name) {
                return this.createModuleAst(firstChild);
            }
        }
        // ?toProgram
        return this.toProgram(cst);
    }
    /**
     * Script CST ?AST
     */ createScriptAst(cst) {
        const scriptBody = cst.children?.find((ch)=>ch.name === 'ScriptBody' || ch.name === _SlimeParser$1.prototype.ScriptBody?.name);
        if (scriptBody) {
            return this.createScriptBodyAst(scriptBody);
        }
        return SlimeAstCreateUtil.createProgram([], 'script');
    }
    /**
     * ScriptBody CST ?AST
     */ createScriptBodyAst(cst) {
        const stmtList = cst.children?.find((ch)=>ch.name === 'StatementList' || ch.name === _SlimeParser$1.prototype.StatementList?.name);
        if (stmtList) {
            const body = this.createStatementListAst(stmtList);
            return SlimeAstCreateUtil.createProgram(body, 'script');
        }
        return SlimeAstCreateUtil.createProgram([], 'script');
    }
    /**
     * Module CST ?AST
     */ createModuleAst(cst) {
        const moduleBody = cst.children?.find((ch)=>ch.name === 'ModuleBody' || ch.name === _SlimeParser$1.prototype.ModuleBody?.name);
        if (moduleBody) {
            return this.createModuleBodyAst(moduleBody);
        }
        return SlimeAstCreateUtil.createProgram([], 'module');
    }
    /**
     * ModuleBody CST ?AST
     */ createModuleBodyAst(cst) {
        const moduleItemList = cst.children?.find((ch)=>ch.name === 'ModuleItemList' || ch.name === _SlimeParser$1.prototype.ModuleItemList?.name);
        if (moduleItemList) {
            const body = this.createModuleItemListAst(moduleItemList);
            return SlimeAstCreateUtil.createProgram(body, 'module');
        }
        return SlimeAstCreateUtil.createProgram([], 'module');
    }
    /**
     * NameSpaceImport CST ?AST
     * NameSpaceImport -> * as ImportedBinding
     */ createNameSpaceImportAst(cst) {
        // NameSpaceImport: Asterisk as ImportedBinding
        // children: [Asterisk, AsTok, ImportedBinding]
        let asteriskToken = undefined;
        let asToken = undefined;
        for (const child of cst.children){
            if (child.name === 'Asterisk' || child.value === '*') {
                asteriskToken = SlimeTokenCreate.createAsteriskToken(child.loc);
            } else if (child.name === 'As' || child.value === 'as') {
                asToken = SlimeTokenCreate.createAsToken(child.loc);
            }
        }
        const binding = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ImportedBinding?.name);
        if (!binding) throw new Error('NameSpaceImport missing ImportedBinding');
        const local = this.createImportedBindingAst(binding);
        return SlimeAstCreateUtil.createImportNamespaceSpecifier(local, cst.loc, asteriskToken, asToken);
    }
    /**
     * NamedImports CST  AST
     * NamedImports -> { } | { ImportsList } | { ImportsList , }
     */ createNamedImportsAst(cst) {
        // NamedImports: {LBrace, ImportsList?, RBrace}
        const importsList = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ImportsList?.name);
        if (!importsList) return [];
        const specifiers = [];
        for (const child of importsList.children){
            if (child.name === _SlimeParser$1.prototype.ImportSpecifier?.name) {
                // ImportSpecifier
                // 1. ImportedBinding 
                // 2. IdentifierName AsTok ImportedBinding 
                const identifierName = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.IdentifierName?.name);
                const binding = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ImportedBinding?.name);
                if (identifierName && binding) {
                    // import {name as localName}  import {default as MyClass} - 
                    const imported = this.createIdentifierNameAst(identifierName);
                    const local = this.createImportedBindingAst(binding);
                    specifiers.push({
                        type: SlimeNodeType.ImportSpecifier,
                        imported: imported,
                        local: local,
                        loc: child.loc
                    });
                } else if (binding) {
                    // import {name} - 
                    const id = this.createImportedBindingAst(binding);
                    specifiers.push({
                        type: SlimeNodeType.ImportSpecifier,
                        imported: id,
                        local: id,
                        loc: child.loc
                    });
                }
            }
        }
        return specifiers;
    }
    /**
     * ImportsList CST ?AST
     * ImportsList -> ImportSpecifier (, ImportSpecifier)*
     */ createImportsListAst(cst) {
        const specifiers = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.ImportSpecifier?.name || child.name === 'ImportSpecifier') {
                specifiers.push(this.createImportSpecifierAst(child));
            }
        }
        return specifiers;
    }
    /**
     * ImportSpecifier CST ?AST
     * ImportSpecifier -> ImportedBinding | ModuleExportName as ImportedBinding
     */ createImportSpecifierAst(cst) {
        const children = cst.children || [];
        let imported = null;
        let local = null;
        let asToken = undefined;
        for (const child of children){
            if (child.name === 'As' || child.value === 'as') {
                asToken = SlimeTokenCreate.createAsToken(child.loc);
            } else if (child.name === _SlimeParser$1.prototype.ImportedBinding?.name || child.name === 'ImportedBinding') {
                local = this.createImportedBindingAst(child);
            } else if (child.name === _SlimeParser$1.prototype.ModuleExportName?.name || child.name === 'ModuleExportName' || child.name === _SlimeParser$1.prototype.IdentifierName?.name || child.name === 'IdentifierName') {
                if (!imported) {
                    imported = this.createModuleExportNameAst(child);
                }
            }
        }
        //  asimported ?local 
        if (!local && imported) {
            local = {
                ...imported
            };
        }
        if (!imported && local) {
            imported = {
                ...local
            };
        }
        return SlimeAstCreateUtil.createImportSpecifier(imported, local, asToken);
    }
    /**
     * AttributeKey CST ?AST
     * AttributeKey -> IdentifierName | StringLiteral
     */ createAttributeKeyAst(cst) {
        const firstChild = cst.children?.[0];
        if (!firstChild) throw new Error('AttributeKey has no children');
        if (firstChild.name === _SlimeParser$1.prototype.IdentifierName?.name || firstChild.name === 'IdentifierName' || firstChild.value !== undefined && !firstChild.value.startsWith('"') && !firstChild.value.startsWith("'")) {
            return this.createIdentifierNameAst(firstChild);
        } else {
            return this.createStringLiteralAst(firstChild);
        }
    }
    /**
     * ExportFromClause CST ?AST
     * ExportFromClause -> * | * as ModuleExportName | NamedExports
     */ createExportFromClauseAst(cst) {
        const children = cst.children || [];
        //  * (export all)
        const asterisk = children.find((ch)=>ch.name === 'Asterisk' || ch.value === '*');
        if (asterisk) {
            const asTok = children.find((ch)=>ch.name === 'As' || ch.value === 'as');
            const exportedName = children.find((ch)=>ch.name === _SlimeParser$1.prototype.ModuleExportName?.name || ch.name === 'ModuleExportName');
            if (asTok && exportedName) {
                // * as name
                return {
                    type: 'exportAll',
                    exported: this.createModuleExportNameAst(exportedName)
                };
            } else {
                // * (export all)
                return {
                    type: 'exportAll',
                    exported: null
                };
            }
        }
        // NamedExports
        const namedExports = children.find((ch)=>ch.name === _SlimeParser$1.prototype.NamedExports?.name || ch.name === 'NamedExports');
        if (namedExports) {
            return {
                type: 'namedExports',
                specifiers: this.createNamedExportsAst(namedExports)
            };
        }
        return {
            type: 'unknown'
        };
    }
    /**
     * WithEntries CST ?AST
     * WithEntries -> AttributeKey : StringLiteral (, AttributeKey : StringLiteral)*
     */ createWithEntriesAst(cst) {
        const entries = [];
        let currentKey = null;
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.AttributeKey?.name || child.name === 'AttributeKey') {
                currentKey = this.createAttributeKeyAst(child);
            } else if (child.name === 'StringLiteral' || child.value && (child.value.startsWith('"') || child.value.startsWith("'"))) {
                if (currentKey) {
                    entries.push({
                        type: 'ImportAttribute',
                        key: currentKey,
                        value: this.createStringLiteralAst(child)
                    });
                    currentKey = null;
                }
            }
        }
        return entries;
    }
    createModuleItemAst(item) {
        const name = item.name;
        if (name === _SlimeParser$1.prototype.ExportDeclaration?.name || name === 'ExportDeclaration') {
            return this.createExportDeclarationAst(item);
        } else if (name === _SlimeParser$1.prototype.ImportDeclaration?.name || name === 'ImportDeclaration') {
            return this.createImportDeclarationAst(item);
        } else if (name === _SlimeParser$1.prototype.StatementListItem?.name || name === 'StatementListItem') {
            return this.createStatementListItemAst(item);
        }
        console.warn(`createModuleItemAst: Unknown item type: ${name}`);
        return undefined;
    }
    createImportDeclarationAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ImportDeclaration?.name);
        const first = cst.children[0];
        const first1 = cst.children[1];
        let importDeclaration;
        // Token fields
        let importToken = undefined;
        let semicolonToken = undefined;
        //  import token
        if (first && (first.name === 'Import' || first.value === 'import')) {
            importToken = SlimeTokenCreate.createImportToken(first.loc);
        }
        //  semicolon
        const semicolonCst = cst.children.find((ch)=>ch.name === 'Semicolon' || ch.value === ';');
        if (semicolonCst) {
            semicolonToken = SlimeTokenCreate.createSemicolonToken(semicolonCst.loc);
        }
        //  WithClause (ES2025 Import Attributes)
        const withClauseCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.WithClause?.name || ch.name === 'WithClause');
        let attributes = [];
        let withToken = undefined;
        if (withClauseCst) {
            const parsed = this.createWithClauseAst(withClauseCst);
            attributes = parsed.attributes;
            withToken = parsed.withToken;
        }
        if (first1.name === _SlimeParser$1.prototype.ImportClause?.name) {
            const clauseResult = this.createImportClauseAst(first1);
            const fromClause = this.createFromClauseAst(cst.children[2]);
            importDeclaration = SlimeAstCreateUtil.createImportDeclaration(clauseResult.specifiers, fromClause.source, cst.loc, importToken, fromClause.fromToken, clauseResult.lBraceToken, clauseResult.rBraceToken, semicolonToken, attributes, withToken);
        } else if (first1.name === _SlimeParser$1.prototype.ModuleSpecifier?.name) {
            // import 'module' (side effect import) ?import 'module' with {...}
            const source = this.createModuleSpecifierAst(first1);
            importDeclaration = SlimeAstCreateUtil.createImportDeclaration([], source, cst.loc, importToken, undefined, undefined, undefined, semicolonToken, attributes, withToken);
        }
        return importDeclaration;
    }
    /**  WithClause: with { type: "json" } */ createWithClauseAst(cst) {
        // WithClause: With, LBrace, WithEntries?, RBrace
        let withToken = undefined;
        const attributes = [];
        for (const child of cst.children || []){
            if (child.name === 'With' || child.value === 'with') {
                withToken = {
                    type: 'With',
                    value: 'with',
                    loc: child.loc
                };
            } else if (child.name === _SlimeParser$1.prototype.WithEntries?.name || child.name === 'WithEntries') {
                // WithEntries  AttributeKey, Colon, StringLiteral, 
                let currentKey = null;
                for (const entry of child.children || []){
                    if (entry.name === _SlimeParser$1.prototype.AttributeKey?.name || entry.name === 'AttributeKey') {
                        // AttributeKey ?IdentifierName ?StringLiteral
                        const keyChild = entry.children?.[0];
                        if (keyChild) {
                            if (keyChild.name === 'IdentifierName' || keyChild.name === _SlimeParser$1.prototype.IdentifierName?.name) {
                                const nameToken = keyChild.children?.[0];
                                currentKey = {
                                    type: SlimeNodeType.Identifier,
                                    name: nameToken?.value || keyChild.value,
                                    loc: keyChild.loc
                                };
                            } else if (keyChild.name === 'StringLiteral' || keyChild.value?.startsWith('"') || keyChild.value?.startsWith("'")) {
                                currentKey = this.createStringLiteralAst(keyChild);
                            }
                        }
                    } else if (entry.name === 'StringLiteral' || entry.value?.startsWith('"') || entry.value?.startsWith("'")) {
                        //  attribute ?
                        if (currentKey) {
                            attributes.push({
                                type: 'ImportAttribute',
                                key: currentKey,
                                value: this.createStringLiteralAst(entry),
                                loc: {
                                    ...currentKey.loc,
                                    end: entry.loc?.end
                                }
                            });
                            currentKey = null;
                        }
                    }
                //  Colon ?Comma
                }
            }
        }
        return {
            attributes,
            withToken
        };
    }
    createFromClauseAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.FromClause?.name);
        const first = cst.children[0];
        const ModuleSpecifier = this.createModuleSpecifierAst(cst.children[1]);
        //  from token
        let fromToken = undefined;
        if (first && (first.name === 'From' || first.value === 'from')) {
            fromToken = SlimeTokenCreate.createFromToken(first.loc);
        }
        return {
            source: ModuleSpecifier,
            fromToken: fromToken
        };
    }
    createModuleSpecifierAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ModuleSpecifier?.name);
        const first = cst.children[0];
        const ast = SlimeAstCreateUtil.createStringLiteral(first.value);
        return ast;
    }
    createImportClauseAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ImportClause?.name);
        const result = [];
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.ImportedDefaultBinding?.name) {
            // 
            const specifier = this.createImportedDefaultBindingAst(first);
            // 
            const commaCst = cst.children.find((ch)=>ch.name === 'Comma' || ch.value === ',');
            const commaToken = commaCst ? SlimeTokenCreate.createCommaToken(commaCst.loc) : undefined;
            result.push(SlimeAstCreateUtil.createImportSpecifierItem(specifier, commaToken));
            // ?NamedImports ?NameSpaceImport
            const namedImportsCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.NamedImports?.name || ch.name === 'NamedImports');
            const namespaceImportCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.NameSpaceImport?.name || ch.name === 'NameSpaceImport');
            if (namedImportsCst) {
                const namedResult = this.createNamedImportsListAstWrapped(namedImportsCst);
                result.push(...namedResult.specifiers);
                lBraceToken = namedResult.lBraceToken;
                rBraceToken = namedResult.rBraceToken;
            } else if (namespaceImportCst) {
                result.push(SlimeAstCreateUtil.createImportSpecifierItem(this.createNameSpaceImportAst(namespaceImportCst), undefined));
            }
        } else if (first.name === _SlimeParser$1.prototype.NameSpaceImport?.name) {
            // import * as name from 'module'
            result.push(SlimeAstCreateUtil.createImportSpecifierItem(this.createNameSpaceImportAst(first), undefined));
        } else if (first.name === _SlimeParser$1.prototype.NamedImports?.name) {
            // import {name, greet} from 'module'
            const namedResult = this.createNamedImportsListAstWrapped(first);
            result.push(...namedResult.specifiers);
            lBraceToken = namedResult.lBraceToken;
            rBraceToken = namedResult.rBraceToken;
        }
        return {
            specifiers: result,
            lBraceToken,
            rBraceToken
        };
    }
    createImportedDefaultBindingAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ImportedDefaultBinding?.name);
        const first = cst.children[0];
        const id = this.createImportedBindingAst(first);
        const importDefaultSpecifier = SlimeAstCreateUtil.createImportDefaultSpecifier(id);
        return importDefaultSpecifier;
    }
    createImportedBindingAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ImportedBinding?.name);
        const first = cst.children[0];
        return this.createBindingIdentifierAst(first);
    }
    /**  brace tokens */ createNamedImportsListAstWrapped(cst) {
        // NamedImports: {LBrace, ImportsList?, RBrace}
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        //  brace tokens
        for (const child of cst.children || []){
            if (child.name === 'LBrace' || child.value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
            } else if (child.name === 'RBrace' || child.value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
            }
        }
        const importsList = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ImportsList?.name);
        // ?import {} from "foo" - ?specifiers  brace tokens
        if (!importsList) return {
            specifiers: [],
            lBraceToken,
            rBraceToken
        };
        const specifiers = [];
        let currentSpec = null;
        let hasSpec = false;
        for(let i = 0; i < importsList.children.length; i++){
            const child = importsList.children[i];
            if (child.name === _SlimeParser$1.prototype.ImportSpecifier?.name) {
                // ?specifier 
                if (hasSpec) {
                    specifiers.push(SlimeAstCreateUtil.createImportSpecifierItem(currentSpec, undefined));
                }
                // ES2025: ImportSpecifier ?
                // 1. ModuleExportName "as" ImportedBinding ()
                // 2. ImportedBinding (?
                const moduleExportName = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ModuleExportName?.name || ch.name === 'ModuleExportName');
                const binding = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ImportedBinding?.name || ch.name === 'ImportedBinding');
                if (moduleExportName && binding) {
                    // : import { foo as bar }
                    const imported = this.createModuleExportNameAst(moduleExportName);
                    const local = this.createImportedBindingAst(binding);
                    currentSpec = {
                        type: SlimeNodeType.ImportSpecifier,
                        imported: imported,
                        local: local,
                        loc: child.loc
                    };
                } else if (binding) {
                    // ? import { foo }
                    const id = this.createImportedBindingAst(binding);
                    currentSpec = {
                        type: SlimeNodeType.ImportSpecifier,
                        imported: id,
                        local: id,
                        loc: child.loc
                    };
                }
                hasSpec = true;
            } else if (child.name === 'Comma' || child.value === ',') {
                //  specifier 
                if (hasSpec) {
                    const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    specifiers.push(SlimeAstCreateUtil.createImportSpecifierItem(currentSpec, commaToken));
                    hasSpec = false;
                    currentSpec = null;
                }
            }
        }
        // ?specifier?
        if (hasSpec) {
            specifiers.push(SlimeAstCreateUtil.createImportSpecifierItem(currentSpec, undefined));
        }
        return {
            specifiers,
            lBraceToken,
            rBraceToken
        };
    }
    createIdentifierNameAst(cst) {
        // IdentifierName ?
        // 1. ?value ?token
        // 2. 
        // ?value
        if (cst.value !== undefined) {
            const decodedName = decodeUnicodeEscapes(cst.value);
            return SlimeAstCreateUtil.createIdentifier(decodedName, cst.loc);
        }
        //  value
        let current = cst;
        while(current.children && current.children.length > 0 && current.value === undefined){
            current = current.children[0];
        }
        if (current.value !== undefined) {
            const decodedName = decodeUnicodeEscapes(current.value);
            return SlimeAstCreateUtil.createIdentifier(decodedName, current.loc || cst.loc);
        }
        throw new Error(`createIdentifierNameAst: Cannot extract value from IdentifierName`);
    }
    createBindingIdentifierAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BindingIdentifier?.name);
        // BindingIdentifier ?
        // ES2025: BindingIdentifier -> Identifier -> IdentifierNameTok
        // ? BindingIdentifier -> YieldTok | AwaitTok
        const first = cst.children[0];
        // ?Identifier 
        if (first.name === 'Identifier' || first.name === _SlimeParser$1.prototype.Identifier?.name) {
            // Identifier  IdentifierNameTok
            const tokenCst = first.children?.[0];
            if (tokenCst && tokenCst.value !== undefined) {
                return SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
            }
        }
        // ?token YieldTok, AwaitTok,  token?
        if (first.value !== undefined) {
            return SlimeAstCreateUtil.createIdentifier(first.value, first.loc);
        }
        throw new Error(`createBindingIdentifierAst: Cannot extract identifier value from ${first.name}`);
    }
    /*createImportClauseAst(cst: SubhutiCst.ts):Array<SlimeImportSpecifier | SlimeImportDefaultSpecifier | SlimeImportNamespaceSpecifier>{
    let astName = checkCstName(cst, Es2025Parser.prototype.ImportClause?.name);


  }*/ createStatementListAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.StatementList?.name);
        if (cst.children) {
            const statements = cst.children.map((item)=>this.createStatementListItemAst(item)).flat();
            return statements;
        }
        return [];
    }
    createStatementListItemAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.StatementListItem?.name);
        const statements = cst.children.map((item)=>{
            // ?Declaration?
            if (item.name === _SlimeParser$1.prototype.Declaration?.name) {
                return [
                    this.createDeclarationAst(item)
                ];
            }
            // ?Statement?FunctionExpression ?ClassExpression
            const statement = this.createStatementAst(item);
            const result = statement.flat();
            // ?FunctionExpression ?ClassExpression?Declaration?
            return result.map((stmt)=>{
                if (stmt.type === SlimeNodeType.ExpressionStatement) {
                    const expr = stmt.expression;
                    // ?FunctionExpression ?FunctionDeclaration
                    if (expr.type === SlimeNodeType.FunctionExpression) {
                        const funcExpr = expr;
                        if (funcExpr.id) {
                            return {
                                type: SlimeNodeType.FunctionDeclaration,
                                id: funcExpr.id,
                                params: funcExpr.params,
                                body: funcExpr.body,
                                generator: funcExpr.generator,
                                async: funcExpr.async,
                                loc: funcExpr.loc
                            };
                        }
                    }
                    // ClassExpression ?ClassDeclaration
                    if (expr.type === SlimeNodeType.ClassExpression) {
                        const classExpr = expr;
                        if (classExpr.id) {
                            return {
                                type: SlimeNodeType.ClassDeclaration,
                                id: classExpr.id,
                                superClass: classExpr.superClass,
                                body: classExpr.body,
                                loc: classExpr.loc
                            };
                        }
                    }
                }
                return stmt;
            });
        }).flat();
        return statements;
    }
    createStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Statement?.name);
        const statements = cst.children.map((item)=>this.createStatementDeclarationAst(item)).filter((stmt)=>stmt !== undefined) // ?undefined
        ;
        return statements;
    }
    /**
     * []  CST ?Statement/Declaration AST
     *
     * ECMAScript ?Statement ?Declaration 
     * ?
     *
     * 
     * - Statement  ??
     * - BreakableStatement ?IterationStatement | SwitchStatement
     * - VariableStatement ?VariableDeclaration
     * - ExpressionStatement ?ExpressionStatement
     * - IfStatement, ForStatement, WhileStatement ?
     * - FunctionDeclaration, ClassDeclaration ?
     */ createStatementDeclarationAst(cst) {
        // Statement - ?
        if (cst.name === _SlimeParser$1.prototype.Statement?.name || cst.name === 'Statement') {
            if (cst.children && cst.children.length > 0) {
                return this.createStatementDeclarationAst(cst.children[0]);
            }
            return undefined;
        } else if (cst.name === _SlimeParser$1.prototype.BreakableStatement?.name) {
            if (cst.children && cst.children.length > 0) {
                return this.createStatementDeclarationAst(cst.children[0]);
            }
            return undefined;
        } else if (cst.name === _SlimeParser$1.prototype.IterationStatement?.name) {
            if (cst.children && cst.children.length > 0) {
                return this.createStatementDeclarationAst(cst.children[0]);
            }
            return undefined;
        } else if (cst.name === 'IfStatementBody') {
            if (cst.children && cst.children.length > 0) {
                return this.createStatementDeclarationAst(cst.children[0]);
            }
            return undefined;
        } else if (cst.name === _SlimeParser$1.prototype.VariableStatement?.name || cst.name === 'VariableStatement') {
            return this.createVariableStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.VariableDeclaration?.name) {
            return this.createVariableDeclarationAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ExpressionStatement?.name) {
            return this.createExpressionStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ReturnStatement?.name) {
            return this.createReturnStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.IfStatement?.name) {
            return this.createIfStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ForStatement?.name) {
            return this.createForStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ForInOfStatement?.name) {
            return this.createForInOfStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.WhileStatement?.name) {
            return this.createWhileStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.DoWhileStatement?.name) {
            return this.createDoWhileStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.BlockStatement?.name) {
            return this.createBlockStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.SwitchStatement?.name) {
            return this.createSwitchStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.TryStatement?.name) {
            return this.createTryStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ThrowStatement?.name) {
            return this.createThrowStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.BreakStatement?.name) {
            return this.createBreakStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ContinueStatement?.name) {
            return this.createContinueStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.LabelledStatement?.name) {
            return this.createLabelledStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.WithStatement?.name) {
            return this.createWithStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.DebuggerStatement?.name) {
            return this.createDebuggerStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.EmptyStatement?.name) {
            return this.createEmptyStatementAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.FunctionDeclaration?.name) {
            return this.createFunctionDeclarationAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ClassDeclaration?.name) {
            return this.createClassDeclarationAst(cst);
        }
    }
    createExportDeclarationAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ExportDeclaration?.name);
        const children = cst.children || [];
        // Token fields
        let exportToken = undefined;
        let defaultToken = undefined;
        let asteriskToken = undefined;
        let semicolonToken = undefined;
        let asToken = undefined;
        // ?
        let exportFromClause = null;
        let fromClause = null;
        let namedExports = null;
        let variableStatement = null;
        let declaration = null;
        let hoistableDeclaration = null;
        let classDeclaration = null;
        let assignmentExpression = null;
        let withClauseCst = null;
        let isDefault = false;
        for (const child of children){
            const name = child.name;
            if (name === SlimeTokenConsumer.prototype.Export?.name || child.value === 'export') {
                exportToken = SlimeTokenCreate.createExportToken(child.loc);
            } else if (name === SlimeTokenConsumer.prototype.Default?.name || child.value === 'default') {
                defaultToken = SlimeTokenCreate.createDefaultToken(child.loc);
                isDefault = true;
            } else if (name === SlimeTokenConsumer.prototype.Asterisk?.name || child.value === '*') {
                asteriskToken = SlimeTokenCreate.createAsteriskToken(child.loc);
            } else if (name === SlimeTokenConsumer.prototype.Semicolon?.name || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (name === SlimeTokenConsumer.prototype.As?.name || child.value === 'as') {
                asToken = SlimeTokenCreate.createAsToken(child.loc);
            } else if (name === _SlimeParser$1.prototype.ExportFromClause?.name) {
                exportFromClause = child;
            } else if (name === _SlimeParser$1.prototype.FromClause?.name) {
                fromClause = child;
            } else if (name === _SlimeParser$1.prototype.NamedExports?.name) {
                namedExports = child;
            } else if (name === _SlimeParser$1.prototype.VariableStatement?.name) {
                variableStatement = child;
            } else if (name === _SlimeParser$1.prototype.Declaration?.name) {
                declaration = child;
            } else if (name === _SlimeParser$1.prototype.HoistableDeclaration?.name) {
                hoistableDeclaration = child;
            } else if (name === _SlimeParser$1.prototype.ClassDeclaration?.name) {
                classDeclaration = child;
            } else if (name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                assignmentExpression = child;
            } else if (name === _SlimeParser$1.prototype.WithClause?.name || name === 'WithClause') {
                withClauseCst = child;
            }
        }
        //  WithClause (ES2025 Import Attributes)
        let attributes = [];
        let withToken = undefined;
        if (withClauseCst) {
            const parsed = this.createWithClauseAst(withClauseCst);
            attributes = parsed.attributes;
            withToken = parsed.withToken;
        }
        // export default ...
        if (isDefault) {
            let decl = null;
            if (hoistableDeclaration) {
                decl = this.createHoistableDeclarationAst(hoistableDeclaration);
            } else if (classDeclaration) {
                decl = this.createClassDeclarationAst(classDeclaration);
            } else if (assignmentExpression) {
                decl = this.createAssignmentExpressionAst(assignmentExpression);
            }
            return SlimeAstCreateUtil.createExportDefaultDeclaration(decl, cst.loc, exportToken, defaultToken);
        }
        // export ExportFromClause FromClause ; (export * from ... or export { } from ...)
        if (exportFromClause && fromClause) {
            const fromClauseResult = this.createFromClauseAst(fromClause);
            // Check if it's export * or export * as name
            const hasAsterisk = exportFromClause.children?.some((ch)=>ch.name === SlimeTokenConsumer.prototype.Asterisk?.name || ch.value === '*');
            if (hasAsterisk) {
                // export * from ... or export * as name from ...
                let exported = null;
                const moduleExportName = exportFromClause.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.ModuleExportName?.name);
                if (moduleExportName) {
                    exported = this.createModuleExportNameAst(moduleExportName);
                }
                const result = SlimeAstCreateUtil.createExportAllDeclaration(fromClauseResult.source, exported, cst.loc, exportToken, asteriskToken, asToken, fromClauseResult.fromToken, semicolonToken);
                //  attributes withToken?attributes ?
                if (withToken) {
                    result.attributes = attributes;
                    result.withToken = withToken;
                }
                return result;
            } else {
                // export { ... } from ...
                // exportFromClause  [NamedExports]?NamedExports
                const namedExportsCst = exportFromClause.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.NamedExports?.name || ch.name === 'NamedExports');
                const specifiers = namedExportsCst ? this.createNamedExportsAst(namedExportsCst) : [];
                const result = SlimeAstCreateUtil.createExportNamedDeclaration(null, specifiers, fromClauseResult.source, cst.loc, exportToken, fromClauseResult.fromToken, semicolonToken);
                //  attributes withToken?attributes ?
                if (withToken) {
                    result.attributes = attributes;
                    result.withToken = withToken;
                }
                return result;
            }
        }
        // export NamedExports ; (export { ... })
        if (namedExports) {
            const specifiers = this.createNamedExportsAst(namedExports);
            return SlimeAstCreateUtil.createExportNamedDeclaration(null, specifiers, null, cst.loc, exportToken, undefined, semicolonToken);
        }
        // export VariableStatement
        if (variableStatement) {
            const decl = this.createVariableStatementAst(variableStatement);
            return SlimeAstCreateUtil.createExportNamedDeclaration(decl, [], null, cst.loc, exportToken);
        }
        // export Declaration
        if (declaration) {
            const decl = this.createDeclarationAst(declaration);
            return SlimeAstCreateUtil.createExportNamedDeclaration(decl, [], null, cst.loc, exportToken);
        }
        throw new Error(`Unsupported export declaration structure`);
    }
    /**
     *  NamedExports AST (export { a, b, c })
     */ createNamedExportsAst(cst) {
        // NamedExports: { ExportsList? }
        const specifiers = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.ExportsList?.name) {
                return this.createExportsListAst(child);
            } else if (child.name === _SlimeParser$1.prototype.ExportSpecifier?.name) {
                specifiers.push({
                    specifier: this.createExportSpecifierAst(child)
                });
            }
        }
        return specifiers;
    }
    /**
     *  ExportsList AST
     */ createExportsListAst(cst) {
        const specifiers = [];
        let lastSpecifier = null;
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.ExportSpecifier?.name) {
                if (lastSpecifier) {
                    specifiers.push({
                        specifier: lastSpecifier
                    });
                }
                lastSpecifier = this.createExportSpecifierAst(child);
            } else if (child.name === SlimeTokenConsumer.prototype.Comma?.name || child.value === ',') {
                if (lastSpecifier) {
                    specifiers.push({
                        specifier: lastSpecifier,
                        commaToken: SlimeTokenCreate.createCommaToken(child.loc)
                    });
                    lastSpecifier = null;
                }
            }
        }
        if (lastSpecifier) {
            specifiers.push({
                specifier: lastSpecifier
            });
        }
        return specifiers;
    }
    /**
     *  ExportSpecifier AST
     */ createExportSpecifierAst(cst) {
        // ExportSpecifier: ModuleExportName | ModuleExportName as ModuleExportName
        const children = cst.children || [];
        let local = null;
        let exported = null;
        let asToken = undefined;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.name === _SlimeParser$1.prototype.ModuleExportName?.name) {
                if (!local) {
                    local = this.createModuleExportNameAst(child);
                } else {
                    exported = this.createModuleExportNameAst(child);
                }
            } else if (child.name === SlimeTokenConsumer.prototype.As?.name || child.value === 'as') {
                asToken = SlimeTokenCreate.createAsToken(child.loc);
            }
        }
        // If no 'as', exported is same as local
        if (!exported) {
            exported = local;
        }
        return SlimeAstCreateUtil.createExportSpecifier(local, exported, cst.loc, asToken);
    }
    /**
     *  ModuleExportName AST
     */ createModuleExportNameAst(cst) {
        const first = cst.children?.[0];
        if (!first) {
            throw new Error('ModuleExportName has no children');
        }
        if (first.name === _SlimeParser$1.prototype.IdentifierName?.name) {
            return this.createIdentifierNameAst(first);
        } else if (first.name === SlimeTokenConsumer.prototype.StringLiteral?.name) {
            return SlimeAstCreateUtil.createStringLiteral(first.value, first.loc);
        } else {
            // Direct token
            return SlimeAstCreateUtil.createIdentifier(first.value, first.loc);
        }
    }
    createDeclarationAst(cst) {
        // Support both Declaration wrapper and direct types
        const first = cst.name === _SlimeParser$1.prototype.Declaration?.name || cst.name === 'Declaration' ? cst.children[0] : cst;
        const name = first.name;
        if (name === _SlimeParser$1.prototype.VariableDeclaration?.name || name === 'VariableDeclaration') {
            return this.createVariableDeclarationAst(first);
        } else if (name === _SlimeParser$1.prototype.LexicalDeclaration?.name || name === 'LexicalDeclaration') {
            // LexicalDeclaration: let/const declarations
            return this.createLexicalDeclarationAst(first);
        } else if (name === _SlimeParser$1.prototype.ClassDeclaration?.name || name === 'ClassDeclaration') {
            return this.createClassDeclarationAst(first);
        } else if (name === _SlimeParser$1.prototype.FunctionDeclaration?.name || name === 'FunctionDeclaration') {
            return this.createFunctionDeclarationAst(first);
        } else if (name === _SlimeParser$1.prototype.HoistableDeclaration?.name || name === 'HoistableDeclaration') {
            return this.createHoistableDeclarationAst(first);
        } else {
            throw new Error(`Unsupported Declaration type: ${name}`);
        }
    }
    createLexicalDeclarationAst(cst) {
        // ES2025 LexicalDeclaration: LetOrConst BindingList ;
        // BindingList: LexicalBinding (, LexicalBinding)*
        // LexicalBinding: BindingIdentifier Initializer? | BindingPattern Initializer
        const children = cst.children || [];
        let kind = 'const' // ?
        ;
        const declarations = [];
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            // Skip tokens (semicolons, commas)
            if (child.loc?.type === 'Semicolon' || child.value === ';' || child.value === ',') {
                continue;
            }
            // LetOrConst 
            if (name === _SlimeParser$1.prototype.LetOrConst?.name || name === 'LetOrConst') {
                // ?LetTok ?ConstTok
                if (child.children && child.children.length > 0) {
                    const tokenCst = child.children[0];
                    kind = tokenCst.value || 'const';
                }
                continue;
            }
            // ?LetTok ?ConstTok (ES2025 )
            if (name === 'Let' || child.value === 'let') {
                kind = 'let';
                continue;
            }
            if (name === 'Const' || child.value === 'const') {
                kind = 'const';
                continue;
            }
            // Handle BindingList wrapper
            if (name === 'BindingList' || name === _SlimeParser$1.prototype.BindingList?.name) {
                for (const binding of child.children || []){
                    if (binding.name === 'LexicalBinding' || binding.name === _SlimeParser$1.prototype.LexicalBinding?.name) {
                        declarations.push(this.createLexicalBindingAst(binding));
                    }
                    // Skip commas
                    if (binding.value === ',') continue;
                }
                continue;
            }
            // Direct LexicalBinding
            if (name === 'LexicalBinding' || name === _SlimeParser$1.prototype.LexicalBinding?.name) {
                declarations.push(this.createLexicalBindingAst(child));
            }
        }
        return {
            type: SlimeNodeType.VariableDeclaration,
            kind: kind,
            declarations: declarations,
            loc: cst.loc
        };
    }
    createLexicalBindingAst(cst) {
        // LexicalBinding: BindingIdentifier Initializer? | BindingPattern Initializer
        const children = cst.children || [];
        let id = null;
        let init = null;
        let assignToken = undefined;
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                id = this.createBindingIdentifierAst(child);
            } else if (name === _SlimeParser$1.prototype.BindingPattern?.name || name === 'BindingPattern') {
                id = this.createBindingPatternAst(child);
            } else if (name === _SlimeParser$1.prototype.Initializer?.name || name === 'Initializer') {
                // Initializer: = AssignmentExpression
                // children[0] ?Assign tokenchildren[1] ?AssignmentExpression
                if (child.children && child.children[0]) {
                    const assignCst = child.children[0];
                    assignToken = SlimeTokenCreate.createAssignToken(assignCst.loc);
                }
                init = this.createInitializerAst(child);
            }
        }
        return SlimeAstCreateUtil.createVariableDeclarator(id, assignToken, init, cst.loc);
    }
    /**
     *  var  AST
     * ES2025 VariableStatement: var VariableDeclarationList ;
     */ createVariableStatementAst(cst) {
        const children = cst.children || [];
        const declarations = [];
        //  VariableDeclarationList
        for (const child of children){
            if (!child) continue;
            if (child.name === _SlimeParser$1.prototype.VariableDeclarationList?.name || child.name === 'VariableDeclarationList') {
                // VariableDeclarationList  VariableDeclaration
                for (const varDeclCst of child.children || []){
                    if (varDeclCst.name === _SlimeParser$1.prototype.VariableDeclaration?.name || varDeclCst.name === 'VariableDeclaration') {
                        declarations.push(this.createVariableDeclaratorFromVarDeclaration(varDeclCst));
                    }
                }
            }
        }
        return {
            type: SlimeNodeType.VariableDeclaration,
            kind: 'var',
            declarations: declarations,
            loc: cst.loc
        };
    }
    /**
     * ?VariableDeclaration CST  VariableDeclarator AST
     * VariableDeclaration: BindingIdentifier Initializer? | BindingPattern Initializer
     */ createVariableDeclaratorFromVarDeclaration(cst) {
        const children = cst.children || [];
        let id = null;
        let init = null;
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                id = this.createBindingIdentifierAst(child);
            } else if (name === _SlimeParser$1.prototype.BindingPattern?.name || name === 'BindingPattern') {
                id = this.createBindingPatternAst(child);
            } else if (name === _SlimeParser$1.prototype.Initializer?.name || name === 'Initializer') {
                init = this.createInitializerAst(child);
            }
        }
        return {
            type: SlimeNodeType.VariableDeclarator,
            id: id,
            init: init,
            loc: cst.loc
        };
    }
    createHoistableDeclarationAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.HoistableDeclaration?.name);
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.FunctionDeclaration?.name || first.name === 'FunctionDeclaration') {
            return this.createFunctionDeclarationAst(first);
        } else if (first.name === _SlimeParser$1.prototype.GeneratorDeclaration?.name || first.name === 'GeneratorDeclaration') {
            // GeneratorDeclaration -> FunctionDeclaration*?
            return this.createGeneratorDeclarationAst(first);
        } else if (first.name === _SlimeParser$1.prototype.AsyncFunctionDeclaration?.name || first.name === 'AsyncFunctionDeclaration') {
            // AsyncFunctionDeclaration -> async function
            return this.createAsyncFunctionDeclarationAst(first);
        } else if (first.name === _SlimeParser$1.prototype.AsyncGeneratorDeclaration?.name || first.name === 'AsyncGeneratorDeclaration') {
            // AsyncGeneratorDeclaration -> async function*
            return this.createAsyncGeneratorDeclarationAst(first);
        } else {
            throw new Error(`Unsupported HoistableDeclaration type: ${first.name}`);
        }
    }
    createGeneratorDeclarationAst(cst) {
        // GeneratorDeclaration: function* name(params) { body }
        //  CST children: [FunctionTok, Asterisk, BindingIdentifier, LParen, FormalParameterList?, RParen, FunctionBodyDefine]
        // Es2025 CST children: [FunctionTok, Asterisk, BindingIdentifier, LParen, FormalParameters?, RParen, LBrace, GeneratorBody, RBrace]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList ()
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListFromEs2025Wrapped(formalParams);
            }
        }
        //  GeneratorBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'GeneratorBody' || ch.name === _SlimeParser$1.prototype.GeneratorBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return {
            type: SlimeNodeType.FunctionDeclaration,
            id: id,
            params: params,
            body: body,
            generator: true,
            async: false,
            loc: cst.loc
        };
    }
    createAsyncFunctionDeclarationAst(cst) {
        // AsyncFunctionDeclaration: async function name(params) { body }
        // CST children: [AsyncTok, FunctionTok, BindingIdentifier, LParen, FormalParameters?, RParen, LBrace, AsyncFunctionBody, RBrace]
        // ? [AsyncTok, FunctionTok, BindingIdentifier, LParen, FormalParameterList?, RParen, FunctionBodyDefine]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListAstWrapped(formalParams);
            }
        }
        //  AsyncFunctionBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'AsyncFunctionBody' || ch.name === _SlimeParser$1.prototype.AsyncFunctionBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return SlimeAstCreateUtil.createFunctionDeclaration(id, params, body, false, true, cst.loc);
    }
    createAsyncGeneratorDeclarationAst(cst) {
        // AsyncGeneratorDeclaration: async function* name(params) { body }
        // CST children: [AsyncTok, FunctionTok, Asterisk, BindingIdentifier, LParen, FormalParameters?, RParen, LBrace, AsyncGeneratorBody, RBrace]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList ()
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListFromEs2025Wrapped(formalParams);
            }
        }
        //  AsyncGeneratorBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'AsyncGeneratorBody' || ch.name === _SlimeParser$1.prototype.AsyncGeneratorBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return {
            type: SlimeNodeType.FunctionDeclaration,
            id: id,
            params: params,
            body: body,
            generator: true,
            async: true,
            loc: cst.loc
        };
    }
    createVariableDeclarationAst(cst) {
        //
        //                 this.Statement()
        //                 this.Declaration()
        checkCstName$1(cst, _SlimeParser$1.prototype.VariableDeclaration?.name);
        let kindCst = cst.children[0].children[0];
        //  kind token
        let kindToken = undefined;
        const kindValue = kindCst.value;
        if (kindValue === 'var') {
            kindToken = SlimeTokenCreate.createVarToken(kindCst.loc);
        } else if (kindValue === 'let') {
            kindToken = SlimeTokenCreate.createLetToken(kindCst.loc);
        } else if (kindValue === 'const') {
            kindToken = SlimeTokenCreate.createConstToken(kindCst.loc);
        }
        let declarations = [];
        if (cst.children[1]) {
            declarations = this.createVariableDeclarationListAst(cst.children[1]);
        }
        return SlimeAstCreateUtil.createVariableDeclaration(kindToken, declarations, cst.loc);
    }
    createVariableDeclarationListAst(cst) {
        // VariableDeclaratorComma token?
        //  VariableDeclarator ?LexicalBinding
        let declarations = cst.children.filter((item)=>item.name === _SlimeParser$1.prototype.LexicalBinding?.name || item.name === 'VariableDeclarator').map((item)=>this.createVariableDeclaratorAst(item));
        return declarations;
    }
    createClassDeclarationAst(cst) {
        // ?CST ?ClassDeclaration
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassDeclaration?.name);
        // Token fields
        let classToken = undefined;
        let id = null;
        let classTailCst = null;
        //  class token?ClassTail
        for (const child of cst.children){
            const name = child.name;
            if (name === 'Class' || child.value === 'class') {
                classToken = SlimeTokenCreate.createClassToken(child.loc);
            } else if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                id = this.createBindingIdentifierAst(child);
            } else if (name === _SlimeParser$1.prototype.ClassTail?.name || name === 'ClassTail') {
                classTailCst = child;
            }
        }
        // ClassTail 
        if (!classTailCst) {
            throw new Error('ClassDeclaration missing ClassTail');
        }
        //  ClassTail
        const classTailResult = this.createClassTailAst(classTailCst);
        // ?AST id ?null?
        const ast = SlimeAstCreateUtil.createClassDeclaration(id, classTailResult.body, classTailResult.superClass, cst.loc, classToken, classTailResult.extendsToken);
        return ast;
    }
    createClassTailAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassTail?.name);
        let superClass = null // ?null
        ;
        let body = {
            type: SlimeNodeType.ClassBody,
            body: [],
            loc: cst.loc
        } // ?
        ;
        let extendsToken = undefined;
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        // ClassTail = ClassHeritage? { ClassBody? }
        //  children  ClassHeritage ?ClassBody
        for (const child of cst.children){
            if (child.name === _SlimeParser$1.prototype.ClassHeritage?.name) {
                const heritageResult = this.createClassHeritageAstWithToken(child);
                superClass = heritageResult.superClass;
                extendsToken = heritageResult.extendsToken;
            } else if (child.name === _SlimeParser$1.prototype.ClassBody?.name) {
                body = this.createClassBodyAst(child);
            } else if (child.name === 'LBrace' || child.value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
            } else if (child.name === 'RBrace' || child.value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
            }
        }
        //  body ?brace tokens
        if (body) {
            body.lBraceToken = lBraceToken;
            body.rBraceToken = rBraceToken;
        }
        return {
            superClass,
            body,
            extendsToken,
            lBraceToken,
            rBraceToken
        };
    }
    createClassHeritageAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassHeritage?.name);
        return this.createLeftHandSideExpressionAst(cst.children[1]) // ClassHeritage -> extends + LeftHandSideExpression
        ;
    }
    createClassHeritageAstWithToken(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassHeritage?.name);
        let extendsToken = undefined;
        // ClassHeritage: extends LeftHandSideExpression
        const extendsCst = cst.children.find((ch)=>ch.name === 'Extends' || ch.value === 'extends');
        if (extendsCst) {
            extendsToken = SlimeTokenCreate.createExtendsToken(extendsCst.loc);
        }
        const superClass = this.createLeftHandSideExpressionAst(cst.children[1]);
        return {
            superClass,
            extendsToken
        };
    }
    createInitializerAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Initializer?.name);
        // Initializer -> Eq + AssignmentExpression
        const assignmentExpressionCst = cst.children[1];
        return this.createAssignmentExpressionAst(assignmentExpressionCst);
    }
    createFieldDefinitionAst(staticCst, cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.FieldDefinition?.name);
        // FieldDefinition -> (ClassElementName | PropertyName) + Initializer?
        // ES2022: ClassElementName = PrivateIdentifier | PropertyName
        const elementNameCst = cst.children[0];
        const key = this.createClassElementNameAst(elementNameCst);
        // ?
        const isComputed = this.isComputedPropertyName(elementNameCst);
        // 
        let value = null;
        if (cst.children.length > 1) {
            const initializerCst = cst.children[1];
            if (initializerCst && initializerCst.name === _SlimeParser$1.prototype.Initializer?.name) {
                value = this.createInitializerAst(initializerCst);
            }
        }
        //  static ?
        const isStatic = this.isStaticModifier(staticCst);
        // ?key, value, computed, isStatic, loc)
        return SlimeAstCreateUtil.createPropertyDefinition(key, value, isComputed, isStatic || false, cst.loc);
    }
    /**
     * ?ClassElementName/PropertyName 
     */ isComputedPropertyName(cst) {
        if (!cst || !cst.children) return false;
        //  ComputedPropertyName
        function hasComputedPropertyName(node) {
            if (!node) return false;
            if (node.name === 'ComputedPropertyName' || node.name === _SlimeParser$1.prototype.ComputedPropertyName?.name) {
                return true;
            }
            if (node.children) {
                for (const child of node.children){
                    if (hasComputedPropertyName(child)) return true;
                }
            }
            return false;
        }
        return hasComputedPropertyName(cst);
    }
    /**
     * [AST ] PrivateIdentifier ??Identifier AST
     *
     * PrivateIdentifier ?CST token
     *  ESTree AST  Identifier name ?# ?
     *
     * PrivateIdentifier :: # IdentifierName
     * AST { type: "Identifier", name: "#count" }
     */ createPrivateIdentifierAst(cst) {
        // Es2025Parser: PrivateIdentifier  tokenvalue  #
        // { name: 'PrivateIdentifier', value: '#count' } ?value: '#\u{61}'
        if (cst.value) {
            const rawName = cst.value;
            const decodedName = decodeUnicodeEscapes(rawName);
            // ?
            const name = decodedName.startsWith('#') ? decodedName : '#' + decodedName;
            const raw = rawName.startsWith('#') ? rawName : '#' + rawName;
            const identifier = SlimeAstCreateUtil.createIdentifier(name, cst.loc);
            //  raw ?
            if (raw !== name) {
                identifier.raw = raw;
            }
            return identifier;
        }
        // PrivateIdentifier -> HashTok + IdentifierName
        if (cst.children && cst.children.length >= 2) {
            const identifierNameCst = cst.children[1];
            const identifierCst = identifierNameCst.children[0];
            const rawName = identifierCst.value;
            const decodedName = decodeUnicodeEscapes(rawName);
            const identifier = SlimeAstCreateUtil.createIdentifier('#' + decodedName);
            // ?
            if (rawName !== decodedName) {
                identifier.raw = '#' + rawName;
            }
            return identifier;
        }
        // ?IdentifierName
        if (cst.children && cst.children.length === 1) {
            const child = cst.children[0];
            if (child.value) {
                const rawName = child.value;
                const decodedName = decodeUnicodeEscapes(rawName);
                const identifier = SlimeAstCreateUtil.createIdentifier('#' + decodedName);
                if (rawName !== decodedName) {
                    identifier.raw = '#' + rawName;
                }
                return identifier;
            }
        }
        throw new Error('createPrivateIdentifierAst:  PrivateIdentifier');
    }
    /**
     * ?CST  static ?
     *  Static ?IdentifierNameTok (value='static') 
     */ isStaticModifier(cst) {
        if (!cst) return false;
        // 1 Static
        if (cst.name === SlimeTokenConsumer.prototype.Static?.name || cst.name === 'Static' || cst.name === 'Static') {
            return true;
        }
        // 2 IdentifierNameTok ?value ?'static'
        if ((cst.name === 'IdentifierName' || cst.name === 'IdentifierName') && cst.value === 'static') {
            return true;
        }
        return false;
    }
    createClassBodyAst(cst) {
        const astName = checkCstName$1(cst, _SlimeParser$1.prototype.ClassBody?.name);
        const elementsWrapper = cst.children && cst.children[0] // ClassBody -> ClassElementList?
        ;
        const body = [] //  (any  StaticBlock)
        ;
        if (elementsWrapper && Array.isArray(elementsWrapper.children)) {
            for (const element of elementsWrapper.children){
                const elementChildren = element.children ?? [] // 
                ;
                if (!elementChildren.length) {
                    continue; // ?ClassElement 
                }
                //  static ?SemicolonASI?
                let staticCst = null;
                let targetCst = null;
                let classStaticBlockCst = null;
                for (const child of elementChildren){
                    if (child.name === 'Static' || child.value === 'static') {
                        staticCst = child;
                    } else if (child.name === 'SemicolonASI' || child.name === 'Semicolon' || child.value === ';') {
                        continue;
                    } else if (child.name === 'ClassStaticBlock') {
                        // ES2022 
                        classStaticBlockCst = child;
                    } else if (child.name === _SlimeParser$1.prototype.MethodDefinition?.name || child.name === _SlimeParser$1.prototype.FieldDefinition?.name || child.name === 'MethodDefinition' || child.name === 'FieldDefinition') {
                        targetCst = child;
                    }
                }
                // 
                if (classStaticBlockCst) {
                    const staticBlock = this.createClassStaticBlockAst(classStaticBlockCst);
                    if (staticBlock) {
                        body.push(staticBlock);
                    }
                    continue;
                }
                if (targetCst) {
                    // 
                    if (targetCst.name === _SlimeParser$1.prototype.MethodDefinition?.name) {
                        body.push(this.createMethodDefinitionAst(staticCst, targetCst));
                    } else if (targetCst.name === _SlimeParser$1.prototype.FieldDefinition?.name) {
                        body.push(this.createFieldDefinitionAst(staticCst, targetCst));
                    }
                }
            }
        }
        return {
            type: astName,
            body: body,
            loc: cst.loc // 
        };
    }
    /**
     *  ClassStaticBlock AST (ES2022)
     * ClassStaticBlock: static { ClassStaticBlockBody }
     */ createClassStaticBlockAst(cst) {
        // CST : ClassStaticBlock -> [IdentifierName:"static", LBrace, ClassStaticBlockBody, RBrace]
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        let bodyStatements = [];
        for (const child of cst.children || []){
            if (child.name === 'LBrace' || child.value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
            } else if (child.name === 'RBrace' || child.value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
            } else if (child.name === 'ClassStaticBlockBody') {
                // ClassStaticBlockBody -> ClassStaticBlockStatementList -> StatementList
                const stmtListCst = child.children?.find((c)=>c.name === 'ClassStaticBlockStatementList' || c.name === 'StatementList');
                if (stmtListCst) {
                    const actualStatementList = stmtListCst.name === 'ClassStaticBlockStatementList' ? stmtListCst.children?.find((c)=>c.name === 'StatementList') : stmtListCst;
                    if (actualStatementList) {
                        bodyStatements = this.createStatementListAst(actualStatementList);
                    }
                }
            }
        }
        return SlimeAstCreateUtil.createStaticBlock(bodyStatements, cst.loc, lBraceToken, rBraceToken);
    }
    // ==================== /?====================
    /**
     * GeneratorMethod CST ?AST
     * GeneratorMethod -> * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
     */ createGeneratorMethodAst(cst) {
        return this.createMethodDefinitionAstInternal(cst, 'method', true, false);
    }
    /**
     * GeneratorBody CST ?AST?FunctionBody?
     */ createGeneratorBodyAst(cst) {
        return this.createFunctionBodyAst(cst);
    }
    /**
     * AsyncMethod CST ?AST
     * AsyncMethod -> async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
     */ createAsyncMethodAst(cst) {
        return this.createMethodDefinitionAstInternal(cst, 'method', false, true);
    }
    /**
     * AsyncFunctionBody CST ?AST?FunctionBody?
     */ createAsyncFunctionBodyAst(cst) {
        return this.createFunctionBodyAst(cst);
    }
    /**
     * AsyncGeneratorMethod CST ?AST
     */ createAsyncGeneratorMethodAst(cst) {
        return this.createMethodDefinitionAstInternal(cst, 'method', true, true);
    }
    /**
     * AsyncGeneratorBody CST ?AST?FunctionBody?
     */ createAsyncGeneratorBodyAst(cst) {
        return this.createFunctionBodyAst(cst);
    }
    /**
     *  MethodDefinition AST
     */ createMethodDefinitionAstInternal(cst, kind, generator, async) {
        // 
        const classElementName = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.ClassElementName?.name || ch.name === 'ClassElementName' || ch.name === _SlimeParser$1.prototype.PropertyName?.name || ch.name === 'PropertyName');
        const key = classElementName ? this.createClassElementNameAst(classElementName) : null;
        // 
        const formalParams = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name || ch.name === 'UniqueFormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters');
        const params = formalParams ? this.createFormalParametersAst(formalParams) : [];
        // ?
        const bodyNode = cst.children?.find((ch)=>ch.name === 'GeneratorBody' || ch.name === 'AsyncFunctionBody' || ch.name === 'AsyncGeneratorBody' || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        const bodyStatements = bodyNode ? this.createFunctionBodyAst(bodyNode) : [];
        const body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode?.loc);
        const value = {
            type: SlimeNodeType.FunctionExpression,
            id: null,
            params: params,
            body: body,
            generator: generator,
            async: async,
            loc: cst.loc
        };
        return SlimeAstCreateUtil.createMethodDefinition(key, value, kind, false, false, cst.loc);
    }
    /**
     * ClassElement CST ?AST
     * ClassElement -> MethodDefinition | static MethodDefinition | FieldDefinition | ...
     */ createClassElementAst(cst) {
        const firstChild = cst.children?.[0];
        if (!firstChild) return null;
        //  static
        let staticCst = null;
        let startIndex = 0;
        if (firstChild.name === 'Static' || firstChild.value === 'static') {
            staticCst = firstChild;
            startIndex = 1;
        }
        const actualChild = cst.children?.[startIndex];
        if (!actualChild) return null;
        // 
        if (actualChild.name === _SlimeParser$1.prototype.MethodDefinition?.name || actualChild.name === 'MethodDefinition') {
            return this.createMethodDefinitionAst(staticCst, actualChild);
        } else if (actualChild.name === _SlimeParser$1.prototype.FieldDefinition?.name || actualChild.name === 'FieldDefinition') {
            return this.createFieldDefinitionAst(staticCst, actualChild);
        } else if (actualChild.name === _SlimeParser$1.prototype.ClassStaticBlock?.name || actualChild.name === 'ClassStaticBlock') {
            return this.createClassStaticBlockAst(actualChild);
        }
        return null;
    }
    /**
     * ClassElementName CST ?AST
     * ClassElementName :: PropertyName | PrivateIdentifier
     */ createClassElementNameAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassElementName?.name);
        const first = cst.children[0];
        if (!first) {
            throw new Error('createClassElementNameAst: ClassElementName has no children');
        }
        if (first.name === 'PrivateIdentifier') {
            return this.createPrivateIdentifierAst(first);
        }
        // PropertyName
        return this.createPropertyNameAst(first);
    }
    /**
     * ClassElementList CST ?AST
     */ createClassElementListAst(cst) {
        const elements = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.ClassElement?.name || child.name === 'ClassElement') {
                const element = this.createClassElementAst(child);
                if (element) {
                    elements.push(element);
                }
            }
        }
        return elements;
    }
    /**
     * ClassStaticBlockBody CST ?AST
     */ createClassStaticBlockBodyAst(cst) {
        const stmtList = cst.children?.find((ch)=>ch.name === 'ClassStaticBlockStatementList' || ch.name === _SlimeParser$1.prototype.ClassStaticBlockStatementList?.name);
        if (stmtList) {
            return this.createClassStaticBlockStatementListAst(stmtList);
        }
        return [];
    }
    /**
     * ClassStaticBlockStatementList CST ?AST
     */ createClassStaticBlockStatementListAst(cst) {
        const stmtList = cst.children?.find((ch)=>ch.name === 'StatementList' || ch.name === _SlimeParser$1.prototype.StatementList?.name);
        if (stmtList) {
            return this.createStatementListAst(stmtList);
        }
        return [];
    }
    /**
     * AsyncArrowBindingIdentifier CST ?AST
     */ createAsyncArrowBindingIdentifierAst(cst) {
        const bindingId = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            return this.createBindingIdentifierAst(bindingId);
        }
        // 
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createBindingIdentifierAst(firstChild);
        }
        throw new Error('AsyncArrowBindingIdentifier has no identifier');
    }
    /**
     * AsyncConciseBody CST ?AST
     */ createAsyncConciseBodyAst(cst) {
        return this.createConciseBodyAst(cst);
    }
    /**
     * AsyncArrowHead CST ?AST?
     */ createAsyncArrowHeadAst(cst) {
        // AsyncArrowHead ?AST ?AsyncArrowFunction ?
        return cst.children?.[0] ? this.createAstFromCst(cst.children[0]) : null;
    }
    createFormalParameterListAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.FormalParameterList?.name);
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const params = [];
        for (const child of cst.children){
            const name = child.name;
            // FunctionRestParameter - rest
            if (name === 'FunctionRestParameter' || name === _SlimeParser$1.prototype.FunctionRestParameter?.name) {
                params.push(this.createFunctionRestParameterAst(child));
                continue;
            }
            // FormalParameter - 
            if (name === 'FormalParameter' || name === _SlimeParser$1.prototype.FormalParameter?.name) {
                params.push(this.createFormalParameterAst(child));
                continue;
            }
            // BindingElement
            if (name === 'BindingElement' || name === _SlimeParser$1.prototype.BindingElement?.name) {
                params.push(this.createBindingElementAst(child));
                continue;
            }
            // BindingIdentifier
            if (name === 'BindingIdentifier' || name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
                params.push(this.createBindingIdentifierAst(child));
                continue;
            }
            // 
            if (child.value === ',') {
                continue;
            }
        }
        return params;
    }
    createBindingElementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BindingElement?.name);
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.SingleNameBinding?.name) {
            return this.createSingleNameBindingAst(first);
        } else if (first.name === _SlimeParser$1.prototype.BindingPattern?.name || first.name === _SlimeParser$1.prototype.ArrayBindingPattern?.name || first.name === _SlimeParser$1.prototype.ObjectBindingPattern?.name) {
            // function({name, age}) ?function([a, b])
            //  Initializer
            const initializer = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Initializer?.name || ch.name === 'Initializer');
            let pattern;
            if (first.name === _SlimeParser$1.prototype.BindingPattern?.name) {
                pattern = this.createBindingPatternAst(first);
            } else if (first.name === _SlimeParser$1.prototype.ArrayBindingPattern?.name) {
                pattern = this.createArrayBindingPatternAst(first);
            } else {
                pattern = this.createObjectBindingPatternAst(first);
            }
            if (initializer) {
                //  AssignmentPattern
                const init = this.createInitializerAst(initializer);
                return {
                    type: SlimeNodeType.AssignmentPattern,
                    left: pattern,
                    right: init,
                    loc: cst.loc
                };
            }
            return pattern;
        }
        return this.createSingleNameBindingAst(first);
    }
    createSingleNameBindingAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.SingleNameBinding?.name);
        //BindingIdentifier + Initializer?
        const first = cst.children[0];
        const id = this.createBindingIdentifierAst(first);
        // Initializer?
        const initializer = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Initializer?.name);
        if (initializer) {
            // AssignmentPattern
            const init = this.createInitializerAst(initializer);
            return {
                type: SlimeNodeType.AssignmentPattern,
                left: id,
                right: init,
                loc: cst.loc
            };
        }
        return id;
    }
    createFunctionRestParameterAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.FunctionRestParameter?.name);
        const first = cst.children[0];
        return this.createBindingRestElementAst(first);
    }
    createBindingRestElementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BindingRestElement?.name);
        // BindingRestElement: ... BindingIdentifier | ... BindingPattern
        const argumentCst = cst.children[1];
        let argument;
        if (argumentCst.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            // ...rest
            argument = this.createBindingIdentifierAst(argumentCst);
        } else if (argumentCst.name === _SlimeParser$1.prototype.BindingPattern?.name) {
            // ?..[a, b] ?...{x, y}
            argument = this.createBindingPatternAst(argumentCst);
        } else {
            throw new Error(`BindingRestElement:  ${argumentCst.name}`);
        }
        return SlimeAstCreateUtil.createRestElement(argument);
    }
    createFunctionBodyAst(cst) {
        // FunctionBody: FunctionStatementList | StatementList
        // GeneratorBody, AsyncFunctionBody, AsyncGeneratorBody ?FunctionBody
        const children = cst.children || [];
        if (children.length === 0) {
            return [];
        }
        const first = children[0];
        if (!first) {
            return [];
        }
        const name = first.name;
        // Handle nested FunctionBody (from GeneratorBody, AsyncFunctionBody, AsyncGeneratorBody)
        if (name === 'FunctionBody' || name === _SlimeParser$1.prototype.FunctionBody?.name) {
            return this.createFunctionBodyAst(first);
        }
        // Handle FunctionStatementList (ES2025)
        if (name === 'FunctionStatementList' || name === _SlimeParser$1.prototype.FunctionStatementList?.name) {
            return this.createFunctionStatementListAst(first);
        }
        // Handle StatementList (legacy)
        if (name === 'StatementList' || name === _SlimeParser$1.prototype.StatementList?.name) {
            return this.createStatementListAst(first);
        }
        // If the first child is a statement directly, process it
        return this.createStatementListAst(first);
    }
    createFunctionStatementListAst(cst) {
        // FunctionStatementList: StatementList?
        const children = cst.children || [];
        if (children.length === 0) {
            return [];
        }
        const first = children[0];
        if (!first) {
            return [];
        }
        // If child is StatementList, process it
        if (first.name === 'StatementList' || first.name === _SlimeParser$1.prototype.StatementList?.name) {
            return this.createStatementListAst(first);
        }
        // If child is a statement directly
        return this.createStatementListItemAst(first);
    }
    /**
     *  FormalParameterList AST ()
     */ createFormalParameterListAstWrapped(cst) {
        const params = [];
        let lastParam = null;
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.FormalParameter?.name) {
                if (lastParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(lastParam));
                }
                lastParam = this.createFormalParameterAst(child);
            } else if (child.name === _SlimeParser$1.prototype.FunctionRestParameter?.name) {
                if (lastParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(lastParam));
                }
                lastParam = this.createFunctionRestParameterAst(child);
            } else if (child.name === SlimeTokenConsumer.prototype.Comma?.name || child.value === ',') {
                if (lastParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(lastParam, SlimeTokenCreate.createCommaToken(child.loc)));
                    lastParam = null;
                }
            }
        }
        if (lastParam) {
            params.push(SlimeAstCreateUtil.createFunctionParam(lastParam));
        }
        return params;
    }
    createMethodDefinitionAst(staticCst, cst) {
        //  (staticCst, cst)?
        checkCstName$1(cst, _SlimeParser$1.prototype.MethodDefinition?.name);
        const first = cst.children?.[0];
        if (!first) {
            throw new Error('MethodDefinition has no children');
        }
        if (first.name === 'ClassElementName') {
            // MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
            return this.createMethodDefinitionClassElementNameAst(staticCst, cst);
        } else if (first.name === 'Get') {
            // MethodDefinition : get ClassElementName ( ) { FunctionBody }
            return this.createMethodDefinitionGetterMethodAst(staticCst, cst);
        } else if (first.name === 'Set') {
            // MethodDefinition : set ClassElementName ( PropertySetParameterList ) { FunctionBody }
            return this.createMethodDefinitionSetterMethodAst(staticCst, cst);
        } else if (first.name === _SlimeParser$1.prototype.GeneratorMethod?.name || first.name === 'GeneratorMethod') {
            // MethodDefinition : GeneratorMethod
            return this.createMethodDefinitionGeneratorMethodAst(staticCst, first);
        } else if (first.name === 'AsyncMethod' || first.name === _SlimeParser$1.prototype.AsyncMethod?.name) {
            // MethodDefinition : AsyncMethod
            return this.createMethodDefinitionAsyncMethodAst(staticCst, first);
        } else if (first.name === 'AsyncGeneratorMethod' || first.name === _SlimeParser$1.prototype.AsyncGeneratorMethod?.name) {
            // MethodDefinition : AsyncGeneratorMethod
            return this.createMethodDefinitionAsyncGeneratorMethodAst(staticCst, first);
        } else if (first.name === 'Asterisk') {
            // MethodDefinition : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
            return this.createMethodDefinitionGeneratorMethodAst(staticCst, cst);
        } else if (first.name === 'Async') {
            // MethodDefinition : async [no LineTerminator here] ClassElementName ( ... ) { ... }
            return this.createMethodDefinitionAsyncMethodFromChildren(staticCst, cst);
        } else if (first.name === 'IdentifierName' || first.name === 'IdentifierName' || first.name === 'PropertyName' || first.name === 'LiteralPropertyName') {
            //  getter/setter
            if (first.value === 'get' && cst.children[1]?.name === 'ClassElementName') {
                // getterget ClassElementName ( ) { FunctionBody }
                return this.createMethodDefinitionGetterMethodFromIdentifier(staticCst, cst);
            } else if (first.value === 'set' && cst.children[1]?.name === 'ClassElementName') {
                // setterset ClassElementName ( PropertySetParameterList ) { FunctionBody }
                return this.createMethodDefinitionSetterMethodFromIdentifier(staticCst, cst);
            }
            // MethodDefinition : 
            return this.createMethodDefinitionMethodDefinitionFromIdentifier(staticCst, cst);
        } else {
            throw new Error(': ' + first.name);
        }
    }
    // ==================== ES2025  ====================
    // ?ES2025 Parser CST ?CST ?
    // ES2025 Parser ?CST ?ES6 ?
    /**
     * [] ?
     *  ES2025 Parser ?IdentifierNameTok ( UniqueFormalParameters ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionMethodDefinitionFromIdentifier(staticCst, cst) {
        let i = 0;
        const children = cst.children;
        // Token fields
        let staticToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        // ?static token
        if (staticCst && (staticCst.name === 'Static' || staticCst.value === 'static')) {
            staticToken = SlimeTokenCreate.createStaticToken(staticCst.loc);
        }
        //  IdentifierNameTok, IdentifierName, PropertyName, LiteralPropertyName?
        const firstChild = children[i++];
        let key;
        if (firstChild.name === 'IdentifierName') {
            // ?token
            key = SlimeAstCreateUtil.createIdentifier(firstChild.value, firstChild.loc);
        } else if (firstChild.name === 'IdentifierName') {
            // IdentifierName 
            const tokenCst = firstChild.children[0];
            key = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
        } else if (firstChild.name === 'PropertyName' || firstChild.name === 'LiteralPropertyName') {
            key = this.createPropertyNameAst(firstChild);
        } else {
            key = this.createClassElementNameAst(firstChild);
        }
        // LParen
        if (children[i]?.name === 'LParen' || children[i]?.value === '(') {
            lParenToken = SlimeTokenCreate.createLParenToken(children[i].loc);
            i++;
        }
        // UniqueFormalParameters ()
        let params = [];
        if (children[i]?.name === 'UniqueFormalParameters' || children[i]?.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
            params = this.createUniqueFormalParametersAstWrapped(children[i]);
            i++;
        } else if (children[i]?.name === 'FormalParameters' || children[i]?.name === _SlimeParser$1.prototype.FormalParameters?.name) {
            params = this.createFormalParametersAstWrapped(children[i]);
            i++;
        }
        // RParen
        if (children[i]?.name === 'RParen' || children[i]?.value === ')') {
            rParenToken = SlimeTokenCreate.createRParenToken(children[i].loc);
            i++;
        }
        // LBrace
        if (children[i]?.name === 'LBrace' || children[i]?.value === '{') {
            lBraceToken = SlimeTokenCreate.createLBraceToken(children[i].loc);
            i++;
        }
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc, lBraceToken, rBraceToken);
            i++;
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([], undefined, lBraceToken, rBraceToken);
        }
        // RBrace
        if (children[i]?.name === 'RBrace' || children[i]?.value === '}') {
            rBraceToken = SlimeTokenCreate.createRBraceToken(children[i].loc);
        }
        // ?
        const functionExpression = SlimeAstCreateUtil.createFunctionExpression(body, null, params, false, false, cst.loc, undefined, undefined, undefined, lParenToken, rParenToken, lBraceToken, rBraceToken);
        //  constructor
        const isConstructor = key.type === "Identifier" && key.name === "constructor" && !this.isStaticModifier(staticCst);
        const isStatic = this.isStaticModifier(staticCst);
        const kind = isConstructor ? 'constructor' : 'method';
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, functionExpression, kind, false, isStatic, cst.loc, staticToken);
        return methodDef;
    }
    /**
     * [] ?
     *  ES2025 Parser ?ClassElementName ( UniqueFormalParameters ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionClassElementNameAst(staticCst, cst) {
        // children: [ClassElementName, LParen, UniqueFormalParameters?, RParen, LBrace, FunctionBody?, RBrace]
        let i = 0;
        const children = cst.children;
        // ClassElementName
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // UniqueFormalParameters ()
        let params = [];
        if (children[i]?.name === 'UniqueFormalParameters' || children[i]?.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
            params = this.createUniqueFormalParametersAstWrapped(children[i]);
            i++;
        } else if (children[i]?.name === 'FormalParameters' || children[i]?.name === _SlimeParser$1.prototype.FormalParameters?.name) {
            params = this.createFormalParametersAstWrapped(children[i]);
            i++;
        }
        //  RParen, LBrace
        if (children[i]?.name === 'RParen') i++;
        if (children[i]?.name === 'LBrace') i++;
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        // ?
        const functionExpression = SlimeAstCreateUtil.createFunctionExpression(body, null, params, false, false, cst.loc);
        // ?
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  constructor
        const isConstructor = key.type === "Identifier" && key.name === "constructor" && !this.isStaticModifier(staticCst);
        const isStatic = this.isStaticModifier(staticCst);
        const kind = isConstructor ? 'constructor' : 'method';
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, functionExpression, kind, isComputed, isStatic, cst.loc);
        return methodDef;
    }
    /**
     * [] getter 
     *  ES2025 Parser ?get ClassElementName ( ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionGetterMethodAst(staticCst, cst) {
        // children: [GetTok, ClassElementName, LParen, RParen, LBrace, FunctionBody?, RBrace]
        const children = cst.children;
        let i = 1 //  GetTok
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen, RParen, LBrace
        while(i < children.length && [
            'LParen',
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, {
            type: 'FunctionExpression',
            id: null,
            params: [],
            body: body
        });
        methodDef.kind = 'get';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] setter 
     *  ES2025 Parser ?set ClassElementName ( PropertySetParameterList ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionSetterMethodAst(staticCst, cst) {
        // children: [SetTok, ClassElementName, LParen, PropertySetParameterList, RParen, LBrace, FunctionBody?, RBrace]
        const children = cst.children;
        let i = 1 //  SetTok
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // PropertySetParameterList
        let params = [];
        if (children[i]?.name === 'PropertySetParameterList' || children[i]?.name === _SlimeParser$1.prototype.PropertySetParameterList?.name) {
            params = this.createPropertySetParameterListAst(children[i]);
            i++;
        }
        //  RParen, LBrace
        while(i < children.length && [
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, {
            type: 'FunctionExpression',
            id: null,
            params: params,
            body: body
        });
        methodDef.kind = 'set';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] getter  (?IdentifierNameTok="get" ?
     *  ES2025 Parser ?IdentifierNameTok="get" ClassElementName ( ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionGetterMethodFromIdentifier(staticCst, cst) {
        const children = cst.children;
        let i = 1 //  IdentifierNameTok="get"
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen, RParen
        while(i < children.length && [
            'LParen',
            'RParen'
        ].includes(children[i]?.name))i++;
        //  LBrace
        if (children[i]?.name === 'LBrace') i++;
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, {
            type: 'FunctionExpression',
            id: null,
            params: [],
            body: body
        });
        methodDef.kind = 'get';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] setter  (?IdentifierNameTok="set" ?
     *  ES2025 Parser ?IdentifierNameTok="set" ClassElementName ( ... ) { FunctionBody } 
     * @internal
     */ createMethodDefinitionSetterMethodFromIdentifier(staticCst, cst) {
        const children = cst.children;
        let i = 1 //  IdentifierNameTok="set"
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // PropertySetParameterList  BindingIdentifier
        let params = [];
        if (children[i]?.name === 'PropertySetParameterList' || children[i]?.name === _SlimeParser$1.prototype.PropertySetParameterList?.name) {
            params = this.createPropertySetParameterListAst(children[i]);
            i++;
        } else if (children[i]?.name === 'BindingIdentifier' || children[i]?.name === 'BindingElement') {
            // 
            params = [
                this.createBindingIdentifierAst(children[i])
            ];
            i++;
        }
        //  RParen, LBrace
        while(i < children.length && [
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // FunctionBody
        let body;
        if (children[i]?.name === 'FunctionBody' || children[i]?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(children[i]);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, children[i].loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, {
            type: 'FunctionExpression',
            id: null,
            params: params,
            body: body
        });
        methodDef.kind = 'set';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] generator 
     *  ES2025 Parser ?* ClassElementName ( UniqueFormalParameters ) { GeneratorBody } 
     * @internal
     */ createMethodDefinitionGeneratorMethodAst(staticCst, cst) {
        // GeneratorMethod children: [Asterisk, ClassElementName, LParen, UniqueFormalParameters?, RParen, LBrace, GeneratorBody, RBrace]
        const children = cst.children;
        let i = 1 //  Asterisk
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // UniqueFormalParameters
        let params = [];
        if (children[i]?.name === 'UniqueFormalParameters' || children[i]?.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
            params = this.createUniqueFormalParametersAst(children[i]);
            i++;
        }
        //  RParen, LBrace
        while(i < children.length && [
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // GeneratorBody ?FunctionBody
        let body;
        const bodyChild = children[i];
        if (bodyChild?.name === 'GeneratorBody' || bodyChild?.name === _SlimeParser$1.prototype.GeneratorBody?.name || bodyChild?.name === 'FunctionBody' || bodyChild?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(bodyChild);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyChild.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const functionExpression = {
            type: 'FunctionExpression',
            id: null,
            params: params,
            body: body,
            generator: true,
            async: false
        };
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, functionExpression);
        methodDef.kind = 'method';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] generator  (?MethodDefinition children )
     * @internal
     */ createMethodDefinitionGeneratorMethodFromChildren(staticCst, cst) {
        return this.createMethodDefinitionGeneratorMethodAst(staticCst, cst);
    }
    /**
     * [] async 
     *  ES2025 Parser ?async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody } 
     * @internal
     */ createMethodDefinitionAsyncMethodAst(staticCst, cst) {
        // AsyncMethod children: [AsyncTok, ClassElementName, LParen, UniqueFormalParameters?, RParen, LBrace, AsyncFunctionBody, RBrace]
        const children = cst.children;
        let i = 1 //  AsyncTok
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // UniqueFormalParameters
        let params = [];
        if (children[i]?.name === 'UniqueFormalParameters' || children[i]?.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
            params = this.createUniqueFormalParametersAst(children[i]);
            i++;
        }
        //  RParen, LBrace
        while(i < children.length && [
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // AsyncFunctionBody ?FunctionBody
        let body;
        const bodyChild = children[i];
        if (bodyChild?.name === 'AsyncFunctionBody' || bodyChild?.name === _SlimeParser$1.prototype.AsyncFunctionBody?.name || bodyChild?.name === 'FunctionBody' || bodyChild?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(bodyChild);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyChild.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const functionExpression = {
            type: 'FunctionExpression',
            id: null,
            params: params,
            body: body,
            generator: false,
            async: true
        };
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, functionExpression);
        methodDef.kind = 'method';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     * [] async  (?MethodDefinition children )
     * @internal
     */ createMethodDefinitionAsyncMethodFromChildren(staticCst, cst) {
        //  AsyncGeneratorMethod (async * ...)
        const children = cst.children;
        if (children[1]?.name === 'Asterisk') {
            return this.createMethodDefinitionAsyncGeneratorMethodAst(staticCst, cst);
        }
        return this.createMethodDefinitionAsyncMethodAst(staticCst, cst);
    }
    /**
     * [] async generator 
     *  ES2025 Parser ?async * ClassElementName ( ... ) { AsyncGeneratorBody } 
     * @internal
     */ createMethodDefinitionAsyncGeneratorMethodAst(staticCst, cst) {
        // AsyncGeneratorMethod children: [AsyncTok, Asterisk, ClassElementName, LParen, UniqueFormalParameters?, RParen, LBrace, AsyncGeneratorBody, RBrace]
        const children = cst.children;
        let i = 2 //  AsyncTok ?Asterisk
        ;
        const classElementNameCst = children[i++];
        const key = this.createClassElementNameAst(classElementNameCst);
        const isComputed = this.isComputedPropertyName(classElementNameCst);
        //  LParen
        if (children[i]?.name === 'LParen') i++;
        // UniqueFormalParameters
        let params = [];
        if (children[i]?.name === 'UniqueFormalParameters' || children[i]?.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
            params = this.createUniqueFormalParametersAst(children[i]);
            i++;
        }
        //  RParen, LBrace
        while(i < children.length && [
            'RParen',
            'LBrace'
        ].includes(children[i]?.name))i++;
        // AsyncGeneratorBody ?FunctionBody
        let body;
        const bodyChild = children[i];
        if (bodyChild?.name === 'AsyncGeneratorBody' || bodyChild?.name === _SlimeParser$1.prototype.AsyncGeneratorBody?.name || bodyChild?.name === 'FunctionBody' || bodyChild?.name === _SlimeParser$1.prototype.FunctionBody?.name) {
            const bodyStatements = this.createFunctionBodyAst(bodyChild);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyChild.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const functionExpression = {
            type: 'FunctionExpression',
            id: null,
            params: params,
            body: body,
            generator: true,
            async: true
        };
        const methodDef = SlimeAstCreateUtil.createMethodDefinition(key, functionExpression);
        methodDef.kind = 'method';
        methodDef.computed = isComputed;
        if (this.isStaticModifier(staticCst)) {
            methodDef.static = true;
        }
        return methodDef;
    }
    /**
     *  UniqueFormalParameters CST 
     */ createUniqueFormalParametersAst(cst) {
        // UniqueFormalParameters: FormalParameters
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const first = cst.children[0];
        if (first.name === 'FormalParameters' || first.name === _SlimeParser$1.prototype.FormalParameters?.name) {
            return this.createFormalParametersAst(first);
        }
        // ?FormalParameterList
        return this.createFormalParametersAst(cst);
    }
    /** ?*/ createUniqueFormalParametersAstWrapped(cst) {
        // UniqueFormalParameters: FormalParameters
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const first = cst.children[0];
        if (first.name === 'FormalParameters' || first.name === _SlimeParser$1.prototype.FormalParameters?.name) {
            return this.createFormalParametersAstWrapped(first);
        }
        // ?FormalParameterList
        return this.createFormalParametersAstWrapped(cst);
    }
    /**
     *  PropertySetParameterList
     */ createPropertySetParameterListAst(cst) {
        // PropertySetParameterList: FormalParameter
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const first = cst.children[0];
        if (first.name === 'FormalParameter' || first.name === _SlimeParser$1.prototype.FormalParameter?.name) {
            return [
                this.createFormalParameterAst(first)
            ];
        }
        if (first.name === 'BindingElement' || first.name === _SlimeParser$1.prototype.BindingElement?.name) {
            return [
                this.createBindingElementAst(first)
            ];
        }
        return [];
    }
    /** ?*/ createPropertySetParameterListAstWrapped(cst) {
        // PropertySetParameterList: FormalParameter
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const first = cst.children[0];
        if (first.name === 'FormalParameter' || first.name === _SlimeParser$1.prototype.FormalParameter?.name) {
            return [
                SlimeAstCreateUtil.createFunctionParam(this.createFormalParameterAst(first), undefined)
            ];
        }
        if (first.name === 'BindingElement' || first.name === _SlimeParser$1.prototype.BindingElement?.name) {
            return [
                SlimeAstCreateUtil.createFunctionParam(this.createBindingElementAst(first), undefined)
            ];
        }
        return [];
    }
    createFormalParameterAst(cst) {
        // FormalParameter: BindingElement
        const first = cst.children[0];
        if (first.name === 'BindingElement' || first.name === _SlimeParser$1.prototype.BindingElement?.name) {
            return this.createBindingElementAst(first);
        }
        return this.createBindingElementAst(cst);
    }
    createBindingPatternAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BindingPattern?.name);
        const child = cst.children[0];
        if (child.name === _SlimeParser$1.prototype.ArrayBindingPattern?.name) {
            return this.createArrayBindingPatternAst(child);
        } else if (child.name === _SlimeParser$1.prototype.ObjectBindingPattern?.name) {
            return this.createObjectBindingPatternAst(child);
        } else {
            throw new Error(`Unknown BindingPattern type: ${child.name}`);
        }
    }
    createArrayBindingPatternAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ArrayBindingPattern?.name);
        // CST[LBracket, BindingElementList?, Comma?, Elision?, BindingRestElement?, RBracket]
        const elements = [];
        //  LBracket ?RBracket tokens
        let lBracketToken;
        let rBracketToken;
        for (const child of cst.children){
            if (child.value === '[') {
                lBracketToken = SlimeTokenCreate.createLBracketToken(child.loc);
            } else if (child.value === ']') {
                rBracketToken = SlimeTokenCreate.createRBracketToken(child.loc);
            }
        }
        // BindingElementList
        const bindingList = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElementList?.name);
        if (bindingList) {
            for(let i = 0; i < bindingList.children.length; i++){
                const child = bindingList.children[i];
                if (child.value === ',') {
                    // 
                    if (elements.length > 0 && !elements[elements.length - 1].commaToken) {
                        elements[elements.length - 1].commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    } else {
                        SlimeTokenCreate.createCommaToken(child.loc);
                    }
                } else if (child.name === _SlimeParser$1.prototype.BindingElisionElement?.name) {
                    // BindingElisionElementElision + BindingElement
                    // Elision?
                    const elision = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Elision?.name);
                    if (elision) {
                        // Elisionnull
                        for (const elisionChild of elision.children || []){
                            if (elisionChild.value === ',') {
                                elements.push({
                                    element: null,
                                    commaToken: SlimeTokenCreate.createCommaToken(elisionChild.loc)
                                });
                            }
                        }
                    }
                    // BindingElement
                    const bindingElement = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElement?.name);
                    if (bindingElement) {
                        //  createBindingElementAst  BindingElement?Initializer?
                        const element = this.createBindingElementAst(bindingElement);
                        if (element) {
                            elements.push({
                                element
                            });
                        }
                    }
                }
            }
        }
        //  ArrayBindingPattern ?Comma ?Elision
        // CST: [LBracket, BindingElementList, Comma, Elision, RBracket]
        for(let i = 0; i < cst.children.length; i++){
            const child = cst.children[i];
            //  LBracket, RBracket, BindingElementList?
            if (child.value === '[' || child.value === ']' || child.name === _SlimeParser$1.prototype.BindingElementList?.name || child.name === _SlimeParser$1.prototype.BindingRestElement?.name) {
                continue;
            }
            //  BindingElementList ?Comma
            if (child.value === ',') {
                // ?
                if (elements.length > 0 && !elements[elements.length - 1].commaToken) {
                    elements[elements.length - 1].commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                }
            }
            // ?Elision
            if (child.name === _SlimeParser$1.prototype.Elision?.name || child.name === 'Elision') {
                for (const elisionChild of child.children || []){
                    if (elisionChild.value === ',') {
                        elements.push({
                            element: null,
                            commaToken: SlimeTokenCreate.createCommaToken(elisionChild.loc)
                        });
                    }
                }
            }
        }
        // BindingRestElement?..rest ?...[a, b]?
        const restElement = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingRestElement?.name);
        if (restElement) {
            const restNode = this.createBindingRestElementAst(restElement);
            elements.push({
                element: restNode
            });
        }
        return {
            type: SlimeNodeType.ArrayPattern,
            elements,
            lBracketToken,
            rBracketToken,
            loc: cst.loc
        };
    }
    createObjectBindingPatternAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ObjectBindingPattern?.name);
        // CST[LBrace, BindingPropertyList?, RBrace]
        const properties = [];
        //  LBrace ?RBrace tokens
        let lBraceToken;
        let rBraceToken;
        for (const child of cst.children){
            if (child.value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
            } else if (child.value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
            }
        }
        // BindingPropertyList
        const propList = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingPropertyList?.name);
        if (propList) {
            // BindingPropertyListBindingPropertyComma
            for(let i = 0; i < propList.children.length; i++){
                const child = propList.children[i];
                if (child.value === ',') {
                    // ?
                    if (properties.length > 0 && !properties[properties.length - 1].commaToken) {
                        properties[properties.length - 1].commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    }
                } else if (child.name === _SlimeParser$1.prototype.BindingProperty?.name) {
                    // BindingProperty -> SingleNameBinding (? ?PropertyName + BindingElement ()
                    const singleName = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.SingleNameBinding?.name);
                    if (singleName) {
                        // {name} ?{name = "Guest"}
                        const value = this.createSingleNameBindingAst(singleName);
                        const identifier = singleName.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name);
                        const key = this.createBindingIdentifierAst(identifier);
                        properties.push({
                            property: {
                                type: SlimeNodeType.Property,
                                key: key,
                                value: value,
                                kind: 'init',
                                computed: false,
                                shorthand: true,
                                loc: child.loc
                            }
                        });
                    } else {
                        // {name: userName}
                        const propName = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.PropertyName?.name);
                        const bindingElement = child.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElement?.name);
                        if (propName && bindingElement) {
                            const key = this.createPropertyNameAst(propName);
                            const value = this.createBindingElementAst(bindingElement);
                            const isComputed = this.isComputedPropertyName(propName);
                            properties.push({
                                property: {
                                    type: SlimeNodeType.Property,
                                    key: key,
                                    value: value,
                                    kind: 'init',
                                    computed: isComputed,
                                    shorthand: false,
                                    loc: child.loc
                                }
                            });
                        }
                    }
                }
            }
        }
        //  BindingPropertyList BindingRestProperty ?
        // CST : { BindingPropertyList , BindingRestProperty }
        // ?ObjectBindingPattern 
        for (const child of cst.children){
            if (child.value === ',') {
                // ?
                if (properties.length > 0 && !properties[properties.length - 1].commaToken) {
                    properties[properties.length - 1].commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                }
            }
        }
        // ES2018: BindingRestElement ?BindingRestProperty?..rest?
        const restElement = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingRestElement?.name || ch.name === 'BindingRestElement' || ch.name === _SlimeParser$1.prototype.BindingRestProperty?.name || ch.name === 'BindingRestProperty');
        if (restElement) {
            const identifier = restElement.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
            if (identifier) {
                const restId = this.createBindingIdentifierAst(identifier);
                //  ellipsis token
                const ellipsisCst = restElement.children.find((ch)=>ch.value === '...');
                const ellipsisToken = ellipsisCst ? SlimeTokenCreate.createEllipsisToken(ellipsisCst.loc) : undefined;
                const restNode = {
                    type: SlimeNodeType.RestElement,
                    argument: restId,
                    ellipsisToken,
                    loc: restElement.loc
                };
                properties.push({
                    property: restNode
                });
            }
        }
        return {
            type: SlimeNodeType.ObjectPattern,
            properties,
            lBraceToken,
            rBraceToken,
            loc: cst.loc
        };
    }
    // ====================  ====================
    /**
     * AssignmentPattern CST ?AST
     * AssignmentPattern -> ObjectAssignmentPattern | ArrayAssignmentPattern
     */ createAssignmentPatternAst(cst) {
        const firstChild = cst.children?.[0];
        if (!firstChild) throw new Error('AssignmentPattern has no children');
        if (firstChild.name === _SlimeParser$1.prototype.ObjectAssignmentPattern?.name || firstChild.name === 'ObjectAssignmentPattern') {
            return this.createObjectAssignmentPatternAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.ArrayAssignmentPattern?.name || firstChild.name === 'ArrayAssignmentPattern') {
            return this.createArrayAssignmentPatternAst(firstChild);
        }
        throw new Error(`Unknown AssignmentPattern type: ${firstChild.name}`);
    }
    /**
     * ObjectAssignmentPattern CST ?AST
     */ createObjectAssignmentPatternAst(cst) {
        return this.createObjectBindingPatternAst(cst);
    }
    /**
     * ArrayAssignmentPattern CST ?AST
     */ createArrayAssignmentPatternAst(cst) {
        return this.createArrayBindingPatternAst(cst);
    }
    /**
     * BindingProperty CST ?AST
     * BindingProperty -> SingleNameBinding | PropertyName : BindingElement
     */ createBindingPropertyAst(cst) {
        const children = cst.children || [];
        //  SingleNameBinding
        const singleNameBinding = children.find((ch)=>ch.name === _SlimeParser$1.prototype.SingleNameBinding?.name || ch.name === 'SingleNameBinding');
        if (singleNameBinding) {
            return this.createSingleNameBindingAst(singleNameBinding);
        }
        // ?PropertyName : BindingElement
        const propertyName = children.find((ch)=>ch.name === _SlimeParser$1.prototype.PropertyName?.name || ch.name === 'PropertyName');
        const bindingElement = children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElement?.name || ch.name === 'BindingElement');
        const key = propertyName ? this.createPropertyNameAst(propertyName) : null;
        const value = bindingElement ? this.createBindingElementAst(bindingElement) : null;
        return {
            type: SlimeNodeType.Property,
            key: key,
            value: value,
            kind: 'init',
            method: false,
            shorthand: false,
            computed: false,
            loc: cst.loc
        };
    }
    /**
     * BindingPropertyList CST  AST
     */ createBindingPropertyListAst(cst) {
        const properties = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.BindingProperty?.name || child.name === 'BindingProperty') {
                properties.push(this.createBindingPropertyAst(child));
            }
        }
        return properties;
    }
    /**
     * BindingElementList CST ?AST
     */ createBindingElementListAst(cst) {
        const elements = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.BindingElement?.name || child.name === 'BindingElement') {
                elements.push(this.createBindingElementAst(child));
            } else if (child.name === _SlimeParser$1.prototype.BindingRestElement?.name || child.name === 'BindingRestElement') {
                elements.push(this.createBindingRestElementAst(child));
            } else if (child.name === _SlimeParser$1.prototype.BindingElisionElement?.name || child.name === 'BindingElisionElement') {
                // Elision  BindingElement
                elements.push(null); // 
                const bindingElement = child.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElement?.name || ch.name === 'BindingElement');
                if (bindingElement) {
                    elements.push(this.createBindingElementAst(bindingElement));
                }
            }
        }
        return elements;
    }
    /**
     * BindingElisionElement CST ?AST
     */ createBindingElisionElementAst(cst) {
        const bindingElement = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingElement?.name || ch.name === 'BindingElement');
        if (bindingElement) {
            return this.createBindingElementAst(bindingElement);
        }
        return null;
    }
    /**
     * AssignmentPropertyList CST ?AST
     */ createAssignmentPropertyListAst(cst) {
        const properties = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.AssignmentProperty?.name || child.name === 'AssignmentProperty') {
                properties.push(this.createAssignmentPropertyAst(child));
            }
        }
        return properties;
    }
    /**
     * AssignmentProperty CST ?AST
     */ createAssignmentPropertyAst(cst) {
        return this.createBindingPropertyAst(cst);
    }
    /**
     * AssignmentElementList CST ?AST
     */ createAssignmentElementListAst(cst) {
        return this.createBindingElementListAst(cst);
    }
    /**
     * AssignmentElement CST ?AST
     */ createAssignmentElementAst(cst) {
        return this.createBindingElementAst(cst);
    }
    /**
     * AssignmentElisionElement CST ?AST
     */ createAssignmentElisionElementAst(cst) {
        return this.createBindingElisionElementAst(cst);
    }
    /**
     * AssignmentRestElement CST ?AST
     */ createAssignmentRestElementAst(cst) {
        return this.createBindingRestElementAst(cst);
    }
    /**
     * AssignmentRestProperty CST ?AST
     */ createAssignmentRestPropertyAst(cst) {
        return this.createBindingRestPropertyAst(cst);
    }
    /**
     * BindingRestProperty CST ?AST
     */ createBindingRestPropertyAst(cst) {
        const argument = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        const id = argument ? this.createBindingIdentifierAst(argument) : null;
        return SlimeAstCreateUtil.createRestElement(id);
    }
    createFunctionExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.FunctionExpression?.name);
        // Es2025Parser FunctionExpression 
        let isAsync = false;
        let isGenerator = false;
        let functionId = null;
        let params = [];
        let body;
        // Token fields
        let functionToken = undefined;
        let asyncToken = undefined;
        let asteriskToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        for (const child of cst.children || []){
            if (!child) continue;
            const name = child.name;
            const value = child.value;
            if (name === 'Function' || value === 'function') {
                functionToken = SlimeTokenCreate.createFunctionToken(child.loc);
                continue;
            }
            if (name === 'Async' || value === 'async') {
                asyncToken = SlimeTokenCreate.createAsyncToken(child.loc);
                isAsync = true;
                continue;
            }
            if (name === 'Asterisk' || value === '*') {
                asteriskToken = SlimeTokenCreate.createAsteriskToken(child.loc);
                isGenerator = true;
                continue;
            }
            if (name === 'LParen' || value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                continue;
            }
            if (name === 'RParen' || value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                continue;
            }
            if (name === 'LBrace' || value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
                continue;
            }
            if (name === 'RBrace' || value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
                continue;
            }
            // BindingIdentifier?
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                functionId = this.createBindingIdentifierAst(child);
                continue;
            }
            // FormalParameters - 
            if (name === _SlimeParser$1.prototype.FormalParameters?.name || name === 'FormalParameters') {
                params = this.createFormalParametersAstWrapped(child);
                continue;
            }
            // FunctionBody
            if (name === _SlimeParser$1.prototype.FunctionBody?.name || name === 'FunctionBody') {
                const bodyStatements = this.createFunctionBodyAst(child);
                body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, child.loc);
                continue;
            }
        }
        // 
        if (!body) {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return SlimeAstCreateUtil.createFunctionExpression(body, functionId, params, isGenerator, isAsync, cst.loc, functionToken, asyncToken, asteriskToken, lParenToken, rParenToken, lBraceToken, rBraceToken);
    }
    /**
     *  FormalParameters CST 
     */ createFormalParametersAst(cst) {
        // FormalParameters  FormalParameterList ?
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const params = [];
        for (const child of cst.children){
            const name = child.name;
            // FormalParameterList
            if (name === _SlimeParser$1.prototype.FormalParameterList?.name || name === 'FormalParameterList') {
                return this.createFormalParameterListAst(child);
            }
            // FormalParameter
            if (name === _SlimeParser$1.prototype.FormalParameter?.name || name === 'FormalParameter') {
                params.push(this.createFormalParameterAst(child));
                continue;
            }
            // BindingIdentifier - 
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                params.push(this.createBindingIdentifierAst(child));
                continue;
            }
            // BindingElement
            if (name === _SlimeParser$1.prototype.BindingElement?.name || name === 'BindingElement') {
                params.push(this.createBindingElementAst(child));
                continue;
            }
            // FunctionRestParameter
            if (name === _SlimeParser$1.prototype.FunctionRestParameter?.name || name === 'FunctionRestParameter') {
                params.push(this.createFunctionRestParameterAst(child));
                continue;
            }
            // ?
            if (child.value === ',' || child.value === '(' || child.value === ')') {
                continue;
            }
        }
        return params;
    }
    /**
     *  BlockStatement AST
     * ?
     * 1. ?StatementList
     * 2. ?BlockStatement Block -> StatementList
     */ createBlockStatementAst(cst) {
        let statements;
        // ?StatementList?
        if (cst.name === _SlimeParser$1.prototype.StatementList?.name) {
            statements = this.createStatementListAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.BlockStatement?.name) {
            // BlockStatement -> Block -> StatementList
            const blockCst = cst.children?.[0];
            if (blockCst && blockCst.name === _SlimeParser$1.prototype.Block?.name) {
                // Block LBrace StatementList RBrace
                const statementListCst = blockCst.children?.find((child)=>child.name === _SlimeParser$1.prototype.StatementList?.name);
                if (statementListCst) {
                    statements = this.createStatementListAst(statementListCst);
                } else {
                    statements = [];
                }
            } else {
                statements = [];
            }
        } else {
            throw new Error(`Expected StatementList or BlockStatement, got ${cst.name}`);
        }
        const ast = {
            type: _SlimeParser$1.prototype.BlockStatement?.name,
            body: statements,
            loc: cst.loc
        };
        return ast;
    }
    createReturnStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ReturnStatement?.name);
        // return ?
        // children[0] = ReturnTok
        // children[1] = Expression? | Semicolon | SemicolonASI
        let argument = null;
        let returnToken = undefined;
        let semicolonToken = undefined;
        //  return token
        const returnCst = cst.children[0];
        if (returnCst && (returnCst.name === 'Return' || returnCst.value === 'return')) {
            returnToken = SlimeTokenCreate.createReturnToken(returnCst.loc);
        }
        if (cst.children.length > 1) {
            for(let i = 1; i < cst.children.length; i++){
                const child = cst.children[i];
                // 
                if (child.name === 'Semicolon' || child.name === 'SemicolonASI' || child.name === 'Semicolon' || child.value === ';') {
                    semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
                } else if (!argument) {
                    argument = this.createExpressionAst(child);
                }
            }
        }
        return SlimeAstCreateUtil.createReturnStatement(argument, cst.loc, returnToken, semicolonToken);
    }
    createExpressionStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ExpressionStatement?.name);
        let semicolonToken = undefined;
        let expression = null;
        for (const child of cst.children || []){
            if (child.name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression' || !expression) {
                expression = this.createExpressionAst(child);
            }
        }
        return SlimeAstCreateUtil.createExpressionStatement(expression, cst.loc, semicolonToken);
    }
    /**
     *  if  AST
     * if (test) consequent [else alternate]
     * ES2025: if ( Expression ) IfStatementBody [else IfStatementBody]
     */ createIfStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.IfStatement?.name);
        let test = null;
        let consequent = null;
        let alternate = null;
        let ifToken = undefined;
        let elseToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        const children = cst.children || [];
        let foundElse = false;
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            // if token
            if (name === 'If' || child.value === 'if') {
                ifToken = SlimeTokenCreate.createIfToken(child.loc);
                continue;
            }
            // LParen token
            if (name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                continue;
            }
            // RParen token
            if (name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                continue;
            }
            // else token
            if (name === 'Else' || child.value === 'else') {
                elseToken = SlimeTokenCreate.createElseToken(child.loc);
                foundElse = true;
                continue;
            }
            // Expression (test condition)
            if (name === _SlimeParser$1.prototype.Expression?.name || name === 'Expression') {
                test = this.createExpressionAst(child);
                continue;
            }
            // IfStatementBody
            if (name === _SlimeParser$1.prototype.IfStatementBody?.name || name === 'IfStatementBody') {
                const body = this.createIfStatementBodyAst(child);
                if (!foundElse) {
                    consequent = body;
                } else {
                    alternate = body;
                }
                continue;
            }
            // Legacy: ?Statement
            if (name === _SlimeParser$1.prototype.Statement?.name || name === 'Statement') {
                const stmts = this.createStatementAst(child);
                const body = Array.isArray(stmts) ? stmts[0] : stmts;
                if (!foundElse) {
                    consequent = body;
                } else {
                    alternate = body;
                }
                continue;
            }
        }
        return SlimeAstCreateUtil.createIfStatement(test, consequent, alternate, cst.loc, ifToken, elseToken, lParenToken, rParenToken);
    }
    /**
     *  IfStatementBody AST
     * IfStatementBody: Statement | FunctionDeclaration
     */ createIfStatementBodyAst(cst) {
        const children = cst.children || [];
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            if (name === _SlimeParser$1.prototype.Statement?.name || name === 'Statement') {
                const stmts = this.createStatementAst(child);
                return Array.isArray(stmts) ? stmts[0] : stmts;
            }
            if (name === _SlimeParser$1.prototype.FunctionDeclaration?.name || name === 'FunctionDeclaration') {
                return this.createFunctionDeclarationAst(child);
            }
        }
        // 
        return this.createStatementDeclarationAst(cst);
    }
    /**
     *  for  AST
     * ES2025 ForStatement:
     *   for ( var VariableDeclarationList ; Expression_opt ; Expression_opt ) Statement
     *   for ( LexicalDeclaration Expression_opt ; Expression_opt ) Statement
     *   for ( Expression_opt ; Expression_opt ; Expression_opt ) Statement
     *
     * LexicalDeclaration SemicolonASI?
     */ createForStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ForStatement?.name);
        let init = null;
        let test = null;
        let update = null;
        let body = null;
        let forToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        const semicolonTokens = [];
        const children = cst.children || [];
        //  test ?update?
        const expressions = [];
        let hasLexicalDeclaration = false;
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            // for token
            if (name === 'For' || child.value === 'for') {
                forToken = SlimeTokenCreate.createForToken(child.loc);
                continue;
            }
            // LParen token
            if (name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                continue;
            }
            // RParen token
            if (name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                continue;
            }
            // var token - skip (kind handled separately)
            if (name === 'Var' || child.value === 'var') continue;
            // Semicolon token
            if (name === 'Semicolon' || child.value === ';' || child.loc?.type === 'Semicolon') {
                semicolonTokens.push(SlimeTokenCreate.createSemicolonToken(child.loc));
                continue;
            }
            // VariableDeclarationList (for var) - init
            if (name === _SlimeParser$1.prototype.VariableDeclarationList?.name || name === 'VariableDeclarationList') {
                init = this.createVariableDeclarationFromList(child, 'var');
                continue;
            }
            // LexicalDeclaration (for let/const) - init
            // LexicalDeclaration ?
            if (name === _SlimeParser$1.prototype.LexicalDeclaration?.name || name === 'LexicalDeclaration') {
                init = this.createLexicalDeclarationAst(child);
                hasLexicalDeclaration = true;
                continue;
            }
            // VariableDeclaration (legacy) - init
            if (name === _SlimeParser$1.prototype.VariableDeclaration?.name || name === 'VariableDeclaration') {
                init = this.createVariableDeclarationAst(child);
                continue;
            }
            // Expression - 
            if (name === _SlimeParser$1.prototype.Expression?.name || name === 'Expression') {
                expressions.push(this.createExpressionAst(child));
                continue;
            }
            // Statement (body)
            if (name === _SlimeParser$1.prototype.Statement?.name || name === 'Statement') {
                const stmts = this.createStatementAst(child);
                body = Array.isArray(stmts) ? stmts[0] : stmts;
                continue;
            }
        }
        //  LexicalDeclaration ?
        if (hasLexicalDeclaration) {
            // for (let i = 0; test; update) - LexicalDeclaration ?init
            //  test ?update
            if (expressions.length >= 1) test = expressions[0];
            if (expressions.length >= 2) update = expressions[1];
        } else if (init) {
            // for (var i = 0; test; update) - init ?
            //  test ?update
            if (expressions.length >= 1) test = expressions[0];
            if (expressions.length >= 2) update = expressions[1];
        } else {
            // for (init; test; update) - ?
            if (expressions.length >= 1) init = expressions[0];
            if (expressions.length >= 2) test = expressions[1];
            if (expressions.length >= 3) update = expressions[2];
        }
        return SlimeAstCreateUtil.createForStatement(body, init, test, update, cst.loc, forToken, lParenToken, rParenToken, semicolonTokens[0], semicolonTokens[1]);
    }
    /**
     * ?VariableDeclarationList  VariableDeclaration AST
     */ createVariableDeclarationFromList(cst, kind) {
        const children = cst.children || [];
        const declarations = [];
        for (const child of children){
            if (!child) continue;
            const name = child.name;
            // Skip commas
            if (child.value === ',' || name === 'Comma') continue;
            // VariableDeclaration
            if (name === _SlimeParser$1.prototype.VariableDeclaration?.name || name === 'VariableDeclaration') {
                declarations.push(this.createVariableDeclaratorFromVarDeclaration(child));
            }
        }
        return {
            type: SlimeNodeType.VariableDeclaration,
            kind: kind,
            declarations: declarations,
            loc: cst.loc
        };
    }
    /**
     *  for...in / for...of  AST
     */ createForInOfStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ForInOfStatement?.name);
        // ForInOfStatement ?
        // ?for-in/of: [ForTok, LParen, ForDeclaration, InTok/OfTok, Expression, RParen, Statement]
        // for await: [ForTok, AwaitTok, LParen, ForDeclaration, OfTok, AssignmentExpression, RParen, Statement]
        //  for await
        const hasAwait = cst.children.some((ch)=>ch.name === 'Await');
        // ?
        let left = null;
        let right = null;
        let body = null;
        let isForOf = false;
        //  ForDeclaration ?LeftHandSideExpression
        const forDeclarationCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ForDeclaration?.name || ch.name === 'ForDeclaration');
        const leftHandSideCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.LeftHandSideExpression?.name || ch.name === 'LeftHandSideExpression');
        const varBindingCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ForBinding?.name || ch.name === 'ForBinding');
        //  ES5 : for (var x = init in expr)
        // CST : [For, LParen, Var, BindingIdentifier, Initializer, In, Expression, RParen, Statement]
        const varTokenCst = cst.children.find((ch)=>ch.name === 'Var' || ch.value === 'var');
        const bindingIdCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        const initializerCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Initializer?.name || ch.name === 'Initializer');
        if (forDeclarationCst) {
            // ForDeclaration ?LetOrConst + ForBinding
            const letOrConstCst = forDeclarationCst.children[0];
            const forBindingCst = forDeclarationCst.children[1];
            // ForBindingBindingIdentifierBindingPattern
            const actualBinding = forBindingCst.children[0];
            let id;
            if (actualBinding.name === _SlimeParser$1.prototype.BindingPattern?.name || actualBinding.name === 'BindingPattern') {
                id = this.createBindingPatternAst(actualBinding);
            } else if (actualBinding.name === _SlimeParser$1.prototype.BindingIdentifier?.name || actualBinding.name === 'BindingIdentifier') {
                id = this.createBindingIdentifierAst(actualBinding);
            } else {
                id = this.createBindingIdentifierAst(actualBinding);
            }
            const kind = letOrConstCst.children[0].value // 'let' or 'const'
            ;
            left = {
                type: SlimeNodeType.VariableDeclaration,
                declarations: [
                    {
                        type: SlimeNodeType.VariableDeclarator,
                        id: id,
                        init: null,
                        loc: forBindingCst.loc
                    }
                ],
                kind: {
                    type: 'VariableDeclarationKind',
                    value: kind,
                    loc: letOrConstCst.loc
                },
                loc: forDeclarationCst.loc
            };
        } else if (varTokenCst && bindingIdCst && initializerCst) {
            // ES5 : for (var x = init in expr) - 
            const id = this.createBindingIdentifierAst(bindingIdCst);
            const init = this.createInitializerAst(initializerCst);
            left = {
                type: SlimeNodeType.VariableDeclaration,
                declarations: [
                    {
                        type: SlimeNodeType.VariableDeclarator,
                        id: id,
                        init: init,
                        loc: {
                            ...bindingIdCst.loc,
                            end: initializerCst.loc.end
                        }
                    }
                ],
                kind: {
                    type: 'VariableDeclarationKind',
                    value: 'var',
                    loc: varTokenCst.loc
                },
                loc: {
                    ...varTokenCst.loc,
                    end: initializerCst.loc.end
                }
            };
        } else if (leftHandSideCst) {
            left = this.createLeftHandSideExpressionAst(leftHandSideCst);
        } else if (varBindingCst) {
            // var ForBinding
            const actualBinding = varBindingCst.children[0];
            let id;
            if (actualBinding.name === _SlimeParser$1.prototype.BindingPattern?.name || actualBinding.name === 'BindingPattern') {
                id = this.createBindingPatternAst(actualBinding);
            } else {
                id = this.createBindingIdentifierAst(actualBinding);
            }
            left = {
                type: SlimeNodeType.VariableDeclaration,
                declarations: [
                    {
                        type: SlimeNodeType.VariableDeclarator,
                        id: id,
                        init: null,
                        loc: varBindingCst.loc
                    }
                ],
                kind: {
                    type: 'VariableDeclarationKind',
                    value: 'var',
                    loc: cst.children.find((ch)=>ch.name === 'Var')?.loc
                },
                loc: varBindingCst.loc
            };
        }
        //  in/of token
        const inOrOfCst = cst.children.find((ch)=>ch.name === 'In' || ch.name === 'Of' || ch.value === 'in' || ch.value === 'of');
        isForOf = inOrOfCst?.value === 'of' || inOrOfCst?.name === 'OfTok';
        //  right expression (?in/of )
        const inOrOfIndex = cst.children.indexOf(inOrOfCst);
        if (inOrOfIndex !== -1 && inOrOfIndex + 1 < cst.children.length) {
            const rightCst = cst.children[inOrOfIndex + 1];
            if (rightCst.name !== 'RParen') {
                right = this.createExpressionAst(rightCst);
            }
        }
        //  Statement (body)
        const statementCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Statement?.name || ch.name === 'Statement');
        if (statementCst) {
            const bodyStatements = this.createStatementAst(statementCst);
            body = Array.isArray(bodyStatements) && bodyStatements.length > 0 ? bodyStatements[0] : bodyStatements;
        }
        const result = {
            type: isForOf ? SlimeNodeType.ForOfStatement : SlimeNodeType.ForInStatement,
            left: left,
            right: right,
            body: body,
            loc: cst.loc
        };
        // for await ?await ?
        if (hasAwait) {
            result.await = true;
        }
        return result;
    }
    /**
     *  while  AST
     */ createWhileStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.WhileStatement?.name);
        // WhileStatement: WhileTok LParen Expression RParen Statement
        let whileToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        for (const child of cst.children){
            if (!child) continue;
            if (child.name === 'While' || child.value === 'while') {
                whileToken = SlimeTokenCreate.createWhileToken(child.loc);
            } else if (child.name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
            } else if (child.name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
            }
        }
        const expression = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Expression?.name);
        const statement = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Statement?.name);
        const test = expression ? this.createExpressionAst(expression) : null;
        // createStatementAst?
        const bodyArray = statement ? this.createStatementAst(statement) : [];
        const body = bodyArray.length > 0 ? bodyArray[0] : null;
        return SlimeAstCreateUtil.createWhileStatement(test, body, cst.loc, whileToken, lParenToken, rParenToken);
    }
    /**
     *  do...while  AST
     */ createDoWhileStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.DoWhileStatement?.name);
        // DoWhileStatement: do Statement while ( Expression ) ;
        let doToken = undefined;
        let whileToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        let semicolonToken = undefined;
        let body = null;
        let test = null;
        for (const child of cst.children){
            if (!child) continue;
            const name = child.name;
            if (name === 'Do' || child.value === 'do') {
                doToken = SlimeTokenCreate.createDoToken(child.loc);
            } else if (name === 'While' || child.value === 'while') {
                whileToken = SlimeTokenCreate.createWhileToken(child.loc);
            } else if (name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
            } else if (name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
            } else if (name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (name === _SlimeParser$1.prototype.Statement?.name || name === 'Statement') {
                const bodyArray = this.createStatementAst(child);
                body = bodyArray.length > 0 ? bodyArray[0] : null;
            } else if (name === _SlimeParser$1.prototype.Expression?.name || name === 'Expression') {
                test = this.createExpressionAst(child);
            }
        }
        return SlimeAstCreateUtil.createDoWhileStatement(body, test, cst.loc, doToken, whileToken, lParenToken, rParenToken, semicolonToken);
    }
    /**
     *  switch  AST
     * SwitchStatement: switch ( Expression ) CaseBlock
     */ createSwitchStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.SwitchStatement?.name);
        let switchToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        for (const child of cst.children){
            if (!child) continue;
            if (child.name === 'Switch' || child.value === 'switch') {
                switchToken = SlimeTokenCreate.createSwitchToken(child.loc);
            } else if (child.name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
            } else if (child.name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
            }
        }
        //  discriminant?
        const discriminantCst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.Expression?.name);
        const discriminant = discriminantCst ? this.createExpressionAst(discriminantCst) : null;
        //  cases CaseBlock 
        const caseBlockCst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.CaseBlock?.name);
        const cases = caseBlockCst ? this.extractCasesFromCaseBlock(caseBlockCst) : [];
        // ?CaseBlock  brace tokens
        if (caseBlockCst && caseBlockCst.children) {
            const lBraceCst = caseBlockCst.children.find((ch)=>ch.name === 'LBrace' || ch.value === '{');
            const rBraceCst = caseBlockCst.children.find((ch)=>ch.name === 'RBrace' || ch.value === '}');
            if (lBraceCst) lBraceToken = SlimeTokenCreate.createLBraceToken(lBraceCst.loc);
            if (rBraceCst) rBraceToken = SlimeTokenCreate.createRBraceToken(rBraceCst.loc);
        }
        return SlimeAstCreateUtil.createSwitchStatement(discriminant, cases, cst.loc, switchToken, lParenToken, rParenToken, lBraceToken, rBraceToken);
    }
    // ====================  ====================
    /**
     * BreakableStatement CST ?AST?
     * BreakableStatement -> IterationStatement | SwitchStatement
     */ createBreakableStatementAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createStatementDeclarationAst(firstChild);
        }
        throw new Error('BreakableStatement has no children');
    }
    /**
     * IterationStatement CST ?AST?
     * IterationStatement -> DoWhileStatement | WhileStatement | ForStatement | ForInOfStatement
     */ createIterationStatementAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createStatementDeclarationAst(firstChild);
        }
        throw new Error('IterationStatement has no children');
    }
    /**
     * CaseBlock CST ?AST
     * CaseBlock -> { CaseClauses? DefaultClause? CaseClauses? }
     */ createCaseBlockAst(cst) {
        return this.extractCasesFromCaseBlock(cst);
    }
    /**
     * CaseClauses CST ?AST
     * CaseClauses -> CaseClause+
     */ createCaseClausesAst(cst) {
        const cases = [];
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.CaseClause?.name || child.name === 'CaseClause') {
                cases.push(this.createSwitchCaseAst(child));
            }
        }
        return cases;
    }
    /**
     * CaseClause CST ?AST
     * CaseClause -> case Expression : StatementList?
     */ createCaseClauseAst(cst) {
        return this.createSwitchCaseAst(cst);
    }
    /**
     * DefaultClause CST ?AST
     * DefaultClause -> default : StatementList?
     */ createDefaultClauseAst(cst) {
        return this.createSwitchCaseAst(cst);
    }
    /**
     * LabelledItem CST ?AST?
     * LabelledItem -> Statement | FunctionDeclaration
     */ createLabelledItemAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createStatementDeclarationAst(firstChild);
        }
        throw new Error('LabelledItem has no children');
    }
    /**
     * Catch CST ?CatchClause AST
     * Catch -> catch ( CatchParameter ) Block | catch Block
     */ createCatchAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Catch?.name);
        // Catch: CatchTok LParen CatchParameter RParen Block
        let catchToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        for (const child of cst.children){
            if (!child) continue;
            if (child.name === 'Catch' || child.value === 'catch') {
                catchToken = SlimeTokenCreate.createCatchToken(child.loc);
            } else if (child.name === 'LParen' || child.value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
            } else if (child.name === 'RParen' || child.value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
            }
        }
        const paramCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.CatchParameter?.name);
        const blockCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Block?.name);
        const param = paramCst ? this.createCatchParameterAst(paramCst) : null;
        const body = blockCst ? this.createBlockAst(blockCst) : SlimeAstCreateUtil.createBlockStatement([]);
        return SlimeAstCreateUtil.createCatchClause(body, param, cst.loc, catchToken, lParenToken, rParenToken);
    }
    /**
     * SemicolonASI CST ?AST
     * 
     */ createSemicolonASIAst(cst) {
        // ASI  AST ?null
        return null;
    }
    /**
     * ForDeclaration CST ?AST
     * ForDeclaration -> LetOrConst ForBinding
     */ createForDeclarationAst(cst) {
        const letOrConst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.LetOrConst?.name || ch.name === 'LetOrConst');
        const forBinding = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.ForBinding?.name || ch.name === 'ForBinding');
        const kind = letOrConst?.children?.[0]?.value || 'let';
        const id = forBinding ? this.createForBindingAst(forBinding) : null;
        return {
            type: SlimeNodeType.VariableDeclaration,
            declarations: [
                {
                    type: SlimeNodeType.VariableDeclarator,
                    id: id,
                    init: null,
                    loc: forBinding?.loc
                }
            ],
            kind: {
                type: 'VariableDeclarationKind',
                value: kind,
                loc: letOrConst?.loc
            },
            loc: cst.loc
        };
    }
    /**
     * ForBinding CST ?AST
     * ForBinding -> BindingIdentifier | BindingPattern
     */ createForBindingAst(cst) {
        const firstChild = cst.children?.[0];
        if (!firstChild) return null;
        if (firstChild.name === _SlimeParser$1.prototype.BindingIdentifier?.name || firstChild.name === 'BindingIdentifier') {
            return this.createBindingIdentifierAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.BindingPattern?.name || firstChild.name === 'BindingPattern') {
            return this.createBindingPatternAst(firstChild);
        }
        return this.createBindingIdentifierAst(firstChild);
    }
    /**
     * LetOrConst CST ?AST
     * LetOrConst -> let | const
     */ createLetOrConstAst(cst) {
        const token = cst.children?.[0];
        return token?.value || 'let';
    }
    /**
     * ?CaseBlock ?case/default 
     * CaseBlock: { CaseClauses? DefaultClause? CaseClauses? }
     */ extractCasesFromCaseBlock(caseBlockCst) {
        const cases = [];
        if (!caseBlockCst.children) return cases;
        // CaseBlock ?children:
        // [0]: LBrace
        // [1-n]: CaseClauses / DefaultClause
        // [last]: RBrace
        caseBlockCst.children.forEach((child)=>{
            if (child.name === _SlimeParser$1.prototype.CaseClauses?.name) {
                // CaseClauses  CaseClause
                if (child.children) {
                    child.children.forEach((caseClauseCst)=>{
                        cases.push(this.createSwitchCaseAst(caseClauseCst));
                    });
                }
            } else if (child.name === _SlimeParser$1.prototype.DefaultClause?.name) {
                // DefaultClause
                cases.push(this.createSwitchCaseAst(child));
            }
        });
        return cases;
    }
    /**
     * [AST ] CaseClause/DefaultClause CST ?SwitchCase AST
     *
     * CST ?case ?default CaseClause/DefaultClause
     * ?ESTree AST  SwitchCase  test ?null ?
     *
     * CaseClause: case Expression : StatementList?
     * DefaultClause: default : StatementList?
     * @internal
     */ createSwitchCaseAst(cst) {
        let test = null;
        let consequent = [];
        let caseToken = undefined;
        let defaultToken = undefined;
        let colonToken = undefined;
        if (cst.name === _SlimeParser$1.prototype.CaseClause?.name) {
            // CaseClause ?
            // children[0]: CaseTok
            // children[1]: Expression - test
            // children[2]: Colon
            // children[3]: StatementList
            for (const child of cst.children || []){
                if (child.name === 'Case' || child.value === 'case') {
                    caseToken = SlimeTokenCreate.createCaseToken(child.loc);
                } else if (child.name === 'Colon' || child.value === ':') {
                    colonToken = SlimeTokenCreate.createColonToken(child.loc);
                }
            }
            const testCst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.Expression?.name);
            test = testCst ? this.createExpressionAst(testCst) : null;
            const stmtListCst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.StatementList?.name);
            consequent = stmtListCst ? this.createStatementListAst(stmtListCst) : [];
        } else if (cst.name === _SlimeParser$1.prototype.DefaultClause?.name) {
            // DefaultClause ?
            // children[0]: DefaultTok
            // children[1]: Colon
            // children[2]: StatementList
            for (const child of cst.children || []){
                if (child.name === 'Default' || child.value === 'default') {
                    defaultToken = SlimeTokenCreate.createDefaultToken(child.loc);
                } else if (child.name === 'Colon' || child.value === ':') {
                    colonToken = SlimeTokenCreate.createColonToken(child.loc);
                }
            }
            test = null; // default  test
            const stmtListCst = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.StatementList?.name);
            consequent = stmtListCst ? this.createStatementListAst(stmtListCst) : [];
        }
        return SlimeAstCreateUtil.createSwitchCase(consequent, test, cst.loc, caseToken, defaultToken, colonToken);
    }
    /**
     *  try  AST
     */ createTryStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.TryStatement?.name);
        // TryStatement: TryTok Block (Catch Finally? | Finally)
        let tryToken = undefined;
        let finallyToken = undefined;
        for (const child of cst.children){
            if (!child) continue;
            if (child.name === 'Try' || child.value === 'try') {
                tryToken = SlimeTokenCreate.createTryToken(child.loc);
            } else if (child.name === 'Finally' || child.value === 'finally') {
                finallyToken = SlimeTokenCreate.createFinallyToken(child.loc);
            }
        }
        const blockCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Block?.name);
        const catchCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Catch?.name);
        const finallyCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Finally?.name);
        const block = blockCst ? this.createBlockAst(blockCst) : null;
        const handler = catchCst ? this.createCatchAst(catchCst) : null;
        const finalizer = finallyCst ? this.createFinallyAst(finallyCst) : null;
        return SlimeAstCreateUtil.createTryStatement(block, handler, finalizer, cst.loc, tryToken, finallyToken);
    }
    /**
     * Block CSTBlockStatement AST
     * Block: LBrace StatementList? RBrace
     */ createBlockAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Block?.name);
        // Block LBrace StatementList? RBrace
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        if (cst.children) {
            for (const child of cst.children){
                if (child.name === 'LBrace' || child.value === '{') {
                    lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
                } else if (child.name === 'RBrace' || child.value === '}') {
                    rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
                }
            }
        }
        const statementListCst = cst.children?.find((child)=>child.name === _SlimeParser$1.prototype.StatementList?.name);
        const statements = statementListCst ? this.createStatementListAst(statementListCst) : [];
        return SlimeAstCreateUtil.createBlockStatement(statements, cst.loc, lBraceToken, rBraceToken);
    }
    /**
     *  CatchParameter AST
     */ createCatchParameterAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.CatchParameter?.name);
        // CatchParameter: BindingIdentifier | BindingPattern
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            return this.createBindingIdentifierAst(first);
        } else if (first.name === _SlimeParser$1.prototype.BindingPattern?.name) {
            return this.createBindingPatternAst(first);
        }
        return null;
    }
    /**
     *  Finally  AST
     */ createFinallyAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Finally?.name);
        // Finally: FinallyTok Block
        const blockCst = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.Block?.name);
        return blockCst ? this.createBlockAst(blockCst) : null;
    }
    /**
     *  throw  AST
     */ createThrowStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ThrowStatement?.name);
        // ThrowStatement: throw Expression ;
        let throwToken = undefined;
        let semicolonToken = undefined;
        let argument = null;
        for (const child of cst.children || []){
            if (child.name === 'Throw' || child.value === 'throw') {
                throwToken = SlimeTokenCreate.createThrowToken(child.loc);
            } else if (child.name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression') {
                argument = this.createExpressionAst(child);
            }
        }
        return SlimeAstCreateUtil.createThrowStatement(argument, cst.loc, throwToken, semicolonToken);
    }
    /**
     *  break  AST
     */ createBreakStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BreakStatement?.name);
        // BreakStatement: break Identifier? ;
        let breakToken = undefined;
        let semicolonToken = undefined;
        let label = null;
        for (const child of cst.children || []){
            if (child.name === 'Break' || child.value === 'break') {
                breakToken = SlimeTokenCreate.createBreakToken(child.loc);
            } else if (child.name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (child.name === _SlimeParser$1.prototype.LabelIdentifier?.name || child.name === 'LabelIdentifier') {
                label = this.createLabelIdentifierAst(child);
            } else if (child.name === _SlimeParser$1.prototype.IdentifierName?.name) {
                label = this.createIdentifierNameAst(child);
            } else if (child.name === SlimeTokenConsumer.prototype.IdentifierName?.name) {
                label = this.createIdentifierAst(child);
            }
        }
        return SlimeAstCreateUtil.createBreakStatement(label, cst.loc, breakToken, semicolonToken);
    }
    /**
     *  continue  AST
     */ createContinueStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ContinueStatement?.name);
        // ContinueStatement: continue Identifier? ;
        let continueToken = undefined;
        let semicolonToken = undefined;
        let label = null;
        for (const child of cst.children || []){
            if (child.name === 'Continue' || child.value === 'continue') {
                continueToken = SlimeTokenCreate.createContinueToken(child.loc);
            } else if (child.name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            } else if (child.name === _SlimeParser$1.prototype.LabelIdentifier?.name || child.name === 'LabelIdentifier') {
                label = this.createLabelIdentifierAst(child);
            } else if (child.name === _SlimeParser$1.prototype.IdentifierName?.name) {
                label = this.createIdentifierNameAst(child);
            } else if (child.name === SlimeTokenConsumer.prototype.IdentifierName?.name) {
                label = this.createIdentifierAst(child);
            }
        }
        return SlimeAstCreateUtil.createContinueStatement(label, cst.loc, continueToken, semicolonToken);
    }
    /**
     *  AST
     * ES2025: LabelledStatement -> LabelIdentifier : LabelledItem
     * LabelledItem -> Statement | FunctionDeclaration
     */ createLabelledStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.LabelledStatement?.name);
        let label = null;
        let body = null;
        if (cst.children && cst.children.length > 0) {
            for (const child of cst.children){
                if (!child) continue;
                const name = child.name;
                // Skip tokens (Colon)
                if (child.value === ':' || name === 'Colon') continue;
                // LabelIdentifier -> Identifier | yield | await
                if (name === _SlimeParser$1.prototype.LabelIdentifier?.name || name === 'LabelIdentifier') {
                    label = this.createLabelIdentifierAst(child);
                    continue;
                }
                // LabelledItem -> Statement | FunctionDeclaration
                if (name === _SlimeParser$1.prototype.LabelledItem?.name || name === 'LabelledItem') {
                    // LabelledItem ?Statement ?FunctionDeclaration
                    const itemChild = child.children?.[0];
                    if (itemChild) {
                        //  createStatementDeclarationAst ?createStatementAst
                        //  LabelledItem  FunctionDeclaration
                        body = this.createStatementDeclarationAst(itemChild);
                    }
                    continue;
                }
                //  Statement
                if (name === _SlimeParser$1.prototype.Statement?.name || name === 'Statement') {
                    body = this.createStatementDeclarationAst(child);
                    continue;
                }
                //  Identifier
                if (name === _SlimeParser$1.prototype.IdentifierName?.name) {
                    label = this.createIdentifierNameAst(child);
                    continue;
                }
                if (name === SlimeTokenConsumer.prototype.IdentifierName?.name) {
                    label = this.createIdentifierAst(child);
                    continue;
                }
            }
        }
        return {
            type: SlimeNodeType.LabeledStatement,
            label: label,
            body: body,
            loc: cst.loc
        };
    }
    /**
     *  with  AST
     * WithStatement: with ( Expression ) Statement
     */ createWithStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.WithStatement?.name);
        let object = null;
        let body = null;
        let withToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        for (const child of cst.children || []){
            if (child.name === 'With' || child.value === 'with') {
                withToken = child;
            } else if (child.name === 'LParen' || child.value === '(') {
                lParenToken = child;
            } else if (child.name === 'RParen' || child.value === ')') {
                rParenToken = child;
            } else if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression') {
                object = this.createExpressionAst(child);
            } else if (child.name === _SlimeParser$1.prototype.Statement?.name || child.name === 'Statement') {
                // createStatementAst ?
                const bodyArray = this.createStatementAst(child);
                body = Array.isArray(bodyArray) && bodyArray.length > 0 ? bodyArray[0] : bodyArray;
            }
        }
        return {
            type: SlimeNodeType.WithStatement,
            object,
            body,
            withToken,
            lParenToken,
            rParenToken,
            loc: cst.loc
        };
    }
    /**
     *  debugger  AST
     */ createDebuggerStatementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.DebuggerStatement?.name);
        let debuggerToken = undefined;
        let semicolonToken = undefined;
        for (const child of cst.children || []){
            if (child.name === 'Debugger' || child.value === 'debugger') {
                debuggerToken = SlimeTokenCreate.createDebuggerToken(child.loc);
            } else if (child.name === 'Semicolon' || child.value === ';') {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(child.loc);
            }
        }
        return SlimeAstCreateUtil.createDebuggerStatement(cst.loc, debuggerToken, semicolonToken);
    }
    /**
     * ?AST
     */ createEmptyStatementAst(cst) {
        //  EmptyStatement ?NotEmptySemicolon
        // checkCstName(cst, Es2025Parser.prototype.EmptyStatement?.name);
        let semicolonToken = undefined;
        // EmptyStatement ?Semicolon token
        if (cst.value === ';' || cst.name === SlimeTokenConsumer.prototype.Semicolon?.name) {
            semicolonToken = SlimeTokenCreate.createSemicolonToken(cst.loc);
        } else {
            // ?semicolon token
            const semicolonCst = cst.children?.find((ch)=>ch.name === 'Semicolon' || ch.value === ';');
            if (semicolonCst) {
                semicolonToken = SlimeTokenCreate.createSemicolonToken(semicolonCst.loc);
            }
        }
        return SlimeAstCreateUtil.createEmptyStatement(cst.loc, semicolonToken);
    }
    /**
     *  AST
     * ES2025 FunctionDeclaration structure:
     * - function BindingIdentifier ( FormalParameters ) { FunctionBody }
     * Children: [FunctionTok, BindingIdentifier, LParen, FormalParameters, RParen, LBrace, FunctionBody, RBrace]
     */ createFunctionDeclarationAst(cst) {
        const children = cst.children || [];
        let functionName = null;
        let params = [];
        let body = null;
        let isAsync = false;
        let isGenerator = false;
        // Token fields
        let functionToken = undefined;
        let asyncToken = undefined;
        let asteriskToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (!child) continue;
            const name = child.name;
            const value = child.value || child.loc?.value;
            // Collect tokens
            if (name === 'Function' || value === 'function') {
                functionToken = SlimeTokenCreate.createFunctionToken(child.loc);
                continue;
            }
            if (name === 'LParen' || value === '(') {
                lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                continue;
            }
            if (name === 'RParen' || value === ')') {
                rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                continue;
            }
            if (name === 'LBrace' || value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
                continue;
            }
            if (name === 'RBrace' || value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
                continue;
            }
            if (name === 'Async' || value === 'async') {
                asyncToken = SlimeTokenCreate.createAsyncToken(child.loc);
                isAsync = true;
                continue;
            }
            if (name === 'Asterisk' || value === '*') {
                asteriskToken = SlimeTokenCreate.createAsteriskToken(child.loc);
                isGenerator = true;
                continue;
            }
            // BindingIdentifier - function name
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                functionName = this.createBindingIdentifierAst(child);
                continue;
            }
            // FormalParameters - function parameters ()
            if (name === _SlimeParser$1.prototype.FormalParameters?.name || name === 'FormalParameters') {
                params = this.createFormalParametersAstWrapped(child);
                continue;
            }
            // FunctionBody - function body
            if (name === _SlimeParser$1.prototype.FunctionBody?.name || name === 'FunctionBody') {
                const statements = this.createFunctionBodyAst(child);
                body = SlimeAstCreateUtil.createBlockStatement(statements, child.loc);
                continue;
            }
        }
        // Create default empty body if not found
        if (!body) {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return SlimeAstCreateUtil.createFunctionDeclaration(functionName, params, body, isGenerator, isAsync, cst.loc, functionToken, asyncToken, asteriskToken, lParenToken, rParenToken, lBraceToken, rBraceToken);
    }
    /**
     * Create FormalParameters AST
     * ES2025 FormalParameters:
     *   [empty]
     *   FunctionRestParameter
     *   FormalParameterList
     *   FormalParameterList ,
     *   FormalParameterList , FunctionRestParameter
     */ createFormalParametersAstWrapped(cst) {
        const children = cst.children || [];
        const params = [];
        let currentParam = null;
        let hasParam = false;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (!child) continue;
            const name = child.name;
            // Skip parentheses
            if (child.value === '(' || name === 'LParen') continue;
            if (child.value === ')' || name === 'RParen') continue;
            // Handle comma - pair with previous param
            if (child.value === ',' || name === 'Comma') {
                if (hasParam) {
                    const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, commaToken));
                    hasParam = false;
                    currentParam = null;
                }
                continue;
            }
            // FormalParameterList?FormalParameter ()
            if (name === _SlimeParser$1.prototype.FormalParameterList?.name || name === 'FormalParameterList') {
                // 
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                    hasParam = false;
                    currentParam = null;
                }
                params.push(...this.createFormalParameterListFromEs2025Wrapped(child));
                continue;
            }
            // FunctionRestParameter
            if (name === _SlimeParser$1.prototype.FunctionRestParameter?.name || name === 'FunctionRestParameter') {
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                }
                currentParam = this.createFunctionRestParameterAst(child);
                hasParam = true;
                continue;
            }
            // Direct FormalParameterES2025 ?
            if (name === _SlimeParser$1.prototype.FormalParameter?.name || name === 'FormalParameter') {
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                }
                currentParam = this.createFormalParameterAst(child);
                hasParam = true;
                continue;
            }
            // Direct BindingElement or BindingIdentifier
            if (name === _SlimeParser$1.prototype.BindingElement?.name || name === 'BindingElement') {
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                }
                currentParam = this.createBindingElementAst(child);
                hasParam = true;
                continue;
            }
            if (name === _SlimeParser$1.prototype.BindingIdentifier?.name || name === 'BindingIdentifier') {
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                }
                currentParam = this.createBindingIdentifierAst(child);
                hasParam = true;
                continue;
            }
        }
        // ?
        if (hasParam) {
            params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
        }
        return params;
    }
    /**
     * ?ES2025 FormalParameterList  AST
     * FormalParameterList: FormalParameter (, FormalParameter)*
     */ createFormalParameterListFromEs2025Wrapped(cst) {
        const children = cst.children || [];
        const params = [];
        let currentParam = null;
        let hasParam = false;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (!child) continue;
            const name = child.name;
            // Handle comma - pair with previous param
            if (child.value === ',' || name === 'Comma') {
                if (hasParam) {
                    const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, commaToken));
                    hasParam = false;
                    currentParam = null;
                }
                continue;
            }
            // FormalParameter -> BindingElement
            if (name === _SlimeParser$1.prototype.FormalParameter?.name || name === 'FormalParameter') {
                if (hasParam) {
                    params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
                }
                currentParam = this.createFormalParameterAst(child);
                hasParam = true;
            }
        }
        // ?
        if (hasParam) {
            params.push(SlimeAstCreateUtil.createFunctionParam(currentParam, undefined));
        }
        return params;
    }
    createFunctionRestParameterAstAlt(cst) {
        // FunctionRestParameter: ... BindingIdentifier | ... BindingPattern
        // ?FunctionRestParameter -> BindingRestElement
        const children = cst.children || [];
        let argument = null;
        for (const child of children){
            if (!child) continue;
            if (child.value === '...' || child.name === 'Ellipsis') continue;
            if (child.name === _SlimeParser$1.prototype.BindingIdentifier?.name || child.name === 'BindingIdentifier') {
                argument = this.createBindingIdentifierAst(child);
            } else if (child.name === _SlimeParser$1.prototype.BindingRestElement?.name || child.name === 'BindingRestElement') {
                // BindingRestElement ?RestElement 
                return this.createBindingRestElementAst(child);
            } else if (child.name === _SlimeParser$1.prototype.BindingPattern?.name || child.name === 'BindingPattern') {
                argument = this.createBindingPatternAst(child);
            }
        }
        return {
            type: SlimeNodeType.RestElement,
            argument: argument,
            loc: cst.loc
        };
    }
    createCallExpressionAst(cst) {
        // Support both CallExpression and CoverCallExpressionAndAsyncArrowHead
        const isCallExpr = cst.name === _SlimeParser$1.prototype.CallExpression?.name || cst.name === 'CallExpression';
        const isCoverExpr = cst.name === 'CoverCallExpressionAndAsyncArrowHead';
        if (!isCallExpr && !isCoverExpr) {
            throw new Error(`createCallExpressionAst: Expected CallExpression or CoverCallExpressionAndAsyncArrowHead, got ${cst.name}`);
        }
        if (cst.children.length === 1) {
            // SuperCall
            const first = cst.children[0];
            if (first.name === _SlimeParser$1.prototype.SuperCall?.name) {
                return this.createSuperCallAst(first);
            }
            return this.createExpressionAst(first);
        }
        // childrenMemberExpression + Arguments + 
        // children[0]: MemberExpression ?CoverCallExpressionAndAsyncArrowHead
        // children[1]: Arguments (?
        // children[2+]: Dot/Identifier/Arguments
        let current;
        const firstChild = cst.children[0];
        // 
        if (firstChild.name === 'CoverCallExpressionAndAsyncArrowHead') {
            // CoverCallExpressionAndAsyncArrowHead : [MemberExpression, Arguments]
            // ?
            current = this.createCallExpressionAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.MemberExpression?.name || firstChild.name === 'MemberExpression') {
            current = this.createMemberExpressionAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.SuperCall?.name || firstChild.name === 'SuperCall') {
            current = this.createSuperCallAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.ImportCall?.name || firstChild.name === 'ImportCall') {
            current = this.createImportCallAst(firstChild);
        } else {
            // ?
            current = this.createExpressionAst(firstChild);
        }
        // children
        for(let i = 1; i < cst.children.length; i++){
            const child = cst.children[i];
            if (child.name === _SlimeParser$1.prototype.Arguments?.name || child.name === 'Arguments') {
                // () - 
                const args = this.createArgumentsAst(child);
                current = SlimeAstCreateUtil.createCallExpression(current, args);
            } else if (child.name === 'DotMemberExpression') {
                // DotMemberExpressionDotIdentifierName ()
                const dotChild = child.children[0] // Dot token
                ;
                const identifierNameCst = child.children[1] // IdentifierName
                ;
                const tokenCst = identifierNameCst.children[0] // tokenIdentifier?
                ;
                const property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
                const dotOp = SlimeTokenCreate.createDotToken(dotChild.loc);
                current = SlimeAstCreateUtil.createMemberExpression(current, dotOp, property);
            } else if (child.name === 'Dot') {
                // Es2025Parser?Dot token + IdentifierName
                const dotOp = SlimeTokenCreate.createDotToken(child.loc);
                // childIdentifierNamePrivateIdentifier
                const nextChild = cst.children[i + 1];
                let property = null;
                if (nextChild) {
                    if (nextChild.name === _SlimeParser$1.prototype.IdentifierName?.name || nextChild.name === 'IdentifierName') {
                        const tokenCst = nextChild.children[0];
                        property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
                        i++; // IdentifierName
                    } else if (nextChild.name === 'PrivateIdentifier') {
                        property = SlimeAstCreateUtil.createIdentifier(nextChild.value, nextChild.loc);
                        i++; // PrivateIdentifier
                    }
                }
                current = SlimeAstCreateUtil.createMemberExpression(current, dotOp, property);
            } else if (child.name === 'BracketExpression') {
                // [expr] - computed property ()
                const propertyExpression = this.createExpressionAst(child.children[1]);
                current = {
                    type: SlimeNodeType.MemberExpression,
                    object: current,
                    property: propertyExpression,
                    computed: true,
                    optional: false,
                    loc: cst.loc
                };
            } else if (child.name === 'LBracket') {
                // Es2025Parser?LBracket + Expression + RBracket
                const expressionChild = cst.children[i + 1];
                if (expressionChild && expressionChild.name !== 'RBracket') {
                    const propertyExpression = this.createExpressionAst(expressionChild);
                    current = {
                        type: SlimeNodeType.MemberExpression,
                        object: current,
                        property: propertyExpression,
                        computed: true,
                        optional: false,
                        loc: cst.loc
                    };
                    i += 2; // ExpressionRBracket
                }
            } else if (child.name === _SlimeParser$1.prototype.TemplateLiteral?.name || child.name === 'TemplateLiteral') {
                // `template` - Tagged Template
                const quasi = this.createTemplateLiteralAst(child);
                current = {
                    type: 'TaggedTemplateExpression',
                    tag: current,
                    quasi: quasi,
                    loc: cst.loc
                };
            } else if (child.name === 'RBracket') {
                continue;
            }
        }
        return current;
    }
    createSuperCallAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.SuperCall?.name);
        // SuperCall -> SuperTok + Arguments
        // children[0]: SuperTok token
        // children[1]: Arguments CST
        const argumentsCst = cst.children[1];
        const argumentsAst = this.createArgumentsAst(argumentsCst);
        // Supercallee
        const superNode = {
            type: "Super",
            loc: cst.children[0].loc
        };
        return SlimeAstCreateUtil.createCallExpression(superNode, argumentsAst);
    }
    /**
     *  ImportCall AST
     * ImportCall: import ( AssignmentExpression ,_opt )
     *           | import ( AssignmentExpression , AssignmentExpression ,_opt )
     */ createImportCallAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ImportCall?.name);
        // ImportCall -> ImportTok + LParen + AssignmentExpression + (Comma + AssignmentExpression)? + Comma? + RParen
        // children: [ImportTok, LParen, AssignmentExpression, (Comma, AssignmentExpression)?, Comma?, RParen]
        const args = [];
        for (const child of cst.children){
            if (child.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                const expr = this.createAssignmentExpressionAst(child);
                args.push(SlimeAstCreateUtil.createCallArgument(expr));
            }
        }
        //  import ?callee
        const importIdentifier = SlimeAstCreateUtil.createIdentifier('import', cst.children[0].loc);
        return SlimeAstCreateUtil.createCallExpression(importIdentifier, args);
    }
    createSuperPropertyAst(cst) {
        // SuperProperty:
        // 1: SuperTok + Dot + IdentifierName
        // 2: SuperTok + LBracket + Expression + RBracket
        const superNode = {
            type: "Super",
            loc: cst.children[0].loc
        };
        const second = cst.children[1];
        if (second.name === 'BracketExpression') {
            // super[expression] - 
            const propertyExpression = this.createExpressionAst(second.children[1]);
            return {
                type: SlimeNodeType.MemberExpression,
                object: superNode,
                property: propertyExpression,
                computed: true,
                optional: false,
                loc: cst.loc
            };
        } else if (second.name === 'LBracket') {
            // Es2025Parser: super[expression]
            // children: [SuperTok, LBracket, Expression, RBracket]
            const expressionCst = cst.children[2];
            const propertyExpression = this.createExpressionAst(expressionCst);
            return {
                type: SlimeNodeType.MemberExpression,
                object: superNode,
                property: propertyExpression,
                computed: true,
                optional: false,
                loc: cst.loc
            };
        } else if (second.name === 'Dot') {
            // Es2025Parser: super.property
            // children: [SuperTok, Dot, IdentifierName]
            const identifierNameCst = cst.children[2];
            let property;
            if (identifierNameCst.name === 'IdentifierName' || identifierNameCst.name === _SlimeParser$1.prototype.IdentifierName?.name) {
                const tokenCst = identifierNameCst.children[0];
                property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
            } else {
                // token
                property = SlimeAstCreateUtil.createIdentifier(identifierNameCst.value, identifierNameCst.loc);
            }
            return {
                type: SlimeNodeType.MemberExpression,
                object: superNode,
                property: property,
                computed: false,
                optional: false,
                loc: cst.loc
            };
        } else {
            // : super.property
            // children: [SuperTok, Dot, Identifier]
            const propToken = cst.children[2];
            const property = SlimeAstCreateUtil.createIdentifier(propToken.value, propToken.loc);
            return {
                type: SlimeNodeType.MemberExpression,
                object: superNode,
                property: property,
                computed: false,
                optional: false,
                loc: cst.loc
            };
        }
    }
    createMetaPropertyAst(cst) {
        // MetaProperty: children[0]NewTargetImportMeta
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.NewTarget?.name) {
            // new.target
            return {
                type: 'MetaProperty',
                meta: SlimeAstCreateUtil.createIdentifier('new', first.loc),
                property: SlimeAstCreateUtil.createIdentifier('target', first.loc),
                loc: cst.loc
            };
        } else {
            // import.meta
            return {
                type: 'MetaProperty',
                meta: SlimeAstCreateUtil.createIdentifier('import', first.loc),
                property: SlimeAstCreateUtil.createIdentifier('meta', first.loc),
                loc: cst.loc
            };
        }
    }
    createArgumentsAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Arguments?.name);
        const first1 = cst.children[1];
        if (first1) {
            if (first1.name === _SlimeParser$1.prototype.ArgumentList?.name) {
                const res = this.createArgumentListAst(first1);
                return res;
            }
        }
        return [];
    }
    createArgumentListAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ArgumentList?.name);
        const arguments_ = [];
        // children?Ellipsis + AssignmentExpression + Comma 
        // 
        let currentArg = null;
        let hasArg = false;
        let pendingEllipsis = null;
        for(let i = 0; i < cst.children.length; i++){
            const child = cst.children[i];
            if (child.name === 'Ellipsis' || child.name === 'Ellipsis') {
                //  ellipsis?spread
                pendingEllipsis = child;
            } else if (child.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                // 
                if (hasArg) {
                    arguments_.push(SlimeAstCreateUtil.createCallArgument(currentArg, undefined));
                }
                const expr = this.createAssignmentExpressionAst(child);
                if (pendingEllipsis) {
                    //  SpreadElement
                    const ellipsisToken = SlimeTokenCreate.createEllipsisToken(pendingEllipsis.loc);
                    currentArg = SlimeAstCreateUtil.createSpreadElement(expr, child.loc, ellipsisToken);
                    pendingEllipsis = null;
                } else {
                    currentArg = expr;
                }
                hasArg = true;
            } else if (child.name === _SlimeParser$1.prototype.SpreadElement?.name) {
                //  spread ?..args?
                if (hasArg) {
                    arguments_.push(SlimeAstCreateUtil.createCallArgument(currentArg, undefined));
                }
                currentArg = this.createSpreadElementAst(child);
                hasArg = true;
            } else if (child.name === 'Comma' || child.value === ',') {
                // 
                const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                if (hasArg) {
                    arguments_.push(SlimeAstCreateUtil.createCallArgument(currentArg, commaToken));
                    hasArg = false;
                    currentArg = null;
                }
            }
        }
        // ?
        if (hasArg) {
            arguments_.push(SlimeAstCreateUtil.createCallArgument(currentArg, undefined));
        }
        return arguments_;
    }
    createMemberExpressionFirstOr(cst) {
        if (cst.name === _SlimeParser$1.prototype.PrimaryExpression?.name || cst.name === 'PrimaryExpression') {
            return this.createPrimaryExpressionAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.SuperProperty?.name || cst.name === 'SuperProperty') {
            return this.createSuperPropertyAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.MetaProperty?.name || cst.name === 'MetaProperty') {
            return this.createMetaPropertyAst(cst);
        } else if (cst.name === 'NewMemberExpressionArguments') {
            return this.createNewExpressionAst(cst);
        } else if (cst.name === 'New') {
            // Es2025Parser: new MemberExpression Arguments  token 
            // ?createMemberExpressionAst ?
            throw new Error('createMemberExpressionFirstOr: NewTok should be handled in createMemberExpressionAst');
        } else {
            throw new Error('createMemberExpressionFirstOr: : ' + cst.name);
        }
    }
    createNewExpressionAst(cst) {
        // NewExpression ?NewMemberExpressionArguments
        const isNewMemberExpr = cst.name === 'NewMemberExpressionArguments';
        const isNewExpr = cst.name === _SlimeParser$1.prototype.NewExpression?.name;
        if (!isNewMemberExpr && !isNewExpr) {
            throw new Error('createNewExpressionAst:  ' + cst.name);
        }
        if (isNewMemberExpr) {
            // NewMemberExpressionArguments -> NewTok + MemberExpression + Arguments
            // Token fields
            let newToken = undefined;
            let lParenToken = undefined;
            let rParenToken = undefined;
            //  new token
            const newCst = cst.children[0];
            if (newCst && (newCst.name === 'New' || newCst.value === 'new')) {
                newToken = SlimeTokenCreate.createNewToken(newCst.loc);
            }
            //  Arguments  LParen/RParen tokens
            const argsCst = cst.children[2];
            if (argsCst && argsCst.children) {
                for (const child of argsCst.children){
                    if (child.name === 'LParen' || child.value === '(') {
                        lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                    } else if (child.name === 'RParen' || child.value === ')') {
                        rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                    }
                }
            }
            const calleeExpression = this.createMemberExpressionAst(cst.children[1]);
            const args = this.createArgumentsAst(cst.children[2]);
            return SlimeAstCreateUtil.createNewExpression(calleeExpression, args, cst.loc, newToken, lParenToken, rParenToken);
        } else {
            // NewExpression 
            // 1. MemberExpression - ?MemberExpression
            // 2. new NewExpression -  NewExpression?
            const firstChild = cst.children[0];
            if (firstChild.name === 'New' || firstChild.value === 'new') {
                //  `new NewExpression` ?NewExpression
                const newToken = SlimeTokenCreate.createNewToken(firstChild.loc);
                const innerNewExpr = cst.children[1];
                const calleeExpression = this.createNewExpressionAst(innerNewExpr);
                return SlimeAstCreateUtil.createNewExpression(calleeExpression, [], cst.loc, newToken, undefined, undefined);
            } else {
                //  MemberExpression 
                return this.createExpressionAst(firstChild);
            }
        }
    }
    createMemberExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.MemberExpression?.name);
        if (cst.children.length === 0) {
            throw new Error('MemberExpression has no children');
        }
        // childbase
        let current;
        let startIdx = 1;
        // Es2025Parser:  new MemberExpression Arguments 
        // ?NewTok
        if (cst.children[0].name === 'New') {
            // new MemberExpression Arguments []
            // children: [NewTok, MemberExpression, Arguments, Dot?, IdentifierName?, ...]
            const newCst = cst.children[0];
            const memberExprCst = cst.children[1];
            const argsCst = cst.children[2];
            const callee = this.createMemberExpressionAst(memberExprCst);
            const args = argsCst ? this.createArgumentsAst(argsCst) : [];
            //  tokens
            const newToken = SlimeTokenCreate.createNewToken(newCst.loc);
            let lParenToken = undefined;
            let rParenToken = undefined;
            if (argsCst && argsCst.children) {
                for (const child of argsCst.children){
                    if (child.name === 'LParen' || child.value === '(') {
                        lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                    } else if (child.name === 'RParen' || child.value === ')') {
                        rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                    }
                }
            }
            current = {
                type: 'NewExpression',
                callee: callee,
                arguments: args,
                newToken: newToken,
                lParenToken: lParenToken,
                rParenToken: rParenToken,
                loc: cst.loc
            };
            // ?Arguments  .bar?
            startIdx = 3;
        } else {
            current = this.createMemberExpressionFirstOr(cst.children[0]);
        }
        // childrenDot+IdentifierNameLBracket+Expression+RBracketArgumentsTemplateLiteral?
        for(let i = startIdx; i < cst.children.length; i++){
            const child = cst.children[i];
            if (child.name === 'DotIdentifier') {
                // .property -  ()
                const dotToken = SlimeTokenCreate.createDotToken(child.children[0].loc);
                // children[1]IdentifierNameIdentifiertoken
                let property = null;
                if (child.children[1]) {
                    const identifierNameCst = child.children[1];
                    if (identifierNameCst.name === _SlimeParser$1.prototype.IdentifierName?.name) {
                        // IdentifierName -> Identifier or Keyword token
                        const tokenCst = identifierNameCst.children[0];
                        property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
                    } else {
                        // token
                        property = this.createIdentifierAst(identifierNameCst);
                    }
                }
                // MemberExpressioncurrentobject
                current = SlimeAstCreateUtil.createMemberExpression(current, dotToken, property);
            } else if (child.name === 'Dot') {
                // Es2025Parser?Dot token + IdentifierName
                // .property - 
                const dotToken = SlimeTokenCreate.createDotToken(child.loc);
                // childIdentifierNamePrivateIdentifier
                const nextChild = cst.children[i + 1];
                let property = null;
                if (nextChild) {
                    if (nextChild.name === _SlimeParser$1.prototype.IdentifierName?.name || nextChild.name === 'IdentifierName') {
                        // IdentifierName -> Identifier or Keyword token
                        const tokenCst = nextChild.children[0];
                        property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
                        i++; // IdentifierName
                    } else if (nextChild.name === 'PrivateIdentifier') {
                        // ?#prop
                        property = SlimeAstCreateUtil.createIdentifier(nextChild.value, nextChild.loc);
                        i++; // PrivateIdentifier
                    }
                }
                // MemberExpressioncurrentobject
                current = SlimeAstCreateUtil.createMemberExpression(current, dotToken, property);
            } else if (child.name === 'BracketExpression') {
                // [expression] - computed property access ()
                const propertyExpression = this.createExpressionAst(child.children[1]);
                current = {
                    type: SlimeNodeType.MemberExpression,
                    object: current,
                    property: propertyExpression,
                    computed: true,
                    optional: false,
                    loc: cst.loc
                };
            } else if (child.name === 'LBracket') {
                // Es2025Parser?LBracket + Expression + RBracket
                // [expression] - computed property access
                const expressionChild = cst.children[i + 1];
                if (expressionChild) {
                    const propertyExpression = this.createExpressionAst(expressionChild);
                    current = {
                        type: SlimeNodeType.MemberExpression,
                        object: current,
                        property: propertyExpression,
                        computed: true,
                        optional: false,
                        loc: cst.loc
                    };
                    i += 2; // ExpressionRBracket
                }
            } else if (child.name === _SlimeParser$1.prototype.Arguments?.name || child.name === 'Arguments') {
                // () - function call
                const args = this.createArgumentsAst(child);
                current = SlimeAstCreateUtil.createCallExpression(current, args);
            } else if (child.name === _SlimeParser$1.prototype.TemplateLiteral?.name || child.name === 'TemplateLiteral') {
                // `template` - Tagged Template
                const quasi = this.createTemplateLiteralAst(child);
                current = {
                    type: 'TaggedTemplateExpression',
                    tag: current,
                    quasi: quasi,
                    loc: cst.loc
                };
            } else if (child.name === 'RBracket') {
                continue;
            } else {
                throw new Error(`MemberExpression? ${child.name}`);
            }
        }
        return current;
    }
    createVariableDeclaratorAst(cst) {
        //  LexicalBinding ?VariableDeclaration
        // const astName = checkCstName(cst, 'LexicalBinding');
        // children[0]BindingIdentifierBindingPattern
        const firstChild = cst.children[0];
        let id;
        if (firstChild.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            id = this.createBindingIdentifierAst(firstChild);
        } else if (firstChild.name === _SlimeParser$1.prototype.BindingPattern?.name) {
            id = this.createBindingPatternAst(firstChild);
        } else {
            throw new Error(`Unexpected variable declarator id type: ${firstChild.name}`);
        }
        // console.log(6565656)
        // console.log(id)
        let variableDeclarator;
        const varCst = cst.children[1];
        if (varCst) {
            const eqCst = varCst.children[0];
            const eqAst = SlimeTokenCreate.createAssignToken(eqCst.loc);
            const initCst = varCst.children[1];
            if (initCst) {
                // initCstAssignmentExpression
                if (initCst.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                    const init = this.createAssignmentExpressionAst(initCst);
                    variableDeclarator = SlimeAstCreateUtil.createVariableDeclarator(id, eqAst, init);
                } else {
                    // AssignmentExpression
                    const init = this.createExpressionAst(initCst);
                    variableDeclarator = SlimeAstCreateUtil.createVariableDeclarator(id, eqAst, init);
                }
            } else {
                variableDeclarator = SlimeAstCreateUtil.createVariableDeclarator(id, eqAst);
            }
        } else {
            variableDeclarator = SlimeAstCreateUtil.createVariableDeclarator(id);
        }
        variableDeclarator.loc = cst.loc;
        return variableDeclarator;
    }
    // ==================== ?====================
    /**
     * CoverParenthesizedExpressionAndArrowParameterList CST ?AST
     * ?cover grammar?
     */ createCoverParenthesizedExpressionAndArrowParameterListAst(cst) {
        // 
        return this.createParenthesizedExpressionAst(cst);
    }
    /**
     * ParenthesizedExpression CST ?AST
     * ParenthesizedExpression -> ( Expression )
     */ createParenthesizedExpressionAst(cst) {
        // ?Expression
        for (const child of cst.children || []){
            if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression' || child.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                return this.createExpressionAst(child);
            }
        }
        //  Expression
        const innerExpr = cst.children?.find((ch)=>ch.name !== 'LParen' && ch.name !== 'RParen' && ch.value !== '(' && ch.value !== ')');
        if (innerExpr) {
            return this.createExpressionAst(innerExpr);
        }
        throw new Error('ParenthesizedExpression has no inner expression');
    }
    /**
     * ComputedPropertyName CST ?AST
     * ComputedPropertyName -> [ AssignmentExpression ]
     */ createComputedPropertyNameAst(cst) {
        const expr = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.AssignmentExpression?.name || ch.name === 'AssignmentExpression');
        if (expr) {
            return this.createAssignmentExpressionAst(expr);
        }
        throw new Error('ComputedPropertyName missing AssignmentExpression');
    }
    /**
     * CoverInitializedName CST ?AST
     * CoverInitializedName -> IdentifierReference Initializer
     */ createCoverInitializedNameAst(cst) {
        const idRef = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.IdentifierReference?.name || ch.name === 'IdentifierReference');
        const init = cst.children?.find((ch)=>ch.name === _SlimeParser$1.prototype.Initializer?.name || ch.name === 'Initializer');
        const id = idRef ? this.createIdentifierReferenceAst(idRef) : null;
        const initValue = init ? this.createInitializerAst(init) : null;
        return {
            type: SlimeNodeType.AssignmentPattern,
            left: id,
            right: initValue,
            loc: cst.loc
        };
    }
    /**
     * CoverCallExpressionAndAsyncArrowHead CST ?AST
     * ?cover grammar CallExpression 
     */ createCoverCallExpressionAndAsyncArrowHeadAst(cst) {
        return this.createCallExpressionAst(cst);
    }
    /**
     * CallMemberExpression CST ?AST
     * CallMemberExpression -> MemberExpression Arguments
     */ createCallMemberExpressionAst(cst) {
        return this.createCallExpressionAst(cst);
    }
    /**
     * ShortCircuitExpression CST ?AST?
     * ShortCircuitExpression -> LogicalORExpression | CoalesceExpression
     */ createShortCircuitExpressionAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createExpressionAst(firstChild);
        }
        throw new Error('ShortCircuitExpression has no children');
    }
    /**
     * CoalesceExpressionHead CST  AST
     * CoalesceExpressionHead -> CoalesceExpression | BitwiseORExpression
     */ createCoalesceExpressionHeadAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createExpressionAst(firstChild);
        }
        throw new Error('CoalesceExpressionHead has no children');
    }
    /**
     * MultiplicativeOperator CST ?AST
     * MultiplicativeOperator -> * | / | %
     */ createMultiplicativeOperatorAst(cst) {
        const token = cst.children?.[0];
        return token?.value || '*';
    }
    /**
     * AssignmentOperator CST ?AST
     * AssignmentOperator -> *= | /= | %= | += | -= | <<= | >>= | >>>= | &= | ^= | |= | **= | &&= | ||= | ??=
     */ createAssignmentOperatorAst(cst) {
        const token = cst.children?.[0];
        return token?.value || '=';
    }
    /**
     * ExpressionBody CST ?AST
     * ExpressionBody -> AssignmentExpression
     */ createExpressionBodyAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild) {
            return this.createAssignmentExpressionAst(firstChild);
        }
        throw new Error('ExpressionBody has no children');
    }
    createExpressionAst(cst) {
        const cached = this.expressionAstCache.get(cst);
        if (cached) {
            return cached;
        }
        const result = this.createExpressionAstUncached(cst);
        this.expressionAstCache.set(cst, result);
        return result;
    }
    createExpressionAstUncached(cst) {
        const astName = cst.name;
        let left;
        if (astName === _SlimeParser$1.prototype.Expression?.name) {
            // Expression ?(SequenceExpression)
            // : Expression -> AssignmentExpression | Expression, AssignmentExpression
            // 
            const expressions = [];
            for (const child of cst.children || []){
                if (child.name === 'Comma' || child.value === ',') {
                    continue;
                }
                expressions.push(this.createExpressionAst(child));
            }
            if (expressions.length === 1) {
                // 
                left = expressions[0];
            } else if (expressions.length > 1) {
                //  SequenceExpression
                left = {
                    type: 'SequenceExpression',
                    expressions: expressions,
                    loc: cst.loc
                };
            } else {
                throw new Error('Expression has no children');
            }
        } else if (astName === _SlimeParser$1.prototype.Statement?.name) {
            left = this.createStatementAst(cst);
        } else if (astName === _SlimeParser$1.prototype.AssignmentExpression?.name) {
            left = this.createAssignmentExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.ConditionalExpression?.name) {
            left = this.createConditionalExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.LogicalORExpression?.name) {
            left = this.createLogicalORExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.LogicalANDExpression?.name) {
            left = this.createLogicalANDExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.BitwiseORExpression?.name) {
            left = this.createBitwiseORExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.BitwiseXORExpression?.name) {
            left = this.createBitwiseXORExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.BitwiseANDExpression?.name) {
            left = this.createBitwiseANDExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.EqualityExpression?.name) {
            left = this.createEqualityExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.RelationalExpression?.name) {
            left = this.createRelationalExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.ShiftExpression?.name) {
            left = this.createShiftExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.AdditiveExpression?.name) {
            left = this.createAdditiveExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.MultiplicativeExpression?.name) {
            left = this.createMultiplicativeExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.UnaryExpression?.name) {
            left = this.createUnaryExpressionAst(cst);
        } else if (astName === 'PostfixExpression') {
            left = this.createUpdateExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.UpdateExpression?.name || astName === 'UpdateExpression') {
            left = this.createUpdateExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.LeftHandSideExpression?.name) {
            left = this.createLeftHandSideExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.CallExpression?.name) {
            left = this.createCallExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.NewExpression?.name) {
            left = this.createNewExpressionAst(cst);
        } else if (astName === 'NewMemberExpressionArguments') {
            left = this.createNewExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.MemberExpression?.name) {
            left = this.createMemberExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.PrimaryExpression?.name) {
            left = this.createPrimaryExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.YieldExpression?.name) {
            left = this.createYieldExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.AwaitExpression?.name) {
            left = this.createAwaitExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.SuperProperty?.name) {
            left = this.createSuperPropertyAst(cst);
        } else if (astName === _SlimeParser$1.prototype.MetaProperty?.name) {
            left = this.createMetaPropertyAst(cst);
        } else if (astName === 'ShortCircuitExpression') {
            // ES2020: ShortCircuitExpression = LogicalORExpression | CoalesceExpression
            // ShortCircuitExpression: LogicalANDExpression ShortCircuitExpressionTail?
            left = this.createExpressionAst(cst.children[0]);
            //  ShortCircuitExpressionTail (|| ?
            if (cst.children.length > 1 && cst.children[1]) {
                const tailCst = cst.children[1];
                if (tailCst.name === 'ShortCircuitExpressionTail' || tailCst.name === 'LogicalORExpressionTail') {
                    //  LogicalORExpressionTail ?CoalesceExpressionTail
                    left = this.createShortCircuitExpressionTailAst(left, tailCst);
                }
            }
        } else if (astName === 'CoalesceExpression') {
            // ES2020: CoalesceExpression ( ?? ?
            left = this.createCoalesceExpressionAst(cst);
        } else if (astName === 'ExponentiationExpression') {
            // ES2016: ExponentiationExpression ( ** ?
            left = this.createExponentiationExpressionAst(cst);
        } else if (astName === 'CoverCallExpressionAndAsyncArrowHead') {
            // ES2017+: Cover grammar for CallExpression and async arrow function
            // In non-async-arrow context, this is a CallExpression
            left = this.createCallExpressionAst(cst);
        } else if (astName === 'OptionalExpression') {
            // ES2020: Optional chaining (?.)
            left = this.createOptionalExpressionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.ArrowFunction?.name || astName === 'ArrowFunction') {
            // 
            left = this.createArrowFunctionAst(cst);
        } else if (astName === 'AsyncArrowFunction') {
            // Async 
            left = this.createAsyncArrowFunctionAst(cst);
        } else if (astName === _SlimeParser$1.prototype.ImportCall?.name || astName === 'ImportCall') {
            // ES2020: ?import()
            left = this.createImportCallAst(cst);
        } else if (astName === 'PrivateIdentifier') {
            // ES2022: PrivateIdentifier (e.g. #x in `#x in obj`)
            left = this.createPrivateIdentifierAst(cst);
        } else {
            throw new Error('Unsupported expression type: ' + cst.name);
        }
        return left;
    }
    /**
     *  OptionalExpression ASTES2020?
     *  ?.
     *
     * OptionalExpression:
     *   MemberExpression OptionalChain
     *   CallExpression OptionalChain
     *   OptionalExpression OptionalChain
     */ createOptionalExpressionAst(cst) {
        // OptionalExpression ?
        // children[0] = MemberExpression | CallExpression
        // children[1...n] = OptionalChain
        if (!cst.children || cst.children.length === 0) {
            throw new Error('OptionalExpression: no children');
        }
        // MemberExpression ?CallExpression?
        let result = this.createExpressionAst(cst.children[0]);
        //  OptionalChain?
        for(let i = 1; i < cst.children.length; i++){
            const chainCst = cst.children[i];
            if (chainCst.name === 'OptionalChain') {
                result = this.createOptionalChainAst(result, chainCst);
            }
        }
        return result;
    }
    /**
     *  OptionalChain AST
     *  ?. 
     *
     *  ?.  optional: true
     * ?foo?.().bar()  .bar() optional: false
     */ createOptionalChainAst(object, chainCst) {
        let result = object;
        // ??. token optional
        let nextIsOptional = false;
        for (const child of chainCst.children){
            const name = child.name;
            if (name === 'OptionalChaining' || child.value === '?.') {
                //  ?. token optional
                nextIsOptional = true;
                continue;
            } else if (name === 'Arguments') {
                // () - ?
                const args = this.createArgumentsAst(child);
                result = {
                    type: SlimeNodeType.OptionalCallExpression,
                    callee: result,
                    arguments: args,
                    optional: nextIsOptional,
                    loc: chainCst.loc
                };
                nextIsOptional = false;
            } else if (name === 'LBracket' || child.value === '[') {
                // [expr] ?- ?
                // ?]
                const exprIndex = chainCst.children.indexOf(child) + 1;
                if (exprIndex < chainCst.children.length) {
                    const property = this.createExpressionAst(chainCst.children[exprIndex]);
                    result = {
                        type: SlimeNodeType.OptionalMemberExpression,
                        object: result,
                        property: property,
                        computed: true,
                        optional: nextIsOptional,
                        loc: chainCst.loc
                    };
                    nextIsOptional = false;
                }
            } else if (name === 'IdentifierName') {
                // .prop ?- ?
                let property;
                // IdentifierName ?Identifier  token
                const tokenCst = child.children[0];
                property = SlimeAstCreateUtil.createIdentifier(tokenCst.value, tokenCst.loc);
                result = {
                    type: SlimeNodeType.OptionalMemberExpression,
                    object: result,
                    property: property,
                    computed: false,
                    optional: nextIsOptional,
                    loc: chainCst.loc
                };
                nextIsOptional = false;
            } else if (name === 'Dot' || child.value === '.') {
                continue;
            } else if (name === 'RBracket' || child.value === ']') {
                continue;
            } else if (name === 'PrivateIdentifier') {
                // #prop - ?
                const property = this.createPrivateIdentifierAst(child);
                result = {
                    type: SlimeNodeType.OptionalMemberExpression,
                    object: result,
                    property: property,
                    computed: false,
                    optional: nextIsOptional,
                    loc: chainCst.loc
                };
                nextIsOptional = false;
            } else if (name === 'Expression') {
                continue;
            }
        }
        return result;
    }
    /**
     *  CoalesceExpression ASTES2020?
     *  ?? 
     */ createCoalesceExpressionAst(cst) {
        // CoalesceExpression -> BitwiseORExpression ( ?? BitwiseORExpression )*
        if (cst.children.length === 1) {
            return this.createExpressionAst(cst.children[0]);
        }
        // ?
        let left = this.createExpressionAst(cst.children[0]);
        for(let i = 1; i < cst.children.length; i += 2){
            cst.children[i] // ?? token
            ;
            const right = this.createExpressionAst(cst.children[i + 1]);
            left = {
                type: SlimeNodeType.LogicalExpression,
                operator: '??',
                left: left,
                right: right
            };
        }
        return left;
    }
    /**
     *  ExponentiationExpression ASTES2016?
     *  ** 
     */ createExponentiationExpressionAst(cst) {
        // ExponentiationExpression -> UnaryExpression | UpdateExpression ** ExponentiationExpression
        if (cst.children.length === 1) {
            return this.createExpressionAst(cst.children[0]);
        }
        // a ** b ** c = a ** (b ** c)
        const left = this.createExpressionAst(cst.children[0]);
        cst.children[1] // ** token
        ;
        const right = this.createExponentiationExpressionAst(cst.children[2]) // 
        ;
        return {
            type: SlimeNodeType.BinaryExpression,
            operator: '**',
            left: left,
            right: right
        };
    }
    createLogicalORExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.LogicalORExpression?.name);
        if (cst.children.length > 1) {
            // ?LogicalExpression
            // a || b || c
            let left = this.createExpressionAst(cst.children[0]);
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.LogicalExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createLogicalANDExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.LogicalANDExpression?.name);
        if (cst.children.length > 1) {
            // ?LogicalExpression
            // a && b && c
            let left = this.createExpressionAst(cst.children[0]);
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.LogicalExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createBitwiseORExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BitwiseORExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpressiona | b | c?
            let left = this.createExpressionAst(cst.children[0]);
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createBitwiseXORExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BitwiseXORExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpressiona ^ b ^ c?
            let left = this.createExpressionAst(cst.children[0]);
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createBitwiseANDExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.BitwiseANDExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpressiona & b & c?
            let left = this.createExpressionAst(cst.children[0]);
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createEqualityExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.EqualityExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpression
            const left = this.createExpressionAst(cst.children[0]);
            const operator = cst.children[1].value// ===, !==, ==, != ?
            ;
            const right = this.createExpressionAst(cst.children[2]);
            return {
                type: SlimeNodeType.BinaryExpression,
                operator: operator,
                left: left,
                right: right,
                loc: cst.loc
            };
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createRelationalExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.RelationalExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpression
            // x < y < z => BinaryExpression(BinaryExpression(x, <, y), <, z)
            let left = this.createExpressionAst(cst.children[0]);
            // ?(operator, operand) ?
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createShiftExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ShiftExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpression
            // x << y << z => BinaryExpression(BinaryExpression(x, <<, y), <<, z)
            let left = this.createExpressionAst(cst.children[0]);
            // ?(operator, operand) ?
            for(let i = 1; i < cst.children.length; i += 2){
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createAdditiveExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.AdditiveExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpression
            // x + y + z => BinaryExpression(BinaryExpression(x, +, y), +, z)
            let left = this.createExpressionAst(cst.children[0]);
            // ?(operator, operand) ?
            // CST: [operand, operator, operand, operator, operand, ...]
            for(let i = 1; i < cst.children.length; i += 2){
                // ?- tokenCST
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createMultiplicativeExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.MultiplicativeExpression?.name);
        if (cst.children.length > 1) {
            // ?BinaryExpression
            // a * b * c => BinaryExpression(BinaryExpression(a, *, b), *, c)
            let left = this.createExpressionAst(cst.children[0]);
            // ?(operator, operand) ?
            for(let i = 1; i < cst.children.length; i += 2){
                // ?- tokenCST
                const operatorNode = cst.children[i];
                const operator = operatorNode.children ? operatorNode.children[0].value : operatorNode.value;
                const right = this.createExpressionAst(cst.children[i + 1]);
                left = {
                    type: SlimeNodeType.BinaryExpression,
                    operator: operator,
                    left: left,
                    right: right,
                    loc: cst.loc
                };
            }
            return left;
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createUnaryExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.UnaryExpression?.name);
        // children?
        if (!cst.children || cst.children.length === 0) {
            console.error('UnaryExpression CSTchildren:', JSON.stringify(cst, null, 2));
            throw new Error(`UnaryExpression CSTchildrenParserCST`);
        }
        // token
        if (cst.children.length === 1) {
            const child = cst.children[0];
            // tokentokenvaluechildren?
            if (child.value !== undefined && !child.children) {
                // tokenParserCST?
                // UnaryExpression+PostfixExpression
                throw new Error(`UnaryExpression CSTtoken '${child.name}' (${child.value})` + `ParserEs2025Parser.UnaryExpressionOr`);
            }
            // 
            return this.createExpressionAst(child);
        }
        // ?
        // children[0]: ?token (!, +, -, ~, typeof, void, delete?
        // children[1]: UnaryExpression?
        const operatorToken = cst.children[0];
        const argumentCst = cst.children[1];
        // ?
        const operatorMap = {
            'Exclamation': '!',
            'Plus': '+',
            'Minus': '-',
            'Tilde': '~',
            'Typeof': 'typeof',
            'Void': 'void',
            'Delete': 'delete',
            'PlusPlus': '++',
            'MinusMinus': '--'
        };
        const operator = operatorMap[operatorToken.name] || operatorToken.value;
        // ?
        const argument = this.createExpressionAst(argumentCst);
        //  UnaryExpression AST
        return {
            type: SlimeNodeType.UnaryExpression,
            operator: operator,
            prefix: true,
            argument: argument,
            loc: cst.loc
        };
    }
    // Renamed from createPostfixExpressionAst - ES2025 uses UpdateExpression
    createUpdateExpressionAst(cst) {
        // Support both PostfixExpression (old) and UpdateExpression (new)
        if (cst.children.length > 1) {
            // UpdateExpression: argument ++ | argument -- | ++argument | --argument
            // Check if prefix or postfix
            const first = cst.children[0];
            const isPrefix = first.loc?.type === 'PlusPlus' || first.loc?.type === 'MinusMinus' || first.value === '++' || first.value === '--';
            if (isPrefix) {
                // Prefix: ++argument or --argument
                const operator = first.value || first.loc?.value;
                const argument = this.createExpressionAst(cst.children[1]);
                return {
                    type: SlimeNodeType.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true,
                    loc: cst.loc
                };
            } else {
                // Postfix: argument++ or argument--
                const argument = this.createExpressionAst(cst.children[0]);
                let operator;
                for(let i = 1; i < cst.children.length; i++){
                    const child = cst.children[i];
                    if (child.loc?.type === 'PlusPlus' || child.loc?.type === 'MinusMinus' || child.value === '++' || child.value === '--') {
                        operator = child.value || child.loc?.value;
                        break;
                    }
                }
                if (operator) {
                    return {
                        type: SlimeNodeType.UpdateExpression,
                        operator: operator,
                        argument: argument,
                        prefix: false,
                        loc: cst.loc
                    };
                }
            }
        }
        return this.createExpressionAst(cst.children[0]);
    }
    createLeftHandSideExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.LeftHandSideExpression?.name);
        // ParserASICST?
        if (!cst.children || cst.children.length === 0) {
            return SlimeAstCreateUtil.createIdentifier('', cst.loc);
        }
        if (cst.children.length > 1) ;
        return this.createExpressionAst(cst.children[0]);
    }
    createPrimaryExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.PrimaryExpression?.name);
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.IdentifierReference?.name) {
            return this.createIdentifierAst(first.children[0]);
        } else if (first.name === _SlimeParser$1.prototype.Literal?.name) {
            return this.createLiteralAst(first);
        } else if (first.name === _SlimeParser$1.prototype.ArrayLiteral?.name) {
            return this.createArrayLiteralAst(first);
        } else if (first.name === _SlimeParser$1.prototype.FunctionExpression?.name) {
            return this.createFunctionExpressionAst(first);
        } else if (first.name === _SlimeParser$1.prototype.ObjectLiteral?.name) {
            return this.createObjectLiteralAst(first);
        } else if (first.name === _SlimeParser$1.prototype.ClassExpression?.name) {
            return this.createClassExpressionAst(first);
        } else if (first.name === SlimeTokenConsumer.prototype.This?.name) {
            //  this ?
            return SlimeAstCreateUtil.createThisExpression(first.loc);
        } else if (first.name === SlimeTokenConsumer.prototype.RegularExpressionLiteral?.name) {
            // 
            return this.createRegExpLiteralAst(first);
        } else if (first.name === _SlimeParser$1.prototype.GeneratorExpression?.name || first.name === 'GeneratorExpression') {
            //  function* ?
            return this.createGeneratorExpressionAst(first);
        } else if (first.name === _SlimeParser$1.prototype.AsyncFunctionExpression?.name || first.name === 'AsyncFunctionExpression') {
            //  async function ?
            return this.createAsyncFunctionExpressionAst(first);
        } else if (first.name === _SlimeParser$1.prototype.AsyncGeneratorExpression?.name || first.name === 'AsyncGeneratorExpression') {
            //  async function* ?
            return this.createAsyncGeneratorExpressionAst(first);
        } else if (first.name === _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name || first.name === 'CoverParenthesizedExpressionAndArrowParameterList') {
            // Cover Grammar - try to interpret as parenthesized expression
            // Structure varies: [LParen, content?, RParen] or [LParen, Expression, RParen]
            // Empty parentheses: ()
            if (!first.children || first.children.length === 0) {
                return SlimeAstCreateUtil.createIdentifier('undefined', first.loc);
            }
            // Only 2 children (empty parens): LParen, RParen
            if (first.children.length === 2) {
                return SlimeAstCreateUtil.createIdentifier('undefined', first.loc);
            }
            // Find the content (skip LParen at start, RParen at end)
            const middleCst = first.children[1];
            if (!middleCst) {
                return SlimeAstCreateUtil.createIdentifier('undefined', first.loc);
            }
            // If it's an Expression, process it directly
            if (middleCst.name === _SlimeParser$1.prototype.Expression?.name || middleCst.name === 'Expression') {
                const innerExpr = this.createExpressionAst(middleCst);
                return SlimeAstCreateUtil.createParenthesizedExpression(innerExpr, first.loc);
            }
            // If it's AssignmentExpression, process it
            if (middleCst.name === _SlimeParser$1.prototype.AssignmentExpression?.name || middleCst.name === 'AssignmentExpression') {
                const innerExpr = this.createExpressionAst(middleCst);
                return SlimeAstCreateUtil.createParenthesizedExpression(innerExpr, first.loc);
            }
            // If it's FormalParameterList, convert to expression
            if (middleCst.name === _SlimeParser$1.prototype.FormalParameterList?.name || middleCst.name === 'FormalParameterList') {
                const params = this.createFormalParameterListAst(middleCst);
                if (params.length === 1 && params[0].type === SlimeNodeType.Identifier) {
                    return SlimeAstCreateUtil.createParenthesizedExpression(params[0], first.loc);
                }
                if (params.length > 1) {
                    const expressions = params.map((p)=>p);
                    return SlimeAstCreateUtil.createParenthesizedExpression({
                        type: 'SequenceExpression',
                        expressions: expressions
                    }, first.loc);
                }
                return SlimeAstCreateUtil.createIdentifier('undefined', first.loc);
            }
            // Try to process the middle content as an expression
            try {
                const innerExpr = this.createExpressionAst(middleCst);
                return SlimeAstCreateUtil.createParenthesizedExpression(innerExpr, first.loc);
            } catch (e) {
                // Fallback: return the first child as identifier
                return SlimeAstCreateUtil.createIdentifier('undefined', first.loc);
            }
        } else if (first.name === _SlimeParser$1.prototype.TemplateLiteral?.name) {
            // ?
            return this.createTemplateLiteralAst(first);
        } else if (first.name === _SlimeParser$1.prototype.ParenthesizedExpression?.name) {
            // ? Expression )
            // children[0]=LParen, children[1]=Expression, children[2]=RParen
            const expressionCst = first.children[1];
            const innerExpression = this.createExpressionAst(expressionCst);
            return SlimeAstCreateUtil.createParenthesizedExpression(innerExpression, first.loc);
        } else if (first.name === 'RegularExpressionLiteral' || first.name === 'RegularExpressionLiteral') {
            // 
            return this.createRegExpLiteralAst(first);
        } else {
            throw new Error(' PrimaryExpression : ' + first.name);
        }
    }
    // function* (...) { ... }
    createGeneratorExpressionAst(cst) {
        // GeneratorExpression: function* [name](params) { body }
        //  CST children: [FunctionTok, Asterisk, BindingIdentifier?, LParen, FormalParameterList?, RParen, FunctionBodyDefine]
        // Es2025 CST children: [FunctionTok, Asterisk, BindingIdentifier?, LParen, FormalParameters?, RParen, LBrace, GeneratorBody, RBrace]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList ()
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListFromEs2025Wrapped(formalParams);
            }
        }
        //  GeneratorBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'GeneratorBody' || ch.name === _SlimeParser$1.prototype.GeneratorBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const func = SlimeAstCreateUtil.createFunctionExpression(body, id, params, true, false, cst.loc);
        return func;
    }
    // Async async function (...) { ... }
    createAsyncFunctionExpressionAst(cst) {
        // AsyncFunctionExpression: async function [name](params) { body }
        // Es2025 CST children: [AsyncTok, FunctionTok, BindingIdentifier?, LParen, FormalParameters?, RParen, LBrace, AsyncFunctionBody, RBrace]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList ()
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListFromEs2025Wrapped(formalParams);
            }
        }
        //  AsyncFunctionBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'AsyncFunctionBody' || ch.name === _SlimeParser$1.prototype.AsyncFunctionBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const func = SlimeAstCreateUtil.createFunctionExpression(body, id, params, false, true, cst.loc);
        return func;
    }
    // Async Generator async function* (...) { ... }
    createAsyncGeneratorExpressionAst(cst) {
        // AsyncGeneratorExpression: async function* [name](params) { body }
        // Es2025 CST children: [AsyncTok, FunctionTok, Asterisk, BindingIdentifier?, LParen, FormalParameters?, RParen, LBrace, AsyncGeneratorBody, RBrace]
        let id = null;
        let params = [];
        let body;
        //  BindingIdentifier
        const bindingId = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.BindingIdentifier?.name || ch.name === 'BindingIdentifier');
        if (bindingId) {
            id = this.createBindingIdentifierAst(bindingId);
        }
        //  FormalParameters ?FormalParameterList ()
        const formalParams = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.FormalParameters?.name || ch.name === 'FormalParameters' || ch.name === _SlimeParser$1.prototype.FormalParameterList?.name || ch.name === 'FormalParameterList');
        if (formalParams) {
            if (formalParams.name === 'FormalParameters' || formalParams.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                params = this.createFormalParametersAstWrapped(formalParams);
            } else {
                params = this.createFormalParameterListFromEs2025Wrapped(formalParams);
            }
        }
        //  AsyncGeneratorBody ?FunctionBody
        const bodyNode = cst.children.find((ch)=>ch.name === 'AsyncGeneratorBody' || ch.name === _SlimeParser$1.prototype.AsyncGeneratorBody?.name || ch.name === 'FunctionBody' || ch.name === _SlimeParser$1.prototype.FunctionBody?.name);
        if (bodyNode) {
            const bodyStatements = this.createFunctionBodyAst(bodyNode);
            body = SlimeAstCreateUtil.createBlockStatement(bodyStatements, bodyNode.loc);
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        const func = SlimeAstCreateUtil.createFunctionExpression(body, id, params, true, true, cst.loc);
        return func;
    }
    // ?
    createTemplateLiteralAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.TemplateLiteral?.name);
        const first = cst.children[0];
        // `hello` (?
        if (first.name === SlimeTokenConsumer.prototype.NoSubstitutionTemplate?.name || first.name === 'NoSubstitutionTemplate') {
            //  TemplateLiteral AST?
            const raw = first.value || '``';
            const cooked = raw.slice(1, -1) //  ` ?`
            ;
            const quasis = [
                SlimeAstCreateUtil.createTemplateElement(true, raw, cooked, first.loc)
            ];
            return SlimeAstCreateUtil.createTemplateLiteral(quasis, [], cst.loc);
        }
        // `hello ${name}` ?`a ${x} b ${y} c`
        // ES2025 : TemplateLiteral -> SubstitutionTemplate -> [TemplateHead, Expression, TemplateSpans]
        //  SubstitutionTemplate 
        let targetCst = cst;
        if (first.name === _SlimeParser$1.prototype.SubstitutionTemplate?.name || first.name === 'SubstitutionTemplate') {
            targetCst = first;
        }
        const quasis = [];
        const expressions = [];
        //  targetCst.children 
        for(let i = 0; i < targetCst.children.length; i++){
            const child = targetCst.children[i];
            // TemplateHead: `xxx${
            if (child.name === SlimeTokenConsumer.prototype.TemplateHead?.name || child.name === 'TemplateHead') {
                const raw = child.value || '';
                const cooked = raw.slice(1, -2) //  ` ?${
                ;
                quasis.push(SlimeAstCreateUtil.createTemplateElement(false, raw, cooked, child.loc));
            } else if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression') {
                expressions.push(this.createExpressionAst(child));
            } else if (child.name === _SlimeParser$1.prototype.TemplateSpans?.name || child.name === 'TemplateSpans') {
                this.processTemplateSpans(child, quasis, expressions);
            }
        }
        return SlimeAstCreateUtil.createTemplateLiteral(quasis, expressions, cst.loc);
    }
    // TemplateSpansTemplateTailTemplateMiddleList+TemplateTail
    processTemplateSpans(cst, quasis, expressions) {
        const first = cst.children[0];
        // 1TemplateTail -> }` 
        if (first.name === SlimeTokenConsumer.prototype.TemplateTail?.name) {
            const raw = first.value || '';
            const cooked = raw.slice(1, -1) //  } ?`
            ;
            quasis.push(SlimeAstCreateUtil.createTemplateElement(true, raw, cooked, first.loc));
            return;
        }
        // 2TemplateMiddleList -> ?
        if (first.name === _SlimeParser$1.prototype.TemplateMiddleList?.name) {
            this.processTemplateMiddleList(first, quasis, expressions);
            // TemplateTail
            if (cst.children[1] && cst.children[1].name === SlimeTokenConsumer.prototype.TemplateTail?.name) {
                const tail = cst.children[1];
                const raw = tail.value || '';
                const cooked = raw.slice(1, -1) //  } ?`
                ;
                quasis.push(SlimeAstCreateUtil.createTemplateElement(true, raw, cooked, tail.loc));
            }
        }
    }
    // TemplateMiddleListTemplateMiddle+Expression?
    processTemplateMiddleList(cst, quasis, expressions) {
        // TemplateMiddleListEs2025
        // - children = [TemplateMiddle, Expression, TemplateMiddle, Expression, ...]
        // ?
        // - children[0] = TemplateMiddle (token)
        // - children[1] = Expression
        // - children[2] = TemplateMiddleList (?
        for(let i = 0; i < cst.children.length; i++){
            const child = cst.children[i];
            if (child.name === SlimeTokenConsumer.prototype.TemplateMiddle?.name || child.name === 'TemplateMiddle') {
                const raw = child.value || '';
                const cooked = raw.slice(1, -2) //  } ?${
                ;
                quasis.push(SlimeAstCreateUtil.createTemplateElement(false, raw, cooked, child.loc));
            } else if (child.name === _SlimeParser$1.prototype.Expression?.name || child.name === 'Expression') {
                expressions.push(this.createExpressionAst(child));
            } else if (child.name === _SlimeParser$1.prototype.TemplateMiddleList?.name || child.name === 'TemplateMiddleList') {
                // ?TemplateMiddleList
                this.processTemplateMiddleList(child, quasis, expressions);
            }
        }
    }
    createClassExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ClassExpression?.name);
        let id = null // class ?
        ;
        let tailStartIndex = 1 //  ClassTail  1
        ;
        const nextChild = cst.children[1];
        if (nextChild && nextChild.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            id = this.createBindingIdentifierAst(nextChild); // ?
            tailStartIndex = 2; // ClassTail ?
        }
        const classTail = this.createClassTailAst(cst.children[tailStartIndex]) //  ClassTail
        ;
        return SlimeAstCreateUtil.createClassExpression(id, classTail.superClass, classTail.body, cst.loc) //  ClassExpression AST
        ;
    }
    createPropertyDefinitionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.PropertyDefinition?.name);
        //  children ?
        // {}PropertyDefinition
        if (!cst.children || cst.children.length === 0) {
            throw new Error('PropertyDefinition CST has no children - this should not happen for valid syntax');
        }
        const first = cst.children[0];
        // ES2018: spread {...obj}
        // firstEllipsis tokenname?Ellipsis'?
        if (first.name === 'Ellipsis' || first.value === '...') {
            // PropertyDefinition -> Ellipsis + AssignmentExpression
            const AssignmentExpressionCst = cst.children[1];
            const argument = this.createAssignmentExpressionAst(AssignmentExpressionCst);
            // SpreadElementProperty
            return {
                type: SlimeNodeType.SpreadElement,
                argument: argument,
                loc: cst.loc
            };
        } else if (cst.children.length > 2) {
            // PropertyName : AssignmentExpression
            const PropertyNameCst = cst.children[0];
            const AssignmentExpressionCst = cst.children[2];
            const key = this.createPropertyNameAst(PropertyNameCst);
            const value = this.createAssignmentExpressionAst(AssignmentExpressionCst);
            const keyAst = SlimeAstCreateUtil.createPropertyAst(key, value);
            // 
            if (PropertyNameCst.children[0].name === _SlimeParser$1.prototype.ComputedPropertyName?.name) {
                keyAst.computed = true;
            }
            return keyAst;
        } else if (first.name === _SlimeParser$1.prototype.MethodDefinition?.name) {
            // static?
            const SlimeMethodDefinition = this.createMethodDefinitionAst(null, first);
            const keyAst = SlimeAstCreateUtil.createPropertyAst(SlimeMethodDefinition.key, SlimeMethodDefinition.value);
            // MethodDefinitioncomputed
            if (SlimeMethodDefinition.computed) {
                keyAst.computed = true;
            }
            // MethodDefinitionkindgetter/setter/method?
            if (SlimeMethodDefinition.kind === 'get' || SlimeMethodDefinition.kind === 'set') {
                keyAst.kind = SlimeMethodDefinition.kind;
            } else {
                // ?method: true
                keyAst.method = true;
            }
            return keyAst;
        } else if (first.name === _SlimeParser$1.prototype.IdentifierReference?.name) {
            // ?{name} -> {name: name}
            const identifierCst = first.children[0] // IdentifierReference -> Identifier
            ;
            const identifier = this.createIdentifierAst(identifierCst);
            const keyAst = SlimeAstCreateUtil.createPropertyAst(identifier, identifier);
            keyAst.shorthand = true;
            return keyAst;
        } else if (first.name === 'CoverInitializedName') {
            // CoverInitializedName: ?{name = 'default'}
            // CoverInitializedName -> IdentifierReference + Initializer
            const identifierRefCst = first.children[0];
            const initializerCst = first.children[1];
            const identifierCst = identifierRefCst.children[0] // IdentifierReference -> Identifier
            ;
            const identifier = this.createIdentifierAst(identifierCst);
            // Initializer -> Assign + AssignmentExpression
            const defaultValue = this.createAssignmentExpressionAst(initializerCst.children[1]);
            //  AssignmentPattern  value
            const assignmentPattern = {
                type: SlimeNodeType.AssignmentPattern,
                left: identifier,
                right: defaultValue,
                loc: first.loc
            };
            const keyAst = SlimeAstCreateUtil.createPropertyAst(identifier, assignmentPattern);
            keyAst.shorthand = true;
            return keyAst;
        } else {
            throw new Error(`PropertyDefinition: ${first.name}`);
        }
    }
    createPropertyNameAst(cst) {
        if (!cst || !cst.children || cst.children.length === 0) {
            throw new Error('createPropertyNameAst: invalid cst or no children');
        }
        const first = cst.children[0];
        if (first.name === _SlimeParser$1.prototype.LiteralPropertyName?.name || first.name === 'LiteralPropertyName') {
            return this.createLiteralPropertyNameAst(first);
        } else if (first.name === _SlimeParser$1.prototype.ComputedPropertyName?.name || first.name === 'ComputedPropertyName') {
            // [expression]: value
            // ComputedPropertyName -> LBracket + AssignmentExpression + RBracket
            return this.createAssignmentExpressionAst(first.children[1]);
        }
        // first LiteralPropertyName ?
        return this.createLiteralPropertyNameAst(first);
    }
    createLiteralPropertyNameAst(cst) {
        if (!cst) {
            throw new Error('createLiteralPropertyNameAst: cst is null');
        }
        // ?LiteralPropertyName ?
        let first = cst;
        if (cst.name === _SlimeParser$1.prototype.LiteralPropertyName?.name || cst.name === 'LiteralPropertyName') {
            if (!cst.children || cst.children.length === 0) {
                throw new Error('createLiteralPropertyNameAst: LiteralPropertyName has no children');
            }
            first = cst.children[0];
        }
        // IdentifierName (Es2025Parser) -  token
        if (first.name === 'IdentifierName' || first.name === _SlimeParser$1.prototype.IdentifierName?.name) {
            // ?value?
            if (first.value !== undefined) {
                return SlimeAstCreateUtil.createIdentifier(first.value, first.loc);
            }
            //  value
            let current = first;
            while(current.children && current.children.length > 0 && current.value === undefined){
                current = current.children[0];
            }
            if (current.value !== undefined) {
                return SlimeAstCreateUtil.createIdentifier(current.value, current.loc || first.loc);
            }
            throw new Error(`createLiteralPropertyNameAst: Cannot extract value from IdentifierName`);
        } else if (first.name === 'Identifier' || first.name === _SlimeParser$1.prototype.Identifier?.name) {
            return this.createIdentifierAst(first);
        } else if (first.name === SlimeTokenConsumer.prototype.NumericLiteral?.name || first.name === 'NumericLiteral' || first.name === 'Number') {
            return this.createNumericLiteralAst(first);
        } else if (first.name === SlimeTokenConsumer.prototype.StringLiteral?.name || first.name === 'StringLiteral' || first.name === 'String') {
            return this.createStringLiteralAst(first);
        } else if (first.value !== undefined) {
            return SlimeAstCreateUtil.createIdentifier(first.value, first.loc);
        }
        throw new Error(`createLiteralPropertyNameAst: Unknown type: ${first.name}`);
    }
    /**
     * [AST ] NumericLiteral ??Literal AST
     *
     * NumericLiteral ?CST ?ESTree AST  Literal ?
     */ createNumericLiteralAst(cst) {
        //  NumericLiteral NumericLiteral, NumericLiteralTok, Number
        const validNames = [
            SlimeTokenConsumer.prototype.NumericLiteral?.name,
            'NumericLiteral',
            'NumericLiteral',
            'Number'
        ];
        if (!validNames.includes(cst.name)) {
            throw new Error(`Expected NumericLiteral, got ${cst.name}`);
        }
        // raw 0xFF?
        const rawValue = cst.value;
        return SlimeAstCreateUtil.createNumericLiteral(Number(rawValue), rawValue);
    }
    /**
     * [AST ] StringLiteral ??Literal AST
     *
     * StringLiteral ?CST ?ESTree AST  Literal ?
     */ createStringLiteralAst(cst) {
        //  StringLiteral StringLiteral, StringLiteralTok, String
        const validNames = [
            SlimeTokenConsumer.prototype.StringLiteral?.name,
            'StringLiteral',
            'StringLiteral',
            'String'
        ];
        if (!validNames.includes(cst.name)) {
            throw new Error(`Expected StringLiteral, got ${cst.name}`);
        }
        // raw
        const rawValue = cst.value;
        const ast = SlimeAstCreateUtil.createStringLiteral(rawValue, cst.loc, rawValue);
        return ast;
    }
    /**
     * [AST ] RegularExpressionLiteral ??Literal AST
     *
     * RegularExpressionLiteral ?CST 
     * ?ESTree AST  Literal ?pattern ?flags?
     *
     * RegularExpressionLiteral: /pattern/flags
     */ createRegExpLiteralAst(cst) {
        const rawValue = cst.value;
        // ?pattern/flags
        // /.../  flags
        const match = rawValue.match(/^\/(.*)\/([gimsuy]*)$/);
        if (match) {
            const pattern = match[1];
            const flags = match[2];
            return {
                type: SlimeNodeType.Literal,
                value: new RegExp(pattern, flags),
                raw: rawValue,
                regex: {
                    pattern: pattern,
                    flags: flags
                },
                loc: cst.loc
            };
        }
        // ?
        return {
            type: SlimeNodeType.Literal,
            value: rawValue,
            raw: rawValue,
            loc: cst.loc
        };
    }
    createLiteralFromToken(token) {
        const tokenName = token.tokenName;
        if (tokenName === SlimeTokenConsumer.prototype.NullLiteral?.name) {
            return SlimeAstCreateUtil.createNullLiteralToken();
        } else if (tokenName === SlimeTokenConsumer.prototype.True?.name) {
            return SlimeAstCreateUtil.createBooleanLiteral(true);
        } else if (tokenName === SlimeTokenConsumer.prototype.False?.name) {
            return SlimeAstCreateUtil.createBooleanLiteral(false);
        } else if (tokenName === SlimeTokenConsumer.prototype.NumericLiteral?.name) {
            return SlimeAstCreateUtil.createNumericLiteral(Number(token.tokenValue));
        } else if (tokenName === SlimeTokenConsumer.prototype.StringLiteral?.name) {
            return SlimeAstCreateUtil.createStringLiteral(token.tokenValue);
        } else {
            throw new Error(`Unsupported literal token: ${tokenName}`);
        }
    }
    createElementListAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ElementList?.name);
        const elements = [];
        // ?AssignmentExpressionSpreadElementElision ?Comma
        // 
        let currentElement = null;
        let hasElement = false;
        for(let i = 0; i < cst.children.length; i++){
            const child = cst.children[i];
            if (child.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                // 
                if (hasElement) {
                    elements.push(SlimeAstCreateUtil.createArrayElement(currentElement, undefined));
                }
                currentElement = this.createAssignmentExpressionAst(child);
                hasElement = true;
            } else if (child.name === _SlimeParser$1.prototype.SpreadElement?.name) {
                if (hasElement) {
                    elements.push(SlimeAstCreateUtil.createArrayElement(currentElement, undefined));
                }
                currentElement = this.createSpreadElementAst(child);
                hasElement = true;
            } else if (child.name === _SlimeParser$1.prototype.Elision?.name) {
                // Elision [1, , 3] - 
                //  Elision ?
                const elisionCommas = child.children?.filter((c)=>c.name === 'Comma' || c.value === ',') || [];
                for(let j = 0; j < elisionCommas.length; j++){
                    if (hasElement) {
                        const commaToken = SlimeTokenCreate.createCommaToken(elisionCommas[j].loc);
                        elements.push(SlimeAstCreateUtil.createArrayElement(currentElement, commaToken));
                        hasElement = false;
                        currentElement = null;
                    } else {
                        // 
                        const commaToken = SlimeTokenCreate.createCommaToken(elisionCommas[j].loc);
                        elements.push(SlimeAstCreateUtil.createArrayElement(null, commaToken));
                    }
                }
            } else if (child.name === 'Comma' || child.value === ',') {
                // 
                const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                elements.push(SlimeAstCreateUtil.createArrayElement(currentElement, commaToken));
                hasElement = false;
                currentElement = null;
            }
        }
        // ?
        if (hasElement) {
            elements.push(SlimeAstCreateUtil.createArrayElement(currentElement, undefined));
        }
        return elements;
    }
    createSpreadElementAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.SpreadElement?.name);
        // SpreadElement: [Ellipsis, AssignmentExpression]
        //  Ellipsis token
        let ellipsisToken = undefined;
        const ellipsisCst = cst.children.find((ch)=>ch.name === 'Ellipsis' || ch.name === 'Ellipsis' || ch.value === '...');
        if (ellipsisCst) {
            ellipsisToken = SlimeTokenCreate.createEllipsisToken(ellipsisCst.loc);
        }
        const expression = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.AssignmentExpression?.name);
        if (!expression) {
            throw new Error('SpreadElement missing AssignmentExpression');
        }
        return SlimeAstCreateUtil.createSpreadElement(this.createAssignmentExpressionAst(expression), cst.loc, ellipsisToken);
    }
    // ==================== ?====================
    /**
     * ?CST ?AST
     * BooleanLiteral -> true | false
     */ createBooleanLiteralAst(cst) {
        const firstChild = cst.children?.[0];
        if (firstChild?.name === 'True' || firstChild?.value === 'true') {
            const lit = SlimeAstCreateUtil.createBooleanLiteral(true);
            lit.loc = firstChild.loc || cst.loc;
            return lit;
        } else {
            const lit = SlimeAstCreateUtil.createBooleanLiteral(false);
            lit.loc = firstChild?.loc || cst.loc;
            return lit;
        }
    }
    /**
     * ArrayLiteral CST ?ArrayExpression AST
     * ArrayLiteral -> [ Elision? ] | [ ElementList ] | [ ElementList , Elision? ]
     */ createArrayLiteralAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ArrayLiteral?.name);
        // ArrayLiteral: [LBracket, ElementList?, Comma?, Elision?, RBracket]
        //  LBracket ?RBracket tokens
        let lBracketToken = undefined;
        let rBracketToken = undefined;
        if (cst.children && cst.children.length > 0) {
            const firstChild = cst.children[0];
            if (firstChild && (firstChild.name === 'LBracket' || firstChild.value === '[')) {
                lBracketToken = SlimeTokenCreate.createLBracketToken(firstChild.loc);
            }
            const lastChild = cst.children[cst.children.length - 1];
            if (lastChild && (lastChild.name === 'RBracket' || lastChild.value === ']')) {
                rBracketToken = SlimeTokenCreate.createRBracketToken(lastChild.loc);
            }
        }
        const elementList = cst.children.find((ch)=>ch.name === _SlimeParser$1.prototype.ElementList?.name);
        const elements = elementList ? this.createElementListAst(elementList) : [];
        for (const child of cst.children){
            if (child.name === 'Comma' || child.value === ',') ; else if (child.name === _SlimeParser$1.prototype.Elision?.name || child.name === 'Elision') {
                //  Elision
                const elisionCommas = child.children?.filter((c)=>c.name === 'Comma' || c.value === ',') || [];
                for(let j = 0; j < elisionCommas.length; j++){
                    const commaToken = SlimeTokenCreate.createCommaToken(elisionCommas[j].loc);
                    elements.push(SlimeAstCreateUtil.createArrayElement(null, commaToken));
                }
            }
        }
        return SlimeAstCreateUtil.createArrayExpression(elements, cst.loc, lBracketToken, rBracketToken);
    }
    /**
     * ?CST ?AST?ObjectExpression?
     * ObjectLiteral -> { } | { PropertyDefinitionList } | { PropertyDefinitionList , }
     */ createObjectLiteralAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ObjectLiteral?.name);
        const properties = [];
        //  LBrace ?RBrace tokens
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        // ObjectLiteral: { PropertyDefinitionList? ,? }
        // children[0] = LBrace, children[last] = RBrace (if exists)
        if (cst.children && cst.children.length > 0) {
            const firstChild = cst.children[0];
            if (firstChild && (firstChild.name === 'LBrace' || firstChild.value === '{')) {
                lBraceToken = SlimeTokenCreate.createLBraceToken(firstChild.loc);
            }
            const lastChild = cst.children[cst.children.length - 1];
            if (lastChild && (lastChild.name === 'RBrace' || lastChild.value === '}')) {
                rBraceToken = SlimeTokenCreate.createRBraceToken(lastChild.loc);
            }
        }
        if (cst.children.length > 2) {
            const PropertyDefinitionListCst = cst.children[1];
            let currentProperty = null;
            let hasProperty = false;
            for (const child of PropertyDefinitionListCst.children){
                // childrenPropertyDefinitionSubhutiParser?
                if (child.name === _SlimeParser$1.prototype.PropertyDefinition?.name && child.children && child.children.length > 0) {
                    // 
                    if (hasProperty) {
                        properties.push(SlimeAstCreateUtil.createObjectPropertyItem(currentProperty, undefined));
                    }
                    currentProperty = this.createPropertyDefinitionAst(child);
                    hasProperty = true;
                } else if (child.name === 'Comma' || child.value === ',') {
                    // ?
                    const commaToken = SlimeTokenCreate.createCommaToken(child.loc);
                    if (hasProperty) {
                        properties.push(SlimeAstCreateUtil.createObjectPropertyItem(currentProperty, commaToken));
                        hasProperty = false;
                        currentProperty = null;
                    }
                }
            }
            // ?
            if (hasProperty) {
                properties.push(SlimeAstCreateUtil.createObjectPropertyItem(currentProperty, undefined));
            }
        }
        return SlimeAstCreateUtil.createObjectExpression(properties, cst.loc, lBraceToken, rBraceToken);
    }
    /**
     * ElisionCST ?AST
     * Elision -> , | Elision ,
     *  null ?
     */ createElisionAst(cst) {
        // ?
        let count = 0;
        for (const child of cst.children || []){
            if (child.value === ',') {
                count++;
            }
        }
        return count;
    }
    createLiteralAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.Literal?.name);
        const firstChild = cst.children[0];
        let value;
        // ?
        const childName = firstChild.name;
        // ?token ?
        if (childName === SlimeTokenConsumer.prototype.NumericLiteral?.name || childName === 'NumericLiteral') {
            const rawValue = firstChild.value;
            value = SlimeAstCreateUtil.createNumericLiteral(Number(rawValue), rawValue);
        } else if (childName === SlimeTokenConsumer.prototype.True?.name || childName === 'True') {
            value = SlimeAstCreateUtil.createBooleanLiteral(true);
        } else if (childName === SlimeTokenConsumer.prototype.False?.name || childName === 'False') {
            value = SlimeAstCreateUtil.createBooleanLiteral(false);
        } else if (childName === SlimeTokenConsumer.prototype.NullLiteral?.name || childName === 'NullLiteral' || childName === 'Null') {
            value = SlimeAstCreateUtil.createNullLiteralToken();
        } else if (childName === SlimeTokenConsumer.prototype.StringLiteral?.name || childName === 'StringLiteral') {
            const rawValue = firstChild.value;
            value = SlimeAstCreateUtil.createStringLiteral(rawValue, firstChild.loc, rawValue);
        } else if (childName === 'BooleanLiteral' || childName === _SlimeParser$1.prototype.BooleanLiteral?.name) {
            // BooleanLiteral ?True | False
            const innerChild = firstChild.children?.[0];
            if (innerChild?.name === 'True' || innerChild?.value === 'true') {
                value = SlimeAstCreateUtil.createBooleanLiteral(true);
            } else {
                value = SlimeAstCreateUtil.createBooleanLiteral(false);
            }
            value.loc = innerChild?.loc || firstChild.loc;
            return value;
        } else if (childName === 'NullLiteral') {
            value = SlimeAstCreateUtil.createNullLiteralToken();
        } else if (childName === 'BigIntLiteral') {
            const rawValue = firstChild.value || firstChild.children?.[0]?.value;
            // ?'n'
            const numStr = rawValue.endsWith('n') ? rawValue.slice(0, -1) : rawValue;
            value = SlimeAstCreateUtil.createBigIntLiteral(numStr, rawValue);
        } else {
            const rawValue = firstChild.value;
            if (rawValue !== undefined) {
                value = SlimeAstCreateUtil.createStringLiteral(rawValue, firstChild.loc, rawValue);
            } else {
                // 
                const innerChild = firstChild.children?.[0];
                if (innerChild?.value) {
                    value = SlimeAstCreateUtil.createStringLiteral(innerChild.value, innerChild.loc, innerChild.value);
                } else {
                    throw new Error(`Cannot extract value from Literal: ${childName}`);
                }
            }
        }
        value.loc = firstChild.loc;
        return value;
    }
    createAssignmentExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.AssignmentExpression?.name);
        if (cst.children.length === 1) {
            const child = cst.children[0];
            // 
            if (child.name === _SlimeParser$1.prototype.ArrowFunction?.name) {
                return this.createArrowFunctionAst(child);
            }
            // ?
            return this.createExpressionAst(child);
        }
        // AssignmentExpression -> LeftHandSideExpression + Eq + AssignmentExpression
        // ?LeftHandSideExpression + AssignmentOperator + AssignmentExpression
        const leftCst = cst.children[0];
        const operatorCst = cst.children[1];
        const rightCst = cst.children[2];
        const left = this.createExpressionAst(leftCst);
        const right = this.createAssignmentExpressionAst(rightCst);
        // AssignmentOperator?PlusEq/MinusEq?children[0].value
        const operator = operatorCst.children && operatorCst.children[0]?.value || operatorCst.value || '=';
        const ast = {
            type: 'AssignmentExpression',
            operator: operator,
            left: left,
            right: right,
            loc: cst.loc
        };
        return ast;
    }
    /**
     *  AST
     */ createArrowFunctionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ArrowFunction?.name);
        // ArrowFunction async
        // children[0]: AsyncTok (?
        // children[1]: BindingIdentifier ?CoverParenthesizedExpressionAndArrowParameterList ()
        // children[2]: Arrow (=>)
        // children[3]: ConciseBody (?
        // Token fields
        let asyncToken = undefined;
        let arrowToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        const commaTokens = [];
        // async
        let offset = 0;
        let isAsync = false;
        if (cst.children[0] && cst.children[0].name === 'Async') {
            asyncToken = SlimeTokenCreate.createAsyncToken(cst.children[0].loc);
            isAsync = true;
            offset = 1;
        }
        // children
        if (!cst.children || cst.children.length < 3 + offset) {
            throw new Error(`createArrowFunctionAst: ${3 + offset}children?{cst.children?.length || 0}`);
        }
        const arrowParametersCst = cst.children[0 + offset];
        const arrowCst = cst.children[1 + offset];
        const conciseBodyCst = cst.children[2 + offset];
        //  token
        if (arrowCst && (arrowCst.name === 'Arrow' || arrowCst.value === '=>')) {
            arrowToken = SlimeTokenCreate.createArrowToken(arrowCst.loc);
        }
        //  - 
        // SlimeFunctionParam  param  commaToken
        let params;
        if (arrowParametersCst.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            // x => x * 2
            params = [
                {
                    param: this.createBindingIdentifierAst(arrowParametersCst)
                }
            ];
        } else if (arrowParametersCst.name === _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name) {
            // ?a, b) => a + b ?() => 42
            //  tokens
            for (const child of arrowParametersCst.children || []){
                if (child.name === 'LParen' || child.value === '(') {
                    lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                } else if (child.name === 'RParen' || child.value === ')') {
                    rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                } else if (child.name === 'Comma' || child.value === ',') {
                    commaTokens.push(SlimeTokenCreate.createCommaToken(child.loc));
                }
            }
            // ?SlimePattern[] ?SlimeFunctionParam[]
            const rawParams = this.createArrowParametersFromCoverGrammar(arrowParametersCst);
            params = rawParams.map((p, i)=>({
                    param: p,
                    commaToken: commaTokens[i] //  token?
                }));
        } else if (arrowParametersCst.name === _SlimeParser$1.prototype.ArrowParameters?.name) {
            // ArrowParameters  CoverParenthesizedExpressionAndArrowParameterList ?BindingIdentifier
            const firstChild = arrowParametersCst.children?.[0];
            if (firstChild?.name === _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name) {
                // ?CoverParenthesizedExpressionAndArrowParameterList  tokens
                for (const child of firstChild.children || []){
                    if (child.name === 'LParen' || child.value === '(') {
                        lParenToken = SlimeTokenCreate.createLParenToken(child.loc);
                    } else if (child.name === 'RParen' || child.value === ')') {
                        rParenToken = SlimeTokenCreate.createRParenToken(child.loc);
                    } else if (child.name === 'Comma' || child.value === ',') {
                        commaTokens.push(SlimeTokenCreate.createCommaToken(child.loc));
                    }
                }
            }
            const rawParams = this.createArrowParametersAst(arrowParametersCst);
            params = rawParams.map((p, i)=>({
                    param: p,
                    commaToken: commaTokens[i] //  token?
                }));
        } else {
            throw new Error(`createArrowFunctionAst:  ${arrowParametersCst.name}`);
        }
        // ?
        const body = this.createConciseBodyAst(conciseBodyCst);
        // createArrowFunctionExpression ?(body, params, expression, async, loc, arrowToken, asyncToken, lParenToken, rParenToken)
        // commaTokens 
        return SlimeAstCreateUtil.createArrowFunctionExpression(body, params, body.type !== SlimeNodeType.BlockStatement, isAsync, cst.loc, arrowToken, asyncToken, lParenToken, rParenToken);
    }
    /**
     *  Async  AST
     * AsyncArrowFunction: async AsyncArrowBindingIdentifier => AsyncConciseBody
     *                   | CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
     */ createAsyncArrowFunctionAst(cst) {
        // AsyncArrowFunction ?
        // 1: [AsyncTok, BindingIdentifier, Arrow, AsyncConciseBody]
        // 2: [CoverCallExpressionAndAsyncArrowHead, Arrow, AsyncConciseBody]
        let params = [];
        let body;
        let arrowIndex = -1;
        let arrowToken = undefined;
        let asyncToken = undefined;
        let lParenToken = undefined;
        let rParenToken = undefined;
        //  Arrow token ?
        for(let i = 0; i < cst.children.length; i++){
            if (cst.children[i].name === 'Arrow' || cst.children[i].value === '=>') {
                arrowToken = SlimeTokenCreate.createArrowToken(cst.children[i].loc);
                arrowIndex = i;
                break;
            }
        }
        //  Arrow token CST ?
        if (arrowIndex === -1) {
            // ?CoverCallExpressionAndAsyncArrowHead 
            for (const child of cst.children){
                if (child.name === 'CoverCallExpressionAndAsyncArrowHead') {
                    params = this.createAsyncArrowParamsFromCover(child);
                    break;
                } else if (child.name === 'Async') {
                    continue;
                } else if (child.name === 'BindingIdentifier' || child.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
                    params = [
                        this.createBindingIdentifierAst(child)
                    ];
                    break;
                }
            }
            // ?body?
            return {
                type: SlimeNodeType.ArrowFunctionExpression,
                id: null,
                params: params,
                body: SlimeAstCreateUtil.createBlockStatement([]),
                generator: false,
                async: true,
                expression: false,
                loc: cst.loc
            };
        }
        // Arrow 
        for(let i = 0; i < arrowIndex; i++){
            const child = cst.children[i];
            if (child.name === 'Async' || child.name === 'IdentifierName' && child.value === 'async') {
                asyncToken = SlimeTokenCreate.createAsyncToken(child.loc);
                continue; //  async ?
            }
            if (child.name === _SlimeParser$1.prototype.BindingIdentifier?.name || child.name === 'BindingIdentifier') {
                params = [
                    this.createBindingIdentifierAst(child)
                ];
            } else if (child.name === 'AsyncArrowBindingIdentifier' || child.name === _SlimeParser$1.prototype.AsyncArrowBindingIdentifier?.name) {
                // AsyncArrowBindingIdentifier ?BindingIdentifier
                const bindingId = child.children?.find((c)=>c.name === 'BindingIdentifier' || c.name === _SlimeParser$1.prototype.BindingIdentifier?.name) || child.children?.[0];
                if (bindingId) {
                    params = [
                        this.createBindingIdentifierAst(bindingId)
                    ];
                }
            } else if (child.name === 'CoverCallExpressionAndAsyncArrowHead') {
                // ?CoverCallExpressionAndAsyncArrowHead ?tokens
                params = this.createAsyncArrowParamsFromCover(child);
                //  tokens
                for (const subChild of child.children || []){
                    if (subChild.name === 'Arguments' || subChild.name === _SlimeParser$1.prototype.Arguments?.name) {
                        for (const argChild of subChild.children || []){
                            if (argChild.name === 'LParen' || argChild.value === '(') {
                                lParenToken = SlimeTokenCreate.createLParenToken(argChild.loc);
                            } else if (argChild.name === 'RParen' || argChild.value === ')') {
                                rParenToken = SlimeTokenCreate.createRParenToken(argChild.loc);
                            }
                        }
                    }
                }
            } else if (child.name === _SlimeParser$1.prototype.ArrowFormalParameters?.name || child.name === 'ArrowFormalParameters') {
                params = this.createArrowFormalParametersAst(child);
                //  tokens
                for (const subChild of child.children || []){
                    if (subChild.name === 'LParen' || subChild.value === '(') {
                        lParenToken = SlimeTokenCreate.createLParenToken(subChild.loc);
                    } else if (subChild.name === 'RParen' || subChild.value === ')') {
                        rParenToken = SlimeTokenCreate.createRParenToken(subChild.loc);
                    }
                }
            }
        }
        // Arrow 
        const bodyIndex = arrowIndex + 1;
        if (bodyIndex < cst.children.length) {
            const bodyCst = cst.children[bodyIndex];
            if (bodyCst.name === 'AsyncConciseBody' || bodyCst.name === 'ConciseBody') {
                body = this.createConciseBodyAst(bodyCst);
            } else {
                body = this.createExpressionAst(bodyCst);
            }
        } else {
            body = SlimeAstCreateUtil.createBlockStatement([]);
        }
        return {
            type: SlimeNodeType.ArrowFunctionExpression,
            id: null,
            params: params,
            body: body,
            generator: false,
            async: true,
            expression: body.type !== SlimeNodeType.BlockStatement,
            arrowToken: arrowToken,
            asyncToken: asyncToken,
            lParenToken: lParenToken,
            rParenToken: rParenToken,
            loc: cst.loc
        };
    }
    /**
     * ?CoverCallExpressionAndAsyncArrowHead  async 
     */ createAsyncArrowParamsFromCover(cst) {
        // CoverCallExpressionAndAsyncArrowHead ?
        // [MemberExpression, Arguments] ?
        //  Arguments ?
        const params = [];
        for (const child of cst.children || []){
            if (child.name === 'Arguments' || child.name === _SlimeParser$1.prototype.Arguments?.name) {
                // ?Arguments ?
                for (const argChild of child.children || []){
                    if (argChild.name === 'ArgumentList' || argChild.name === _SlimeParser$1.prototype.ArgumentList?.name) {
                        let hasEllipsis = false // ?...
                        ;
                        for (const arg of argChild.children || []){
                            if (arg.value === ',') continue; // 
                            //  rest ?..ids
                            if (arg.name === 'Ellipsis' || arg.value === '...') {
                                hasEllipsis = true;
                                continue;
                            }
                            const param = this.convertCoverParameterCstToPattern(arg, hasEllipsis);
                            if (param) {
                                params.push(param);
                                hasEllipsis = false;
                            }
                        }
                    }
                }
            }
        }
        return params;
    }
    /**
     *  CST ?Pattern?cover grammar?
     * ?async (expr) => body  expr ?pattern ?
     */ /**
     * ?CST  Pattern?cover grammar?
     * ?async (expr) => body  expr ?pattern ?
     * ?CST convertExpressionToPattern  AST 
     */ convertCstToPattern(cst) {
        //  AssignmentExpression ( options = {})
        //  findInnerExpr  = ?
        if (cst.name === 'AssignmentExpression' || cst.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
            //  Assign token (=)
            const hasAssign = cst.children?.some((ch)=>ch.name === 'Assign' || ch.value === '=');
            if (hasAssign && cst.children && cst.children.length >= 3) {
                // : left = right
                const expr = this.createAssignmentExpressionAst(cst);
                if (expr.type === SlimeNodeType.AssignmentExpression) {
                    return this.convertAssignmentExpressionToPattern(expr);
                }
            }
        }
        // 
        const findInnerExpr = (node)=>{
            if (!node.children || node.children.length === 0) return node;
            // ?ObjectLiteralArrayLiteralIdentifier ?
            const first = node.children[0];
            if (first.name === 'ObjectLiteral' || first.name === 'ArrayLiteral' || first.name === 'IdentifierReference' || first.name === 'Identifier' || first.name === 'BindingIdentifier') {
                return first;
            }
            // 
            return findInnerExpr(first);
        };
        const inner = findInnerExpr(cst);
        if (inner.name === 'ObjectLiteral') {
            // ?ObjectLiteral ?ObjectPattern
            return this.convertObjectLiteralToPattern(inner);
        } else if (inner.name === 'ArrayLiteral') {
            // ?ArrayLiteral ?ArrayPattern
            return this.convertArrayLiteralToPattern(inner);
        } else if (inner.name === 'IdentifierReference' || inner.name === 'Identifier') {
            // ?
            const idNode = inner.name === 'IdentifierReference' ? findInnerExpr(inner) : inner;
            const identifierName = idNode.children?.[0];
            if (identifierName) {
                return SlimeAstCreateUtil.createIdentifier(identifierName.value, identifierName.loc);
            }
        } else if (inner.name === 'BindingIdentifier') {
            return this.createBindingIdentifierAst(inner);
        }
        //  AST 
        const expr = this.createExpressionAst(cst);
        if (expr.type === SlimeNodeType.Identifier) {
            return expr;
        } else if (expr.type === SlimeNodeType.ObjectExpression) {
            // ObjectExpression  ObjectPattern
            return this.convertObjectExpressionToPattern(expr);
        } else if (expr.type === SlimeNodeType.ArrayExpression) {
            // ArrayExpression  ArrayPattern
            return this.convertArrayExpressionToPattern(expr);
        } else if (expr.type === SlimeNodeType.AssignmentExpression) {
            // AssignmentExpression ?AssignmentPattern
            return this.convertAssignmentExpressionToPattern(expr);
        }
        // ?null?CST?
        return null;
    }
    /**
     * Cover  CST ?Pattern
     *  Arrow / AsyncArrow ?
     */ convertCoverParameterCstToPattern(cst, hasEllipsis) {
        let basePattern = null;
        // 1. ?BindingIdentifier / BindingPattern 
        if (cst.name === _SlimeParser$1.prototype.BindingIdentifier?.name || cst.name === 'BindingIdentifier') {
            basePattern = this.createBindingIdentifierAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.BindingPattern?.name || cst.name === 'BindingPattern') {
            basePattern = this.createBindingPatternAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ArrayBindingPattern?.name || cst.name === 'ArrayBindingPattern') {
            basePattern = this.createArrayBindingPatternAst(cst);
        } else if (cst.name === _SlimeParser$1.prototype.ObjectBindingPattern?.name || cst.name === 'ObjectBindingPattern') {
            basePattern = this.createObjectBindingPatternAst(cst);
        }
        // 2. AssignmentExpression / ObjectLiteral / ArrayLiteral ?CSTPattern 
        if (!basePattern) {
            basePattern = this.convertCstToPattern(cst);
        }
        // 3. ?Identifier
        if (!basePattern) {
            const identifierCst = this.findFirstIdentifierInExpression(cst);
            if (identifierCst) {
                basePattern = this.createIdentifierAst(identifierCst);
            }
        }
        if (!basePattern) return null;
        // 4.  rest ?hasEllipsis ?RestElement
        if (hasEllipsis) {
            return SlimeAstCreateUtil.createRestElement(basePattern);
        }
        return basePattern;
    }
    /**
     * ?ObjectLiteral CST ?ObjectPattern
     */ convertObjectLiteralToPattern(cst) {
        const properties = [];
        let lBraceToken = undefined;
        let rBraceToken = undefined;
        for (const child of cst.children || []){
            if (child.value === '{') {
                lBraceToken = SlimeTokenCreate.createLBraceToken(child.loc);
            } else if (child.value === '}') {
                rBraceToken = SlimeTokenCreate.createRBraceToken(child.loc);
            } else if (child.name === 'PropertyDefinitionList') {
                for (const prop of child.children || []){
                    if (prop.value === ',') {
                        // ?
                        if (properties.length > 0 && !properties[properties.length - 1].commaToken) {
                            properties[properties.length - 1].commaToken = SlimeTokenCreate.createCommaToken(prop.loc);
                        }
                        continue;
                    }
                    if (prop.name === 'PropertyDefinition') {
                        //  SpreadElement (... identifier)
                        const ellipsis = prop.children?.find((c)=>c.value === '...' || c.name === 'Ellipsis');
                        if (ellipsis) {
                            // ?RestElement
                            const assignExpr = prop.children?.find((c)=>c.name === 'AssignmentExpression');
                            if (assignExpr) {
                                // ?AssignmentExpression ?identifier
                                const idCst = this.findFirstIdentifierInExpression(assignExpr);
                                if (idCst) {
                                    const restId = this.createIdentifierAst(idCst);
                                    const restNode = {
                                        type: SlimeNodeType.RestElement,
                                        argument: restId,
                                        ellipsisToken: SlimeTokenCreate.createEllipsisToken(ellipsis.loc),
                                        loc: prop.loc
                                    };
                                    properties.push({
                                        property: restNode
                                    });
                                }
                            }
                        } else {
                            const patternProp = this.convertPropertyDefinitionToPatternProperty(prop);
                            if (patternProp) {
                                properties.push({
                                    property: patternProp
                                });
                            }
                        }
                    }
                }
            }
        }
        return {
            type: SlimeNodeType.ObjectPattern,
            properties,
            lBraceToken,
            rBraceToken,
            loc: cst.loc
        };
    }
    /**
     * ?PropertyDefinition CST ?Pattern ?
     */ convertPropertyDefinitionToPatternProperty(cst) {
        const first = cst.children?.[0];
        if (!first) return null;
        if (first.name === 'IdentifierReference') {
            // ? { id } -> { id: id }
            const idNode = first.children?.[0]?.children?.[0];
            if (idNode) {
                const id = SlimeAstCreateUtil.createIdentifier(idNode.value, idNode.loc);
                return {
                    type: SlimeNodeType.Property,
                    key: id,
                    value: id,
                    kind: 'init',
                    computed: false,
                    shorthand: true,
                    loc: cst.loc
                };
            }
        } else if (first.name === 'CoverInitializedName') {
            // ? { id = value }
            const idRef = first.children?.find((c)=>c.name === 'IdentifierReference');
            const initializer = first.children?.find((c)=>c.name === 'Initializer');
            if (idRef) {
                const idNode = idRef.children?.[0]?.children?.[0];
                if (idNode) {
                    const id = SlimeAstCreateUtil.createIdentifier(idNode.value, idNode.loc);
                    let value = id;
                    if (initializer) {
                        const init = this.createInitializerAst(initializer);
                        value = {
                            type: SlimeNodeType.AssignmentPattern,
                            left: id,
                            right: init,
                            loc: first.loc
                        };
                    }
                    return {
                        type: SlimeNodeType.Property,
                        key: id,
                        value: value,
                        kind: 'init',
                        computed: false,
                        shorthand: true,
                        loc: cst.loc
                    };
                }
            }
        } else if (first.name === 'PropertyName') {
            // : { key: value }
            const propName = first;
            const colonCst = cst.children?.find((c)=>c.value === ':');
            const valueCst = cst.children?.[2];
            if (colonCst && valueCst) {
                const key = this.createPropertyNameAst(propName);
                const valueExpr = this.createExpressionAst(valueCst);
                const value = this.convertExpressionToPatternFromAST(valueExpr);
                return {
                    type: SlimeNodeType.Property,
                    key: key,
                    value: value || valueExpr,
                    kind: 'init',
                    computed: this.isComputedPropertyName(propName),
                    shorthand: false,
                    loc: cst.loc
                };
            }
        }
        return null;
    }
    /**
     * ?ObjectExpression AST ?ObjectPattern
     */ convertObjectExpressionToPattern(expr) {
        const properties = [];
        for (const prop of expr.properties || []){
            const property = prop.property || prop;
            if (property.type === SlimeNodeType.SpreadElement) {
                properties.push({
                    property: {
                        type: SlimeNodeType.RestElement,
                        argument: property.argument,
                        loc: property.loc
                    }
                });
            } else {
                const value = this.convertExpressionToPatternFromAST(property.value);
                properties.push({
                    property: {
                        type: SlimeNodeType.Property,
                        key: property.key,
                        value: value || property.value,
                        kind: 'init',
                        computed: property.computed,
                        shorthand: property.shorthand,
                        loc: property.loc
                    }
                });
            }
        }
        return {
            type: SlimeNodeType.ObjectPattern,
            properties,
            lBraceToken: expr.lBraceToken,
            rBraceToken: expr.rBraceToken,
            loc: expr.loc
        };
    }
    /**
     * ?ArrayExpression AST ?ArrayPattern
     */ convertArrayExpressionToPattern(expr) {
        const elements = [];
        for (const elem of expr.elements || []){
            if (elem === null || elem.element === null) {
                elements.push({
                    element: null
                });
            } else {
                const element = elem.element || elem;
                const pattern = this.convertExpressionToPatternFromAST(element);
                elements.push({
                    element: pattern || element,
                    commaToken: elem.commaToken
                });
            }
        }
        return {
            type: SlimeNodeType.ArrayPattern,
            elements,
            lBracketToken: expr.lBracketToken,
            rBracketToken: expr.rBracketToken,
            loc: expr.loc
        };
    }
    /**
     * ?AssignmentExpression AST ?AssignmentPattern
     */ convertAssignmentExpressionToPattern(expr) {
        const left = this.convertExpressionToPatternFromAST(expr.left);
        return {
            type: SlimeNodeType.AssignmentPattern,
            left: left || expr.left,
            right: expr.right,
            loc: expr.loc
        };
    }
    /**
     *  AST ?Pattern
     */ convertExpressionToPatternFromAST(expr) {
        if (!expr) return null;
        if (expr.type === SlimeNodeType.Identifier) {
            return expr;
        } else if (expr.type === SlimeNodeType.ObjectExpression) {
            return this.convertObjectExpressionToPattern(expr);
        } else if (expr.type === SlimeNodeType.ArrayExpression) {
            return this.convertArrayExpressionToPattern(expr);
        } else if (expr.type === SlimeNodeType.AssignmentExpression) {
            return this.convertAssignmentExpressionToPattern(expr);
        }
        return null;
    }
    /**
     * ?ArrayLiteral CST ?ArrayPattern
     */ convertArrayLiteralToPattern(cst) {
        //  createArrayBindingPatternAst 
        const elements = [];
        let lBracketToken = undefined;
        let rBracketToken = undefined;
        // ?Elision 
        const processElision = (elisionNode)=>{
            for (const elisionChild of elisionNode.children || []){
                if (elisionChild.value === ',') {
                    // 
                    if (elements.length > 0 && !elements[elements.length - 1].commaToken) {
                        elements[elements.length - 1].commaToken = SlimeTokenCreate.createCommaToken(elisionChild.loc);
                    }
                    // ?
                    elements.push({
                        element: null
                    });
                }
            }
        };
        for (const child of cst.children || []){
            if (child.value === '[') {
                lBracketToken = SlimeTokenCreate.createLBracketToken(child.loc);
            } else if (child.value === ']') {
                rBracketToken = SlimeTokenCreate.createRBracketToken(child.loc);
            } else if (child.name === 'Elision') {
                // ?ArrayLiteral  Elision [,,]?
                processElision(child);
            } else if (child.name === 'ElementList') {
                const elemChildren = child.children || [];
                for(let i = 0; i < elemChildren.length; i++){
                    const elem = elemChildren[i];
                    if (elem.value === ',') {
                        // ?
                        if (elements.length > 0 && !elements[elements.length - 1].commaToken) {
                            elements[elements.length - 1].commaToken = SlimeTokenCreate.createCommaToken(elem.loc);
                        }
                    } else if (elem.name === 'Elision') {
                        // ElementList  Elision
                        processElision(elem);
                    } else if (elem.name === 'AssignmentExpression') {
                        const expr = this.createExpressionAst(elem);
                        const pattern = this.convertExpressionToPatternFromAST(expr);
                        elements.push({
                            element: pattern || expr
                        });
                    } else if (elem.name === 'SpreadElement') {
                        const restNode = this.createSpreadElementAst(elem);
                        elements.push({
                            element: {
                                type: SlimeNodeType.RestElement,
                                argument: restNode.argument,
                                loc: restNode.loc
                            }
                        });
                    }
                }
            }
        }
        return {
            type: SlimeNodeType.ArrayPattern,
            elements,
            lBracketToken,
            rBracketToken,
            loc: cst.loc
        };
    }
    /**
     * ?ArrowFormalParameters 
     */ createArrowFormalParametersAst(cst) {
        // ArrowFormalParameters: ( UniqueFormalParameters )
        const params = [];
        for (const child of cst.children || []){
            if (child.name === 'UniqueFormalParameters' || child.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
                return this.createUniqueFormalParametersAst(child);
            }
            if (child.name === 'FormalParameters' || child.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                return this.createFormalParametersAst(child);
            }
        }
        return params;
    }
    /**
     * ?ArrowFormalParameters  ()
     */ createArrowFormalParametersAstWrapped(cst) {
        // ArrowFormalParameters: ( UniqueFormalParameters )
        for (const child of cst.children || []){
            if (child.name === 'UniqueFormalParameters' || child.name === _SlimeParser$1.prototype.UniqueFormalParameters?.name) {
                return this.createUniqueFormalParametersAstWrapped(child);
            }
            if (child.name === 'FormalParameters' || child.name === _SlimeParser$1.prototype.FormalParameters?.name) {
                return this.createFormalParametersAstWrapped(child);
            }
        }
        return [];
    }
    /**
     * CoverParenthesizedExpressionAndArrowParameterList
     */ createArrowParametersFromCoverGrammar(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name);
        // CoverParenthesizedExpressionAndArrowParameterList children?
        // LParen + (FormalParameterList | Expression | ...) + RParen
        // ?LParen + Expression + Comma + Ellipsis + BindingIdentifier + RParen
        if (cst.children.length === 0) {
            return [];
        }
        // () - ?
        if (cst.children.length === 2) {
            return [];
        }
        const params = [];
        // FormalParameterList
        const formalParameterListCst = cst.children.find((child)=>child.name === _SlimeParser$1.prototype.FormalParameterList?.name);
        if (formalParameterListCst) {
            return this.createFormalParameterListAst(formalParameterListCst);
        }
        // Expression?(a, b) ?(x)?
        const expressionCst = cst.children.find((child)=>child.name === _SlimeParser$1.prototype.Expression?.name);
        if (expressionCst && expressionCst.children?.length) {
            // ?Expression ?children ?AssignmentExpression ?
            for (const child of expressionCst.children){
                if (child.name === 'Comma' || child.value === ',') continue;
                const param = this.convertCoverParameterCstToPattern(child, false);
                if (param) {
                    params.push(param);
                }
            }
        }
        //  rest Ellipsis + BindingIdentifier ?BindingPattern?
        const hasEllipsis = cst.children.some((child)=>child.name === 'Ellipsis' || child.name === 'Ellipsis');
        if (hasEllipsis) {
            //  BindingIdentifier / BindingPattern  rest ?
            const bindingIdentifierCst = cst.children.find((child)=>child.name === _SlimeParser$1.prototype.BindingIdentifier?.name || child.name === 'BindingIdentifier');
            const bindingPatternCst = bindingIdentifierCst ? null : cst.children.find((child)=>child.name === _SlimeParser$1.prototype.BindingPattern?.name || child.name === 'BindingPattern' || child.name === _SlimeParser$1.prototype.ArrayBindingPattern?.name || child.name === 'ArrayBindingPattern' || child.name === _SlimeParser$1.prototype.ObjectBindingPattern?.name || child.name === 'ObjectBindingPattern');
            const restTarget = bindingIdentifierCst || bindingPatternCst;
            if (restTarget) {
                const restParam = this.convertCoverParameterCstToPattern(restTarget, true);
                if (restParam) {
                    params.push(restParam);
                }
            }
        } else if (params.length === 0) {
            //  Expression ?rest?BindingIdentifier
            const bindingIdentifierCst = cst.children.find((child)=>child.name === _SlimeParser$1.prototype.BindingIdentifier?.name || child.name === 'BindingIdentifier');
            if (bindingIdentifierCst) {
                params.push(this.createBindingIdentifierAst(bindingIdentifierCst));
            }
        }
        return params;
    }
    /**
     * Expression?
     * ?(a, b) ?(x)
     */ extractParametersFromExpression(expressionCst) {
        // Expression
        // 1. Identifier: x
        // 2. ? a, b ?a, b, c
        // 3. : a = 1
        // AssignmentExpression
        if (expressionCst.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
            const assignmentAst = this.createAssignmentExpressionAst(expressionCst);
            // identifier
            if (assignmentAst.type === SlimeNodeType.Identifier) {
                return [
                    assignmentAst
                ];
            }
            // AssignmentPattern
            if (assignmentAst.type === SlimeNodeType.AssignmentExpression) {
                return [
                    {
                        type: 'AssignmentPattern',
                        left: assignmentAst.left,
                        right: assignmentAst.right
                    }
                ];
            }
            return [
                assignmentAst
            ];
        }
        // Expressionchildren
        if (expressionCst.children && expressionCst.children.length > 0) {
            const params = [];
            // childrenAssignmentExpression?
            for (const child of expressionCst.children){
                if (child.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                    const assignmentAst = this.createAssignmentExpressionAst(child);
                    // ?
                    if (assignmentAst.type === SlimeNodeType.Identifier) {
                        params.push(assignmentAst);
                    } else if (assignmentAst.type === SlimeNodeType.AssignmentExpression) {
                        // 
                        params.push({
                            type: 'AssignmentPattern',
                            left: assignmentAst.left,
                            right: assignmentAst.right
                        });
                    } else if (assignmentAst.type === SlimeNodeType.ObjectExpression) {
                        // ?{ a, b }) => ...
                        //  ObjectExpression ?ObjectPattern
                        params.push(this.convertExpressionToPattern(assignmentAst));
                    } else if (assignmentAst.type === SlimeNodeType.ArrayExpression) {
                        // ?[a, b]) => ...
                        //  ArrayExpression ?ArrayPattern
                        params.push(this.convertExpressionToPattern(assignmentAst));
                    } else {
                        // identifier
                        const identifier = this.findFirstIdentifierInExpression(child);
                        if (identifier) {
                            params.push(this.createIdentifierAst(identifier));
                        }
                    }
                }
            }
            if (params.length > 0) {
                return params;
            }
        }
        // identifier
        const identifierCst = this.findFirstIdentifierInExpression(expressionCst);
        if (identifierCst) {
            return [
                this.createIdentifierAst(identifierCst)
            ];
        }
        return [];
    }
    /**
     * ExpressionIdentifier
     */ findFirstIdentifierInExpression(cst) {
        if (cst.name === SlimeTokenConsumer.prototype.IdentifierName?.name) {
            return cst;
        }
        if (cst.children) {
            for (const child of cst.children){
                const found = this.findFirstIdentifierInExpression(child);
                if (found) return found;
            }
        }
        return null;
    }
    /**
     * ?
     * ObjectExpression -> ObjectPattern
     * ArrayExpression -> ArrayPattern
     * Identifier -> Identifier
     * SpreadElement -> RestElement
     */ convertExpressionToPattern(expr) {
        if (!expr) return expr;
        if (expr.type === SlimeNodeType.Identifier) {
            return expr;
        }
        if (expr.type === SlimeNodeType.ObjectExpression) {
            // ?ObjectExpression ?ObjectPattern
            const properties = [];
            for (const item of expr.properties || []){
                const prop = item.property !== undefined ? item.property : item;
                if (prop.type === SlimeNodeType.SpreadElement) {
                    // SpreadElement -> RestElement
                    properties.push({
                        property: {
                            type: SlimeNodeType.RestElement,
                            argument: this.convertExpressionToPattern(prop.argument),
                            loc: prop.loc
                        },
                        commaToken: item.commaToken
                    });
                } else if (prop.type === SlimeNodeType.Property) {
                    //  Property ?value
                    const convertedValue = this.convertExpressionToPattern(prop.value);
                    properties.push({
                        property: {
                            ...prop,
                            value: convertedValue
                        },
                        commaToken: item.commaToken
                    });
                } else {
                    properties.push(item);
                }
            }
            return {
                type: SlimeNodeType.ObjectPattern,
                properties: properties,
                loc: expr.loc,
                lBraceToken: expr.lBraceToken,
                rBraceToken: expr.rBraceToken
            };
        }
        if (expr.type === SlimeNodeType.ArrayExpression) {
            // ?ArrayExpression ?ArrayPattern
            const elements = [];
            for (const item of expr.elements || []){
                const elem = item.element !== undefined ? item.element : item;
                if (elem === null) {
                    elements.push(item);
                } else if (elem.type === SlimeNodeType.SpreadElement) {
                    // SpreadElement -> RestElement
                    elements.push({
                        element: {
                            type: SlimeNodeType.RestElement,
                            argument: this.convertExpressionToPattern(elem.argument),
                            loc: elem.loc
                        },
                        commaToken: item.commaToken
                    });
                } else {
                    elements.push({
                        element: this.convertExpressionToPattern(elem),
                        commaToken: item.commaToken
                    });
                }
            }
            return {
                type: SlimeNodeType.ArrayPattern,
                elements: elements,
                loc: expr.loc,
                lBracketToken: expr.lBracketToken,
                rBracketToken: expr.rBracketToken
            };
        }
        if (expr.type === SlimeNodeType.AssignmentExpression) {
            // ?AssignmentExpression ?AssignmentPattern
            return {
                type: SlimeNodeType.AssignmentPattern,
                left: this.convertExpressionToPattern(expr.left),
                right: expr.right,
                loc: expr.loc
            };
        }
        if (expr.type === SlimeNodeType.SpreadElement) {
            // SpreadElement -> RestElement
            return {
                type: SlimeNodeType.RestElement,
                argument: this.convertExpressionToPattern(expr.argument),
                loc: expr.loc
            };
        }
        // 
        return expr;
    }
    /**
     *  AST
     */ createArrowParametersAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ArrowParameters?.name);
        // ArrowParameters ?
        if (cst.children.length === 0) {
            return [];
        }
        const first = cst.children[0];
        // BindingIdentifier
        if (first.name === _SlimeParser$1.prototype.BindingIdentifier?.name) {
            const param = this.createBindingIdentifierAst(first);
            return [
                param
            ];
        }
        // CoverParenthesizedExpressionAndArrowParameterList: 
        if (first.name === _SlimeParser$1.prototype.CoverParenthesizedExpressionAndArrowParameterList?.name) {
            return this.createArrowParametersFromCoverGrammar(first);
        }
        // ? FormalParameterList )
        if (first.name === SlimeTokenConsumer.prototype.LParen?.name) {
            //  FormalParameterList
            const formalParameterListCst = cst.children.find((child)=>child.name === _SlimeParser$1.prototype.FormalParameterList?.name);
            if (formalParameterListCst) {
                return this.createFormalParameterListAst(formalParameterListCst);
            }
            return [];
        }
        return [];
    }
    /**
     * ?AST
     */ createConciseBodyAst(cst) {
        // ?
        if (!cst) {
            throw new Error('createConciseBodyAst: cst is null or undefined');
        }
        //  ConciseBody ?AsyncConciseBody
        const validNames = [
            _SlimeParser$1.prototype.ConciseBody?.name,
            'ConciseBody',
            'AsyncConciseBody'
        ];
        if (!validNames.includes(cst.name)) {
            throw new Error(`createConciseBodyAst:  ConciseBody ?AsyncConciseBody?${cst.name}`);
        }
        const first = cst.children[0];
        // Es2025Parser: { FunctionBody } 
        // children: [LBrace, FunctionBody/AsyncFunctionBody, RBrace]
        if (first.name === 'LBrace') {
            //  FunctionBody ?AsyncFunctionBody
            const functionBodyCst = cst.children.find((child)=>child.name === 'FunctionBody' || child.name === _SlimeParser$1.prototype.FunctionBody?.name || child.name === 'AsyncFunctionBody' || child.name === _SlimeParser$1.prototype.AsyncFunctionBody?.name);
            if (functionBodyCst) {
                const bodyStatements = this.createFunctionBodyAst(functionBodyCst);
                return SlimeAstCreateUtil.createBlockStatement(bodyStatements, cst.loc);
            }
            // 
            return SlimeAstCreateUtil.createBlockStatement([], cst.loc);
        }
        // ?
        if (first.name === _SlimeParser$1.prototype.AssignmentExpression?.name || first.name === 'AssignmentExpression') {
            return this.createAssignmentExpressionAst(first);
        }
        // Es2025Parser: ExpressionBody 
        if (first.name === 'ExpressionBody') {
            // ExpressionBody  AssignmentExpression
            const innerExpr = first.children[0];
            if (innerExpr) {
                if (innerExpr.name === 'AssignmentExpression' || innerExpr.name === _SlimeParser$1.prototype.AssignmentExpression?.name) {
                    return this.createAssignmentExpressionAst(innerExpr);
                }
                return this.createExpressionAst(innerExpr);
            }
        }
        return this.createExpressionAst(first);
    }
    createConditionalExpressionAst(cst) {
        checkCstName$1(cst, _SlimeParser$1.prototype.ConditionalExpression?.name);
        const firstChild = cst.children[0];
        let test = this.createExpressionAst(firstChild);
        let alternate;
        let consequent;
        // Token fields
        let questionToken = undefined;
        let colonToken = undefined;
        if (cst.children.length === 1) {
            return this.createExpressionAst(cst.children[0]);
        } else {
            // CST children: [LogicalORExpression, Question, AssignmentExpression, Colon, AssignmentExpression]
            const questionCst = cst.children[1];
            const colonCst = cst.children[3];
            if (questionCst && (questionCst.name === 'Question' || questionCst.value === '?')) {
                questionToken = SlimeTokenCreate.createQuestionToken(questionCst.loc);
            }
            if (colonCst && (colonCst.name === 'Colon' || colonCst.value === ':')) {
                colonToken = SlimeTokenCreate.createColonToken(colonCst.loc);
            }
            consequent = this.createAssignmentExpressionAst(cst.children[2]);
            alternate = this.createAssignmentExpressionAst(cst.children[4]);
        }
        return SlimeAstCreateUtil.createConditionalExpression(test, consequent, alternate, cst.loc, questionToken, colonToken);
    }
    createYieldExpressionAst(cst) {
        // yield [*] AssignmentExpression?
        let yieldToken = undefined;
        let asteriskToken = undefined;
        let delegate = false;
        let startIndex = 1;
        //  yield token
        if (cst.children[0] && (cst.children[0].name === 'Yield' || cst.children[0].value === 'yield')) {
            yieldToken = SlimeTokenCreate.createYieldToken(cst.children[0].loc);
        }
        if (cst.children[1] && cst.children[1].name === SlimeTokenConsumer.prototype.Asterisk?.name) {
            asteriskToken = SlimeTokenCreate.createAsteriskToken(cst.children[1].loc);
            delegate = true;
            startIndex = 2;
        }
        let argument = null;
        if (cst.children[startIndex]) {
            argument = this.createAssignmentExpressionAst(cst.children[startIndex]);
        }
        return SlimeAstCreateUtil.createYieldExpression(argument, delegate, cst.loc, yieldToken, asteriskToken);
    }
    createAwaitExpressionAst(cst) {
        // await UnaryExpression
        checkCstName$1(cst, _SlimeParser$1.prototype.AwaitExpression?.name);
        let awaitToken = undefined;
        //  await token
        if (cst.children[0] && (cst.children[0].name === 'Await' || cst.children[0].value === 'await')) {
            awaitToken = SlimeTokenCreate.createAwaitToken(cst.children[0].loc);
        }
        const argumentCst = cst.children[1];
        const argument = this.createExpressionAst(argumentCst);
        return SlimeAstCreateUtil.createAwaitExpression(argument, cst.loc, awaitToken);
    }
    /**
     *  ShortCircuitExpressionTail (|| ??? )
     * CST ShortCircuitExpressionTail -> LogicalORExpressionTail | CoalesceExpressionTail
     * LogicalORExpressionTail -> LogicalOr LogicalANDExpression LogicalORExpressionTail?
     */ createShortCircuitExpressionTailAst(left, tailCst) {
        const tailChildren = tailCst.children || [];
        // ?ShortCircuitExpressionTail tail
        if (tailCst.name === 'ShortCircuitExpressionTail' && tailChildren.length > 0) {
            const innerTail = tailChildren[0];
            return this.createShortCircuitExpressionTailAst(left, innerTail);
        }
        // LogicalORExpressionTail: (LogicalOr LogicalANDExpression)+
        // [LogicalOr, expr, LogicalOr, expr, ...]
        if (tailCst.name === 'LogicalORExpressionTail') {
            let result = left;
            //  (operator, operand) ?
            for(let i = 0; i < tailChildren.length; i += 2){
                const operatorNode = tailChildren[i];
                const operator = operatorNode.value || '||';
                const rightCst = tailChildren[i + 1];
                if (!rightCst) break;
                const right = this.createExpressionAst(rightCst);
                result = {
                    type: SlimeNodeType.LogicalExpression,
                    operator: operator,
                    left: result,
                    right: right,
                    loc: tailCst.loc
                };
            }
            return result;
        }
        // CoalesceExpressionTail: (?? BitwiseORExpression)+
        // [??, expr, ??, expr, ...]
        if (tailCst.name === 'CoalesceExpressionTail') {
            let result = left;
            for(let i = 0; i < tailChildren.length; i += 2){
                const operatorNode = tailChildren[i];
                const operator = operatorNode.value || '??';
                const rightCst = tailChildren[i + 1];
                if (!rightCst) break;
                const right = this.createExpressionAst(rightCst);
                result = {
                    type: SlimeNodeType.LogicalExpression,
                    operator: operator,
                    left: result,
                    right: right,
                    loc: tailCst.loc
                };
            }
            return result;
        }
        // ?tail ?
        console.warn('Unknown ShortCircuitExpressionTail type:', tailCst.name);
        return left;
    }
    constructor(){
        _define_property$2(this, "expressionAstCache", new WeakMap());
    }
}
new SlimeCstToAst();

function _define_property$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// HTML  $OvsHtmlTag.xxx()
const HTML_TAGS = new Set([
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'menu',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'slot',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'svg',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr'
]);
/**  HTML  */ function isHtmlTag(tagName) {
    return HTML_TAGS.has(tagName.toLowerCase());
}
/**  callee HTML  $OvsHtmlTag.xxx */ function createCalleeForTag(tagName, loc) {
    if (isHtmlTag(tagName)) {
        // HTML   $OvsHtmlTag.tagName
        const memberExpr = SlimeAstCreateUtil.createMemberExpression(SlimeAstCreateUtil.createIdentifier('$OvsHtmlTag'), SlimeTokenCreate.createDotToken(), SlimeAstCreateUtil.createIdentifier(tagName));
        if (loc) memberExpr.loc = loc;
        return memberExpr;
    } else {
        //   
        const id = SlimeAstCreateUtil.createIdentifier(tagName);
        if (loc) id.loc = loc;
        return id;
    }
}
function checkCstName(cst, cstName) {
    if (cst.name !== cstName) {
        console.log(cst);
        throwNewError(cst.name);
    }
    return cstName;
}
function throwNewError(errorMsg = 'syntax error') {
    throw new Error(errorMsg);
}
class OvsCstToSlimeAst extends SlimeCstToAst {
    /**
   *  CST  Program AST
   *
   * OVS   JavaScript AST
   * 
   * - import  ensureOvsAPIImport -  createComponentVNode
   * -  wrapAsVueComponent
   *
   *  CST  SlimeParser 
   * - Program -> ModuleBody -> ModuleItemList
   * - Program -> ScriptBody -> StatementList
   * - Program -> ModuleItemList
   * - Program -> StatementList
   *
   * @param cst Program CST 
   * @returns Program AST
   */ toProgram(cst) {
        checkCstName(cst, _SlimeParser$1.prototype.Program.name);
        // 
        if (!cst.children || cst.children.length === 0) {
            return SlimeAstCreateUtil.createProgram([], SlimeProgramSourceType.Module);
        }
        //  HashbangComment
        let bodyChild = null;
        for (const child of cst.children){
            if (child.name === 'HashbangComment') {
                continue; //  hashbang 
            }
            bodyChild = child;
            break;
        }
        if (!bodyChild) {
            return SlimeAstCreateUtil.createProgram([], SlimeProgramSourceType.Module);
        }
        //  AST
        let body = [];
        let sourceType = SlimeProgramSourceType.Module;
        if (bodyChild.name === 'ModuleBody') {
            // Program -> ModuleBody -> ModuleItemList
            const moduleItemList = bodyChild.children?.[0];
            if (moduleItemList && moduleItemList.name === _SlimeParser$1.prototype.ModuleItemList?.name) {
                body = this.createModuleItemListAst(moduleItemList);
            }
            sourceType = SlimeProgramSourceType.Module;
        } else if (bodyChild.name === _SlimeParser$1.prototype.ModuleItemList?.name) {
            // Program -> ModuleItemList
            body = this.createModuleItemListAst(bodyChild);
            sourceType = SlimeProgramSourceType.Module;
        } else if (bodyChild.name === 'ScriptBody') {
            // Program -> ScriptBody -> StatementList
            const statementList = bodyChild.children?.[0];
            if (statementList && statementList.name === _SlimeParser$1.prototype.StatementList?.name) {
                body = this.createStatementListAst(statementList);
            }
            sourceType = SlimeProgramSourceType.Script;
        } else if (bodyChild.name === _SlimeParser$1.prototype.StatementList?.name) {
            // Program -> StatementList
            body = this.createStatementListAst(bodyChild);
            sourceType = SlimeProgramSourceType.Script;
        }
        //  Program AST
        const program = SlimeAstCreateUtil.createProgram(body, sourceType);
        program.loc = cst.loc;
        return program;
    }
    createDeclarationAst(cst) {
        // Declaration -> OvsViewDeclaration | VariableDeclaration | FunctionDeclaration | ...
        // child OvsViewDeclaration
        const first = cst.children?.[0];
        if (first && first.name === _OvsParser.prototype.OvsViewDeclaration.name) {
            return this.createOvsViewDeclarationAst(first);
        }
        return super.createDeclarationAst(cst);
    }
    /**
   *  OvsViewDeclaration 
   *
   * ovsView ComponentName (state) : div { ... }
   * function ComponentName(state) { return createComponentVNode('div', ...) }
   * 
   * ReactiveVNodeApi
   */ createOvsViewDeclarationAst(cst) {
        checkCstName(cst, _OvsParser.prototype.OvsViewDeclaration.name);
        // OvsViewToken, ovsRenderDomClassDeclaration, OvsRenderDomViewDeclaration
        const children = cst.children || [];
        // 1.  ovsRenderDomClassDeclaration 
        const classDeclCst = children[1];
        if (!classDeclCst) {
            throw new Error('OvsViewDeclaration: missing class declaration');
        }
        // ovsRenderDomClassDeclaration Identifier, FunctionFormalParameters?, Colon
        const classDeclChildren = classDeclCst.children || [];
        // 
        const componentNameCst = classDeclChildren[0];
        if (!componentNameCst) {
            throw new Error('OvsViewDeclaration: missing component name');
        }
        const componentName = this.createIdentifierAst(componentNameCst);
        // 
        let params;
        const formalParamsCst = classDeclChildren.find((c)=>c.name === 'FunctionFormalParameters');
        if (formalParamsCst) {
            // 
            params = this.createFunctionFormalParametersAst(formalParamsCst);
        } else {
            // 
            throw new Error('ovsView : ovsView ComponentName (state) : rootElement { ... }');
        }
        // 2. 3OvsRenderDomViewDeclaration
        const viewCst = children[2];
        if (!viewCst) {
            throw new Error('OvsViewDeclaration: missing view declaration');
        }
        // IIFEh
        const viewExpression = this.createOvsRenderDomViewDeclarationAst(viewCst);
        //  children  child 
        let functionBodyStatements = [];
        if (viewExpression.type === SlimeNodeType.CallExpression) {
            const iife = viewExpression;
            const iifeFunc = iife.callee;
            if (iifeFunc.type === 'FunctionExpression') {
                //  IIFE(function() { const children = []; ...; return h(...) })()
                //  IIFE  child children
                const iifeBody = iifeFunc.body.body;
                //  return  return h(...)
                const statementsWithoutReturn = iifeBody.slice(0, -1);
                const lastReturn = iifeBody[iifeBody.length - 1];
                if (lastReturn && lastReturn.type === SlimeNodeType.ReturnStatement) {
                    const returnExpr = lastReturn.argument;
                    functionBodyStatements = [
                        ...statementsWithoutReturn,
                        SlimeAstCreateUtil.createReturnStatement(returnExpr)
                    ];
                } else {
                    functionBodyStatements = iifeBody;
                }
            } else {
                //  h h('div', {}, [...])
                functionBodyStatements = [
                    SlimeAstCreateUtil.createReturnStatement(viewExpression)
                ];
            }
        } else {
            //  return
            functionBodyStatements = [
                SlimeAstCreateUtil.createReturnStatement(viewExpression)
            ];
        }
        // 
        const functionBody = SlimeAstCreateUtil.createBlockStatement({
            type: 'LBrace',
            value: '{',
            loc: cst.loc
        }, {
            type: 'RBrace',
            value: '}',
            loc: cst.loc
        }, functionBodyStatements, cst.loc);
        // AST
        const functionDeclaration = {
            type: 'FunctionDeclaration',
            id: componentName,
            params: params,
            body: functionBody,
            generator: false,
            async: false,
            loc: cst.loc
        };
        return functionDeclaration;
    }
    /**
   * Override:  StatementList NoRenderBlock
   * 
   * NoRenderBlock (#{ }) 
   * -  noRenderDepth++
   * - 
   * -  #{} 
   * -  noRenderDepth--
   */ createStatementListAst(cst) {
        checkCstName(cst, _SlimeParser$1.prototype.StatementList.name);
        const statements = [];
        if (!cst.children) return statements;
        for (const child of cst.children){
            // StatementListItem  Statement  Declaration
            const stmts = this.createStatementListItemAst(child);
            // 
            if (Array.isArray(stmts)) {
                statements.push(...stmts);
            } else {
                statements.push(stmts);
            }
        }
        return statements;
    }
    /**
   * Override:  StatementListItem NoRenderBlock 
   */ createStatementListItemAst(cst) {
        checkCstName(cst, _SlimeParser$1.prototype.StatementListItem.name);
        if (!cst.children || cst.children.length === 0) {
            return [];
        }
        const child = cst.children[0];
        //  Statement -> NoRenderBlock
        if (child.name === _SlimeParser$1.prototype.Statement.name) {
            const statementChild = child.children?.[0];
            if (statementChild && statementChild.name === _OvsParser.prototype.NoRenderBlock.name) {
                //  NoRenderBlock
                this.noRenderDepth++;
                try {
                    //  StatementList
                    const innerList = statementChild.children?.find((c)=>c.name === _SlimeParser$1.prototype.StatementList.name);
                    if (innerList) {
                        // 
                        const innerStatements = this.createStatementListAst(innerList);
                        //   #{} 
                        //  IIFE 
                        innerStatements.forEach((stmt)=>{
                            stmt.__fromNoRenderBlock = true;
                        });
                        return innerStatements // 
                        ;
                    }
                    return [];
                } finally{
                    this.noRenderDepth--;
                }
            }
        }
        // 
        return super.createStatementListItemAst(cst);
    }
    createExpressionAst(cst) {
        const astName = cst.name;
        let left;
        if (astName === _OvsParser.prototype.OvsRenderFunction.name) {
            left = this.createOvsRenderDomViewDeclarationAst(cst);
        } else {
            left = super.createExpressionAst(cst);
        }
        return left;
    }
    /**
   *  PrimaryExpression 
   *
   *  OvsRenderFunction 
   * OvsRenderFunction  OvsParser  PrimaryExpression 
   */ createPrimaryExpressionAst(cst) {
        const first = cst.children?.[0];
        //  OvsRenderFunction
        if (first && first.name === _OvsParser.prototype.OvsRenderFunction.name) {
            return this.createOvsRenderDomViewDeclarationAst(first);
        }
        // 
        return super.createPrimaryExpressionAst(cst);
    }
    /**
   *  ExpressionStatement 
   *
   * 
   * - OvsRenderFunction > noRenderDepth > ovsRenderDomViewDepth
   * - OvsRenderFunctionp {}
   * -  #{} noRenderDepth > 0 OvsRenderFunction
   * -  div {} ovsRenderDomViewDepth > 0
   * - 
   *
   * 
   * div {
   *   p {}            children.push(h('p', ...))   OvsRenderFunction
   *   func()          children.push(func())         div {} 
   *   #{ func() }     func()                        #{} 
   *   #{ p {} }       children.push(h('p', ...))   OvsRenderFunction 
   * }
   */ /**
   *  CST  OvsRenderFunction 
   * Expression 
   */ findOvsRenderFunction(cst) {
        if (!cst) return false;
        // 
        if (cst.name === _OvsParser.prototype.OvsRenderFunction.name) {
            return true;
        }
        // 
        if (cst.children && cst.children.length > 0) {
            return this.findOvsRenderFunction(cst.children[0]);
        }
        return false;
    }
    createExpressionStatementAst(cst) {
        const exprCst = cst.children?.[0];
        if (!exprCst) {
            throw new Error('ExpressionStatement has no expression');
        }
        //  OvsRenderFunction
        const isOvsRenderFunction = this.findOvsRenderFunction(exprCst);
        const expr = this.createExpressionAst(exprCst);
        // 
        if (this.ovsRenderDomViewDepth > 0) {
            //  div {} 
            // 1. OvsRenderFunction  
            if (isOvsRenderFunction) {
                const pushCall = SlimeAstCreateUtil.createCallExpression(SlimeAstCreateUtil.createMemberExpression(SlimeAstCreateUtil.createIdentifier('children'), SlimeTokenCreate.createDotToken(cst.loc), SlimeAstCreateUtil.createIdentifier('push')), [
                    expr
                ]);
                return {
                    type: SlimeNodeType.ExpressionStatement,
                    expression: pushCall,
                    loc: cst.loc
                };
            }
            // 2.  #{}   
            if (this.noRenderDepth > 0) {
                return {
                    type: SlimeNodeType.ExpressionStatement,
                    expression: expr,
                    loc: cst.loc
                };
            }
            // 3.  div {}  #{}   
            const pushCall = SlimeAstCreateUtil.createCallExpression(SlimeAstCreateUtil.createMemberExpression(SlimeAstCreateUtil.createIdentifier('children'), SlimeTokenCreate.createDotToken(cst.loc), SlimeAstCreateUtil.createIdentifier('push')), [
                expr
            ]);
            return {
                type: SlimeNodeType.ExpressionStatement,
                expression: pushCall,
                loc: cst.loc
            };
        }
        //  div {}   
        return {
            type: SlimeNodeType.ExpressionStatement,
            expression: expr,
            loc: cst.loc
        };
    }
    /**
   *  OvsRenderDomViewDeclaration  IIFE
   *
   * 
   * 1.  +1attrs
   * 2.  StatementList children.push()
   * 3. 
   *    - createComponentVNode('div', {}, [children])    IIFE
   *    - IIFE
   * 4.  -1 try-finally 
   *
   * 
   * div { h1 { greeting } }
   * createComponentVNode('div', {}, [
   *   createComponentVNode('h1', {}, [greeting])
   * ])
   *
   * attrs
   * div { let a = 1; name = a; 123 }
   * (function() {
   *   const children = []
   *   const temp$$attrs$$uuid = {}
   *   let a = 1
   *   let name = a
   *   temp$$attrs$$uuid.name = name
   *   children.push(temp$$attrs$$uuid.name)
   *   children.push(123)
   *   return createComponentVNode('div', {attrs: temp$$attrs$$uuid}, children)
   * })()
   */ createOvsRenderDomViewDeclarationAst(cst) {
        checkCstName(cst, _OvsParser.prototype.OvsRenderFunction.name);
        // /
        // OvsRenderFunction  IdentifierReference
        const idCst = cst.children?.[0];
        if (!idCst) {
            throw new Error('OvsRenderDomViewDeclaration has no identifier');
        }
        const id = this.createIdentifierReferenceAst(idCst);
        //  loc  value
        if (idCst.loc) {
            id.loc = {
                type: idCst.loc.type,
                value: id.name,
                start: idCst.loc.start,
                end: idCst.loc.end
            };
        }
        //  Arguments 
        //  attrs 
        const argumentsCst = cst.children?.find((child)=>child.name === 'Arguments');
        let componentProps = null;
        if (argumentsCst && argumentsCst.children) {
            //  Arguments 
            // Arguments LParen, ArgumentList?, RParen
            const argListCst = argumentsCst.children.find((child)=>child.name === 'ArgumentList');
            if (argListCst && argListCst.children?.[0]?.children?.[0]) {
                //  componentProps
                componentProps = this.createExpressionAst(argListCst.children[0].children[0]);
            }
        }
        //  OvsRenderDomViewDeclaration +1
        this.ovsRenderDomViewDepth++;
        //  uuid attrs children  uuid
        const uuid = Math.random().toString(36).substring(2, 10);
        const attrsVarName = `temp$$attrs$$${uuid}`;
        this.attrsVarNameStack.push(attrsVarName);
        //  noRenderDepth#{} 
        const savedNoRenderDepth = this.noRenderDepth;
        this.noRenderDepth = 0;
        try {
            //  StatementList 
            const statementListCst = cst.children?.find((child)=>child.name === 'StatementList');
            // StatementListdiv
            //  StatementList
            // NoRenderBlock #{} 
            let bodyStatements = [];
            if (statementListCst) {
                const statements = this.createStatementListAst(statementListCst);
                // 
                for (const stmt of statements){
                    if (Array.isArray(stmt)) {
                        bodyStatements.push(...stmt);
                    } else {
                        bodyStatements.push(stmt);
                    }
                }
            }
            //  IIFE
            // 
            // IIFE v0.2.1 
            // IIFE
            // 1.  ExpressionStatement/
            // 2.  #{} 
            // 
            // 
            // -  children.push() 
            // - "IIFE"
            // - 
            const hasComplexStatements = bodyStatements.some((stmt)=>{
                // 1:  ExpressionStatement/
                if (stmt.type !== SlimeNodeType.ExpressionStatement) {
                    return true;
                }
                // 2:  #{} 
                if (stmt.__fromNoRenderBlock) {
                    return true;
                }
                return false;
            });
            const isSimple = !hasComplexStatements;
            const currentAttrsVarName = this.attrsVarNameStack[this.attrsVarNameStack.length - 1];
            if (isSimple) {
                //  h  IIFE
                return this.createSimpleView(id, bodyStatements, currentAttrsVarName, componentProps);
            } else {
                //  IIFE
                return this.createComplexIIFE(id, bodyStatements, currentAttrsVarName, componentProps);
            }
        } finally{
            //  OvsRenderDomViewDeclaration -1 
            //  finally 
            this.ovsRenderDomViewDepth--;
            this.attrsVarNameStack.pop();
            this.noRenderDepth = savedNoRenderDepth; //  noRenderDepth
        }
    }
    /**
   *  IIFE
   *
   * 
   * - HTML div(props, children) -  htmlElements 
   * - MyComponent(props, children) - 
   *
   * @param id /
   * @param statements  ExpressionStatement
   * @param attrsVarName attrs
   * @returns CallExpression - 
   */ createSimpleView(id, statements, _attrsVarName, componentProps) {
        //  ExpressionStatement  ArrayElement
        const childElements = statements.map((stmt, index)=>{
            const exprStmt = stmt;
            const pushCall = exprStmt.expression;
            let element;
            if (pushCall && pushCall.type === SlimeNodeType.CallExpression && pushCall.arguments.length > 0) {
                element = pushCall.arguments[0];
            } else {
                element = exprStmt.expression;
            }
            //  ArrayElement
            const needComma = index < statements.length - 1;
            return SlimeAstCreateUtil.createArrayElement(element, needComma ? SlimeTokenCreate.createCommaToken() : undefined);
        });
        //  children 
        const childrenArray = SlimeAstCreateUtil.createArrayExpression(childElements);
        //  props  componentProps
        const propsObject = componentProps || SlimeAstCreateUtil.createObjectExpression([]);
        //  calleeHTML  $OvsHtmlTag.xxx
        const callee = createCalleeForTag(id.name, id.loc);
        //  tagName(props, children)  $OvsHtmlTag.tagName(props, children) 
        const vNodeCall = SlimeAstCreateUtil.createCallExpression(callee, [
            propsObject,
            childrenArray // children
        ]);
        //  CallExpression  loc
        //  LSP 
        if (id.loc) {
            vNodeCall.loc = id.loc;
        }
        return vNodeCall;
    }
    /**
   *  IIFEid
   *
   * 
   * (function() {
   *   const children = []
   *   ...statements
   *   return children
   * })()
   *
   * IIFE createComplexIIFE 
   *
   * @param statements 
   * @param attrsVarName attrs
   * @returns CallExpression
   */ createBaseIIFE(statements, attrsVarName) {
        //  IIFE 
        const iifeFunctionBody = [
            // 1.  children const children = []
            // loc
            SlimeAstCreateUtil.createVariableDeclaration(SlimeTokenCreate.createConstToken(), [
                SlimeAstCreateUtil.createVariableDeclarator(SlimeAstCreateUtil.createIdentifier('children'), SlimeTokenCreate.createAssignToken(), SlimeAstCreateUtil.createArrayExpression([]))
            ])
        ];
        // 2. attrs attrs const temp$$attrs$$uuid = {}
        // loc
        if (attrsVarName) {
            const attrsDeclaration = SlimeAstCreateUtil.createVariableDeclaration(SlimeTokenCreate.createConstToken(), [
                SlimeAstCreateUtil.createVariableDeclarator(SlimeAstCreateUtil.createIdentifier(attrsVarName), SlimeTokenCreate.createAssignToken(), SlimeAstCreateUtil.createObjectExpression([]))
            ]);
            iifeFunctionBody.push(attrsDeclaration);
        }
        // 3.  temp$$attrs$$.name = value  children.push()
        iifeFunctionBody.push(...statements);
        // 4.  children
        iifeFunctionBody.push(SlimeAstCreateUtil.createReturnStatement(SlimeAstCreateUtil.createIdentifier('children')));
        //  IIFE(function() { ... })()
        return this.createIIFE(iifeFunctionBody);
    }
    /**
   *  IIFEid
   *
   * 
   * (function() {
   *   const children = []
   *   ...statements
   *   return createComponentVNode(firstArg, props, children)
   * })()
   *  firstArg 'div'MyComponent
   *
   *  createBaseIIFE()  createComponentVNode
   *
   * @param id /
   * @param statements 
   * @param attrsVarName attrs
   * @param componentProps props
   * @returns CallExpression
   */ createComplexIIFE(id, statements, attrsVarName, componentProps) {
        // 1.  IIFEchildrenpush
        this.createBaseIIFE(statements, attrsVarName);
        // 2. IIFEchildren createComponentVNode
        // return
        const iifeFunctionBody = [
            // 1.  children const children = []
            SlimeAstCreateUtil.createVariableDeclaration(SlimeTokenCreate.createConstToken(), [
                SlimeAstCreateUtil.createVariableDeclarator(SlimeAstCreateUtil.createIdentifier('children'), SlimeTokenCreate.createAssignToken(), SlimeAstCreateUtil.createArrayExpression([]))
            ])
        ];
        // 2. attrs attrs 
        if (attrsVarName) {
            const attrsDeclaration = SlimeAstCreateUtil.createVariableDeclaration(SlimeTokenCreate.createConstToken(), [
                SlimeAstCreateUtil.createVariableDeclarator(SlimeAstCreateUtil.createIdentifier(attrsVarName), SlimeTokenCreate.createAssignToken(), SlimeAstCreateUtil.createObjectExpression([]))
            ]);
            iifeFunctionBody.push(attrsDeclaration);
        }
        // 3. 
        iifeFunctionBody.push(...statements);
        // 4.  createComponentVNode(id, props, children)  children
        iifeFunctionBody.push(this.createReturnOvsAPICreateVNode(id, attrsVarName, componentProps));
        //  IIFE(function() { ... })()
        return this.createIIFE(iifeFunctionBody);
    }
    /**
   *  return tagName(props, children) 
   *
   * 
   * - HTML return div(props, children)
   * - return MyComponent(props, children)
   *
   * @param id /
   * @param attrsVarName attrs
   * @param componentProps props
   * @returns ReturnStatement
   */ createReturnOvsAPICreateVNode(id, attrsVarName, componentProps) {
        //  props 
        let propsObject;
        if (componentProps) {
            //  componentProps
            propsObject = componentProps;
        } else {
            // props{}
            // attrsVarName 
            propsObject = SlimeAstCreateUtil.createObjectExpression([]);
        }
        //  calleeHTML  $OvsHtmlTag.xxx
        const callee = createCalleeForTag(id.name, id.loc);
        // tagName(props, children)  $OvsHtmlTag.tagName(props, children)
        const callExpression = SlimeAstCreateUtil.createCallExpression(callee, [
            propsObject,
            SlimeAstCreateUtil.createIdentifier('children') // children 
        ]);
        //  CallExpression  loc
        if (id.loc) {
            callExpression.loc = id.loc;
        }
        //  return 
        return SlimeAstCreateUtil.createReturnStatement(callExpression);
    }
    /**
   *  IIFE
   *
   * 
   * (function() {
   *   ...body
   * })()
   *
   * @param body 
   * @returns CallExpression
   */ createIIFE(body) {
        const loc = body[0]?.loc || undefined;
        //  BlockStatement
        const blockStatement = SlimeAstCreateUtil.createBlockStatement(body, loc, SlimeTokenCreate.createLBraceToken(loc), SlimeTokenCreate.createRBraceToken(loc));
        // 
        const functionExpression = SlimeAstCreateUtil.createFunctionExpression(blockStatement, null, [], false, false, loc, undefined, undefined, undefined, SlimeTokenCreate.createLParenToken(loc), SlimeTokenCreate.createRParenToken(loc) // rParenToken
        );
        //  function expression IIFE
        const parenExpr = SlimeAstCreateUtil.createParenthesizedExpression(functionExpression, loc);
        // 
        const callExpression = SlimeAstCreateUtil.createCallExpression(parenExpr, []);
        return callExpression;
    }
    constructor(...args){
        super(...args), /**
   *  OvsRenderDomViewDeclaration 
   *  ExpressionStatement  children.push()
   *
   * 
   * -  OvsRenderDomViewDeclaration  +1
   * -  -1
   * -  > 0  OvsRenderDomViewDeclaration 
   * -  div {  span { } }
   */ _define_property$1(this, "ovsRenderDomViewDepth", 0), /**
   *  NoRenderBlock #{} 
   *  ExpressionStatement 
   *
   * 
   * -  #{}  +1
   * -  -1
   * -  > 0  #{} 
   * -  OvsRenderFunction 
   */ _define_property$1(this, "noRenderDepth", 0), /**
   * viewattrs,ovsview if for 
   */ _define_property$1(this, "attrsVarNameStack", []);
    }
}
const OvsCstToSlimeNodeCreate = new OvsCstToSlimeAst();

// ====================  ====================
function hasReactiveExpression(sourceCode) {
    return sourceCode.includes('#{');
}
function ensureDefineOvsComponentImport(imports) {
    let reactiveVNodeImport = null;
    for (const imp of imports){
        if (imp.type === SlimeNodeType.ImportDeclaration) {
            const source = imp.source;
            if (source.value && (source.value.includes('ReactiveVNode') || source.value.includes('reactiveVNode'))) {
                reactiveVNodeImport = imp;
                break;
            }
        }
    }
    if (reactiveVNodeImport) {
        const specifiers = reactiveVNodeImport.specifiers || [];
        const has = specifiers.some((s)=>s.type === SlimeNodeType.ImportSpecifier && (s.imported?.name === 'defineOvsComponent' || s.local?.name === 'defineOvsComponent'));
        if (!has) {
            specifiers.push({
                type: SlimeNodeType.ImportSpecifier,
                imported: SlimeAstCreateUtil.createIdentifier('defineOvsComponent'),
                local: SlimeAstCreateUtil.createIdentifier('defineOvsComponent')
            });
        }
        return imports;
    }
    const newImport = SlimeAstCreateUtil.createImportDeclaration([
        {
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('defineOvsComponent'),
            local: SlimeAstCreateUtil.createIdentifier('defineOvsComponent')
        }
    ], SlimeAstCreateUtil.createStringLiteral('ovsjs'));
    return [
        newImport,
        ...imports
    ];
}
function createFragmentWrapper(expressions) {
    const arrayElements = expressions.map((expr, index)=>{
        const isLast = index === expressions.length - 1;
        return SlimeAstCreateUtil.createArrayElement(expr, isLast ? undefined : SlimeTokenCreate.createCommaToken());
    });
    return SlimeAstCreateUtil.createCallExpression(SlimeAstCreateUtil.createIdentifier('h'), [
        SlimeAstCreateUtil.createIdentifier('Fragment'),
        SlimeAstCreateUtil.createNullLiteralToken(),
        SlimeAstCreateUtil.createArrayExpression(arrayElements)
    ]);
}
function ensureFragmentImport(imports) {
    let vueImport = null;
    for (const imp of imports){
        if (imp.type === SlimeNodeType.ImportDeclaration) {
            const source = imp.source;
            if (source.value === 'vue') {
                vueImport = imp;
                break;
            }
        }
    }
    if (vueImport) {
        const specifiers = vueImport.specifiers || [];
        const hasFragment = specifiers.some((s)=>s.type === SlimeNodeType.ImportSpecifier && (s.imported?.name === 'Fragment' || s.local?.name === 'Fragment'));
        const hasH = specifiers.some((s)=>s.type === SlimeNodeType.ImportSpecifier && (s.imported?.name === 'h' || s.local?.name === 'h'));
        if (!hasFragment) specifiers.push({
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('Fragment'),
            local: SlimeAstCreateUtil.createIdentifier('Fragment')
        });
        if (!hasH) specifiers.push({
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('h'),
            local: SlimeAstCreateUtil.createIdentifier('h')
        });
        return imports;
    }
    const newImport = SlimeAstCreateUtil.createImportDeclaration([
        {
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('Fragment'),
            local: SlimeAstCreateUtil.createIdentifier('Fragment')
        },
        {
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('h'),
            local: SlimeAstCreateUtil.createIdentifier('h')
        }
    ], SlimeAstCreateUtil.createStringLiteral('vue'));
    return [
        newImport,
        ...imports
    ];
}
/**  AST  $OvsHtmlTag */ function usesOvsHtmlTag(ast) {
    const code = JSON.stringify(ast);
    return code.includes('$OvsHtmlTag');
}
/**  $OvsHtmlTag  */ function ensureOvsHtmlTagImport(imports) {
    //  ovsjs 
    let ovsjsImport = null;
    for (const imp of imports){
        if (imp.type === SlimeNodeType.ImportDeclaration) {
            const source = imp.source;
            if (source.value === 'ovsjs') {
                ovsjsImport = imp;
                break;
            }
        }
    }
    if (ovsjsImport) {
        //  ovsjs  $OvsHtmlTag
        const specifiers = ovsjsImport.specifiers || [];
        const has = specifiers.some((s)=>s.type === SlimeNodeType.ImportSpecifier && (s.imported?.name === '$OvsHtmlTag' || s.local?.name === '$OvsHtmlTag'));
        if (!has) {
            specifiers.push({
                type: SlimeNodeType.ImportSpecifier,
                imported: SlimeAstCreateUtil.createIdentifier('$OvsHtmlTag'),
                local: SlimeAstCreateUtil.createIdentifier('$OvsHtmlTag')
            });
        }
        return imports;
    }
    //  ovsjs 
    const newImport = SlimeAstCreateUtil.createImportDeclaration([
        {
            type: SlimeNodeType.ImportSpecifier,
            imported: SlimeAstCreateUtil.createIdentifier('$OvsHtmlTag'),
            local: SlimeAstCreateUtil.createIdentifier('$OvsHtmlTag')
        }
    ], SlimeAstCreateUtil.createStringLiteral('ovsjs'));
    return [
        newImport,
        ...imports
    ];
}
function wrapTopLevelExpressions(ast, sourceCode) {
    let imports = [], declarations = [], expressions = [], hasAnyExport = false;
    for (const statement of ast.body){
        if (statement.type === SlimeNodeType.ImportDeclaration) imports.push(statement);
        else if (statement.type === SlimeNodeType.ExportDefaultDeclaration || statement.type === SlimeNodeType.ExportNamedDeclaration) hasAnyExport = true;
        else if (statement.type === SlimeNodeType.VariableDeclaration || statement.type === SlimeNodeType.FunctionDeclaration || statement.type === SlimeNodeType.ClassDeclaration) declarations.push(statement);
        else expressions.push(statement);
    }
    //  $OvsHtmlTag
    if (usesOvsHtmlTag(ast)) {
        imports = ensureOvsHtmlTagImport(imports);
    }
    if (hasAnyExport || expressions.length === 0) {
        //  export $OvsHtmlTag 
        if (usesOvsHtmlTag(ast)) {
            //  AST imports 
            const newBody = [
                ...imports,
                ...ast.body.filter((s)=>s.type !== SlimeNodeType.ImportDeclaration)
            ];
            return SlimeAstCreateUtil.createProgram(newBody, SlimeProgramSourceType.Module);
        }
        return ast;
    }
    const exprValues = expressions.map((e)=>e.type === SlimeNodeType.ExpressionStatement ? e.expression : e);
    const needsIIFE = hasReactiveExpression(sourceCode);
    let finalExpr = exprValues.length === 1 ? exprValues[0] : (imports = ensureFragmentImport(imports), createFragmentWrapper(exprValues));
    if (needsIIFE) {
        imports = ensureDefineOvsComponentImport(imports);
        const returnStmt = SlimeAstCreateUtil.createReturnStatement(finalExpr);
        const blockStatement = SlimeAstCreateUtil.createBlockStatement([
            ...declarations,
            returnStmt
        ]);
        const arrowFunction = SlimeAstCreateUtil.createArrowFunctionExpression(blockStatement, [
            SlimeAstCreateUtil.createIdentifier('props')
        ], false, false);
        const defineOvsCall = SlimeAstCreateUtil.createCallExpression(SlimeAstCreateUtil.createIdentifier('defineOvsComponent'), [
            arrowFunction
        ]);
        return SlimeAstCreateUtil.createProgram([
            ...imports,
            SlimeAstCreateUtil.createExportDefaultDeclaration(defineOvsCall)
        ], SlimeProgramSourceType.Module);
    }
    return SlimeAstCreateUtil.createProgram([
        ...imports,
        ...declarations,
        SlimeAstCreateUtil.createExportDefaultDeclaration(finalExpr)
    ], SlimeProgramSourceType.Module);
}
/** OVS  */ function ovsTransformBase(code) {
    const parser = new _OvsParser(code);
    let curCst = parser.Program();
    const tokens = parser.parsedTokens;
    if (!tokens.length) return {
        ast: null,
        tokens: tokens
    };
    let ast = OvsCstToSlimeNodeCreate.toProgram(curCst);
    return {
        ast,
        tokens
    };
}
/** Vite  OVS  */ function vitePluginOvsTransform(code) {
    let codeResult = ovsTransformBase(code);
    let ast = codeResult.ast;
    if (!ast) return {
        code: '',
        mapping: []
    };
    ast = wrapTopLevelExpressions(ast, code);
    const result = SlimeGenerator.generator(ast, codeResult.tokens);
    result.mapping = result.mapping.filter((m)=>m.source && m.source.value && m.source.value !== '' && m.source.length > 0);
    return result;
}

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const ovsLanguagePlugin = {
    getLanguageId (uri) {
        if (uri.path.endsWith('.ovs')) {
            return 'ovs';
        }
    },
    createVirtualCode (_uri, languageId, snapshot) {
        if (languageId === 'ovs') {
            return new OvsVirtualCode(snapshot);
        }
    },
    typescript: {
        extraFileExtensions: [
            {
                extension: 'ovs',
                isMixedContent: true,
                scriptKind: ts.ScriptKind.Deferred
            }
        ],
        getServiceScript () {
            return undefined;
        },
        getExtraServiceScripts (fileName, root) {
            const scripts = [];
            //
            const ary = [
                ...languageCoreExports.forEachEmbeddedCode(root)
            ];
            // console.log(ary.length)
            // LogUtil.log(ary.length)
            // LogUtil.log(root.embeddedCodes)
            for (const code of ary){
                if (code.languageId === 'typescript') {
                    scripts.push({
                        fileName: fileName + '.' + code.id + '.ts',
                        code,
                        extension: '.ts',
                        scriptKind: ts.ScriptKind.TS
                    });
                } else if (code.languageId === 'js') {
                    scripts.push({
                        fileName: fileName + '.' + code.id + '.js',
                        code,
                        extension: '.js',
                        scriptKind: ts.ScriptKind.JS
                    });
                }
            }
            return scripts;
        }
    }
};
class MappingConverter {
    static convertMappings(mappings) {
        // vitePluginOvsTransform
        //  null 
        return mappings.filter((mapping)=>{
            //  null/undefined 
            return mapping.source && mapping.generate;
        }).map((mapping, index)=>{
            const res = {
                original: {
                    offset: mapping.source.index,
                    length: mapping.source.length
                },
                generated: {
                    offset: mapping.generate.index,
                    length: mapping.generate.length
                }
            };
            return res;
        });
    }
}
class OvsVirtualCode {
    constructor(snapshot){
        _define_property(this, "snapshot", void 0);
        _define_property(this, "id", void 0);
        _define_property(this, "languageId", void 0);
        _define_property(this, "mappings", void 0);
        _define_property(this, "embeddedCodes", void 0);
        this.snapshot = snapshot;
        this.id = 'root';
        this.languageId = 'qqovs';
        this.embeddedCodes = [];
        this.mappings = [
            {
                sourceOffsets: [
                    0
                ],
                generatedOffsets: [
                    0
                ],
                lengths: [
                    snapshot.getLength()
                ],
                data: {
                    completion: true,
                    format: true,
                    navigation: true,
                    semantic: true,
                    structure: true,
                    verification: true
                }
            }
        ];
        const styleText = snapshot.getText(0, snapshot.getLength());
        let newCode = styleText;
        LogUtil.log('=== OVS Transform Start ===');
        let mapping = [];
        try {
            LogUtil.log('Input code length: ' + styleText.length);
            //  source map 
            const res = vitePluginOvsTransform(styleText);
            newCode = res.code;
            mapping = res.mapping;
            LogUtil.log('=== OVS Transform Success ===');
            LogUtil.log('Output code length: ' + newCode.length);
        } catch (e) {
            LogUtil.log('=== OVS Transform Error ===');
            if (e instanceof Error) {
                LogUtil.log('Error type: ' + e.constructor.name);
                LogUtil.log('Error message: ' + e.message);
                LogUtil.log('Error stack: ' + e.stack);
            } else {
                LogUtil.log('Unknown error: ' + String(e));
            }
            //  fallback
            newCode = styleText;
            mapping = [];
        }
        const offsets = MappingConverter.convertMappings(mapping);
        LogUtil.log('=== Mapping Debug ===');
        LogUtil.log('Raw mapping count: ' + mapping.length);
        LogUtil.log('Converted offsets count: ' + offsets.length);
        if (offsets.length > 0) {
            LogUtil.log('First 5 offsets:', offsets.slice(0, 5));
        }
        LogUtil.log('Source code:');
        LogUtil.log(styleText);
        LogUtil.log('Generated code:');
        LogUtil.log(newCode);
        const mappings = [
            {
                sourceOffsets: offsets.map((item)=>item.original.offset),
                generatedOffsets: offsets.map((item)=>item.generated.offset),
                lengths: offsets.map((item)=>item.original.length),
                generatedLengths: offsets.map((item)=>item.generated.length),
                data: {
                    completion: true,
                    format: true,
                    navigation: true,
                    semantic: true,
                    structure: true,
                    verification: true
                }
            }
        ];
        this.embeddedCodes = [
            {
                id: 'ovsts',
                languageId: 'typescript',
                snapshot: {
                    getText: (start, end)=>newCode.substring(start, end),
                    getLength: ()=>newCode.length,
                    getChangeRange: ()=>undefined
                },
                mappings: mappings,
                embeddedCodes: []
            }
        ];
    }
}

LogUtil.log('=== OVS Language Server Starting ===');
LogUtil.log('Process ID: ' + process.pid);
LogUtil.log('Node version: ' + process.version);
LogUtil.log('Current directory: ' + process.cwd());
const connection = nodeExports.createConnection();
LogUtil.log('Connection created');
const server = nodeExports.createServer(connection);
LogUtil.log('Server created');
connection.listen();
LogUtil.log('Connection listening...');
connection.onInitialize((params)=>{
    LogUtil.log('=== onInitialize ===');
    LogUtil.log('Client info:', params.clientInfo);
    LogUtil.log('Root URI:', params.rootUri);
    LogUtil.log('Workspace folders:', params.workspaceFolders);
    LogUtil.log('Initialization options:', params.initializationOptions);
    try {
        //  initializationOptions  TypeScript SDK 
        const tsdkPath = params.initializationOptions?.typescript?.tsdk;
        LogUtil.log('TSDK path from client: ' + tsdkPath);
        if (!tsdkPath) {
            LogUtil.log('WARNING: No tsdk path provided, using fallback');
        }
        LogUtil.log('Loading TSDK...');
        const tsdk = nodeExports.loadTsdkByPath(tsdkPath, params.locale);
        LogUtil.log('TSDK loaded, TypeScript version: ' + tsdk.typescript.version);
        const languagePlugins = [
            ovsLanguagePlugin
        ];
        LogUtil.log('Language plugins created: ' + languagePlugins.length);
        const languageServicePlugins = [
            ...createTypeScriptServices(tsdk.typescript)
        ];
        LogUtil.log('Language service plugins created: ' + languageServicePlugins.length);
        const tsProject = nodeExports.createTypeScriptProject(tsdk.typescript, tsdk.diagnosticMessages, ()=>({
                languagePlugins: languagePlugins
            }));
        LogUtil.log('TypeScript project created');
        const res = server.initialize(params, tsProject, [
            ...languageServicePlugins
        ]);
        LogUtil.log('=== Server Initialized Successfully ===');
        LogUtil.log('Capabilities:', res.capabilities);
        return res;
    } catch (e) {
        LogUtil.log('=== ERROR during initialization ===');
        LogUtil.log('Error type: ' + e.constructor?.name);
        LogUtil.log('Error message: ' + e.message);
        LogUtil.log('Error stack: ' + e.stack);
        throw e;
    }
});
connection.onInitialized(()=>{
    LogUtil.log('=== onInitialized - Client confirmed initialization ===');
    server.initialized();
});
connection.onShutdown(()=>{
    LogUtil.log('=== onShutdown ===');
    server.shutdown();
});
// 
process.on('uncaughtException', (error)=>{
    LogUtil.log('=== Uncaught Exception ===');
    LogUtil.log('Error: ' + error.message);
    LogUtil.log('Stack: ' + error.stack);
});
process.on('unhandledRejection', (reason, promise)=>{
    LogUtil.log('=== Unhandled Rejection ===');
    LogUtil.log('Reason: ' + String(reason));
});
//# sourceMappingURL=language-server.cjs.map
